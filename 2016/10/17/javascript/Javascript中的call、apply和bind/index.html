<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/08/23/q9yfYPsHnSvlOQo.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>JavaScript 中的 call、apply 和 bind</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2><span id="apply-amp-call">apply &amp; call</span></h2><blockquote>
<p>在 JavaScript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的 </p>
</blockquote>
<p><strong>在 JavaScript 中，一切都是对象</strong>，包括函数。函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<a id="more"></a>
<p>例：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function people() &#123;&#125;
 
people.prototype &#x3D; &#123;
    name: &quot;ming&quot;,
    say: function() &#123;
        console.log(&quot;My name is &quot; + this.name);
    &#125;
&#125;
 
var a &#x3D; new people;
a.say();    &#x2F;&#x2F;My name is ming<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时我们有一个对象 <code>b=&#123;name:&quot;su&quot;&#125;</code>，不想重新定义<code>say</code> 方法， 那么可以通过 <code>call</code> 或者 <code>apply</code> 方法。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">b&#x3D;&#123;
	name:&quot;su&quot;
&#125;
a.say.call(b); &#x2F;&#x2F;My name is su
a.say.apply(b); &#x2F;&#x2F;My name is su<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 <code>call</code> 和<code>apply</code>都是为了动态改变 <code>this</code> 而出现的。当一个 <code>object</code> 没有某个方法，可以借助 call 或 apply 用其他对象的方法来操作。</p>
<h3><span id="apply-和-call-的区别">apply 和 call 的区别 </span></h3><p> 对于 <code>apply</code>、<code>call</code> 二者而言，作用完全一样，只是接受参数的方式不太一样。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var func &#x3D; function(arg1, arg2) &#123;
     
&#125;;
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>call</code> 需要把参数按顺序传递进去，而 <code>apply</code> 则是把参数放在数组里。　</p>
<p>明确知道参数数量时用 <code>call</code> 。而不确定的时候用 <code>apply</code>，然后把参数 <code>push</code> 进数组传递进去。当参数数量不确定时，函数内部也可以通过 <code>arguments</code> 这个伪数组来遍历所有的参数。</p>
<ul>
<li><p><strong>数组追加</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var array1 &#x3D; [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458]; 
var array2 &#x3D; [&quot;Doe&quot; , 555 , 100]; 
Array.prototype.push.apply(array1, array2); 
&#x2F;* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>获取数组最大最小值</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var  numbers &#x3D; [5, 458 , 120 , -215]; 
var maxInNumbers &#x3D; Math.max.apply(Math, numbers),   &#x2F;&#x2F;458
    maxInNumbers &#x3D; Math.max.call(Math,5, 458 , 120 , -215); &#x2F;&#x2F;458<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>number</code> 本身没有 <code>max</code> 方法，但是 <code>Math</code> 有，我们就可以借助 <code>call</code> 或者 <code>apply</code> 使用其方法。</p>
</li>
<li><p><strong>验证是否是数组</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">functionisArray(obj)&#123; 
    return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39; ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>类（伪）数组使用数组方法</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>JavaScript 中存在一种名为伪数组的对象结构。比较特别的是 <code>arguments</code> 对象，还有像调用 <code>getElementsByTagName</code> , <code>document.childNodes</code> 之类的，它们返回 NodeList 对象都属于伪数组。不能应用 <code>Array</code>下的 <code>push</code> , <code>pop</code> 等方法。</p>
<p>但是我们能通过 <code>Array.prototype.slice.call</code>转换为真正的数组的带有 <code>length</code> 属性的对象，这样 domNodes 就可以应用 <code>Array</code> 下的所有方法了。</p>
</li>
</ul>
<h3><span id="实例">实例</span></h3><ul>
<li><p>用 <code>log</code> 来代理<code>console.log</code></p>
<p>由于传入参数不确定，所以普通的方法对于多个参数是失效的。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function log(msg)　&#123;
  console.log(msg);
&#125;
log(1);    &#x2F;&#x2F;1
log(1,2);    &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时 <code>arguments</code> 就派上用场了，可以把 <code>arguments</code> 传入 <code>apply</code> 方法中。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function log()&#123;
  console.log.apply(console, arguments);
&#125;;
log(1);    &#x2F;&#x2F;1
log(1,2);    &#x2F;&#x2F;1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2><span id="bind">bind</span></h2><p>与 <code>call</code>、<code>apply</code> 一样，<code>bind</code> 也可以改变函数体内 <code>this</code> 的指向。</p>
<blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; &#123;
    bar : 1,
    eventBind: function()&#123;
        var _this &#x3D; this;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            &#x2F;* Act on the event *&#x2F;
            console.log(_this.bar);     &#x2F;&#x2F;1
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 JavaScript 特有的机制，上下文环境在 <code>eventBind:function()&#123; &#125;</code> 过渡到 <code>$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123; &#125;)</code> 发生了改变，上述使用变量保存 <code>this</code> 这些方式都是有用的，也没有什么问题。当然使用 <code>bind()</code> 可以更加优雅的解决这个问题：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; &#123;
    bar : 1,
    eventBind: function()&#123;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            &#x2F;* Act on the event *&#x2F;
            console.log(this.bar);      &#x2F;&#x2F;1
        &#125;.bind(this));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述代码里，<code>bind()</code> 创建了一个函数，当这个 <code>click</code> 事件绑定在被调用的时候，它的 <code>this</code> 关键词会被设置成被传入的值（这里指调用 <code>bind()</code> 时传入的参数）。因此，这里我们传入想要的上下文 <code>this</code>(其实就是 foo)，到 <code>bind()</code> 函数中。然后，当回调函数被执行的时候， <code>this</code> 便指向 <code>foo</code> 对象。再来一个简单的栗子：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var bar &#x3D; function()&#123;
	console.log(this.x);
&#125;
var foo &#x3D; &#123;
	x:3
&#125;
bar(); &#x2F;&#x2F; undefined
var func &#x3D; bar.bind(foo);
func(); &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们创建了一个新的函数 <code>func</code>，当使用 <code>bind()</code> 创建一个绑定函数之后，它被执行的时候，它的 <code>this</code> 会被设置成 <code>foo</code> ， 而不是像我们调用 <code>bar()</code> 时的全局作用域。</p>
<p>如果 <code>bind</code> 多次会如何？</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var bar &#x3D; function()&#123;
    console.log(this.x);
&#125;
var foo &#x3D; &#123;
    x:3
&#125;
var sed &#x3D; &#123;
    x:4
&#125;
var func &#x3D; bar.bind(foo).bind(sed);
func(); &#x2F;&#x2F;3
 
var fiv &#x3D; &#123;
    x:5
&#125;
var func &#x3D; bar.bind(foo).bind(sed).bind(fiv);
func(); &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>仍旧输出 3。原因在于 bind()相当使用函数在内部包了一个<code>call/apply</code>，往后 <code>bind()</code> 相当于再包住第一次 <code>bind()</code> , 故第二次以后的 <code>bind</code> 是无法生效的。</p>
<h2><span id="apply-call-bind-比较">apply、call、bind 比较</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var obj &#x3D; &#123;
    x: 81,
&#125;;
 
var foo &#x3D; &#123;
    getX: function() &#123;
        return this.x;
    &#125;
&#125;
 
console.log(foo.getX.bind(obj)());  &#x2F;&#x2F;81
console.log(foo.getX.call(obj));    &#x2F;&#x2F;81
console.log(foo.getX.apply(obj));   &#x2F;&#x2F;81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>三个都可以改变上下文环境，但 <code>bind</code> 并非立刻执行 (需要调用)，而<code>call</code> 和<code>apply</code>都是立即执行。</p>

            </div>
            <!-- Post Comments -->
            
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: false,
        verify: false,
        app_id: '0gkmTvRakhR8M2UnEvf1POkG-gzGzoHsz',
        app_key: 'UrBohelQ00fEUxu5npX46rtL',
        placeholder: 'Just go go',
        pageSize: '10',
        avatar: 'mm',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>

            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>