<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/uncategorized/">uncategorized</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/09/09/twrYh4p3CXOWVAM.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>MySQL 命令之 Explain 笔记</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>MySQL 提供了一个 EXPLAIN 命令， 它可以对 <code>SELECT</code> 语句进行分析， 并输出 <code>SELECT</code> 执行的详细信息， 以供开发人员针对性优化。借助一个实例操作，来对 Explain 用法做一些总结。</p>
<a id="more"></a>
<h2><span id="简介">简介</span></h2><p>EXPLAIN 命令用法十分简单， 在 SELECT 语句前加上 Explain 就可以了， 例如:</p>
<pre class="line-numbers language-none"><code class="language-none">EXPLAIN SELECT * from user_info WHERE id &lt; 300;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="准备">准备 </span></h2><p> 为了接下来方便演示 EXPLAIN 的使用， 首先我们需要建立两个测试用的表， 并添加相应的数据:</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;user_info&#96; (&#96;id&#96;   BIGINT(20)  NOT NULL AUTO_INCREMENT,
  &#96;name&#96; VARCHAR(50) NOT NULL DEFAULT &#39;&#39;，
  &#96;age&#96;  INT(11)              DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)，
  KEY &#96;name_index&#96; (&#96;name&#96;)
)
  ENGINE &#x3D; InnoDB
  DEFAULT CHARSET &#x3D; utf8

INSERT INTO user_info (name, age) VALUES (&#39;xys&#39;， 20);
INSERT INTO user_info (name, age) VALUES (&#39;a&#39;， 21);
INSERT INTO user_info (name, age) VALUES (&#39;b&#39;， 23);
INSERT INTO user_info (name, age) VALUES (&#39;c&#39;， 50);
INSERT INTO user_info (name, age) VALUES (&#39;d&#39;， 15);
INSERT INTO user_info (name, age) VALUES (&#39;e&#39;， 20);
INSERT INTO user_info (name, age) VALUES (&#39;f&#39;， 21);
INSERT INTO user_info (name, age) VALUES (&#39;g&#39;， 23);
INSERT INTO user_info (name, age) VALUES (&#39;h&#39;， 50);
INSERT INTO user_info (name, age) VALUES (&#39;i&#39;， 15);
CREATE TABLE &#96;order_info&#96; (&#96;id&#96;           BIGINT(20)  NOT NULL AUTO_INCREMENT,
  &#96;user_id&#96;      BIGINT(20)           DEFAULT NULL,
  &#96;product_name&#96; VARCHAR(50) NOT NULL DEFAULT &#39;&#39;，
  &#96;productor&#96;    VARCHAR(30)          DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)，
  KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)
)
  ENGINE &#x3D; InnoDB
  DEFAULT CHARSET &#x3D; utf8

INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p2&#39;， &#39;WL&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;， &#39;DX&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p5&#39;， &#39;WL&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &#39;p3&#39;， &#39;MA&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &#39;p8&#39;， &#39;TE&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="explain-输出格式">EXPLAIN 输出格式</span></h2><p>EXPLAIN 命令的输出内容大致如下:</p>
<pre class="line-numbers language-none"><code class="language-none">mysql&gt; explain select * from user_info where id &#x3D; 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_info
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 8
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3><span id="select_type">select_type</span></h3><p><code>select_type</code> 表示了查询的类型， 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句， 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 <code>SIMPLE</code> 了， 比如当我们的查询没有子查询， 也没有 UNION 查询时， 那么通常就是 <code>SIMPLE</code> 类型， 例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from user_info where id &#x3D; 2;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/eKc6yprMZFaVnHL.png" alt="Screen Shot 2020-09-09 at 9.00.09 AM"></p>
<p>如果我们使用了 UNION 查询， 那么 EXPLAIN 输出 的结果类似如下:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))
UNION
(SELECT * FROM user_info WHERE id IN (3, 4, 5));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/J4oXgiRtnESN1Hv.png" alt="Screen Shot 2020-09-09 at 8.59.34 AM"></p>
<h3><span id="table">table</span></h3><p>表示查询涉及的表或衍生表</p>
<h3><span id="type">type</span></h3><p><code>type</code> 字段比较重要， 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段， 我们判断此次查询是 <code>全表扫描 </code> 还是 <code> 索引扫描</code> 等.</p>
<h4><span id="type-常用类型">type 常用类型</span></h4><p>type 常用的取值有:</p>
<ul>
<li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li>
<li><code>const</code>: 针对主键或唯一索引的等值查询扫描， 最多只返回一行数据. const 查询速度非常快， 因为它仅仅读取一次即可.<br>例如下面的这个查询， 它使用了主键索引， 因此 <code>type</code> 就是 <code>const</code> 类型的.</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from user_info where id &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询， 表示对于前表的每一个结果， 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>， 查询效率较高. 例如:</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id &#x3D; order_info.user_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/hwiS67cE4lopqPL.png" alt="Screen Shot 2020-09-09 at 9.01.59 AM"></p>
<ul>
<li><code>ref</code>: 此类型通常出现在多表的 join 查询， 针对于非唯一或非主键索引， 或者是使用了 <code>最左前缀 </code> 规则索引的查询.<br> 例如下面这个例子中， 就使用到了 <code>ref</code> 类型的查询:</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id &#x3D; order_info.user_id AND order_info.user_id &#x3D; 5;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/UsCitmex8qGyzpa.png" alt="Screen Shot 2020-09-09 at 9.03.29 AM"></p>
<ul>
<li><code>range</code>: 表示使用索引范围查询， 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时， 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT *
FROM user_info
WHERE id BETWEEN 2 AND 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/XKjzHrAqM5Ny4oc.png" alt="Screen Shot 2020-09-09 at 9.06.10 AM"></p>
<ul>
<li><p><code>index</code>: 表示全索引扫描(full index scan)， 和 ALL 类型类似， 只不过 ALL 类型是全表扫描， 而 index 类型则仅仅扫描所有的索引， 而不扫描数据</p>
<p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到， 而不需要扫描数据. 当是这种情况时， Extra 字段 会显示 <code>Using index</code>.</p>
</li>
</ul>
<p>例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT name FROM  user_info;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/UADRNmrVLo7OMju.png" alt="Screen Shot 2020-09-09 at 9.08.30 AM"></p>
<p>上面的例子中， 我们查询的 name 字段恰好是一个索引， 因此我们直接从索引中获取数据就可以满足查询的需求了， 而不需要查询表中的数据. 因此这样的情况下， type 的值是 <code>index</code>， 并且 Extra 的值是 <code>Using index</code>.</p>
<ul>
<li>ALL: 表示全表扫描， 这个类型的查询是性能最差的查询之一. 通常来说， 我们的查询不应该出现 ALL 类型的查询， 因为这样的查询在数据量大的情况下， 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子， 可以看到， 在全表扫描时， possible_keys 和 key 字段都是 NULL, 表示没有使用到索引， 并且 rows 十分巨大， 因此整个查询效率是十分低下的.</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT age FROM  user_info WHERE age &#x3D; 20;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/iEmjy4GMAHsJz5w.png" alt="Screen Shot 2020-09-09 at 9.08.56 AM"></p>
<h4><span id="type-类型的性能比较">type 类型的性能比较 </span></h4><p> 通常来说， 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描， 因此在相同的查询条件下， 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描， 但是它扫描了所有的索引， 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据， 因此可以过滤部分或大部分数据， 因此查询效率就比较高了.</p>
<h3><span id="possible_keys">possible_keys</span></h3><p><code>possible_keys</code> 表示 MySQL 在查询时， 能够使用到的索引. 注意， 即使有些索引在 <code>possible_keys</code> 中出现， 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引， 由 <code>key</code> 字段决定.</p>
<h3><span id="key">key</span></h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<h3><span id="key_len">key_len</span></h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用， 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码， 则是 3 <em>n + 2 字节; 如果是 utf8mb4 编码， 则是 4</em> n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1 字节</li>
<li>SMALLINT: 2 字节</li>
<li>MEDIUMINT: 3 字节</li>
<li>INT: 4 字节</li>
<li>BIGINT: 8 字节</li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3 字节</li>
<li>TIMESTAMP: 4 字节</li>
<li>DATETIME: 8 字节</li>
</ul>
</li>
<li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的， 则没有此属性.</li>
</ul>
<p>我们来举两个简单的栗子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name &#x3D; &#39;p1&#39; AND productor &#x3D; &#39;WHH&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面的例子是从表 order_info 中查询指定的内容， 而我们从此表的建表语句中可以知道， 表 <code>order_info</code> 有一个联合索引:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中， 因为先进行 user_id 的范围查询， 而根据 <code>最左前缀匹配</code> 原则， 当遇到范围查询时， 就停止索引的匹配， 因此实际上我们使用到的索引的字段只有 <code>user_id</code>， 因此在 <code>EXPLAIN</code> 中， 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节， 而 NULL 属性占用一个字节， 因此总共是 9 个字节. 若我们将 user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>， 则 key_length 应该是 8.</p>
<p>上面因为 <code>最左前缀匹配</code> 原则， 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段， 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info WHERE user_id &#x3D; 1 AND product_name &#x3D; &#39;p1&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这次的查询中， 我们没有使用到范围查询， key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中， 仅仅使用到了联合索引中的前两个字段， 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<h3><span id="rows">rows</span></h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息， 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏， 原则上 rows 越少越好.</p>
<h3><span id="extra">Extra</span></h3><p>Explain 中的很多额外的信息会在 Extra 字段显示， 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时， 表示 MySQL 需额外的排序操作， 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>， 都建议优化去掉， 因为这样的查询 CPU 资源消耗大.</li>
</ul>
<p>例如下面的例子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info ORDER BY product_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/BxhONjolU8nLe1t.png" alt="Screen Shot 2020-09-09 at 9.11.24 AM"></p>
<p>我们的索引是</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是上面的查询中根据 <code>product_name</code> 来排序， 因此不能使用索引进行优化， 进而会产生 <code>Using filesort</code>.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>， 那么就不会出现 <code>Using filesort</code> 了. 例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>Using index<br>“覆盖索引扫描”， 表示查询在索引树中就可查找所需数据， 不用扫描表数据文件， 往往说明性能不错</li>
<li>Using temporary<br>查询有使用临时表， 一般出现于排序， 分组和多表 join 的情况， 查询效率不高， 建议优化.</li>
</ul>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>