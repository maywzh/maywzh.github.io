<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/09/08/S1dpotKYcvBOiH9.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>分布式锁:Redis vs. Zookeeper</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>在 Java 中 synchronized 关键字和 ReentrantLock 可重入锁在我们的代码中是经常见的，一般我们用其在多线程环境中控制对资源的并发访问，但是随着分布式的快速发展，本地的加锁往往不能满足我们的需要，在我们的分布式环境中上面加锁的方法就会失去作用。基于此，业界提出了分布式锁的概念。</p>
<a id="more"></a>
<h2><span id="why-分布式锁">Why 分布式锁？</span></h2><p>在讨论这个问题之前，我们先来看一个业务场景：</p>
<p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p>
<p>由于系统有一定的并发，所以会预先将商品的库存保存在 redis 中，用户下单的时候会更新 redis 的库存。</p>
<p>此时系统架构如下：</p>
<p><img src="https://i.loli.net/2020/09/08/EPWQcd1ymU6eHAk.png" alt="img"></p>
<p>但是这样一来会 <strong> 产生一个问题</strong>：假如某个时刻，redis 里面的某个商品库存为 1，此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p>
<p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。</p>
<p>这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p>
<p>很明显不对啊！这就是典型的 <strong> 库存超卖问题</strong></p>
<p>此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p>
<p><img src="https://i.loli.net/2020/09/08/LIgj5Ols4R9xKcw.png" alt="img"></p>
<p>按照上面的图，在执行第 2 步时，使用 Java 提供的 synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。关注公众号互联网架构师，回复关键字 2T，获取最新架构视频</p>
<p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/8OICyhzeSFGkLBj.jpg" alt="img"></p>
<p>增加机器之后，系统变成上图所示。</p>
<p>假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现 <strong> 库存超卖 </strong> 的问题。</p>
<p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p>
<p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了</p>
<p>这是因为两台机器加的锁不是同一个锁(两个锁在不同的 JVM 里面)。</p>
<p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？</p>
<p>此时，就该 <strong> 分布式锁 </strong> 隆重登场了，分布式锁的思路是：</p>
<p>在整个系统提供一个 <strong> 全局、唯一 </strong> 的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p>
<p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。</p>
<p>文字描述不太直观，我们来看下图：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"><img src="https://i.loli.net/2020/09/08/lnpQLjsiq3GvxTJ.png" alt="640 (1)"></p>
<p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p>
<p>那么，如何实现分布式锁呢？接着往下看！</p>
<h2><span id="基于-redis-实现分布式锁">基于 Redis 实现分布式锁 </span></h2><p> 上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。扩展：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247493252&amp;idx=2&amp;sn=5530b330af0e0bcb56f9cc8bd7d0a25d&amp;chksm=ebd5d9a8dca250be07d54c37110fcc2549cb31968557910a77485747d9cb9ee842a2f05c25dc&amp;scene=21#wechat_redirect">Redisson 是如何实现分布式锁的？</a></p>
<p>最常见的一种方案就是使用 Redis 做分布式锁</p>
<p>使用 Redis 做分布式锁的思路大概是这样的：在 redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 key 删除。</p>
<p>具体代码是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取锁
&#x2F;&#x2F; NX 是指如果 key 不存在就成功，key 存在返回 false，PX 可以指定过期时间
SET anyLock unique_value NX PX 30000


&#x2F;&#x2F; 释放锁：通过执行一段 lua 脚本
&#x2F;&#x2F; 释放锁涉及到两条指令，这两条指令不是原子性的
&#x2F;&#x2F; 需要用到 redis 的 lua 脚本支持特性，redis 执行 lua 脚本是原子性的
if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then
return redis.call(&quot;del&quot;,KEYS[1])
else
return 0
end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种方式有几大要点：</p>
<ul>
<li><p><strong>一定要用 SET key value NX PX milliseconds 命令</strong></p>
<p>如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key 永久存在)</p>
</li>
<li><p><strong>value 要具有唯一性</strong></p>
<p>这个是为了在解锁的时候，需要验证 value 是和加锁的一致才删除 key。</p>
<p>这是避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/08/izNaYrJTKcltBVI.png" alt="img"></p>
<p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 redis 的部署问题。</p>
<p>redis 有 3 种部署方式：</p>
<ul>
<li>单机模式</li>
<li>master-slave + sentinel 选举模式</li>
<li>redis cluster 模式</li>
</ul>
<p>使用 redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 redis 故障了。加锁就不行了。</p>
<p>采用 master-slave 模式，加锁的时候只对一个节点加锁，即便通过 sentinel 做了高可用，但是如果 master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p>
<p>基于以上的考虑，其实 redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法，这个算法的意思大概是这样的：</p>
<p>假设 redis 的部署模式是 redis cluster，总共有 5 个 master 节点，通过以下步骤获取一把锁：</p>
<ul>
<li>获取当前时间戳，单位是毫秒</li>
<li>轮流尝试在每个 master 节点上创建锁，过期时间设置较短，一般就几十毫秒</li>
<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了</li>
<li>要是锁建立失败了，那么就依次删除这个锁</li>
<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁</li>
</ul>
<p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p>
<p><img src="https://i.loli.net/2020/09/08/ySZF51vKboscCnU.png" alt="img"></p>
<h3><span id="另一种方式redisson">另一种方式：Redisson</span></h3><p>此外，实现 Redis 的分布式锁，除了自己基于 redis client 原生 api 来实现之外，还可以使用开源框架：Redission</p>
<p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p>
<p>回想一下上面说的，如果自己写代码来通过 redis 设置一个值，是通过下面这个命令设置的。</p>
<ul>
<li>SET anyLock unique_value NX PX 30000</li>
</ul>
<p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，key 会过期，其他线程有可能会获取到锁。</p>
<p>这样一来的话，第一个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。所以我们还需要额外的去维护这个过期时间，太麻烦了~</p>
<p>我们来看看 redisson 是怎么实现的？先感受一下使用 redission 的爽：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Config config &#x3D; new Config();
config.useClusterServers()
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7001&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7002&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7003&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7001&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7002&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7003&quot;);

RedissonClient redisson &#x3D; Redisson.create(config);


RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);
lock.lock();
lock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就是这么简单，我们只需要通过它的 api 中的 lock 和 unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p>
<ul>
<li><p>redisson 所有指令都通过 lua 脚本执行，redis 支持 lua 脚本原子性执行</p>
</li>
<li><p>redisson 设置一个 key 的默认过期时间为 30s, 如果某个客户端持有一个锁超过了 30s 怎么办？</p>
<p>redisson 中有一个 <code>watchdog</code> 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10 秒帮你把 key 的超时时间设为 30s</p>
<p>这样的话，就算一直持有锁也不会出现 key 过期了，其他线程获取到锁的问题了。</p>
</li>
<li><p>redisson 的“看门狗”逻辑保证了没有死锁发生。</p>
<p>(如果机器宕机了，看门狗也就没了。此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/08/VrfIShyRXCWTiEY.png" alt="img"></p>
<p>这里稍微贴出来其实现代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 加锁逻辑
private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) &#123;
    if (leaseTime !&#x3D; -1) &#123;
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    &#125;
    &#x2F;&#x2F; 调用一段 lua 脚本，设置一些 key、过期时间
    RFuture&lt;Long&gt; ttlRemainingFuture &#x3D; tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    ttlRemainingFuture.addListener(new FutureListener&lt;Long&gt;() &#123;
        @Override
        public void operationComplete(Future&lt;Long&gt; future) throws Exception &#123;
            if (!future.isSuccess()) &#123;
                return;
            &#125;

            Long ttlRemaining &#x3D; future.getNow();
            &#x2F;&#x2F; lock acquired
            if (ttlRemaining &#x3D;&#x3D; null) &#123;
                &#x2F;&#x2F; 看门狗逻辑
                scheduleExpirationRenewal(threadId);
            &#125;
        &#125;
    &#125;);
    return ttlRemainingFuture;
&#125;


&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;
    internalLockLeaseTime &#x3D; unit.toMillis(leaseTime);

    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
              &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +
                  &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +
                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +
                  &quot;return nil; &quot; +
              &quot;end; &quot; +
              &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1) then &quot; +
                  &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +
                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +
                  &quot;return nil; &quot; +
              &quot;end; &quot; +
              &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;,
                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
&#125;



&#x2F;&#x2F; 看门狗最终会调用了这里
private void scheduleExpirationRenewal(final long threadId) &#123;
    if (expirationRenewalMap.containsKey(getEntryName())) &#123;
        return;
    &#125;

    &#x2F;&#x2F; 这个任务会延迟 10s 执行
    Timeout task &#x3D; commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;
        @Override
        public void run(Timeout timeout) throws Exception &#123;

            &#x2F;&#x2F; 这个操作会将 key 的过期时间重新设置为 30s
            RFuture&lt;Boolean&gt; future &#x3D; renewExpirationAsync(threadId);

            future.addListener(new FutureListener&lt;Boolean&gt;() &#123;
                @Override
                public void operationComplete(Future&lt;Boolean&gt; future) throws Exception &#123;
                    expirationRenewalMap.remove(getEntryName());
                    if (!future.isSuccess()) &#123;
                        log.error(&quot;Can&#39;t update lock &quot; + getName() + &quot; expiration&quot;, future.cause());
                        return;
                    &#125;

                    if (future.getNow()) &#123;
                        &#x2F;&#x2F; reschedule itself
                        &#x2F;&#x2F; 通过递归调用本方法，无限循环延长过期时间
                        scheduleExpirationRenewal(threadId);
                    &#125;
                &#125;
            &#125;);
        &#125;

    &#125;, internalLockLeaseTime &#x2F; 3, TimeUnit.MILLISECONDS);

    if (expirationRenewalMap.putIfAbsent(getEntryName(), new ExpirationEntry(threadId, task)) !&#x3D; null) &#123;
        task.cancel();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，redisson 还提供了对 redlock 算法的支持,</p>
<p>它的用法也很简单：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RedissonClient redisson &#x3D; Redisson.create(config);
RLock lock1 &#x3D; redisson.getFairLock(&quot;lock1&quot;);
RLock lock2 &#x3D; redisson.getFairLock(&quot;lock2&quot;);
RLock lock3 &#x3D; redisson.getFairLock(&quot;lock3&quot;);
RedissonRedLock multiLock &#x3D; new RedissonRedLock(lock1, lock2, lock3);
multiLock.lock();
multiLock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>小结：</strong></p>
<p>本节分析了使用 redis 作为分布式锁的具体落地方案</p>
<p>以及其一些局限性</p>
<p>然后介绍了一个 redis 的客户端框架 redisson，</p>
<p>这也是我推荐大家使用的，</p>
<p>比自己写代码实现会少 care 很多细节。</p>
<h2><span id="基于-zookeeper-实现分布式锁">基于 zookeeper 实现分布式锁 </span></h2><p> 常见的分布式锁实现方案里面，除了使用 redis 来实现之外，使用 zookeeper 也可以实现分布式锁。</p>
<p>在介绍 zookeeper(下文用 zk 代替)实现分布式锁的机制之前，先粗略介绍一下 zk 是什么东西：</p>
<p>Zookeeper 是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>zk 的模型是这样的：zk 包含一系列的节点，叫做 znode，就好像文件系统一样每个 znode 表示一个目录，然后 znode 有一些特性：</p>
<ul>
<li><p><strong>有序节点</strong>：假如当前有一个父节点为<code>/lock</code>，我们可以在这个父节点下面创建子节点；</p>
<p>zookeeper 提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么 zookeeper 在生成子节点时会根据当前的子节点数量自动添加整数序号</p>
<p>也就是说，如果是第一个创建的子节点，那么生成的子节点为<code>/lock/node-0000000000</code>，下一个节点则为<code>/lock/node-0000000001</code>，依次类推。</p>
</li>
</ul>
<ul>
<li><p><strong>临时节点</strong>：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper 会自动删除该节点。</p>
</li>
<li><p><strong>事件监听</strong>：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper 会通知客户端。当前 zookeeper 有如下四种事件：</p>
</li>
<li><ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
</li>
</ul>
<p>基于以上的一些 zk 的特性，我们很容易得出使用 zk 实现分布式锁的落地方案：</p>
<ol>
<li><p>使用 zk 的临时节点和有序节点，每个线程获取锁就是在 zk 创建一个临时有序的节点，比如在 /lock/ 目录下。</p>
</li>
<li><p>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p>
</li>
<li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</p>
</li>
<li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p>
<p>比如当前线程获取到的节点序号为 <code>/lock/003</code>, 然后所有的节点列表为<code>[/lock/001,/lock/002,/lock/003]</code>, 则对<code>/lock/002</code> 这个节点添加一个事件监听器。</p>
</li>
</ol>
<p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。</p>
<p>比如 <code>/lock/001</code> 释放了，<code>/lock/002</code>监听到时间，此时节点集合为 <code>[/lock/002,/lock/003]</code>, 则<code>/lock/002</code> 为最小序号节点，获取到锁。</p>
<p>整个过程如下：</p>
<p><img src="https://i.loli.net/2020/09/08/prahvcI6zWuGoqN.png" alt="img"></p>
<p>具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。</p>
<h3><span id="curator-介绍">Curator 介绍</span></h3><p>Curator 是一个 zookeeper 的开源客户端，也提供了分布式锁的实现。</p>
<p>他的使用方式也比较简单：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">InterProcessMutex interProcessMutex &#x3D; new InterProcessMutex(client,&quot;&#x2F;anyLock&quot;);
interProcessMutex.acquire();
interProcessMutex.release();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其实现分布式锁的核心源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception
&#123;
    boolean  haveTheLock &#x3D; false;
    boolean  doDelete &#x3D; false;
    try &#123;
        if (revocable.get() !&#x3D; null ) &#123;
            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);
        &#125;

        while ((client.getState() &#x3D;&#x3D; CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123;
            &#x2F;&#x2F; 获取当前所有节点排序后的集合
            List&lt;String&gt;        children &#x3D; getSortedChildren();
            &#x2F;&#x2F; 获取当前节点的名称
            String              sequenceNodeName &#x3D; ourPath.substring(basePath.length() + 1); &#x2F;&#x2F; +1 to include the slash
            &#x2F;&#x2F; 判断当前节点是否是最小的节点
            PredicateResults    predicateResults &#x3D; driver.getsTheLock(client, children, sequenceNodeName, maxLeases);
            if (predicateResults.getsTheLock() ) &#123;
                &#x2F;&#x2F; 获取到锁
                haveTheLock &#x3D; true;
            &#125; else &#123;
                &#x2F;&#x2F; 没获取到锁，对当前节点的上一个节点注册一个监听器
                String  previousSequencePath &#x3D; basePath + &quot;&#x2F;&quot; + predicateResults.getPathToWatch();
                synchronized(this)&#123;
                    Stat stat &#x3D; client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);
                    if (stat !&#x3D; null)&#123;
                        if (millisToWait !&#x3D; null)&#123;
                            millisToWait -&#x3D; (System.currentTimeMillis() - startMillis);
                            startMillis &#x3D; System.currentTimeMillis();
                            if (millisToWait &lt;&#x3D; 0)&#123;
                                doDelete &#x3D; true;    &#x2F;&#x2F; timed out - delete our node
                                break;
                            &#125;
                            wait(millisToWait);
                        &#125;else&#123;
                            wait();
                        &#125;
                    &#125;
                &#125;
                &#x2F;&#x2F; else it may have been deleted (i.e. lock released). Try to acquire again
            &#125;
        &#125;
    &#125;
    catch (Exception e) &#123;
        doDelete &#x3D; true;
        throw e;
    &#125; finally&#123;
        if (doDelete)&#123;
            deleteOurPath(ourPath);
        &#125;
    &#125;
    return haveTheLock;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实 curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p>
<p><img src="https://i.loli.net/2020/09/08/fyikAEdrKow7acD.png" alt="img"></p>
<p>小结：</p>
<p>本节介绍了 zookeeperr 实现分布式锁的方案以及 zk 的开源客户端的基本使用，简要的介绍了其实现原理。</p>
<h2><span id="两种方案的优缺点比较">两种方案的优缺点比较 </span></h2><p> 学完了两种分布式锁的实现方案之后，本节需要讨论的是 redis 和 zk 的实现方案中各自的优缺点。</p>
<p>对于 redis 的分布式锁而言，它有以下缺点：</p>
<ul>
<li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li>
<li>另外来说的话，redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮</li>
<li>即便使用 redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 redlock 的讨论可以看 How to do distributed locking</li>
<li>redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<p>但是另一方面使用 redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”</p>
<p>所以使用 redis 作为分布式锁也不失为一种好的方案，最重要的一点是 redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p>
<p>对于 zk 分布式锁而言:</p>
<ul>
<li>zookeeper 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 zk 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 zk 集群的压力会比较大。</p>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>