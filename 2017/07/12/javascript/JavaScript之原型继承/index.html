<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/uncategorized/">uncategorized</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/08/23/dCF178eOG6mQDEy.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>JavaScript 的原型继承</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2><span id="javascript-继承">JavaScript 继承 </span></h2><p> 一般的面向对象的语言对继承的处理方式都是 class-based，即基于类的继承。一般是说子类继承了父类，继承的主体是类。而类的对象之间的继承体现于类的继承中。</p>
<p>以 Java 为例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 父类 A</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 子类 B 继承了父类 A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 JavaScript 的世界中则并非如此。JS 通过原型链的方式来实现继承，是基于对象的继承。下例中 b 对象继承了 a 对象的所有属性和方法。</p>
<a id="more"></a>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function People(sex) &#123;
    this.sex &#x3D; sex;
    this.say &#x3D; function () &#123;
        console.log(this.sex);
    &#125;
&#125;
let a &#x3D; new People(&quot;man&quot;); &#x2F;&#x2F; 实例化 a 对象
let b &#x3D; Object.create(a);  &#x2F;&#x2F;b 对象继承 a 对象，继承了 a 的属性和方法
console.log(b.sex); &#x2F;&#x2F;man
b.say(); &#x2F;&#x2F;man<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里我们可以说，a 对象是 b 对象的原型。这样的继承方法不需要类，继承在对象之间完成。</p>
<h2><span id="原型继承机制">原型继承机制 </span></h2><p> 对象进行属性查找时，优先查找自己的属性，如果没有查找到再去查找对象的原型上的属性。如果原型对象依旧没有找到，那么递归查找指导原型根部，如果依旧没有找到那么返回<code>undefined</code>。</p>
<pre class="line-numbers language-flow" data-language="flow"><code class="language-flow">st<span class="token operator">=></span>start<span class="token operator">:</span> 对象 a
op<span class="token operator">=></span>operation<span class="token operator">:</span> 查找属性 p
cond<span class="token operator">=></span>condition<span class="token operator">:</span> 是否有属性 p
sub1<span class="token operator">=></span>subroutine<span class="token operator">:</span> 转到对象 a 的继承的原型对象
io<span class="token operator">=></span>inputoutput<span class="token operator">:</span> 返回属性 p
e<span class="token operator">=></span>end<span class="token operator">:</span> 结束

st<span class="token operator">-</span><span class="token operator">></span>op<span class="token operator">-</span><span class="token operator">></span>cond
<span class="token function">cond</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>io<span class="token operator">-</span><span class="token operator">></span>e
<span class="token function">cond</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">sub1</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是原型链的思想，层层往上一级链条上查找。</p>
<p>ES5 中，可以通过 <code>Object.getPrototypeOf(obj)</code> 来获取<code>obj</code> 对象的原型，在 Chrome 浏览器中也可以使用非标准的<code>obj.__proto__</code>。</p>
<p>JS 中定义一个类的是通过声明一个函数来实现，这个函数也称为构造器。JS 中的构造器有一个特殊的属性(函数也是对象，所以也有属性) ———— <code>prototype</code>。此 <code>prototype</code> 用来定义通过构造器构造出来的对象的原型，构造器内部的代码用来给对象初始化。如下</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function People(name) &#123;
    this.name &#x3D; name;
&#125;
console.log(People.prototype); 
&#x2F;&#x2F;&#123;constructor: People&#125; People.prototype 的构造器为 People
People.prototype.say &#x3D; function() &#123;
    console.log(this.name);
&#125;
People.prototype.sex &#x3D; &quot;female&quot;;
let p1 &#x3D; new People(&quot;soda&quot;);
p1.constructor &#x2F;&#x2F;People
p1.sex &#x2F;&#x2F;female
p1.say(); &#x2F;&#x2F;soda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看出 <code>p1</code> 对象获得了 <code>People.prototype</code> 的属性和方法。实际上，通过 <code>new People()</code>，<code>p1</code> 以<code>People</code>的 <code>prototype</code> 为原型来创建了一个新对象，并获得了该原型的全部属性和方法。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">p1 &#x3D; new People() &#x2F;&#x2F; 等价于
p1 &#x3D; Object.create(People.prototype) &#x2F;&#x2F; 用 People 的 prototype 作为原型来创建一个新对象
People.apply(p1, &quot;soda&quot;) &#x2F;&#x2F; 执行构造器用来初始化，构造器中的 this 指向 p1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>p1</code>的原型是 <code>People.prototype</code>，<code>p1</code> 是<code>People</code>构造 (new) 出来的。</p>
<p>为了让 <code>p1.constructor</code> 能构正确执行 <code>p1</code> 的构造器，一个构造器默认的 <code>prototype</code> 上已经存在 <code>constructor</code> 属性，并且指向构造器本身。</p>
<p>⚠️ <code>People.prototype</code>并非 <code>People</code> 的原型，而是 <code>People</code> 构造的对象的原型，即 <code>p1</code> 的原型。<code>People</code>本身是一个 <code>Function</code> 类型，你可以把它理解为一个 <code>Function</code> 构造出来的对象，它的原型是 <code>Object.getPrototypeOf(People)</code> 或<code>People.__proto__</code>。 因为 <code>People</code> 是一个函数对象，所有函数都构造自 <code>Function</code>，原型是 <code>Function.prototype</code>。<code>People.prototype</code> 是 <code>People</code> 构造出来的实例的原型，不是 <code>People</code> 的原型。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">People.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype
&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="探究-constructor">探究 constructor</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Foo() &#123;&#125;
let foo &#x3D; new Foo();
foo.constructor &#x3D;&#x3D;&#x3D; Foo.prototype.constructor &#x2F;&#x2F;true
foo.constructor &#x3D;&#x3D;&#x3D; Foo &#x2F;&#x2F; true
Foo.constructor &#x3D;&#x3D;&#x3D; Object.constructor &#x2F;&#x2F; true
Object.constructor &#x3D;&#x3D;&#x3D; Function.constructor &#x2F;&#x2F; true
Function.constructor &#x3D;&#x3D;&#x3D; Function &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个样例我们可以得知三个信息，</p>
<ul>
<li><p><strong>对于 <code>foo</code> 对象而言，<code>Foo</code>函数是其构造器，<code>foo</code>是 <code>Foo</code> 函数构造的对象。</strong></p>
</li>
<li><p><strong>对于一切函数 <code>fn</code> 而言，<code>Function</code>是它们的构造器，<code>fn</code>是 <code>Function</code> 函数构造的对象，函数也是一种特殊的对象。</strong></p>
</li>
<li><p><strong><code>Function</code>的构造器是 <code>Function</code> 本身。<code>Function</code>既是对象，又是函数。</strong></p>
</li>
</ul>
<p>那么我们可以推断出什么？</p>
<p>因为所有的函数都有同一个构造器，所以所有的函数都有同一个原型，这个原型就是 <code>Function</code> 类的原型<code>Function.prototype</code></p>
<p>即 <code>Object.getPrototypeOf(fn) === Function.prototype</code>，<strong> 所有的函数都是一个类</strong>。</p>
<h2><span id="function-的双重性">Function 的双重性</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">Function.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true
Object.getPrototypeOf(Function) &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等式的左边的 <code>Function</code> 作为对象，求 <code>Function</code> 对象继承的原型</p>
<p>等式的右边的 <code>Funciton</code> 作为构造器，求 <code>Function</code> 类的原型</p>
<p>而对于一般的函数来说则不能这么比较</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Flower()&#123;&#125;
let flower &#x3D; new Flower()
flower.__proto__ &#x3D;&#x3D;&#x3D; Flower.prototype  &#x2F;&#x2F;true
Flower.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以 <code>Function</code> 是一种特殊的函数，也是一种特殊的对象。</p>
<ul>
<li>它的构造器是它的自身。</li>
<li>它与所有的函数继承同一个原型。</li>
<li>所有的函数都由 <code>Function</code> 来构造。</li>
</ul>
<h2><span id="object-与-function">Object 与 Function</span></h2><p>聊完 <code>Function</code> 再来聊聊 <code>Object</code>，JavaScript 原生提供<code>Object</code> 对象。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Foo()&#123;&#125;
let foo &#x3D; new Foo();
let obj &#x3D; new Object();
foo.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F;true
foo.__proto__.__proto__ &#x3D;&#x3D;&#x3D; obj.__proto__ &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，所有的对象都继承自 <code>Object</code> 对象。</p>
<p><code>Object</code>是所有 <code>Object</code> 对象的构造器，而根据 <code>Function</code> 的有趣性质，我们可以获得下面的结果</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">Object instanceof Function &#x2F;&#x2F; true
Function instanceof Object &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>首先，我们需要弄清楚 <code>instanceof</code> 的原理</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">instance instanceof People &#x2F;&#x2F; 等价于

function instanceOf(instance, prototype) &#123;
    var proto &#x3D; Object.getPrototype(instance); &#x2F;&#x2F; 取对象原型
    if(proto &#x3D;&#x3D;&#x3D; null) return false; &#x2F;&#x2F; 空
    if(proto &#x3D;&#x3D;&#x3D; prototype) return true; &#x2F;&#x2F; 原型匹配
    return instanceOf(proto, prototype); &#x2F;&#x2F; 递归检查原型的原型
&#125;

instance(instance, People.prototype);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JavaScript 中的继承概念归根到底是原型的继承，那么 <code>instanceof</code> 实际上就是将 <code>instance</code> 的原型与构造器的 <code>prototype</code> 进行递归检查。</p>
<p><code>Object</code>是一个构造器，一个函数，而函数也是一个对象，这个对象由 <code>Function</code> 这个构造器构造，所以</p>
<p><code>Object.__proto__ === Function.prototype</code> 上式成立</p>
<p> <code>Function</code>是一个函数，一个对象，而所有的对象都是继承于 <code>Object</code> 对象的原型，</p>
<p><code>Function.__proto__ === Object.prototype</code> 下式成立</p>
<h2><span id="总结">总结</span></h2><ul>
<li>JavaScript 的继承是通过原型链继承来实现的</li>
<li>所有的函数都是对象，它们的构造器是<code>Function</code></li>
<li><code>Function</code>是自身的构造器</li>
<li>所有的对象的最终原型是 <code>Object.prototype</code>，即所有的对象都继承于<code>Object</code> 对象</li>
</ul>

            </div>
            <!-- Post Comments -->
            
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: false,
        verify: false,
        app_id: '0gkmTvRakhR8M2UnEvf1POkG-gzGzoHsz',
        app_key: 'UrBohelQ00fEUxu5npX46rtL',
        placeholder: 'Just go go',
        pageSize: '10',
        avatar: 'mm',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>

            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>