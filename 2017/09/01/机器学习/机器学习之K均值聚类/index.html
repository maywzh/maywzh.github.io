<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="author" content="maywzh">


<meta name="subtitle" content="0x01 MAYSTORY">


<meta name="description" content="Namasday.">


<meta name="keywords" content="Tech Blogs">


<title>K均值聚类与python实现 | 0x01 MAYSTORY </title>


    
    <link rel="icon" href="/bitbug_favicon_128s.ico">
    

    
    
    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    
    
    
    
    
    
    
    
<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">梅故事壹</a> | <a
                    href="/">0x01 MAYSTORY</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">梅故事壹</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">K均值聚类与python实现</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">maywzh</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 1, 2017&nbsp;&nbsp;20:51:11</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>K-means算法采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大，是很典型的基于距离的聚类算法。该算法认为簇是由距离靠近的对象组成的，因此把得到紧凑且独立的簇作为最终目标。</p>
<a id="more"></a>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>算法步骤：</p>
<ul>
<li>创建k个点作为起始支点(随机选择)</li>
<li>当任意一个簇的分配结果发生改变的时候</li>
<li>对数据集的每个数据点<ul>
<li>对每个质心<ul>
<li>计算质心与数据点之间的距离</li>
</ul>
</li>
<li>将数据分配到距离其最近的簇</li>
</ul>
</li>
<li>对每一簇，计算簇中所有点的均值并将其均值作为质心</li>
</ul>
<p>k个初始类聚类中心点的选取对聚类结果具有较大的影响，因为在该算法第一步中是随机的选取任意k个对象作为初始聚类的中心，初始地代表一个簇。该算法在每次迭代中对数据集中剩余的每个对象，根据其与各个簇中心的距离将每个对象重新赋给最近的簇。当考察完所有数据对象后，一次迭代运算完成，新的聚类中心被计算出来。如果在一次迭代前后，J的值没有发生变化，说明算法已经收敛。</p>
<h2 id="测试数据集"><a href="#测试数据集" class="headerlink" title="测试数据集"></a>测试数据集</h2><p>首先从 <code>sklearn</code> 导入数据集。我们用非常著名的 <code>iris</code> 数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line"></span><br><span class="line">data = X[:,[<span class="number">1</span>,<span class="number">3</span>]] <span class="comment"># 为了便于可视化，只取两个维度</span></span><br><span class="line">plt.scatter(data[:,<span class="number">0</span>],data[:,<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h2><p>计算欧式距离，我们需要为每个点找到离其最近的质心，需要用这个辅助函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">p1,p2</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  Return Eclud distance between two points.</span></span><br><span class="line"><span class="string">  p1 = np.array([0,0]), p2 = np.array([1,1]) =&gt; 1.414</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  tmp = np.sum((p1-p2)**<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> np.sqrt(tmp)</span><br><span class="line"></span><br><span class="line">distance(np.array([<span class="number">0</span>,<span class="number">0</span>]),np.array([<span class="number">1</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure>
<h2 id="随机质心"><a href="#随机质心" class="headerlink" title="随机质心"></a>随机质心</h2><p>在给定数据范围内随机产生k个簇心，作为初始的簇。随机数都在给定数据的范围之内 <code>dmin + (dmax - dmin) * np.random.rand(k)</code> 实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_center</span>(<span class="params">data,k</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Generate k center within the range of data set.&quot;&quot;&quot;</span></span><br><span class="line">  n = data.shape[<span class="number">1</span>] <span class="comment"># features</span></span><br><span class="line">  centroids = np.zeros((k,n)) <span class="comment"># init with (0,0)....</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    dmin, dmax = np.min(data[:,i]), np.max(data[:,i])</span><br><span class="line">    centroids[:,i] = dmin + (dmax - dmin) * np.random.rand(k)</span><br><span class="line">  <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line">centroids = rand_center(data,<span class="number">2</span>)</span><br><span class="line">centroids</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([[4.18354619, 2.3433686 ],[3.22403937, 0.17507507]])</span><br></pre></td></tr></table></figure>
<h2 id="k均值聚类"><a href="#k均值聚类" class="headerlink" title="k均值聚类"></a>k均值聚类</h2><p>这个基本的算法只需要明白两点。</p>
<ul>
<li>给定一组质心，则簇更新，所有的点被分配到离其最近的质心中。</li>
<li>给定k簇，则质心更新，所有的质心用其簇的均值替换</li>
</ul>
<p>当簇不在有更新的时候，迭代停止。当然kmeans有个缺点，就是可能陷入局部最小值，有改进的方法，比如二分k均值，当然也可以多计算几次，去效果好的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">data,k=<span class="number">2</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_distance</span>(<span class="params">p1,p2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return Eclud distance between two points.</span></span><br><span class="line"><span class="string">    p1 = np.array([0,0]), p2 = np.array([1,1]) =&gt; 1.414</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tmp = np.sum((p1-p2)**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(tmp)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_rand_center</span>(<span class="params">data,k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate k center within the range of data set.&quot;&quot;&quot;</span></span><br><span class="line">    n = data.shape[<span class="number">1</span>] <span class="comment"># features</span></span><br><span class="line">    centroids = np.zeros((k,n)) <span class="comment"># init with (0,0)....</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dmin, dmax = np.min(data[:,i]), np.max(data[:,i])</span><br><span class="line">        centroids[:,i] = dmin + (dmax - dmin) * np.random.rand(k)</span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_converged</span>(<span class="params">centroids1, centroids2</span>):</span></span><br><span class="line">    <span class="comment"># if centroids not changed, we say &#x27;converged&#x27;</span></span><br><span class="line">      set1 = set([tuple(c) <span class="keyword">for</span> c <span class="keyword">in</span> centroids1])</span><br><span class="line">      set2 = set([tuple(c) <span class="keyword">for</span> c <span class="keyword">in</span> centroids2])</span><br><span class="line">      <span class="keyword">return</span> (set1 == set2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  n = data.shape[<span class="number">0</span>] <span class="comment"># number of entries</span></span><br><span class="line">  centroids = _rand_center(data,k)</span><br><span class="line">  label = np.zeros(n,dtype=np.int) <span class="comment"># track the nearest centroid</span></span><br><span class="line">  assement = np.zeros(n) <span class="comment"># for the assement of our model</span></span><br><span class="line">  converged = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> converged:</span><br><span class="line">    old_centroids = np.copy(centroids)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">      <span class="comment"># determine the nearest centroid and track it with label</span></span><br><span class="line">      min_dist, min_index = np.inf, <span class="number">-1</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">        dist = _distance(data[i],centroids[j])</span><br><span class="line">        <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">          min_dist, min_index = dist, j</span><br><span class="line">          label[i] = j</span><br><span class="line">      assement[i] = _distance(data[i],centroids[label[i]])**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># update centroid</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(k):</span><br><span class="line">      centroids[m] = np.mean(data[label==m],axis=<span class="number">0</span>)</span><br><span class="line">    converged = _converged(old_centroids,centroids)</span><br><span class="line">  <span class="keyword">return</span> centroids, label, np.sum(assement)</span><br></pre></td></tr></table></figure>
<p>由于算法可能局部收敛的问题，随机多运行几次，取最优值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">best_assement = np.inf</span><br><span class="line">best_centroids = <span class="literal">None</span></span><br><span class="line">best_label = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">  centroids, label, assement = kmeans(data,<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> assement &lt; best_assement:</span><br><span class="line">    best_assement = assement</span><br><span class="line">    best_centroids = centroids</span><br><span class="line">    best_label = label</span><br><span class="line"></span><br><span class="line">data0 = data[best_label==<span class="number">0</span>]</span><br><span class="line">data1 = data[best_label==<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>如下图，我们把数据分为两簇，绿色的点是每个簇的质心。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1,ax2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">12</span>,<span class="number">5</span>))</span><br><span class="line">ax1.scatter(data[:,<span class="number">0</span>],data[:,<span class="number">1</span>],c=<span class="string">&#x27;c&#x27;</span>,s=<span class="number">30</span>,marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">ax2.scatter(data0[:,<span class="number">0</span>],data0[:,<span class="number">1</span>],c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax2.scatter(data1[:,<span class="number">0</span>],data1[:,<span class="number">1</span>],c=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">ax2.scatter(centroids[:,<span class="number">0</span>],centroids[:,<span class="number">1</span>],c=<span class="string">&#x27;b&#x27;</span>,s=<span class="number">120</span>,marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://mitscherlich.me/assets/k-means/output.png"><img src="http://mitscherlich.me/assets/k-means/output.png" alt="img"></a></p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"># 机器学习</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2017/09/01/Linux/Linux%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86/">Linux之进程调度管理</a>
            
            
            <a class="next" rel="next" href="/2017/09/01/Linux/%E8%B8%A9%E5%9D%91%E8%AE%B0%E4%B9%8Bzsh%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E6%89%BE/">踩坑记之zsh不兼容通配符查找</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span><a href="https://blog.maywzh.com" target="_blank">© maywzh</a>
            
        </span>
        
        <span> | <a href="https://beian.miit.gov.cn" target="_blank">鄂ICP备2020015912号-1</a></span>
        
    </div>
</footer>
    </div>
</body>
</html>
