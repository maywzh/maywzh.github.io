<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="author" content="maywzh">


<meta name="subtitle" content="0x01 MAYSTORY">


<meta name="description" content="Namasday.">


<meta name="keywords" content="Tech Blogs">


<title>CPU的工作原理 | 0x01 MAYSTORY </title>


    
    <link rel="icon" href="/bitbug_favicon_128s.ico">
    

    
    
    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    
    
    
    
    
    
    
    
<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">梅故事壹</a> | <a
                    href="/">0x01 MAYSTORY</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">梅故事壹</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CPU的工作原理</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">maywzh</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 10, 2017&nbsp;&nbsp;11:33:47</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>CPU 的全称是 <code>Central Processing Unit</code>，即中央处理单元，是计算机的核心部件-计算部件。CPU 的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段：<strong>提取，解码和执行</strong>。CPU从系统的主存中提取指令，然后解码该指令的实际内容，然后再由 CPU 的相关部分执行该指令。</p>
<a id="more"></a>
<h3 id="计算机内部处理过程"><a href="#计算机内部处理过程" class="headerlink" title="计算机内部处理过程"></a>计算机内部处理过程</h3><p>以C语言为例来说明程序运行流程：</p>
<p><img src="https://i.loli.net/2020/08/22/NHXAQos2fRl53ZL.jpg" alt="运行流程"></p>
<p>在这个流程中，CPU 负责的就是解释和运行最终转换成机器语言的内容。<br>CPU 主要由两部分构成：控制单元 和 算术逻辑单元（ALU）</p>
<p>控制单元：从内存中提取指令并解码执行<br>算数逻辑单元（ALU）：处理算数和逻辑运算</p>
<p>CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。它与输入/输出（I / O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。<br>从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。</p>
<p><img src="https://i.loli.net/2020/08/22/hHwJPmTrgZDXafE.jpg" alt="cpu部件"></p>
<p><strong>寄存器</strong>是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20 - 100个寄存器。</p>
<p><strong>控制器</strong>负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</p>
<p><strong>运算器</strong>负责运算从内存中读入寄存器的数据</p>
<p><strong>时钟</strong>负责发出 CPU 开始计时的时钟信号</p>
<h3 id="CPU-是一系列寄存器的集合体"><a href="#CPU-是一系列寄存器的集合体" class="headerlink" title="CPU 是一系列寄存器的集合体"></a>CPU 是一系列寄存器的集合体</h3><p>控制器、运算器、时钟都是基于数字电路原理，在计算机科学中主要关注寄存器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>累加寄存器</td>
<td>存储运行的数据和运算后的数据。</td>
</tr>
<tr>
<td>标志寄存器</td>
<td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。</td>
</tr>
<tr>
<td>程序计数器</td>
<td>程序计数器是用于存放下一条指令所在单元的地址的地方。</td>
</tr>
<tr>
<td>基址寄存器</td>
<td>存储数据内存的起始位置</td>
</tr>
<tr>
<td>变址寄存器</td>
<td>存储基址寄存器的相对地址</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>存储任意数据</td>
</tr>
<tr>
<td>指令寄存器</td>
<td>储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td>
</tr>
<tr>
<td>栈寄存器</td>
<td>存储栈区域的起始位置</td>
</tr>
</tbody>
</table>
</div>
<p>其中<strong>程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器</strong>都只有一个，其他寄存器一般有多个。</p>
<p><img src="https://i.loli.net/2020/08/22/6TfRVKgohB1EdUI.jpg" alt="CPU寄存器"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><code>程序计数器(Program Counter)</code>是用来存储下一条指令所在单元的地址。</p>
<p>程序执行时，PC的初值为程序第一条指令的地址，在顺序执行程序时，<code>控制器</code>首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将PC的值加1指向下一条要执行的指令。</p>
<p>我们还是以一个事例为准来详细的看一下程序计数器的执行过程</p>
<p><img src="https://i.loli.net/2020/08/22/b9s4MyeLopKfaJE.jpg" alt="程序计数器"></p>
<p>这是一段进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。</p>
<p>地址 <code>0100</code> 是程序运行的起始位置。Windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器作为设定为起始位置 0100，然后执行程序，每执行一条指令后，程序计数器的数值会增加1（或者直接指向下一条指令的地址），然后，CPU 就会根据程序计数器的数值，从内存中读取命令并执行，也就是说，<strong>程序计数器控制着程序的流程</strong>。</p>
<h4 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h4><p>高级语言中的条件控制流程主要分为三种：<code>顺序执行、条件分支、循环判断</code>三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。</p>
<ul>
<li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li>
<li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li>
</ul>
<p>下面以条件分支为例来说明程序的执行过程（循环也很相似）</p>
<p><img src="https://i.loli.net/2020/08/22/muNPLRZGkgwisQ8.jpg" alt="条件分支和循环机制"></p>
<p>程序的开始过程和顺序流程是一样的，CPU 从0100处开始执行命令，在0100和0101都是顺序执行，PC 的值顺序+1，执行到0102地址的指令时，判断0106寄存器的数值大于0，跳转（jump）到0104地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 <code>if()</code> 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。</p>
<h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>条件和循环分支会使用到 <code>jump（跳转指令）</code>，会根据当前的指令来判断是否跳转，上面我们提到了<code>标志寄存器</code>，无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存</p>
<p>CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定，运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为1时，分别代表着正数、零和负数。</p>
<p>CPU 的执行机制比较有意思，假设累加寄存器中存储的 XXX 和通用寄存器中存储的 YYY 做比较，执行比较的背后，CPU 的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示 XXX 比 YYY 大，结果为零表示 XXX 和 YYY 相等，结果为负表示 XXX 比 YYY 小。<strong>程序比较的指令，实际上是在 CPU 内部做减法运算。</strong></p>
<p><img src="https://i.loli.net/2020/08/22/6B2wr1Zh3okmODN.jpg" alt="标志寄存器"></p>
<h4 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h4><p>接下来，我们继续介绍函数调用机制，哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后，必须进行返回处理，单纯的指令跳转没有意义，下面是一个实现函数跳转的例子</p>
<p><img src="https://i.loli.net/2020/08/22/8cruihwQzUC1HAM.jpg" alt="程序调用"></p>
<p>图中将变量 a 和 b 分别赋值为 123 和 456 ，调用 MyFun(a,b) 方法，进行指令跳转。图中的地址是将 C 语言编译成机器语言后运行时的地址，由于1行 C 程序在编译后通常会变为多行机器语言，所以图中的地址是分散的。在执行完 MyFun(a,b)指令后，程序会返回到 MyFun(a,b) 的下一条指令，CPU 继续执行下面的指令。</p>
<p>函数的调用和返回很重要的两个指令是 <code>call</code> 和 <code>return</code> 指令，再将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 指令。return 指令的功能是把保存在栈中的地址设定到程序计数器。MyFun 函数在被调用之前，0154 地址保存在栈中，MyFun 函数处理完成后，会把 0154 的地址保存在程序计数器中。这个调用过程如下</p>
<p><img src="https://i.loli.net/2020/08/22/vnrEX81DhKyRsjM.jpg" alt="call与return"></p>
<p>在一些高级语言的条件或者循环语句中，函数调用的处理会转换成 call 指令，函数结束后的处理则会转换成 return 指令。</p>
<h4 id="通过地址和索引实现数组"><a href="#通过地址和索引实现数组" class="headerlink" title="通过地址和索引实现数组"></a>通过地址和索引实现数组</h4><p>接下来我们看一下基址寄存器和变址寄存器，通过这两个寄存器，我们可以对主存上的特定区域进行划分，来实现类似数组的操作，首先，我们用十六进制数将计算机内存上的 00000000 - FFFFFFFF 的地址划分出来。那么，凡是该范围的内存地址，只要有一个 32 位的寄存器，便可查看全部地址。但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话，使用两个寄存器会更加方便。</p>
<p>例如，我们用两个寄存器（基址寄存器和变址寄存器）来表示内存的值</p>
<p><img src="https://i.loli.net/2020/08/22/8mMGZuRozht7e5p.jpg" alt="数组"></p>
<p>这种表示方式很类似数组的构造，<code>数组</code>是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值，通过索引来区分数组的各个数据元素，例如: a[0] - a[4]，<code>[]</code>内的 0 - 4 就是数组的下标。</p>
<h3 id="CPU-指令执行过程"><a href="#CPU-指令执行过程" class="headerlink" title="CPU 指令执行过程"></a>CPU 指令执行过程</h3><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：<strong>取指令、指令译码、执行指令、访存取数、结果写回</strong>。</p>
<ul>
<li><code>取指令</code>阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址</li>
<li><code>指令译码</code>阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</li>
<li><code>执行指令</code>阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。</li>
<li><code>访问取数</code>阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li>
<li><code>结果写回</code>阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；</li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/CPU/"># CPU</a>
                    
                        <a href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"># 组成原理</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2017/10/11/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98/">内存的工作原理</a>
            
            
            <a class="next" rel="next" href="/2017/09/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8BRaft%E7%AE%97%E6%B3%95/">分布式协议之Raft算法</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span><a href="https://blog.maywzh.com" target="_blank">© maywzh</a>
            
        </span>
        
        <span> | <a href="https://beian.miit.gov.cn" target="_blank">鄂ICP备2020015912号-1</a></span>
        
        
        <span> | <img src="https://pic3.zhimg.com/80/v2-d0289dc0a46fc5b15b3363ffa78cf6c7.png" style="width:16px;"><a
                href="http://www.beian.gov.cn/" target="_blank">赣公网安备36040302000263号</a></span>
        
    </div>
</footer>
    </div>
</body>
</html>
