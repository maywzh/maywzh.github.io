<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/08/22/pePJMKDAr7o4OQ3.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>内存的工作原理</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>把CPU作为大脑的话，CPU缓存是人的瞬时记忆，内存是人的短时记忆，磁盘是人的长时记忆。那么CPU如何与内存交互?</p>
<a id="more"></a>
<h3 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h3><p>内存（Memory）是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为<code>主存</code>，其作用是存放 CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结果传送出来，主存的运行也决定了计算机的稳定运行。</p>
<p>内存是易失性存储，与磁盘不同，掉电则失去所有数据。</p>
<h3 id="内存的物理结构"><a href="#内存的物理结构" class="headerlink" title="内存的物理结构"></a>内存的物理结构</h3><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器</p>
<ul>
<li>随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 <code>丢失</code>。</li>
<li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。</li>
<li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存<code>更快</code>的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据。</li>
</ul>
<p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图</p>
<p><img src="https://i.loli.net/2020/08/22/Lch5xOsutFeQYB9.jpg" alt="物理模型"></p>
<p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，<strong>+5V 表示1，0V 表示 0</strong>。</p>
<p>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = <code>1024个地址</code>。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p>
<h3 id="内存的读写过程"><a href="#内存的读写过程" class="headerlink" title="内存的读写过程"></a>内存的读写过程</h3><p>让我们把关注点放在内存 IC 对数据的读写过程上来吧！我们来看一个对内存IC 进行数据写入和读取的模型</p>
<p><img src="https://i.loli.net/2020/08/22/u1vzTSMIFcqfehA.jpg" alt="读写过程"></p>
<p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p>
<ul>
<li>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 <code>A0 - A9</code> 来指定数据的存储场所，然后再把数据的值输入给 <code>D0 - D7</code> 的数据信号，并把 <code>WR（write）</code>的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据</li>
<li>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。</li>
<li>图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。</li>
</ul>
<h3 id="内存的现实模型"><a href="#内存的现实模型" class="headerlink" title="内存的现实模型"></a>内存的现实模型</h3><p>为了便于记忆，我们把内存模型映射成为我们现实世界的模型，在现实世界中，内存的模型很想我们生活的楼房。在这个楼房中，1层可以存储一个字节的数据，楼层号就是<code>地址</code>，下面是内存和楼层整合的模型图</p>
<p><img src="https://i.loli.net/2020/08/22/wy5ebZ4inc3QAHh.jpg" alt="内存模型"></p>
<p>我们知道，程序中的数据不仅只有数值，还有<code>数据类型</code>的概念，从内存上来看，就是占用内存大小（占用楼层数）的意思。即使物理上强制以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其数据类型，也能实现以特定字节数为单位来进行读写。、</p>
<h3 id="内存与磁盘的关系"><a href="#内存与磁盘的关系" class="headerlink" title="内存与磁盘的关系"></a>内存与磁盘的关系</h3><p>计算机最主要的存储部件是内存和磁盘。<strong>磁盘中存储的程序必须加载到内存中才能运行</strong>，在磁盘中保存的程序是无法直接运行的，这是因为负责解析和运行程序内容的 CPU 是需要通过程序计数器来指定内存地址从而读出程序指令的。</p>
<p><img src="https://i.loli.net/2020/08/22/lPBhsc7DZFxkMzC.jpg" alt="1ae073cb-2a7f-4404-8f8a-681fed48f2c3"></p>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>我们上面提到，磁盘往往和内存是互利共生的关系，相互协作，彼此持有良好的合作关系。每次内存都需要从磁盘中读取数据，必然会读到相同的内容，所以一定会有一个角色负责存储我们经常需要读到的内容。 我们大家做软件的时候经常会用到<code>缓存技术</code>，那么硬件层面也不例外，磁盘也有缓存，磁盘的缓存叫做<code>磁盘缓存</code>。</p>
<p>磁盘缓存指的是把从磁盘中读出的数据存储到内存的方式，这样一来，当接下来需要读取相同的内容时，就不会再通过实际的磁盘，而是通过磁盘缓存来读取。某一种技术或者框架的出现势必要解决某种问题的，那么磁盘缓存就大大<strong>改善了磁盘访问的速度</strong>。</p>
<p><img src="https://i.loli.net/2020/08/22/nv6VdCAOwjXh3W1.jpg" alt="3cfa9bac-5a56-44ed-b3f9-49db0d00b005"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。它是内存和磁盘交互的第二个媒介。虚拟内存是指把磁盘的一部分作为<code>假想内存</code>来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p><img src="https://i.loli.net/2020/08/22/c3j2rNJyp5xvaq1.png" alt="虚拟地址映射"></p>
<h4 id="虚拟内存与内存的交换方式"><a href="#虚拟内存与内存的交换方式" class="headerlink" title="虚拟内存与内存的交换方式"></a>虚拟内存与内存的交换方式</h4><p>虚拟内存的方法有<code>分页式</code> 和 <code>分段式</code> 两种。Windows 采用的是分页式。该方式是指在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以<code>页</code>为单位进行置换。在分页式中，我们把磁盘的内容读到内存中称为 <code>Page In</code>，把内存的内容写入磁盘称为 <code>Page Out</code>。Windows 计算机的页大小为 4KB ，也就是说，需要把应用程序按照 4KB 的页来进行切分，以页（page）为单位放到磁盘中，然后进行置换。</p>
<p><img src="https://i.loli.net/2020/08/22/tJE5glHcFyeYjUO.jpg" alt="60a51c98-4dbd-4813-a3a3-172c159f2174"> </p>
<p>为了实现内存功能，Windows 在磁盘上提供了虚拟内存使用的文件（page file，页文件）。该文件由 Windows 生成和管理，文件的大小和虚拟内存大小相同，通常大小是内存的 1 - 2 倍。</p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<p><img src="http://www.c-jump.com/CIS77/asm_images/memory_paging.png" alt="memory_paging"></p>
<p><img src="http://www.c-jump.com/CIS77/asm_images/virtual_2_physical.png" alt="virtual_2_physical"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixfang/p/3420462.html">https://www.cnblogs.com/felixfang/p/3420462.html</a></p>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div>
</body>





</html>