<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/uncategorized/">uncategorized</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/08/29/W4Mmi1SLqHOtcpb.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>Docker 核心技术与原理初探</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>提到虚拟化技术，我们首先想到的一定是 Docker，经过四年的快速发展 Docker 已经成为了很多公司的标配，也不再是一个只能在开发阶段使用的玩具了。作为在生产环境中广泛应用的产品，Docker 有着非常成熟的社区以及大量的使用者，代码库中的内容也变得非常庞大。</p>
<p>Docker 目前的组件相当多，并且实现也非常复杂，本文忽略繁杂的细节，集中探讨 Docker 的一些基础技术原理。</p>
<a id="more"></a>
<h2><span id="容器虚拟机">容器？虚拟机？</span></h2><p>容器和虚拟机是非常相似的技术概念，因为他们都提供了隔离应用和依赖环境的能力，都可以看作是提供了一个沙箱环境，使得应用都可以部署在任意宿主机。但两者的底层原理有所不同。</p>
<h3><span id="虚拟机">虚拟机 </span></h3><p> 虚拟机理论上是一个真实的计算机操作系统的封装，它运行在物理设备之上，通过 Hypervisor 进行建立和运行虚拟机体系。常见的虚拟基本架构如下：</p>
<p><img src="https://i.loli.net/2020/09/02/Crgxi5A8OtdD6V1.png" alt="2019-07-31-15-40-55"></p>
<p>在 Host OS 的基础上，通过 Hypervisor 来进行虚拟机资源控制，并拥有自己的 Guest OS，虽然隔离得更彻底，但是显然资源的开销会更大。</p>
<h3><span id="容器">容器 </span></h3><p> 不同于虚拟机提供在物理硬件级别的操作系统隔离，容器技术提供的是操作系统级别的进程隔离，Docker 本身只是操作系统的一个进程，只是在容器技术下，进程之间网络、空间等等是隔离的，互不知道彼此。</p>
<p><img src="https://i.loli.net/2020/08/29/rhYdmqNQnzajc3f.png" alt="docker-core-techs"></p>
<p><strong>容器与虚拟机技术最大的区别在于：多个容器之间是共享了宿主机的操作系统内核</strong>。在 Host OS 上，通过 Docker Engine 共享 Host OS 的内核：</p>
<p><img src="https://i.loli.net/2020/09/02/OgkzsIcBhWbL1nH.png" alt="img"></p>
<p>首先，Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。</p>
<h2><span id="资源隔离命名空间-namespaces">资源隔离：命名空间 Namespaces</span></h2><p>命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到 <strong> 完全隔离</strong>，就像运行在多台不同的机器上一样。</p>
<p><img src="https://i.loli.net/2020/08/29/7XbSceY8OupAmgN.png" alt="multiple-servers-on-linux"></p>
<p>在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这也是我们不想看到的，而 Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。</p>
<p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 <code>CLONE_NEWCGROUP</code>、<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWNS</code>、<code>CLONE_NEWPID</code>、<code>CLONE_NEWUSER</code> 和 <code>CLONE_NEWUTS</code>，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p>
<h3><span id="进程">进程 </span></h3><p> 进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。在每一个 *nix 的操作系统上，我们都能够通过 <code>ps</code> 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> Apr08 ?        00:00:09 /sbin/init
root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:05 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">7</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:07:10 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
root        <span class="token number">39</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span>
root        <span class="token number">40</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:01:54 <span class="token punctuation">[</span>watchdog/0<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 <code>pid</code> 为 1 的 <code>/sbin/init</code> 进程，另一个是 <code>pid</code> 为 2 的 <code>kthreadd</code> 进程，这两个进程都是被 Linux 中的上帝进程 <code>idle</code> 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 <code>getty</code> 的注册进程，而后者负责管理和调度其他的内核进程。</p>
<p><img src="https://i.loli.net/2020/08/29/ecHLJgxUOtnXKGa.png" alt="linux-processes"></p>
<p>如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 <code>exec</code> 进入其内部的 <code>bash</code> 并打印其中的全部进程，我们会得到以下的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@iZ255w13cy6Z:~<span class="token comment"># docker run -it -d ubuntu</span>
b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79
root@iZ255w13cy6Z:~<span class="token comment"># docker exec -it b809a2eb3630 /bin/bash</span>
root@b809a2eb3630:/<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">15</span>:42 pts/0    00:00:00 /bin/bash
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">15</span>:42 pts/1    00:00:00 /bin/bash
root        <span class="token number">17</span>     <span class="token number">9</span>  <span class="token number">0</span> <span class="token number">15</span>:43 pts/1    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在新的容器内部执行 <code>ps</code> 命令打印出了非常干净的进程列表，只有包含当前 <code>ps -ef</code> 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。</p>
<p>当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root     <span class="token number">29407</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov16 ?        00:08:38 /usr/bin/dockerd --raw-logs
root      <span class="token number">1554</span> <span class="token number">29407</span>  <span class="token number">0</span> Nov19 ?        00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval<span class="token operator">=</span><span class="token number">0</span> --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc
root      <span class="token number">5006</span>  <span class="token number">1554</span>  <span class="token number">0</span> 08:38 ?        00:00:00 docker-containerd-shim b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 /var/run/docker/libcontainerd/b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 docker-runc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树：</p>
<p><img src="https://i.loli.net/2020/08/29/jrcaVNQ1OYteB3h.png" alt="docker-process-group"></p>
<p>这就是在使用 <code>clone(2)</code> 创建新进程时传入 <code>CLONE_NEWPID</code> 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">containerRouter.postContainersStart
└── daemon.ContainerStart
    └── daemon.createSpec
        └── setNamespaces
            └── setNamespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 <code>docker run</code> 或者 <code>docker start</code> 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">)</span> <span class="token function">createSpec</span><span class="token punctuation">(</span>c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> oci<span class="token punctuation">.</span><span class="token function">DefaultSpec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"linux spec namespaces: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>setNamespaces</code> 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">,</span> s <span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// user</span>
	<span class="token comment">// network</span>
	<span class="token comment">// ipc</span>
	<span class="token comment">// uts</span>

	<span class="token comment">// pid</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ns <span class="token operator">:=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"pid"</span><span class="token punctuation">&#125;</span>
		pc<span class="token punctuation">,</span> err <span class="token operator">:=</span> daemon<span class="token punctuation">.</span><span class="token function">getPidContainer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">&#125;</span>
		ns<span class="token punctuation">.</span>Path <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"/proc/%d/ns/pid"</span><span class="token punctuation">,</span> pc<span class="token punctuation">.</span>State<span class="token punctuation">.</span><span class="token function">GetPID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		oci<span class="token punctuation">.</span><span class="token function">RemoveNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> specs<span class="token punctuation">.</span><span class="token function">LinuxNamespaceType</span><span class="token punctuation">(</span><span class="token string">"pid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		ns <span class="token operator">:=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"pid"</span><span class="token punctuation">&#125;</span>
		<span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有命名空间相关的设置 <code>Spec</code> 最后都会作为 <code>Create</code> 函数的入参在创建新的容器时进行设置：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">daemon<span class="token punctuation">.</span>containerd<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> spec<span class="token punctuation">,</span> createOptions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔离。</p>
<h3><span id="网络">网络 </span></h3><p> 如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却又没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p>
<p>每一个使用 <code>docker run</code> 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。</p>
<p><img src="https://i.loli.net/2020/08/29/PvBQqfkS3N1mpxi.png" alt="docker-network"></p>
<p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。</p>
<p><img src="https://i.loli.net/2020/08/29/J7uD3G9gSd6eO1l.png" alt="docker-network-topology"></p>
<p>在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。我们可以使用如下的命令来查看当前网桥的接口：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ brctl show
bridge name	bridge <span class="token function">id</span>		STP enabled	interfaces
docker0		<span class="token number">8000</span>.0242a6654980	no		veth3e84d4f
							            veth9953b75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>docker0 会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ iptables -t nat -L
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
RETURN     all  --  anywhere             anywhere<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在当前的机器上使用 <code>docker run -d -p 6379:6379 redis</code> 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 <code>iptables</code> 的 NAT 配置就会看到在 <code>DOCKER</code> 的链中出现了一条新的规则：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">DNAT       tcp  --  anywhere             anywhere             tcp dpt:6379 to:192.168.0.4:6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。</p>
<p>这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ping</span> <span class="token number">192.168</span>.0.4
PING <span class="token number">192.168</span>.0.4 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.4<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.069</span> ms
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.043</span> ms
^C
--- <span class="token number">192.168</span>.0.4 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 999ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.043</span>/0.056/0.069/0.013 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。</p>
<p><img src="https://i.loli.net/2020/08/29/dax5mACvb6NHfEF.png" alt="docker-network-forward"></p>
<p>当我们使用 <code>redis-cli</code> 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6379</span> <span class="token function">ping</span>
PONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p>
<h4><span id="libnetwork">libnetwork</span></h4><p>整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的 <strong> 容器网络模型</strong>。</p>
<blockquote>
<p>The goal of libnetwork is to deliver a robust Container Network Model that provides a consistent programming interface and the required network abstractions for applications.</p>
</blockquote>
<p>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network：</p>
<p><img src="https://i.loli.net/2020/08/29/T5mjHLCXvh4J3tu.png" alt="container-network-model"></p>
<p>在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</p>
<blockquote>
<p>想要获得更多与 libnetwork 或者容器网络模型相关的信息，可以阅读 <a target="_blank" rel="noopener" href="https://github.com/docker/libnetwork/blob/master/docs/design.md">Design · libnetwork</a> 了解更多信息，当然也可以阅读源代码了解不同 OS 对容器网络模型的不同实现。</p>
</blockquote>
<h3><span id="挂载点">挂载点 </span></h3><p> 虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p>
<p>在新的进程中创建隔离的挂载点命名空间需要在 <code>clone</code> 函数中传入 <code>CLONE_NEWNS</code>，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数 <strong> 子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统</strong>。</p>
<p>如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。</p>
<p><img src="https://i.loli.net/2020/08/29/YL8jAqxevWuZPSy.png" alt="libcontainer-filesystem"></p>
<p>想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。</p>
<p><img src="https://i.loli.net/2020/08/29/M7dcRLkSNeVHbj6.png" alt="libcontainer-symlinks-and-io"></p>
<p>为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcontainer 提供的 <code>pivot_root</code> 或者 <code>chroot</code> 函数改变进程能够访问个文件目录的根节点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// pivor_root</span>
put_old <span class="token operator">=</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pivot_root</span><span class="token punctuation">(</span>rootfs<span class="token punctuation">,</span> put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unmount</span><span class="token punctuation">(</span>put_old<span class="token punctuation">,</span> MS_DETACH<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">rmdir</span><span class="token punctuation">(</span>put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chroot</span>
<span class="token function">mount</span><span class="token punctuation">(</span>rootfs<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> MS_MOVE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chroot</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。</p>
<blockquote>
<p>这一部分的内容是作者在 libcontainer 中的 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md">SPEC.md</a> 文件中找到的，其中包含了 Docker 使用的文件系统的说明，对于 Docker 是否真的使用 <code>chroot</code> 来确保当前的进程无法访问宿主机器的目录，作者其实也 <strong> 没有确切的答案 </strong>，一是 Docker 项目的代码太多庞大，不知道该从何入手，作者尝试通过 Google 查找相关的结果，但是既找到了无人回答的 <a target="_blank" rel="noopener" href="https://forums.docker.com/t/does-the-docker-engine-use-chroot/25429"> 问题 </a>，也得到了与 SPEC 中的描述有冲突的 <a target="_blank" rel="noopener" href="https://www.quora.com/Do-Docker-containers-use-a-chroot-environment"> 答案</a> ，如果各位读者有明确的答案可以在博客下面留言，非常感谢。</p>
</blockquote>
<h3><span id="chroot">chroot</span></h3><p>在这里不得不简单介绍一下 <code>chroot</code>（change root），在 Linux 系统中，系统默认的目录就都是以 <code>/</code> 也就是根目录开头的，<code>chroot</code> 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p>
<blockquote>
<p>与 chroot 的相关内容部分来自 <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html">理解 chroot</a> 一文，各位读者可以阅读这篇文章获得更详细的信息。</p>
</blockquote>
<h2><span id="资源限制cgroups">资源限制：CGroups</span></h2><p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。</p>
<p><img src="https://i.loli.net/2020/08/29/os4E8KvWazui521.png" alt="docker-shared-resources"></p>
<p>如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p>
<p>每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p>
<p><img src="https://i.loli.net/2020/08/29/AfvxM3omeE7Tudp.png" alt="cgroups-inheritance"></p>
<p>Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配，CGroup 能够提供以下的几种功能：</p>
<p><img src="https://i.loli.net/2020/08/29/kI4HhGTte6aAymd.png" alt="groups-features"></p>
<blockquote>
<p>在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。</p>
<p>– <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">CGroup 介绍、应用实例及原理描述</a></p>
</blockquote>
<p>Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ lssubsys -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。</p>
<p>如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 docker 的文件夹：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ls</span> cpu
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
docker  
notify_on_release 
release_agent 
tasks

$ <span class="token function">ls</span> cpu/docker/
9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
notify_on_release 
release_agent 
tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>9c3057xxx</code> 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：</p>
<p><img src="https://i.loli.net/2020/08/29/wXYPHcUyBrVfTWN.png" alt="linux-cgroups"></p>
<p>每一个 CGroup 下面都有一个 <code>tasks</code> 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，<code>cpu.cfs_quota_us</code> 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<p>如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 <code>docker</code> 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -it -d --cpu-quota<span class="token operator">=</span><span class="token number">50000</span> busybox
53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274
$ <span class="token builtin class-name">cd</span> 53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274/
$ <span class="token function">ls</span>
cgroup.clone_children  cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.shares  cpu.stat  notify_on_release  tasks
$ <span class="token function">cat</span> cpu.cfs_quota_us
<span class="token number">50000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。</p>
<h2><span id="存储驱动unionfs">存储驱动：UnionFS</span></h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p>
<p>镜像到底是什么，它又是如何组成和组织的是作者使用 Docker 以来的一段时间内一直比较让作者感到困惑的问题，我们可以使用 <code>docker run</code> 非常轻松地从远程下载 Docker 的镜像并在本地运行。</p>
<p>Docker 镜像其实本质就是一个压缩包，我们可以使用下面的命令将一个 Docker 镜像中的文件导出：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker <span class="token builtin class-name">export</span> <span class="token variable"><span class="token variable">$(</span>docker create busybox<span class="token variable">)</span></span> <span class="token operator">|</span> <span class="token function">tar</span> -C rootfs -xvf -
$ <span class="token function">ls</span>
bin  dev  etc  home proc root sys  tmp  usr  var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可以看到这个 busybox 镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 <strong>Docker 镜像就是一个文件</strong>。</p>
<h3><span id="存储驱动">存储驱动</span></h3><p>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与 Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。</p>
<p>想要理解 Docker 使用的存储驱动，我们首先需要理解 Docker 是如何构建并且存储镜像的，也需要明白 Docker 的镜像是如何被每一个容器所使用的；Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntu:15.04
COPY . &#x2F;app
RUN make &#x2F;app
CMD python &#x2F;app&#x2F;app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>容器中的每一层都只对当前容器进行了非常小的修改，上述的 Dockerfile 文件会构建一个拥有四层 layer 的镜像：</p>
<p><img src="https://i.loli.net/2020/08/29/OjlPgrkvCB6QdA4.png" alt="docker-container-laye"></p>
<p>当镜像被 <code>docker run</code> 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。</p>
<p>容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。</p>
<p><img src="https://i.loli.net/2020/08/29/I3DQBAdHYpEbXWq.png" alt="docker-images-and-container"></p>
<h3><span id="aufs">AUFS</span></h3><p>其实在有了 Namespace 和 cgroups 的情况下，对于 Docker 项目的初始化可以简单抽象为：</p>
<ol>
<li>启动 Namespace 配置</li>
<li>设置 cgroups 参数，对资源进行限制</li>
<li>切换进程的根目录</li>
</ol>
<p>但是还有另外一个问题，<strong>是否每次打包、升级镜像都要重新走一遍整个初始化流程</strong>？这显然是不合理的。</p>
<p>Docker 中最典型的存储驱动就是 AUFS（Advanced Multi-layered unification filesytem），可以将 AUFS 想象为一个可以 “栈式叠加” 的文件系统，AUFS 允许在一个基础的文件系统的上，“增量式” 的增加文件。AUFS 支持将不同目录挂载到同一个目录下，这种挂载对用户来说是透明的。通常，AUFS 最上层是可读写层，而最底层是只读层，每一层都是一个普通的文件系统。</p>
<p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p>
<p>AUFS 作为联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为 <em> 联合挂载（Union Mount）</em>：</p>
<p><img src="https://i.loli.net/2020/08/29/GgsoNJSW7kFymVu.png" alt="docker-aufs"></p>
<p>每一个镜像层或者容器层都是 <code>/var/lib/docker/</code> 目录下的一个子文件夹；在 Docker 中，所有镜像层和容器层的内容都存储在 <code>/var/lib/docker/aufs/diff/</code> 目录中：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ls</span> /var/lib/docker/aufs/diff/00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c       93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8
00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c-init  93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8-init
019a8283e2ff6fca8d0a07884c78b41662979f848190f0658813bb6a9a464a90       93b06191602b7934fafc984fbacae02911b579769d0debd89cf2a032e7f35cfa
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而 <code>/var/lib/docker/aufs/layers/</code> 中存储着镜像层的元数据，每一个文件都保存着镜像层的元数据，最后的 <code>/var/lib/docker/aufs/mnt/</code> 包含镜像或者容器层的挂载点，最终会被 Docker 通过联合的方式进行组装。</p>
<p><img src="https://i.loli.net/2020/08/29/XxoDKUnTwsmidc5.png" alt="docker-filesystems"></p>
<p>上面的这张图片非常好的展示了组装的过程，每一个镜像层都是建立在另一个镜像层之上的，同时所有的镜像层都是只读的，只有每个容器最顶层的容器层才可以被用户直接读写，所有的容器都建立在一些底层服务（Kernel）上，包括命名空间、控制组、rootfs 等等，这种容器的组装方式提供了非常大的灵活性，只读的镜像层通过共享也能够减少磁盘的占用。</p>
<h4><span id="aufs-的读写操作">AUFS 的读写操作 </span></h4><h5><span id="读操作"> 读操作 </span></h5><p> 当需要 <strong> 写入 </strong> 一个文件时，不存在时则在可读写层新建一个，否则一直从向下寻找。</p>
<h5><span id="写操作">写操作 </span></h5><p> 当<strong>删除 </strong> 一个文件中，如果文件仅存在可读写层，则直接删除这个文件。</p>
<p>但是又有一个问题，如果删除的是只读层的文件呢？所以在这种情况下，会先删除可读写层中的备份，之后通过创建一个 whiteout 文件来标记文件不存在，这其实是一种 “遮挡”，只读层文件却不会被真正的删除，但是表现上确是已经被 “删除” 了。</p>
<p>当 <strong> 新建 </strong> 文件时，由于 whiteout 的 存在，所以需要先检查 whiteout 是否存在，存在的情况下，需要先删除再创建。</p>
<p>AUFS 只是 Docker 存储驱动的其中一种，在有些场景下并不是最优的选择，但都是属于 Union File System，主要是基于 “写时复制” 以及 “用时配置” 两种方式，但它能够有效帮助我们理解 Docker 的分层结构以及原理。其他的 Docker 存储驱动还有 OverlayFS、Devicemapper、Btrfs、ZFS 等，这里不再赘述。</p>
<h3><span id="其他存储驱动">其他存储驱动</span></h3><p>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 <code>aufs</code>、<code>devicemapper</code>、<code>overlay2</code>、<code>zfs</code> 和 <code>vfs</code> 等等，在最新的 Docker 中，<code>overlay2</code> 取代了 <code>aufs</code> 成为了推荐的存储驱动，但是在没有 <code>overlay2</code> 驱动的机器上仍然会使用 <code>aufs</code> 作为 Docker 的默认驱动。</p>
<p><img src="https://i.loli.net/2020/08/29/FaMDlpWB1UKAzYk.png" alt="docker-storage-driver"></p>
<p>不同的存储驱动在存储镜像和容器文件时也有着完全不同的实现，有兴趣的读者可以在 Docker 的官方文档 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/storagedriver/selectadriver/">Select a storage driver</a> 中找到相应的内容。</p>
<p>想要查看当前系统的 Docker 上使用了哪种存储驱动只需要使用以下的命令就能得到相对应的信息：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker info <span class="token operator">|</span> <span class="token function">grep</span> Storage
Storage Driver: aufs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="总结">总结</span></h2><p>Docker 目前已经成为了非常主流的技术，已经在很多成熟公司的生产环境中使用，但是 Docker 的核心技术其实已经有很多年的历史了，Linux 命名空间、控制组 Cgroups 和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。</p>
<h2><span id="参考文献">参考文献</span></h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.safaribooksonline.com/library/view/using-docker/9781491915752/ch04.html">Chapter 4. Docker Fundamentals · Using Docker by Adrian Mount</a></li>
<li><a target="_blank" rel="noopener" href="https://washraf.gitbooks.io/the-docker-ecosystem/content/Chapter 1/Section 3/techniques_behind_docker.html">TECHNIQUES BEHIND DOCKER</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/docker-overview/#the-underlying-technology">Docker overview</a></li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/312641/">Unifying filesystems with union mounts</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17061.html">DOCKER 基础技术：AUFS</a></li>
<li><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/">RESOURCE MANAGEMENT GUIDE</a></li>
<li><a target="_blank" rel="noopener" href="http://www.linuxjournal.com/article/7714">Kernel Korner - Unionfs: Bringing Filesystems Together</a></li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/325369/">Union file systems: Implementations, part I</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.docker.com/2016/05/docker-unikernels-open-source/">IMPROVING DOCKER WITH UNIKERNELS: INTRODUCING HYPERKIT, VPNKIT AND DATAKIT</a></li>
<li><a target="_blank" rel="noopener" href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces">Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html">理解 chroot</a></li>
<li><a target="_blank" rel="noopener" href="http://www.yolinux.com/TUTORIALS/LinuxTutorialInitProcess.html">Linux Init Process / PC Boot Procedure</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice#">Docker 网络详解及 pipework 源码解读与实践</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/default_network/container-communication/#communication-between-containers">Understand container communication</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/labs/blob/master/networking/concepts/05-bridge-networks.md">Docker Bridge Network Driver Architecture</a></li>
<li><a target="_blank" rel="noopener" href="http://www.thegeekstuff.com/2011/01/iptables-fundamentals/">Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iptables.info/en/structure-of-iptables.html">Traversing of tables and chains</a></li>
<li><a target="_blank" rel="noopener" href="http://dockone.io/article/1255">Docker 网络部分执行流分析（Libnetwork 源码解读）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/libnetwork/blob/master/docs/design.md">Libnetwork Design</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper">剖析 Docker 文件系统：Aufs 与 Devicemapper</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22889241/linux-understanding-the-mount-namespace-clone-clone-newns-flag">Linux - understanding the mount namespace &amp; clone CLONE_NEWNS flag</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation">Docker 背后的内核知识 —— Namespace 资源隔离</a></li>
<li><a target="_blank" rel="noopener" href="https://linuxcontainers.org/">Infrastructure for container projects</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md">Spec · libcontainer</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">DOCKER 基础技术：LINUX NAMESPACE（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17049.html">DOCKER 基础技术：LINUX CGROUP</a></li>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/65034">《自己动手写 Docker》书摘之三： Linux UnionFS</a></li>
<li><a target="_blank" rel="noopener" href="http://www.programering.com/a/MDMzAjMwATk.html">Introduction to Docker</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/v1.9/engine/userguide/storagedriver/imagesandcontainers/">Understand images, containers, and storage drivers</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/#configure-docker-with-the-aufs-storage-driver">Use the AUFS storage driver</a></li>
</ul>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>