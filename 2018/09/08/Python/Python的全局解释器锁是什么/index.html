<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="author" content="maywzh">


<meta name="subtitle" content="0x01 MAYSTORY">


<meta name="description" content="Namasday.">


<meta name="keywords" content="Tech Blogs">


<title>Python的全局解释器锁是什么 | 0x01 MAYSTORY </title>


    
    <link rel="icon" href="/bitbug_favicon_128s.ico">
    

    
    
    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    
    
    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    
    
    
    
    
    
    
    
<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">梅故事壹</a> | <a
                    href="/">0x01 MAYSTORY</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">梅故事壹</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://blog.maywzh.com">Blog</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://tech.maywzh.com">Tech</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python的全局解释器锁是什么</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">maywzh</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 8, 2018&nbsp;&nbsp;2:38:33</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>全局解释性锁，简称GIL(Global Interpreter Lock)，它是什么，官方有如下解释：</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<p>我们可以得出：</p>
<ul>
<li><code>GIL</code>在执行Python字节码时保护访问Python对象而阻止多个线程执行的互斥锁，主要因为CPython的解释器非线程安全。</li>
<li><code>GIL</code>非Python语言特性，而是依赖于解释器的实现，<code>CPython</code>实现了<code>GIL</code>机制</li>
<li><code>GIL</code>保证Python解释器运行时，同一时刻只有一个线程运行，保证内存管理安全</li>
<li>目前已经有许多功能依赖<code>GIL</code></li>
</ul>
<a id="more"></a>
<p>常见的Python解释器有如下几种，以及这些解释器是否存在<code>GIL</code>：</p>
<ul>
<li><code>CPython</code>：<code>C</code>语言开发的解释器，默认官方版本，使用最为广泛，有<code>GIL</code></li>
<li><code>IPython</code>：基于<code>CPython</code>开发的交互式解释器，只是增强了交互功能，执行功能与<code>CPython</code>完全一样</li>
<li><code>PyPy</code>：目标是加快执行速度，采用JIT技术，对Python代码进行动态编译（不是解释），可显著提高执行速度，但执行结果可能与<code>CPython</code>不同。有<code>GIL</code>，但其开发者宣布发布去掉<code>GIL</code>的版本</li>
<li><code>Jython</code>：运行在Java平台上的Python解释器，可以把Python代码编译成<code>Java</code>字节码，依赖<code>Java</code>平台，没有<code>GIL</code></li>
<li><code>IronPython</code>：和<code>Jython</code>类似，执行在微软<code>.Net</code>平台的Python解释器，可以把Python代码编译成<code>.Net</code>字节码依赖<code>.Net</code>平台，没有<code>GIL</code></li>
</ul>
<h2 id="GIL-Problem"><a href="#GIL-Problem" class="headerlink" title="GIL Problem:"></a>GIL Problem:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="number">1000000000</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2个线程执行loop方法</span></span><br><span class="line">t1 = threading.Thread(target=loop)</span><br><span class="line">t2 = threading.Thread(target=loop)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<p>上面这段代码，虽然开了2个线程执行，但我们观察CPU使用情况，发现其只能跑满一个核心。</p>
<p>由于<code>GIL</code>的存在，当线程被操作系统唤醒后，必须拿到<code>GIL</code>锁后才能执行代码，也就是说同一时刻永远只有一个线程在执行，这就导致如果我们的程序是CPU密集运算型的任务，那么使用Python多线程是不能提高效率的。</p>
<p>但即使有<code>GIL</code>的存在，理论来上来说，只要<code>GIL</code>释放的够勤快，多线程执行怎么也要比单线程效率高吧？</p>
<p>现实结果是：效率比我们想象的更糟糕！</p>
<ul>
<li>串行执行2次CPU密集型任务：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">time</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">def <span class="keyword">loop</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="number">5000000000</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 串行执行<span class="number">2</span>次CPU密集型任务</span><br><span class="line">    start = <span class="type">time</span>.time()</span><br><span class="line">    <span class="keyword">loop</span>()</span><br><span class="line">    <span class="keyword">loop</span>()</span><br><span class="line">    print <span class="type">time</span>.time() - <span class="keyword">start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"># <span class="number">540.302778006</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2个线程同时执行CPU密集型任务：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">time</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">def <span class="keyword">loop</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= <span class="number">5000000000</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # <span class="number">2</span>个线程同时执行CPU密集型任务</span><br><span class="line">    start = <span class="type">time</span>.time()</span><br><span class="line">    </span><br><span class="line">    t1 = threading.Thread(target=<span class="keyword">loop</span>)</span><br><span class="line">    t2 = threading.Thread(target=<span class="keyword">loop</span>)</span><br><span class="line">    t1.<span class="keyword">start</span>()</span><br><span class="line">    t2.<span class="keyword">start</span>()</span><br><span class="line">    t1.<span class="keyword">join</span>()</span><br><span class="line">    t2.<span class="keyword">join</span>()</span><br><span class="line">    </span><br><span class="line">    print <span class="type">time</span>.time() - <span class="keyword">start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"># <span class="number">573.972337961</span></span><br></pre></td></tr></table></figure>
<p>上面的代码分别模拟了一个CPU密集型任务在串行执行2次和2个线程同时执行的场景，执行结果发现，多线程的效率还不如串行效率高！</p>
<p>为什么会导致这种情况？我们来分析其背后的工作原理。</p>
<h2 id="How-GIL"><a href="#How-GIL" class="headerlink" title="How GIL?"></a>How GIL?</h2><p>由于Python的线程就是C语言的<code>pthread</code>，它是通过操作系统调度算法调度执行。而Python的执行是基于<code>opcode</code>数量的调度方式，简单来说就是每执行一定数量的字节码，或遇到系统IO时，会强制释放<code>GIL</code>，然后触发一次操作系统的线程调度。</p>
<h3 id="单核CPU下的多线程"><a href="#单核CPU下的多线程" class="headerlink" title="单核CPU下的多线程"></a>单核CPU下的多线程</h3><p>如果是单核CPU情况下，在多线程执行时，每次线程A释放<code>GIL</code>后，被唤醒的线程B能够立即拿到<code>GIL</code>，能够无缝执行，执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/PH9e8qMihbvyTDz.png" alt="1524717396"></p>
<h3 id="多核CPU下的多线程"><a href="#多核CPU下的多线程" class="headerlink" title="多核CPU下的多线程"></a>多核CPU下的多线程</h3><p>但在多核CPU情况下多线程执行时，一个线程在CPU0执行完之后释放<code>GIL</code>，其他CPU上的线程都会进行竞争，但CPU0可能又马上获取到了<code>GIL</code>，这就导致其他CPU上被唤醒的线程只能眼巴巴地看着CPU0上的线程欢快地执行着，而自己只能等待，直到又被切换到待调度的状态，这就会产生多核CPU频繁进行线程切换，消耗着资源，但只有一个线程能够拿到<code>GIL</code>真正执行Python代码，这就导致多线程在多核CPU情况下，效率还不如单线程执行效率高。执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/hGA8qPFcK2Vezr7.png" alt="1524709489"></p>
<p>绿色部分是线程获得了<code>GIL</code>并进行有效的CPU运算，红色部分是被唤醒的线程由于没有争夺到<code>GIL</code>，只能无效地等待，无法充分利用CPU的并行运算能力。这就是多线程在多核CPU下，执行效率还不如单线程或单核CPU效率高的原因。</p>
<h3 id="多线程IO密集型任务"><a href="#多线程IO密集型任务" class="headerlink" title="多线程IO密集型任务"></a>多线程IO密集型任务</h3><p>我们再进一步试想，如果多线程执行IO密集型任务，效率如何？</p>
<p>答案是比单线程效率要高。</p>
<p>这是由于IO密集型的任务，大部分时间都在等待IO上，很少消耗CPU的资源，所以在IO密集型任务的场景下，使用多线程是可以提升效率的。</p>
<h2 id="Why-GIL"><a href="#Why-GIL" class="headerlink" title="Why GIL?"></a>Why GIL?</h2><p>既然<code>GIL</code>的影响这么大，那为什么Python的解释器<code>CPython</code>在设计时要采用这种方式呢？</p>
<p>这就要追溯历史原因，2000年以前，各个CPU厂商都在努力提升核心频率从而提高计算机的性能，但到2000年以后逐渐遇到天花板，之后提升方向改为多核心方向。</p>
<p>为了更有效的利用多核心CPU，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。</p>
<p>Python设计者在设计解释器时，可能没有想到CPU的性能提升会这么快转为多核心方向发展，所以在当时的场景下，设计一个全局锁是那个时代保护多线程资源一致性的最简单经济的设计方案。</p>
<p>而随着多核心时代来临，当大家试图去拆分和去除<code>GIL</code>的时候，发现大量库的代码开发者已经重度依赖<code>GIL</code>（默认Pythonn内部对象是线程安全的，无需在开发时额外加锁），所以这个去除<code>GIL</code>的任务变得复杂且难以实现。</p>
<p>所以简单来说<code>GIL</code>的存在更多的是历史原因，如果推倒重来重新设计，面对多线程问题可能设计得会更为优雅。</p>
<h2 id="How-to-solve"><a href="#How-to-solve" class="headerlink" title="How to solve?"></a>How to solve?</h2><p>既然<code>GIL</code>存在会导致这么多问题，那我们有什么方式可以绕开这些问题，提高程序性能？总结如下：</p>
<ul>
<li>IO密集型任务场景，多线程可以提高运行效率（推荐）</li>
<li>使用没有<code>GIL</code>的Python解释器（不推荐）</li>
<li>CPU密集型任务场景，可改为多进程执行（推荐）</li>
<li>编写Python的C扩展模块，把CPU密集型任务交给C模块处理（编码复杂，不推荐）</li>
<li>更换其他语言实现CPU密集型任务</li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/10/10/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8BDiffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/">密码学之Diffie-Hellman密钥交换</a>
            
            
            <a class="next" rel="next" href="/2018/03/04/Redis/Redis%E8%AF%A6%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%A8%E9%80%94/">Redis详解之——特性与用途</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span><a href="https://blog.maywzh.com" target="_blank">© maywzh</a>
            
        </span>
        
        <span> | <a href="https://beian.miit.gov.cn" target="_blank">鄂ICP备2020015912号-1</a></span>
        
        
        <span> | <img src="http://www.beian.gov.cn/img/ghs.png" style="width:16px;"><a href="http://www.beian.gov.cn/"
                target="_blank">赣公网安备36040302000263号</a></span>
        
    </div>
</footer>
    </div>
</body>
</html>
