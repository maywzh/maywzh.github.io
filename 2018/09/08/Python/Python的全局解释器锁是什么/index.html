<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/09/08/7kMiOVb39dGHfmS.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>Python 的全局解释器锁是什么</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>全局解释性锁，简称 GIL(Global Interpreter Lock)，它是什么，官方有如下解释：</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<p>我们可以得出：</p>
<ul>
<li><code>GIL</code>在执行 Python 字节码时保护访问 Python 对象而阻止多个线程执行的互斥锁，主要因为 CPython 的解释器非线程安全。</li>
<li><code>GIL</code>非 Python 语言特性，而是依赖于解释器的实现，<code>CPython</code>实现了 <code>GIL</code> 机制</li>
<li><code>GIL</code>保证 Python 解释器运行时，同一时刻只有一个线程运行，保证内存管理安全</li>
<li>目前已经有许多功能依赖<code>GIL</code></li>
</ul>
<a id="more"></a>
<p>常见的 Python 解释器有如下几种，以及这些解释器是否存在<code>GIL</code>：</p>
<ul>
<li><code>CPython</code>：<code>C</code>语言开发的解释器，默认官方版本，使用最为广泛，有<code>GIL</code></li>
<li><code>IPython</code>：基于 <code>CPython</code> 开发的交互式解释器，只是增强了交互功能，执行功能与 <code>CPython</code> 完全一样</li>
<li><code>PyPy</code>：目标是加快执行速度，采用 JIT 技术，对 Python 代码进行动态编译（不是解释），可显著提高执行速度，但执行结果可能与 <code>CPython</code> 不同。有 <code>GIL</code>，但其开发者宣布发布去掉<code>GIL</code> 的版本</li>
<li><code>Jython</code>：运行在 Java 平台上的 Python 解释器，可以把 Python 代码编译成 <code>Java</code> 字节码，依赖 <code>Java</code> 平台，没有<code>GIL</code></li>
<li><code>IronPython</code>：和 <code>Jython</code> 类似，执行在微软 <code>.Net</code> 平台的 Python 解释器，可以把 Python 代码编译成 <code>.Net</code> 字节码依赖 <code>.Net</code> 平台，没有<code>GIL</code></li>
</ul>
<h2><span id="gil-problem">GIL Problem:</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading

<span class="token keyword">def</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> count <span class="token operator">&lt;=</span> <span class="token number">1000000000</span><span class="token punctuation">:</span>
        count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token comment"># 2 个线程执行 loop 方法</span>
t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>loop<span class="token punctuation">)</span>
t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>loop<span class="token punctuation">)</span>

t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这段代码，虽然开了 2 个线程执行，但我们观察 CPU 使用情况，发现其只能跑满一个核心。</p>
<p>由于 <code>GIL</code> 的存在，当线程被操作系统唤醒后，必须拿到 <code>GIL</code> 锁后才能执行代码，也就是说同一时刻永远只有一个线程在执行，这就导致如果我们的程序是 CPU 密集运算型的任务，那么使用 Python 多线程是不能提高效率的。</p>
<p>但即使有 <code>GIL</code> 的存在，理论来上来说，只要 <code>GIL</code> 释放的够勤快，多线程执行怎么也要比单线程效率高吧？</p>
<p>现实结果是：效率比我们想象的更糟糕！</p>
<ul>
<li>串行执行 2 次 CPU 密集型任务：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">import time
import threading

def loop():
    count &#x3D; 0
    while count &lt;&#x3D; 5000000000:
        count +&#x3D; 1


def main():
    # 串行执行 2 次 CPU 密集型任务
    start &#x3D; time.time()
    loop()
    loop()
    print time.time() - start

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    main()

# 540.302778006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>2 个线程同时执行 CPU 密集型任务：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">import time
import threading

def loop():
    count &#x3D; 0
    while count &lt;&#x3D; 5000000000:
        count +&#x3D; 1


def main():
    # 2 个线程同时执行 CPU 密集型任务
    start &#x3D; time.time()
    
    t1 &#x3D; threading.Thread(target&#x3D;loop)
    t2 &#x3D; threading.Thread(target&#x3D;loop)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    
    print time.time() - start

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    main()
    
# 573.972337961<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码分别模拟了一个 CPU 密集型任务在串行执行 2 次和 2 个线程同时执行的场景，执行结果发现，多线程的效率还不如串行效率高！</p>
<p>为什么会导致这种情况？我们来分析其背后的工作原理。</p>
<h2><span id="how-gil">How GIL?</span></h2><p>由于 Python 的线程就是 C 语言的 <code>pthread</code>，它是通过操作系统调度算法调度执行。而 Python 的执行是基于<code>opcode</code> 数量的调度方式，简单来说就是每执行一定数量的字节码，或遇到系统 IO 时，会强制释放<code>GIL</code>，然后触发一次操作系统的线程调度。</p>
<h3><span id="单核-cpu-下的多线程">单核 CPU 下的多线程 </span></h3><p> 如果是单核 CPU 情况下，在多线程执行时，每次线程 A 释放 <code>GIL</code> 后，被唤醒的线程 B 能够立即拿到<code>GIL</code>，能够无缝执行，执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/PH9e8qMihbvyTDz.png" alt="1524717396"></p>
<h3><span id="多核-cpu-下的多线程">多核 CPU 下的多线程 </span></h3><p> 但在多核 CPU 情况下多线程执行时，一个线程在 CPU0 执行完之后释放 <code>GIL</code>，其他 CPU 上的线程都会进行竞争，但 CPU0 可能又马上获取到了<code>GIL</code>，这就导致其他 CPU 上被唤醒的线程只能眼巴巴地看着 CPU0 上的线程欢快地执行着，而自己只能等待，直到又被切换到待调度的状态，这就会产生多核 CPU 频繁进行线程切换，消耗着资源，但只有一个线程能够拿到<code>GIL</code> 真正执行 Python 代码，这就导致多线程在多核 CPU 情况下，效率还不如单线程执行效率高。执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/hGA8qPFcK2Vezr7.png" alt="1524709489"></p>
<p>绿色部分是线程获得了 <code>GIL</code> 并进行有效的 CPU 运算，红色部分是被唤醒的线程由于没有争夺到<code>GIL</code>，只能无效地等待，无法充分利用 CPU 的并行运算能力。这就是多线程在多核 CPU 下，执行效率还不如单线程或单核 CPU 效率高的原因。</p>
<h3><span id="多线程-io-密集型任务">多线程 IO 密集型任务 </span></h3><p> 我们再进一步试想，如果多线程执行 IO 密集型任务，效率如何？</p>
<p>答案是比单线程效率要高。</p>
<p>这是由于 IO 密集型的任务，大部分时间都在等待 IO 上，很少消耗 CPU 的资源，所以在 IO 密集型任务的场景下，使用多线程是可以提升效率的。</p>
<h2><span id="why-gil">Why GIL?</span></h2><p>既然 <code>GIL</code> 的影响这么大，那为什么 Python 的解释器 <code>CPython</code> 在设计时要采用这种方式呢？</p>
<p>这就要追溯历史原因，2000 年以前，各个 CPU 厂商都在努力提升核心频率从而提高计算机的性能，但到 2000 年以后逐渐遇到天花板，之后提升方向改为多核心方向。</p>
<p>为了更有效的利用多核心 CPU，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。</p>
<p>Python 设计者在设计解释器时，可能没有想到 CPU 的性能提升会这么快转为多核心方向发展，所以在当时的场景下，设计一个全局锁是那个时代保护多线程资源一致性的最简单经济的设计方案。</p>
<p>而随着多核心时代来临，当大家试图去拆分和去除 <code>GIL</code> 的时候，发现大量库的代码开发者已经重度依赖 <code>GIL</code>（默认 Pythonn 内部对象是线程安全的，无需在开发时额外加锁），所以这个去除<code>GIL</code> 的任务变得复杂且难以实现。</p>
<p>所以简单来说 <code>GIL</code> 的存在更多的是历史原因，如果推倒重来重新设计，面对多线程问题可能设计得会更为优雅。</p>
<h2><span id="how-to-solve">How to solve?</span></h2><p>既然 <code>GIL</code> 存在会导致这么多问题，那我们有什么方式可以绕开这些问题，提高程序性能？总结如下：</p>
<ul>
<li>IO 密集型任务场景，多线程可以提高运行效率（推荐）</li>
<li>使用没有 <code>GIL</code> 的 Python 解释器（不推荐）</li>
<li>CPU 密集型任务场景，可改为多进程执行（推荐）</li>
<li>编写 Python 的 C 扩展模块，把 CPU 密集型任务交给 C 模块处理（编码复杂，不推荐）</li>
<li>更换其他语言实现 CPU 密集型任务</li>
</ul>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>