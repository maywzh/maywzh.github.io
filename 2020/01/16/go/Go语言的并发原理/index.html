<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/09/04/vY4eq6OIRotf19l.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>Go 语言的并发原理</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者。</p>
<a id="more"></a>
<h1><span id="并发和并行">并发和并行 </span></h1><p><strong> 并发(concurrency)</strong>：两个或两个以上的任务在一段时间内被执行。我们不必 care 这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。</p>
<p><strong>并行 (parallellism)：</strong> 两个或两个以上的任务在同一时刻被同时执行。</p>
<p>并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。</p>
<p>（详情请见：Rob Pike 的<a target="_blank" rel="noopener" href="https://talks.golang.org/2012/concurrency.slide#1">PPT</a>）</p>
<h1><span id="go-的-csp-并发模型">Go 的 CSP 并发模型</span></h1><p>Go 实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是 Java 或者 C++ 等语言中的多线程开发。另外一种是 Go 语言特有的，也是 Go 语言推荐的：CSP（communicating sequential processes）并发模型。</p>
<p>CSP 并发模型是在 1970 年左右提出的概念，属于比较新的概念，不同于传统的多线程通过共享内存来通信，CSP 讲究的是“以通信的方式来共享内存”。</p>
<p>请记住下面这句话：<br><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong><br>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p>
<p>普通的线程并发模型，就是像 Java、C++、或者 Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如 Java 提供的包”java.util.concurrent”中的数据结构。Go 中也实现了传统的线程并发模型。</p>
<p>Go 的 CSP 并发模型，是通过 <code>goroutine</code> 和<code>channel</code>来实现的。</p>
<ul>
<li><code>goroutine</code> 是 Go 语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li>
<li><code>channel</code>是 Go 语言中各个并发结构体 (<code>goroutine</code>) 之前的通信机制。 通俗的讲，就是各个 <code>goroutine</code> 之间通信的”管道“，有点类似于 Linux 中的管道。</li>
</ul>
<p>生成一个 <code>goroutine</code> 的方式非常的简单：Go 一下，就生成了。</p>
<pre class="line-numbers language-none"><code class="language-none">go f();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通信机制 <code>channel</code> 也很方便，传数据用<code>channel &lt;- data</code>，取数据用<code>&lt;-channel</code>。</p>
<p>在通信过程中，传数据 <code>channel &lt;- data</code> 和取数据 <code>&lt;-channel</code> 必然会成对出现，因为这边传，那边取，两个 <code>goroutine</code> 之间才会实现通信。</p>
<p>而且不管传还是取，必阻塞，直到另外的 <code>goroutine</code> 传或者取为止。</p>
<p>有两个 <code>goroutine</code>，其中一个发起了向<code>channel</code> 中发起了传值操作。（<code>goroutine</code>为矩形，<code>channel</code>为箭头）</p>
<p><img src="https://i6448038.github.io/img/csp/send.png" alt="img"></p>
<p>左边的 <code>goroutine</code> 开始阻塞，等待有人接收。</p>
<p>这时候，右边的 <code>goroutine</code> 发起了接收操作。</p>
<p><img src="https://i6448038.github.io/img/csp/accept.png" alt="img"></p>
<p>右边的 <code>goroutine</code> 也开始阻塞，等待别人传送。</p>
<p>这时候，两边 <code>goroutine</code> 都发现了对方，于是两个 <code>goroutine</code> 开始一传，一收。</p>
<p><img src="https://i6448038.github.io/img/csp/communicate.png" alt="img"></p>
<p>这便是 Golang CSP 并发模型最基本的形式。</p>
<h1><span id="go-并发模型的实现原理">Go 并发模型的实现原理 </span></h1><p> 我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问 CPU 资源、I/O 资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell 脚本”来调用内核空间提供的资源。</p>
<p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称 KSE），还是有区别的。</p>
<p>线程模型的实现，可以分为以下几种方式：</p>
<h3><span id="用户级线程模型">用户级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/yonghutai.png" alt="img"></p>
<p>如图所示，多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。</p>
<h3><span id="内核级线程模型">内核级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/neiheji.png" alt="img"></p>
<p>这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++ 就是这种。</p>
<h3><span id="两级线程模型">两级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/liangji.png" alt="img"></p>
<p>这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。</p>
<p>Go 语言的线程模型就是一种特殊的两级线程模型。暂且叫它“MPG”模型吧。</p>
<h2><span id="go-线程实现模型-mpg">Go 线程实现模型 MPG</span></h2><p><code>M</code>指的是 <code>Machine</code>，一个<code>M</code> 直接关联了一个内核线程。<br><code>P</code>指的是”processor”，代表了 <code>M</code> 所需的上下文环境，也是处理用户级代码逻辑的处理器。<br><code>G</code>指的是<code>Goroutine</code>，其实本质上也是一种轻量级的线程。</p>
<p>三者关系如下图所示：</p>
<p><img src="https://i6448038.github.io/img/csp/GMPrelation.png" alt="img"></p>
<p>以上这个图讲的是两个线程 (内核线程) 的情况。一个 M 会对应一个内核线程，一个 M 也会连接一个上下文 P，一个上下文 P 相当于一个“处理器”，一个上下文连接一个或者多个 Goroutine。P(Processor)的数量是在启动时被设置为环境变量 GOMAXPROCS 的值，或者通过运行时调用函数 <code>runtime.GOMAXPROCS()</code> 进行设置。Processor 数量固定意味着任意时刻只有固定数量的线程在运行 go 代码。Goroutine 中就是我们要执行并发的代码。图中 P 正在执行的 <code>Goroutine</code> 为蓝色的；处于待执行状态的 <code>Goroutine</code> 为灰色的，灰色的 <code>Goroutine</code> 形成了一个队列<code>runqueues</code></p>
<p>三者关系的宏观的图为：</p>
<p><img src="https://i6448038.github.io/img/csp/total.png" alt="img"></p>
<h4><span id="抛弃-pprocessor">抛弃 P(Processor)</span></h4><p>你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让 <code>Goroutine</code> 的<code>runqueues</code>挂到 M 上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。</p>
<p>一个很简单的例子就是系统调用 <code>sysall</code>，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程 M 需要放弃当前的上下文环境 P，以便可以让其他的<code>Goroutine</code> 被调度执行。</p>
<p><img src="https://i6448038.github.io/img/csp/giveupP.png" alt="img"></p>
<p>如上图左图所示，M0 中的 G0 执行了 syscall，然后就创建了一个 M1(也有可能本身就存在，没创建)，（转向右图）然后 M0 丢弃了 P，等待 syscall 的返回值，M1 接受了 P，将·继续执行 <code>Goroutine</code> 队列中的其他<code>Goroutine</code>。</p>
<p>当系统调用 syscall 结束后，M0 会“偷”一个上下文，如果不成功，M0 就把它的 Gouroutine G0 放到一个全局的 runqueue 中，然后自己放到线程池或者转入休眠状态。全局 runqueue 是各个 P 在运行完自己的本地的 Goroutine runqueue 后用来拉取新 goroutine 的地方。P 也会周期性的检查这个全局 runqueue 上的 goroutine，否则，全局 runqueue 上的 goroutines 可能得不到执行而饿死。</p>
<h4><span id="均衡的分配工作">均衡的分配工作 </span></h4><p> 按照以上的说法，上下文 P 会定期的检查全局的 goroutine 队列中的 goroutine，以便自己在消费掉自身 Goroutine 队列的时候有事可做。假如全局 goroutine 队列中的 goroutine 也没了呢？就从其他运行的中的 P 的 runqueue 里偷。</p>
<p>每个 P 中的 <code>Goroutine</code> 不同导致他们运行的效率和时间也不同，在一个有很多 P 和 M 的环境中，不能让一个 P 跑完自身的 <code>Goroutine</code> 就没事可做了，因为或许其他的 P 有很长的 <code>goroutine</code> 队列要跑，得需要均衡。<br>该如何解决呢？</p>
<p>Go 的做法倒也直接，从其他 P 中偷一半！</p>
<p><img src="https://i6448038.github.io/img/csp/stealwork.png" alt="img"></p>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>