<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/bitbug_favicon_64s.ico" />
	<link rel="shortcut icon" href="/bitbug_favicon_64s.ico">
	
	    <title>
    Cultoy
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="maywzh" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('https://i.loli.net/2020/03/02/mYeD6WLp3kOy1qw.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="https://cdn.jsdelivr.net/gh/jquery/jquery@1.11.3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/jquery.scrollex@0.2.1/jquery.scrollex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/maywzh/jquery.scrolly@0.0.1/dist/jquery.scrolly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ajlkn/skel@3.0.1/dist/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->

<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MAYWZH</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
	<ul class="menu links">
		<!-- Homepage  主页  -->
		<li>
			<a href="/" rel="nofollow">Home</a>
		</li>
		<!-- categories_name  分类   -->
		
		<li class="active">
			<a href="#s1">Category</a>
			<ul class="submenu">
				<li>
					<a class="category-link" href="/categories/DevOps/">DevOps</a></li><li><a class="category-link" href="/categories/uncategorized/">uncategorized</a></li><li><a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li><a class="category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li><a class="category-link" href="/categories/%E5%9D%91/">坑</a></li><li><a class="category-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li><a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></li><li><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
			</ul>
		</li>
		
		<!-- archives  归档   -->
		
		<li class="active">
			<a href="#s1">Archive</a>
			<ul class="submenu">
				<li>
					<a class="archive-link" href="/archives/2020/">2020</a></li><li><a class="archive-link" href="/archives/2019/">2019</a></li><li><a class="archive-link" href="/archives/2018/">2018</a></li><li><a class="archive-link" href="/archives/2017/">2017</a></li><li><a class="archive-link" href="/archives/2016/">2016</a></li><li><a class="archive-link" href="/archives/2015/">2015</a>
			</ul>
		</li>
		

		<!-- Pages 自定义   -->
		
		<li>
			<a href="/tags/" title="Tags">
				Tags
			</a>
		</li>
		
		<li>
			<a href="/about/" title="About">
				About
			</a>
		</li>
		


	</ul>
	<!-- icons 图标   -->
	<ul class="icons">
		
		<li>
			<a title="search" href="https://io.maywzh.com" target="_blank" rel="noopener">
				<i class="icon fa fa-search"></i>
			</a>
		</li>
		
		
		<li>
			<a title="twitter" href="https://twitter.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-twitter"></i>
			</a>
		</li>
		
		<li>
			<a title="github" href="https://github.com/maywzh" target="_blank" rel="noopener">
				<i class="icon fa fa-github"></i>
			</a>
		</li>
		
	</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img"
                style="height: 25rem;background-image: url(https://i.loli.net/2020/09/04/vY4eq6OIRotf19l.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                    <h2>Go 语言的 select</h2>
                </a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>很多 C 语言或者 Unix 开发者听到 <code>select</code> 想到的都是系统调用，而谈到 I/O 模型时最终大都会提到基于 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建的 IO 多路复用模型。Go 语言的 <code>select</code> 与 C 语言中的 <code>select</code> 有着比较相似的功能。本节会介绍 Go 语言 <code>select</code> 常见的现象、数据结构以及四种不同情况下的实现原理。</p>
<a id="more"></a>
<p>C 语言中的 <code>select</code> 关键字可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 关键字也能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</p>
<p><img src="https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png" alt="Golang-Select-Channels"></p>
<p><strong>图 5-5 Select 和 Channels</strong></p>
<p><code>select</code> 是一种与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a> 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> c <span class="token operator">&lt;-</span> x<span class="token punctuation">:</span>
			x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>quit<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"quit"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个的返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，就会随机选择一个 <code>case</code> 执行。</p>
<h2><span id="现象">现象 </span></h2><p> 当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p>
<ol>
<li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li>
<li><code>select</code> 在遇到多个 Channel 同时响应时会随机挑选 <code>case</code> 执行；</li>
</ol>
<p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体的场景并分析这两个现象背后的设计原理。</p>
<h3><span id="非阻塞的收发">非阻塞的收发 </span></h3><p> 在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 <code>default</code> 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p>
<ol>
<li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code>；</li>
<li>当不存在可以收发的 Channel 是，执行 <code>default</code> 中的语句；</li>
</ol>
<p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码并返回。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
		<span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token keyword">default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象就非常合理。<code>select</code> 的作用就是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 中的代码也是理所当然的。</p>
<p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望向 Channel 发送消息或者从 Channel 中接收消息会阻塞当前 Goroutine，我们只是想看看 Channel 的可读或者可写状态。下面就是一个常见的例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">errCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>
wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> tasks <span class="token punctuation">&#123;</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            errCh <span class="token operator">&lt;-</span> err
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> err <span class="token operator">:=</span> <span class="token operator">&lt;-</span>errCh<span class="token punctuation">:</span>
    <span class="token keyword">return</span> err
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句就能很好地完成这个任务。然而使用 <code>select</code> 的语法不是最原始的设计，它在最初版本使用 <code>x, ok := &lt;-c</code> 的语法实现非阻塞的收发，以下是与非阻塞收发的相关提交：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff">select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code> 情况；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16">gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发的特性。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059">gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c">gc, runtime: replace closed(c) with x, ok := &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态；</li>
</ol>
<p>我们可以从上面的几个提交中看到非阻塞收发从最初到现在的演变。</p>
<h3><span id="随机执行">随机执行 </span></h3><p> 另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择那个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token keyword">range</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			ch <span class="token operator">&lt;-</span> <span class="token number">0</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"case1"</span><span class="token punctuation">)</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"case2"</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
case1
case2
case1
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p>
<p>这个设计是在十多年前被 <a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d">select</a> 提交引入并一直保留到现在的，虽然中间经历过一些修改<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:6">6</a>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p>
<h2><span id="数据结构">数据结构</span></h2><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是 <code>select</code> 控制结构中的 <code>case</code> 却使用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体来表示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> scase <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	c           <span class="token operator">*</span>hchan
	elem        unsafe<span class="token punctuation">.</span>Pointer
	kind        <span class="token builtin">uint16</span>
	pc          <span class="token builtin">uintptr</span>
	releasetime <span class="token builtin">int64</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体中也包含一个 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51"><code>runtime.hchan</code></a> 类型的字段存储 <code>case</code> 中使用的 Channel；除此之外，<code>elem</code> 是接收或者发送数据的变量地址、<code>kind</code> 表示 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 的种类，总共包含以下四种：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
	caseNil <span class="token operator">=</span> <span class="token boolean">iota</span>
	caseRecv
	caseSend
	caseDefault
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这四种常量分别表示不同类型的 <code>case</code>，相信它们的命名已经能够充分帮助我们理解它们的作用了，所以这里也不一一介绍了。</p>
<h2><span id="实现原理">实现原理</span></h2><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每一个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点:</p>
<p><img src="https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png" alt="golang-oselect-and-ocases"></p>
<p><strong>图 5-7 OSELECT 和多个 OCASE</strong></p>
<p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 <code>OCASE</code> 既包含执行条件也包含满足条件后执行的代码。</p>
<p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p>
<ol>
<li><code>select</code> 不存在任何的 <code>case</code>；</li>
<li><code>select</code> 只存在一个 <code>case</code>；</li>
<li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li>
<li><code>select</code> 存在多个 <code>case</code>；</li>
</ol>
<p>上述的四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两方面分析上述情况。</p>
<h3><span id="直接阻塞">直接阻塞 </span></h3><p> 首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code> 时编译器是如何进行处理的，我们截取 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数的前几行代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">walkselectcases</span><span class="token punctuation">(</span>cases <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node <span class="token punctuation">&#123;</span>
	n <span class="token operator">:=</span> cases<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">&#123;</span><span class="token function">mkcall</span><span class="token punctuation">(</span><span class="token string">"block"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码非常简单并且容易理解，它直接将类似 <code>select &#123;&#125;</code> 的空语句转换成调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">gopark</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonSelectNoCases<span class="token punctuation">,</span> traceEvGoStop<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数的实现非常简单，它会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 让出当前 Goroutine 对处理器的使用权，传入的等待原因是 <code>waitReasonSelectNoCases</code>。</p>
<p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p>
<h3><span id="单一管道">单一管道 </span></h3><p> 如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么就会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面展示了原始的 <code>select</code> 语句和被改写、优化后的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 改写前</span>
<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> v<span class="token punctuation">,</span> ok <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span> <span class="token comment">// case ch &lt;- v</span>
    <span class="token operator">...</span>    
<span class="token punctuation">&#125;</span>

<span class="token comment">// 改写后</span>
<span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch <span class="token comment">// case ch &lt;- v</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p>
<h3><span id="非阻塞操作">非阻塞操作 </span></h3><p> 当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数会对这种情况单独处理，不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址。我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p>
<h4><span id="发送">发送 </span></h4><p> 首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用 <code>if/else</code> 语句和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 函数改写代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span>
    <span class="token operator">...</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> <span class="token function">selectnbsend</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码中最重要的就是 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 函数，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a> 一节介绍了向 Channel 发送数据的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectnbsend</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">chansend</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于我们向 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 函数传入了 <code>false</code>，所以哪怕是不存在接收方或者缓冲区空间不足都不会阻塞当前 Goroutine 而是会直接返回。</p>
<h4><span id="接收">接收 </span></h4><p> 由于从 Channel 中接收数据可能会返回一个或者两个值，所以接受数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 改写前</span>
<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> v <span class="token operator">&lt;-</span> ch<span class="token punctuation">:</span> <span class="token comment">// case v, ok &lt;- ch:</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 改写后</span>
<span class="token keyword">if</span> <span class="token function">selectnbrecv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">,</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// if selectnbrecv2(&amp;v, &amp;ok, ch) &#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709"><code>runtime.selectnbrecv2</code></a> 只是对 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 返回值的处理稍有不同：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectnbrecv</span><span class="token punctuation">(</span>elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	selected<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">selectnbrecv2</span><span class="token punctuation">(</span>elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> received <span class="token operator">*</span><span class="token builtin">bool</span><span class="token punctuation">,</span> c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	selected<span class="token punctuation">,</span> <span class="token operator">*</span>received <span class="token operator">=</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为接收方不需要，所以 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 会直接忽略返回的布尔值，而 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709"><code>runtime.selectnbrecv2</code></a> 会将布尔值回传给调用方。与 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 一样，<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 也提供了一个 <code>block</code> 参数用于控制这一次接收是否阻塞。</p>
<h3><span id="常见流程">常见流程 </span></h3><p> 在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p>
<ol>
<li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体；</li>
<li>调用运行时函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 从多个准备就绪的 Channel 中选择一个可执行的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体；</li>
<li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code></li>
</ol>
<p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">selv <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>scase<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
order <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">uint16</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> cas <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">&#123;</span>
    c <span class="token operator">:=</span> scase<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    c<span class="token punctuation">.</span>kind <span class="token operator">=</span> <span class="token operator">...</span>
    c<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token operator">...</span>
    c<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>
chosen<span class="token punctuation">,</span> revcOK <span class="token operator">:=</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>selv<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p>
<ol>
<li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li>
<li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li>
</ol>
<h4><span id="初始化">初始化</span></h4><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cas1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>scase<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>cas0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	order1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">17</span><span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>order0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	
	scases <span class="token operator">:=</span> cas1<span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	pollorder <span class="token operator">:=</span> order1<span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	lockorder <span class="token operator">:=</span> order1<span class="token punctuation">[</span>ncases<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> scases <span class="token punctuation">&#123;</span>
		cas <span class="token operator">:=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ncases<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		j <span class="token operator">:=</span> <span class="token function">fastrandn</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		pollorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pollorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
		pollorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 根据 Channel 的地址排序确定加锁顺序</span>
	<span class="token operator">...</span>
	<span class="token function">sellock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p>
<ul>
<li>轮询顺序：通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L114-L118"><code>runtime.fastrandn</code></a> 函数引入随机性；</li>
<li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li>
</ul>
<p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L45-L54"><code>runtime.sellock</code></a> 函数会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p>
<h4><span id="循环">循环 </span></h4><p> 当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p>
<ol>
<li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li>
<li>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；</li>
<li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数会根据不同情况通过 <code>goto</code> 跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p>
<ul>
<li><code>bufrecv</code>：可以从缓冲区读取数据；</li>
<li><code>bufsend</code>：可以向缓冲区写入数据；</li>
<li><code>recv</code>：可以从休眠的发送方获取数据；</li>
<li><code>send</code>：可以向休眠的接收方发送数据；</li>
<li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li>
<li><code>sclose</code>：向关闭的 Channel 发送数据；</li>
<li><code>retc</code>：结束调用并返回；</li>
</ul>
<p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p>
<ol>
<li><p>```<br>caseNil</p>
<pre class="line-numbers language-none"><code class="language-none">
：当前

 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>case</p>
<pre class="line-numbers language-none"><code class="language-none">
    

   不包含 Channel；

   - 这种 &#96;case&#96; 会被跳过；

2. &#96;&#96;&#96;
   caseRecv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>：当前</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   会从 Channel 中接收数据；</p>
<ul>
<li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine，就会跳到 <code>recv</code> 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</li>
<li>如果当前 Channel 的缓冲区不为空，就会跳到 <code>bufrecv</code> 标签处从缓冲区获取数据；</li>
<li>如果当前 Channel 已经被关闭，就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li>
</ul>
<ol>
<li><p>```<br>caseSend</p>
<pre class="line-numbers language-none"><code class="language-none">
：当前

 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>case</p>
<pre class="line-numbers language-none"><code class="language-none">
    

   会向 Channel 发送数据；

   - 如果当前 Channel 已经被关，闭就会直接跳到 &#96;sclose&#96; 标签，触发 &#96;panic&#96; 尝试中止程序；
   - 如果当前 Channel 的 &#96;recvq&#96; 上有等待的 Goroutine，就会跳到 &#96;send&#96; 标签向 Channel 发送数据；
   - 如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；

4. &#96;&#96;&#96;
   caseDefault<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>：当前</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   为</p>
   <pre class="line-numbers language-none"><code class="language-none">default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   语句；</p>
<ul>
<li>表示前面的所有 <code>case</code> 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 <code>select</code> 结构中的收发都是非阻塞的；</li>
</ul>
<p><img src="https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png" alt="golang-runtime-selectgo"></p>
<p><strong>图 5-8 运行时 selectgo 函数</strong></p>
<p>第一阶段的主要职责是查找所有 <code>case</code> 中 Channel 是否有可以立刻被处理的情况。无论是在包含等待的 Goroutine 还是缓冲区中存在数据，只要满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 <code>sendq</code> 或者 <code>recvq</code> 队列中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	nextp <span class="token operator">=</span> <span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>waiting
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> casei <span class="token operator">:=</span> <span class="token keyword">range</span> lockorder <span class="token punctuation">&#123;</span>
		casi <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>casei<span class="token punctuation">)</span>
		cas <span class="token operator">=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>casi<span class="token punctuation">]</span>
		c <span class="token operator">=</span> cas<span class="token punctuation">.</span>c
		sg <span class="token operator">:=</span> <span class="token function">acquireSudog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		sg<span class="token punctuation">.</span>g <span class="token operator">=</span> gp
		sg<span class="token punctuation">.</span>c <span class="token operator">=</span> c

		<span class="token keyword">switch</span> cas<span class="token punctuation">.</span>kind <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> caseRecv<span class="token punctuation">:</span>
			c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
		<span class="token keyword">case</span> caseSend<span class="token punctuation">:</span>
			c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">gopark</span><span class="token punctuation">(</span>selparkcommit<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonSelect<span class="token punctuation">,</span> traceEvGoBlockSelect<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了将当前 Goroutine 对应的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体加入队列之外，这些 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 函数挂起当前 Goroutine 等待调度器的唤醒。</p>
<p><img src="https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png" alt="Golang-Select-Waiting"></p>
<p><strong>图 5-9 Goroutine 上等待收发的 sudog 链表</strong></p>
<p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数的第三阶段，从 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体中获取数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	sg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>sudog<span class="token punctuation">)</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>param<span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>

	casi <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
	cas <span class="token operator">=</span> <span class="token boolean">nil</span>
	sglist <span class="token operator">=</span> gp<span class="token punctuation">.</span>waiting
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> casei <span class="token operator">:=</span> <span class="token keyword">range</span> lockorder <span class="token punctuation">&#123;</span>
		k <span class="token operator">=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>casei<span class="token punctuation">]</span>
		<span class="token keyword">if</span> sg <span class="token operator">==</span> sglist <span class="token punctuation">&#123;</span>
			casi <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>casei<span class="token punctuation">)</span>
			cas <span class="token operator">=</span> k
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> k<span class="token punctuation">.</span>kind <span class="token operator">==</span> caseSend <span class="token punctuation">&#123;</span>
				c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">dequeueSudoG</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">dequeueSudoG</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		sgnext <span class="token operator">=</span> sglist<span class="token punctuation">.</span>waitlink
		sglist<span class="token punctuation">.</span>waitlink <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token function">releaseSudog</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
		sglist <span class="token operator">=</span> sgnext
	<span class="token punctuation">&#125;</span>

	c <span class="token operator">=</span> cas<span class="token punctuation">.</span>c
	<span class="token keyword">goto</span> retc
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p>
<p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p>
<p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">bufrecv<span class="token punctuation">:</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">true</span>
	qp <span class="token operator">=</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">)</span>
	<span class="token keyword">if</span> cas<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>recvx<span class="token operator">++</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>recvx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>recvx <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>qcount<span class="token operator">--</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc

bufsend<span class="token punctuation">:</span>
	<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sendx<span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>sendx<span class="token operator">++</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>sendx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>sendx <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>qcount<span class="token operator">++</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里在缓冲区进行的操作和直接调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 函数差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p>
<p>两个直接对 Channel 收发的情况会调用 Channel 运行时函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L286-L317"><code>runtime.send</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L594-L635"><code>runtime.recv</code></a>，这两个函数会直接与处于休眠状态的 Goroutine 打交道：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">recv<span class="token punctuation">:</span>
	<span class="token function">recv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token keyword">goto</span> retc

send<span class="token punctuation">:</span>
	<span class="token function">send</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p>
<ul>
<li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li>
<li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rclose<span class="token punctuation">:</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token keyword">if</span> cas<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">goto</span> retc

sclose<span class="token punctuation">:</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"send on closed channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p>
<h2><span id="小结">小结 </span></h2><p> 我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p>
<ol>
<li><p>空的 <code>select</code> 语句会被转换成 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数的调用，直接挂起当前 Goroutine；</p>
</li>
<li><p>如果</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">select<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   语句中只包含一个</p>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   ，就会被转换成</p>
   <pre class="line-numbers language-none"><code class="language-none">if ch &#x3D;&#x3D; nil &#123; block &#125;; n;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   表达式；</p>
<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 <code>case</code> 结构中的内容；</li>
</ul>
<ol>
<li><p>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</p>
</li>
<li><p>在默认情况下会通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</p>
</li>
</ol>
<p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p>
<ol>
<li><p>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</p>
</li>
<li><p>根据</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">pollOrder<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   遍历所有的</p>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   查看是否有可以立刻处理的 Channel；</p>
<ol>
<li>如果存在就直接获取 <code>case</code> 对应的索引并返回；</li>
<li>如果不存在就会创建 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li>
</ol>
<ol>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构对应的索引；</li>
</ol>
<p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/select.2.html">SELECT(2) · Linux</a></li>
</ul>

            </div>
            <!-- Post Comments -->
            
        </div>
        <!-- Copyright 版权 start -->
        <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Theme: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
        <!-- <li><a href="">鄂ICP备2020015912号-1</a></li> -->
    </ul>
    
    <span id="busuanzi_container_site_pv"> 2020 </span>
    
</div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>





</html>