<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>理解 c 语言中的指针</title>
    <url>/2015/10/16/C&amp;C++/c%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>在考虑指针的问题之前，首先我们来回顾一下如何定义一个变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>int</code>类型需要四个字节来存储，这四个字节是从内存中分配而来的，内存在逻辑上是一个线性的存储器，它以字节为单位被划分为许多小的单元。为了区分这些单元，计算机给每一个单元都分配了一个唯一的十六进制整数作为编号，叫做内存地址 (简称地址)。由于这些单元啊数量众多，所以这个内存地址本身就需要四个字节(32 位 bit 位) 来表示。我们所说的 32 位系统就是这个意思。它最大的可寻址范围为 <code>2^32</code> 字节，即 4GB。目前正在占据主流的 64 位系统的最大可寻址范围是 <code>2^64</code> 字节。</p>
<p>理论上说，我们只需要这些内存地址就可以定位到我们所要读写的内存单元，但这些地址不方便理解和记忆，c 语言允许程序员给这些地址起名字，就是我们所说的变量名。</p>
<p>回到 <code>int x</code> 这个声明，它实际上做了两件事：</p>
<ol>
<li>从内存中划分出 4 个字节；</li>
<li>将这个内存单元约定一个名字为 x；</li>
</ol>
<p>一个固定的内存单元的地址是固定的，但存储的值确是可变的。</p>
<a id="more"></a>
<h2><span id="指针概念">指针概念 </span></h2><h3><span id="获取变量的地址"> 获取变量的地址 </span></h3><p> 由于有变量名的存在，我们不需要一个具体地址就可以操作它来进行各种运算，但有的时候需要得到其地址，为了满足其需要，c 语言提供了取地址运算符<code>&amp;</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value is %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"address is %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 5；</span>
<span class="token comment">// 2293620</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>int</code>变量需要四个字节，每个内存单元只有一个字节的容量，所以程序会分配四个连续的单元给 x。<code>&amp;x</code>就是第一个单元的地址，即 <strong> 首地址</strong>。我们可以用一个无符号整型变量来存储它。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>C 语言处于类型安全的考虑，认为一个地址与一个整数不等价（虽然实际上是一回事），所以想把变量 <code>x</code> 的地址存在一个 <code>int</code> 中，需要使用强制转化。</p>
<p>上面的代码中 <code>addr</code> 也是一个整型变量，它也有自己的地址，那么也可以通过 <code>&amp;</code> 来获取它的地址。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> addr_of_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么这样是否可以</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> addr_of_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">// 编译错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为什么会编译报错呢，这是因为取一个变量的地址后，得到的是一个数值，而不是一个变量，取地址只对于变量才有意义。所以只有将这个数值存放于一个变量 addr 中，才能取得这个变量 <code>addr</code> 的地址。</p>
<h3><span id="指针变量">指针变量 </span></h3><p> 由于使用 <code>unsigned int</code> 存储地址会导致无法根据地址得到相应内存单元的值，即取内容，所以 C 语言中用指针变量来存储地址。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要声明一个只想 <code>int</code> 变量的指针是，就使用变量之前加一个 <code>*</code> 来说明这是个指针变量。</p>
<p>如果要定义多个指针，则必须每个变量名前都加星号 <code>*</code>。对一个指针变量前面加上<code>*</code> 代表取指针指向的地址内存储的变量的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//5</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add_x = %d\n"</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//-345631352</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//6</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add_x = %d\n"</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//-345631352</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码可以看出，修改 <code>*p</code> 也会直接修改 <code>x</code> 的值，因为这是对 <code>p</code> 直接指向的内存单元进行操作。</p>
<p>如果对指针变量进行加减一个整数，称之为指针的移动。</p>
<p><code>p+n</code> 等价于<code>(TYPE*)(int)p+n*sizeof(TYPE)</code></p>
<p>一个指针加减一个整数 <code>n</code>，存储的地址将会加上<code>n</code> 倍所指向类型的大小。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> val<span class="token operator">=</span><span class="token number">5.0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d%\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//12344426</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d%\n"</span><span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//12344434 增加了 sizeof(double)==8</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="指针类型">指针类型 </span></h3><p> 指针的类型的含义是：<strong>指针变量的本身的类型</strong>。</p>
<p>上文我们已经知道了指针变量存储的是一个地址，这个地址是 32 位或者 64 位，取决于操作系统。</p>
<p>那么可以得出结论，一个操作系统中，所有的指针变量的大小都是相等的。</p>
<p>从语法的角度看，你只要 <strong> 把指针声明语句里的指针名字去掉</strong>，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token comment">// 指针的类型是 int*</span>
<span class="token keyword">char</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token comment">// 指针的类型是 char*</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token comment">// 指针的类型是 int**</span>
<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 指针的类型是 int(*)[3]</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 指针的类型是 int*(*)[4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="指针所指向的类型">指针所指向的类型 </span></h3><p> 当通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>
<p>从语法上看，只须把指针声明语句中的指针名字和名字左边的指针声明符 <code>*</code> 去掉，剩下的就是指针所指向的类型。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 指针所指向的类型是 int</span>
<span class="token keyword">char</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 指针所指向的的类型是 char</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 指针所指向的的类型是 int*</span>
<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 指针所指向的的类型是 int()[3]</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 指针所指向的的类型是 int*()[4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p><strong>指针的类型 (即指针本身的类型) 和指针所指向的类型是两个概念</strong>。分清这两个概念是理解指针的关键点之一。</p>
<h3><span id="指针的值">指针的值 </span></h3><p> 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是 XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。</p>
<h3><span id="指针自身占据的内存">指针自身占据的内存 </span></h3><p> 因为指针本质上就是一个固定位数整数，在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。</p>
<h2><span id="指针运算">指针运算 </span></h2><p> 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> <span class="token comment">// 强制类型转换并不会改变 a 的类型</span>
ptr<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在上例中，指针 ptr 的类型是 int*, 它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了 1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> array<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        ptr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加 1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<h2><span id="指针表达式">指针表达式 </span></h2><p> 一个表达式的结果如果是一个指针，那么这个表达式就叫指针表达式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span>
pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>         <span class="token comment">//&amp;a 是一个指针表达式。</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pa<span class="token punctuation">;</span> <span class="token comment">//&amp;pa 也是一个指针表达式。</span>
<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>       <span class="token comment">//*ptr 和 &amp;b 都是指针表达式。</span>
pa <span class="token operator">=</span> array<span class="token punctuation">;</span>
pa<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 这也是指针表达式。</span>
<span class="token keyword">char</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>parr <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">// 如果把 arr 看作指针的话，arr 也是指针表达式</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token operator">*</span>parr<span class="token punctuation">;</span>       <span class="token comment">//*parr 是指针表达式</span>
str <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>parr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//*(parr+1)是指针表达式</span>
str <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>parr <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//*(parr+2)是指针表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。</p>
<h2><span id="数组和指针">数组和指针 </span></h2><p> 数组的数组名可以看作一个指针</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token string">"Hello,thisisasample!"</span><span class="token punctuation">,</span>
        <span class="token string">"Hi,goodmorning."</span><span class="token punctuation">,</span>
        <span class="token string">"Helloworld"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 也可写成 strcpy(s,*str);</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 也可写成 strcpy(s,*(str+1));</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 也可写成 strcpy(s,*(str+2));</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char <em>*，它指向的类型是 char </em>。</p>
<p><em>str 也是一个指针，它的类型是 char </em>，它所指向的类型是 char，它指向的地址是字符串”Hello,thisisasample!”的第一个字符的地址，即’H’的地址。注意: 字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变, 且只能是右值. 如果看成指针的话, 他即是常量指针, 也是指针常量.</p>
<p>str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char<em>*，它指向的类型是 char</em>。</p>
<p><em>(str+1)也是一个指针，它的类型是 char</em>，它所指向的类型是 char，它指向”Hi,goodmorning.”的第一个字符’H’</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>array<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上例中 ptr 是一个指针，它的类型是 int(*)[10]，他指向的类型是 int[10] ，我们用整个数组的首地址来初始化它。在语句 ptr=&amp;array 中，array 代表数组本身。</p>
<p>本节中提到了函数 sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？</p>
<p>答案是前者。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>则在 32 位程序中，有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">4</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">40</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h2><span id="指针和结构类型的关系">指针和结构类型的关系 </span></h2><p> 所有的 C/C++ 编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<h2><span id="指针和函数的关系">指针和函数的关系</span></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pfun1<span class="token operator">=</span>fun1<span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过函数指针调用函数。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<p>总结：</p>
<ol>
<li><p>其实，myFun 的函数名与 funP、funA 函数指针都是一样的，即都是函数指针。myFun 函数名是一个函数指针常量，而 funP、funA 是函数数指针变量，这是它们的关系。</p>
</li>
<li><p>但函数名调用如果都得如 (*myFun)(10) 这样，那书写与读起来都是不方便和不习惯的。所以 C 语言的设计者们才会设计成又可允许 myFun(10)这种形式地调用（这样方便多了，并与数学中的函数形式一样）。</p>
</li>
<li><p>为了统一调用方式，funP 函数指针变量也可以 funP(10)的形式来调用。</p>
</li>
<li><p>赋值时，可以写成 funP=&amp;myFun 形式，也可以写成 funP=myFun。</p>
</li>
<li><p>但是在声明时，void myFun(int)不能写成 void (<em>myFun)(int)。void (</em>funP)(int)不能写成 void funP(int)。</p>
</li>
<li><p>函数指针变量也可以存入一个数组内。数组的声明方法：int (*fArray[10]) (int);</p>
</li>
</ol>
<h2><span id="附录-指针类型判断实例">附录 - 指针类型判断实例</span></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> p<span class="token punctuation">;</span> <span class="token comment">// 这是一个普通的整型变量</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 首先从 P 处开始, 先与 * 结合, 所以说明 P 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型. 所以 P 是一个返回整型数据的指针</span>

<span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 首先从 P 处开始, 先与 [] 结合, 说明 P 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 P 是一个由整型数据组成的数组</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 首先从 P 处开始, 先与 [] 结合, 因为其优先级比 * 高, 所以 P 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 P 是一个由返回整型数据的指针所组成的数组</span>

<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 首先从 P 处开始, 先与 * 结合, 说明 P 是一个指针然后再与 [] 结合(与 "()" 这步可以忽略, 只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与 int 结合, 说明数组里的元素是整型的. 所以 P 是一个指向由整型数据组成的数组的指针</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 首先从 P 开始, 先与 * 结合, 说是 P 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据. 由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针.</span>

<span class="token keyword">int</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 P 处起, 先与 () 结合, 说明 P 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据</span>

<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 P 处开始, 先与指针结合, 说明 P 是一个指针, 然后与 () 结合, 说明指针指向的是一个函数, 然后再与 () 里的 int 结合, 说明函数有一个 int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 可以先跳过, 不看这个类型, 过于复杂从 P 开始, 先与 () 结合, 说明 P 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针,, 然后到最外面一层, 先与 [] 结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据. 所以 P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 命令之 Explain 笔记</title>
    <url>/2016/12/09/MySQL/MySQL%E5%91%BD%E4%BB%A4%E4%B9%8BExplain%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MySQL 提供了一个 EXPLAIN 命令， 它可以对 <code>SELECT</code> 语句进行分析， 并输出 <code>SELECT</code> 执行的详细信息， 以供开发人员针对性优化。借助一个实例操作，来对 Explain 用法做一些总结。</p>
<a id="more"></a>
<h2><span id="简介">简介</span></h2><p>EXPLAIN 命令用法十分简单， 在 SELECT 语句前加上 Explain 就可以了， 例如:</p>
<pre class="line-numbers language-none"><code class="language-none">EXPLAIN SELECT * from user_info WHERE id &lt; 300;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="准备">准备 </span></h2><p> 为了接下来方便演示 EXPLAIN 的使用， 首先我们需要建立两个测试用的表， 并添加相应的数据:</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;user_info&#96; (&#96;id&#96;   BIGINT(20)  NOT NULL AUTO_INCREMENT,
  &#96;name&#96; VARCHAR(50) NOT NULL DEFAULT &#39;&#39;，
  &#96;age&#96;  INT(11)              DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)，
  KEY &#96;name_index&#96; (&#96;name&#96;)
)
  ENGINE &#x3D; InnoDB
  DEFAULT CHARSET &#x3D; utf8

INSERT INTO user_info (name, age) VALUES (&#39;xys&#39;， 20);
INSERT INTO user_info (name, age) VALUES (&#39;a&#39;， 21);
INSERT INTO user_info (name, age) VALUES (&#39;b&#39;， 23);
INSERT INTO user_info (name, age) VALUES (&#39;c&#39;， 50);
INSERT INTO user_info (name, age) VALUES (&#39;d&#39;， 15);
INSERT INTO user_info (name, age) VALUES (&#39;e&#39;， 20);
INSERT INTO user_info (name, age) VALUES (&#39;f&#39;， 21);
INSERT INTO user_info (name, age) VALUES (&#39;g&#39;， 23);
INSERT INTO user_info (name, age) VALUES (&#39;h&#39;， 50);
INSERT INTO user_info (name, age) VALUES (&#39;i&#39;， 15);
CREATE TABLE &#96;order_info&#96; (&#96;id&#96;           BIGINT(20)  NOT NULL AUTO_INCREMENT,
  &#96;user_id&#96;      BIGINT(20)           DEFAULT NULL,
  &#96;product_name&#96; VARCHAR(50) NOT NULL DEFAULT &#39;&#39;，
  &#96;productor&#96;    VARCHAR(30)          DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)，
  KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)
)
  ENGINE &#x3D; InnoDB
  DEFAULT CHARSET &#x3D; utf8

INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p2&#39;， &#39;WL&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;， &#39;DX&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p5&#39;， &#39;WL&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &#39;p3&#39;， &#39;MA&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &#39;p1&#39;， &#39;WHH&#39;);
INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &#39;p8&#39;， &#39;TE&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="explain-输出格式">EXPLAIN 输出格式</span></h2><p>EXPLAIN 命令的输出内容大致如下:</p>
<pre class="line-numbers language-none"><code class="language-none">mysql&gt; explain select * from user_info where id &#x3D; 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_info
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 8
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3><span id="select_type">select_type</span></h3><p><code>select_type</code> 表示了查询的类型， 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句， 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 <code>SIMPLE</code> 了， 比如当我们的查询没有子查询， 也没有 UNION 查询时， 那么通常就是 <code>SIMPLE</code> 类型， 例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from user_info where id &#x3D; 2;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/eKc6yprMZFaVnHL.png" alt="Screen Shot 2020-09-09 at 9.00.09 AM"></p>
<p>如果我们使用了 UNION 查询， 那么 EXPLAIN 输出 的结果类似如下:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))
UNION
(SELECT * FROM user_info WHERE id IN (3, 4, 5));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/J4oXgiRtnESN1Hv.png" alt="Screen Shot 2020-09-09 at 8.59.34 AM"></p>
<h3><span id="table">table</span></h3><p>表示查询涉及的表或衍生表</p>
<h3><span id="type">type</span></h3><p><code>type</code> 字段比较重要， 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段， 我们判断此次查询是 <code>全表扫描 </code> 还是 <code> 索引扫描</code> 等.</p>
<h4><span id="type-常用类型">type 常用类型</span></h4><p>type 常用的取值有:</p>
<ul>
<li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li>
<li><code>const</code>: 针对主键或唯一索引的等值查询扫描， 最多只返回一行数据. const 查询速度非常快， 因为它仅仅读取一次即可.<br>例如下面的这个查询， 它使用了主键索引， 因此 <code>type</code> 就是 <code>const</code> 类型的.</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from user_info where id &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询， 表示对于前表的每一个结果， 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>， 查询效率较高. 例如:</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id &#x3D; order_info.user_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/hwiS67cE4lopqPL.png" alt="Screen Shot 2020-09-09 at 9.01.59 AM"></p>
<ul>
<li><code>ref</code>: 此类型通常出现在多表的 join 查询， 针对于非唯一或非主键索引， 或者是使用了 <code>最左前缀 </code> 规则索引的查询.<br> 例如下面这个例子中， 就使用到了 <code>ref</code> 类型的查询:</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id &#x3D; order_info.user_id AND order_info.user_id &#x3D; 5;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/UsCitmex8qGyzpa.png" alt="Screen Shot 2020-09-09 at 9.03.29 AM"></p>
<ul>
<li><code>range</code>: 表示使用索引范围查询， 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时， 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT *
FROM user_info
WHERE id BETWEEN 2 AND 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/XKjzHrAqM5Ny4oc.png" alt="Screen Shot 2020-09-09 at 9.06.10 AM"></p>
<ul>
<li><p><code>index</code>: 表示全索引扫描(full index scan)， 和 ALL 类型类似， 只不过 ALL 类型是全表扫描， 而 index 类型则仅仅扫描所有的索引， 而不扫描数据</p>
<p><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到， 而不需要扫描数据. 当是这种情况时， Extra 字段 会显示 <code>Using index</code>.</p>
</li>
</ul>
<p>例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT name FROM  user_info;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/UADRNmrVLo7OMju.png" alt="Screen Shot 2020-09-09 at 9.08.30 AM"></p>
<p>上面的例子中， 我们查询的 name 字段恰好是一个索引， 因此我们直接从索引中获取数据就可以满足查询的需求了， 而不需要查询表中的数据. 因此这样的情况下， type 的值是 <code>index</code>， 并且 Extra 的值是 <code>Using index</code>.</p>
<ul>
<li>ALL: 表示全表扫描， 这个类型的查询是性能最差的查询之一. 通常来说， 我们的查询不应该出现 ALL 类型的查询， 因为这样的查询在数据量大的情况下， 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子， 可以看到， 在全表扫描时， possible_keys 和 key 字段都是 NULL, 表示没有使用到索引， 并且 rows 十分巨大， 因此整个查询效率是十分低下的.</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT age FROM  user_info WHERE age &#x3D; 20;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/iEmjy4GMAHsJz5w.png" alt="Screen Shot 2020-09-09 at 9.08.56 AM"></p>
<h4><span id="type-类型的性能比较">type 类型的性能比较 </span></h4><p> 通常来说， 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描， 因此在相同的查询条件下， 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描， 但是它扫描了所有的索引， 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据， 因此可以过滤部分或大部分数据， 因此查询效率就比较高了.</p>
<h3><span id="possible_keys">possible_keys</span></h3><p><code>possible_keys</code> 表示 MySQL 在查询时， 能够使用到的索引. 注意， 即使有些索引在 <code>possible_keys</code> 中出现， 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引， 由 <code>key</code> 字段决定.</p>
<h3><span id="key">key</span></h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<h3><span id="key_len">key_len</span></h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用， 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码， 则是 3 <em>n + 2 字节; 如果是 utf8mb4 编码， 则是 4</em> n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1 字节</li>
<li>SMALLINT: 2 字节</li>
<li>MEDIUMINT: 3 字节</li>
<li>INT: 4 字节</li>
<li>BIGINT: 8 字节</li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3 字节</li>
<li>TIMESTAMP: 4 字节</li>
<li>DATETIME: 8 字节</li>
</ul>
</li>
<li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的， 则没有此属性.</li>
</ul>
<p>我们来举两个简单的栗子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name &#x3D; &#39;p1&#39; AND productor &#x3D; &#39;WHH&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面的例子是从表 order_info 中查询指定的内容， 而我们从此表的建表语句中可以知道， 表 <code>order_info</code> 有一个联合索引:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中， 因为先进行 user_id 的范围查询， 而根据 <code>最左前缀匹配</code> 原则， 当遇到范围查询时， 就停止索引的匹配， 因此实际上我们使用到的索引的字段只有 <code>user_id</code>， 因此在 <code>EXPLAIN</code> 中， 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节， 而 NULL 属性占用一个字节， 因此总共是 9 个字节. 若我们将 user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>， 则 key_length 应该是 8.</p>
<p>上面因为 <code>最左前缀匹配</code> 原则， 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段， 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info WHERE user_id &#x3D; 1 AND product_name &#x3D; &#39;p1&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这次的查询中， 我们没有使用到范围查询， key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中， 仅仅使用到了联合索引中的前两个字段， 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<h3><span id="rows">rows</span></h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息， 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏， 原则上 rows 越少越好.</p>
<h3><span id="extra">Extra</span></h3><p>Explain 中的很多额外的信息会在 Extra 字段显示， 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时， 表示 MySQL 需额外的排序操作， 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>， 都建议优化去掉， 因为这样的查询 CPU 资源消耗大.</li>
</ul>
<p>例如下面的例子:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info ORDER BY product_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2020/09/09/BxhONjolU8nLe1t.png" alt="Screen Shot 2020-09-09 at 9.11.24 AM"></p>
<p>我们的索引是</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">KEY &#96;user_product_detail_index&#96; (&#96;user_id&#96;， &#96;product_name&#96;， &#96;productor&#96;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是上面的查询中根据 <code>product_name</code> 来排序， 因此不能使用索引进行优化， 进而会产生 <code>Using filesort</code>.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>， 那么就不会出现 <code>Using filesort</code> 了. 例如:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>Using index<br>“覆盖索引扫描”， 表示查询在索引树中就可查找所需数据， 不用扫描表数据文件， 往往说明性能不错</li>
<li>Using temporary<br>查询有使用临时表， 一般出现于排序， 分组和多表 join 的情况， 查询效率不高， 建议优化.</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 的常用命令</title>
    <url>/2015/02/11/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>总结一下常用的简单 MySQL 命令。</p>
<a id="more"></a>
<h2><span id="mysql-介绍">MySQL 介绍</span></h2><p>MySQL 为关系型数据库由一个或数个表格组成</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>sex</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>张三</td>
<td>m</td>
<td>23</td>
</tr>
<tr>
<td>1</td>
<td>李四</td>
<td>f</td>
<td>35</td>
</tr>
<tr>
<td>2</td>
<td>王五</td>
<td>m</td>
<td>20</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p><strong>表头 (header)：</strong> 每一列的名称；<br><strong>列 (col)：</strong> 每一列用来描述表中所有数据项的某个属性；<br><strong> 行(row)：</strong>每一行用来描述某个数据项的的所有属性；<br><strong>值 (value)：</strong> 行的具体信息, 每个值必须与该列的数据类型相同；</p>
<h2><span id="登录-mysql">登录 MySQL</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h <span class="token number">127.0</span>.0.1 -u username -p
mysql -D dbname -h <span class="token function">hostname</span> -u username -p
mysql<span class="token operator">></span> <span class="token builtin class-name">exit</span> 
<span class="token comment"># 退出</span>
mysql<span class="token operator">></span> quit <span class="token comment"># 退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="创建数据库">创建数据库 </span></h2><p> 对于表的操作需要先进入库 use 库名；</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">database</span> testdb <span class="token keyword">character</span> <span class="token keyword">set</span> gbk<span class="token punctuation">;</span> <span class="token comment">-- 创建一个名为 testdb 的数据库，数据库字符编码指定为 gbk</span>
<span class="token keyword">drop</span> <span class="token keyword">database</span> testdb<span class="token punctuation">;</span>  <span class="token comment">-- 删除 testdb</span>
<span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>        <span class="token comment">-- 显示数据库列表。</span>
<span class="token keyword">use</span> testdb<span class="token punctuation">;</span>      <span class="token comment">-- 选择创建的数据库 people</span>
<span class="token keyword">show</span> 表名<span class="token punctuation">;</span>       <span class="token comment">-- 显示 samp_db 下面所有的表名字</span>
<span class="token keyword">describe</span> 表名<span class="token punctuation">;</span>   <span class="token comment">-- 显示数据表的结构</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span> <span class="token comment">-- 清空表中记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="创建数据库表">创建数据库表 </span></h2><p> 使用 create table 语句可完成对表的创建, create table 的常见形式: 语法：create table 表名称(列声明)；</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>users<span class="token punctuation">`</span> <span class="token punctuation">(</span>  
<span class="token punctuation">`</span>id<span class="token punctuation">`</span>          <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  
<span class="token punctuation">`</span>password<span class="token punctuation">`</span>    <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">' 用户密码 '</span><span class="token punctuation">,</span>  
<span class="token punctuation">`</span>mobile<span class="token punctuation">`</span>         <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">' 手机号码 '</span><span class="token punctuation">,</span>  
<span class="token punctuation">`</span>create_at<span class="token punctuation">`</span>      <span class="token keyword">timestamp</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>      <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  
<span class="token punctuation">`</span>update_at<span class="token punctuation">`</span>      <span class="token keyword">timestamp</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>      <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  
<span class="token comment">-- 创建唯一索引，不允许重复  </span>
<span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> idx_user_mobile<span class="token punctuation">(</span><span class="token punctuation">`</span>mobile<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 
<span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'用户表'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数据类型的属性解释</p>
<ul>
<li><strong>NULL：</strong>数据列可包含 NULL 值；</li>
<li><strong>NOT NULL：</strong>数据列不允许包含 NULL 值；</li>
<li><strong>DEFAULT：</strong>默认值；</li>
<li><strong>PRIMARY：</strong>KEY 主键；</li>
<li><strong>AUTO_INCREMENT：</strong>自动递增，适用于整数类型；</li>
<li><strong>UNSIGNED：</strong>是指数值类型只能为正数；</li>
<li><strong>CHARACTER SET name：</strong>指定一个字符集；</li>
<li><strong>COMMENT：</strong>对表或者字段说明；</li>
</ul>
<h2><span id="crud-增删查改">CRUD - 增删查改 </span></h2><h3><span id="select-查">SELECT 查</span></h3><p>SELECT 语句用于从表中选取数据。<br><strong> 语法：SELECT 列名称 FROM 表名称 </strong> — 选择特定的列<br><strong> 语法：SELECT * FROM 表名称</strong> — 选择所有的列</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 表 abc 两个 id  表 abc 中不包含 字段 a=b 的 查询出来，只显示 id</span>
<span class="token keyword">SELECT</span> s<span class="token punctuation">.</span>id <span class="token keyword">from</span> station s <span class="token keyword">WHERE</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span> <span class="token operator">and</span> user_id <span class="token operator">not</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 从表 Persons 选取 LastName 列的数据</span>
<span class="token keyword">SELECT</span> LastName <span class="token keyword">FROM</span> Persons 
<span class="token comment">-- 结果集中会自动去重复数据</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Company <span class="token keyword">FROM</span> Orders
<span class="token comment">-- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，</span>
<span class="token comment">-- 结果集显示 Persons 表的 LastName、FirstName 字段，Orders 表的 OrderNo 字段</span>
<span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> o<span class="token punctuation">.</span>OrderNo <span class="token keyword">FROM</span> Persons p<span class="token punctuation">,</span> Orders o <span class="token keyword">WHERE</span> p<span class="token punctuation">.</span>Id_P <span class="token operator">=</span> o<span class="token punctuation">.</span>Id_P <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="update-改">UPDATE 改 </span></h3><p>Update 语句用于修改表中的数据。<br> 语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- update 语句设置字段值为另一个结果取出来的字段</span>
<span class="token comment">-- 从 user2 表中查到 name 为 Micki 对应的 id，修改 user 中此 id 的 name 字段为 user1 表中 id=1 的表项的 name 字段</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> 
<span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> name <span class="token keyword">from</span> user1 <span class="token keyword">where</span> user1 <span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">)</span>
<span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> user2 <span class="token keyword">where</span> user2 <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'Micki'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="insert-增">INSERT 增 </span></h3><p>INSERT INTO 语句用于向表格中插入新的行。<br> 语法：INSERT INTO 表名称 VALUES (值 1, 值 2,….)<br>语法：INSERT INTO 表名称 (列 1, 列 2,…) VALUES (值 1, 值 2,….)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 向表 Persons 插入一条字段 FirstName = Andy 字段 Address = beijing</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Persons <span class="token punctuation">(</span>FirstName<span class="token punctuation">,</span> Address<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'Andy'</span><span class="token punctuation">,</span> <span class="token string">'beijing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="delete-删">DELETE 删 </span></h3><p>DELETE 语句用于删除表中的行。<br> 语法：DELETE FROM 表名称 WHERE 列名称 = 值</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 在不删除 table_name 表的情况下删除所有的行，清空表。</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name
<span class="token comment">-- 或者</span>
<span class="token keyword">DELETE</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name
<span class="token comment">-- 删除 Person 表字段 FirstName = 'Andy' </span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Person <span class="token keyword">WHERE</span> FirstName <span class="token operator">=</span> <span class="token string">'Andy'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="列处理">列处理 </span></h2><h3><span id="count">COUNT</span></h3><p>COUNT 统计符合要求的表项数(行数)<br> 语法：SELECT COUNT(“字段名”) FROM “表格名”;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 表 stores 中 store_name 栏不是 NULL 的表项总数</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span> <span class="token punctuation">(</span>Store_Name<span class="token punctuation">)</span> <span class="token keyword">FROM</span> stores <span class="token keyword">WHERE</span> store_name <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span> 
<span class="token comment">-- 获取 Persons 表的总数</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> totals <span class="token keyword">FROM</span> Persons<span class="token punctuation">;</span>
<span class="token comment">-- 获取表 station 字段 user_id 相同的总数</span>
<span class="token keyword">SELECT</span> user_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> totals <span class="token keyword">FROM</span> station <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> user_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="max">MAX</span></h3><p>MAX 函数返回一列中的最大值。NULL 值不包括在计算中。<br>语法：SELECT MAX(“字段名”) FROM “表格名”</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 列出表 orders 字段 OrderPrice 列最大值，</span>
<span class="token comment">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</span>
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>OrderPrice<span class="token punctuation">)</span> <span class="token keyword">AS</span> LargestOrderPrice <span class="token keyword">FROM</span> orders<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="sum">SUM</span></h3><p>SUM 用于计算某一列的和。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 计算 OrderPrice </span>
<span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>OrderPrice<span class="token punctuation">)</span> <span class="token keyword">AS</span> totalprice <span class="token keyword">FROM</span> Orders<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="where-条件限定">WHERE - 条件限定 </span></h2><p>WHERE 子句用于规定选择的标准。<br> 语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 从表 Persons 中选出 Year 字段大于 1965 的数据</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> <span class="token keyword">Year</span><span class="token operator">></span><span class="token number">1965</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="and-和-or">AND 和 OR</span></h3><p>AND – 与； OR – 或；</p>
<h3><span id="not">NOT</span></h3><p>NOT – 用于逻辑运算语句前</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> Products <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> vend_id <span class="token operator">=</span> <span class="token string">'DLL01'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="in">IN</span></h3><p>IN – 在集合中</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 从表 Persons 选取 字段 LastName 等于 Amy、Beck</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> LastName <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'Amy'</span><span class="token punctuation">,</span><span class="token string">'Beck'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="as-别名">AS - 别名</span></h2><p>as – 别名</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查找并设置把 Employee 表格别名为 emp</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Employee <span class="token keyword">AS</span> emp
<span class="token comment">-- 命名一个表之后，可以在下面用 emp 代替 Employee.</span>
<span class="token comment">-- 例如 </span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp<span class="token punctuation">.</span> <span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>OrderPrice<span class="token punctuation">)</span> <span class="token keyword">AS</span> LargestOrderPrice <span class="token keyword">FROM</span> Orders
<span class="token comment">-- 列出表 Orders 字段 OrderPrice 列最大值，</span>
<span class="token comment">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice </span>
<span class="token comment">-- 显示表 users_profile 中的 name 列</span>
<span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>name <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> users_profile a<span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">;</span> 
<span class="token comment">-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up</span>
<span class="token comment">-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id-- 结果集只显示 mobile、name 两列</span>
<span class="token keyword">SELECT</span> ua<span class="token punctuation">.</span>mobile<span class="token punctuation">,</span>up<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> user_accounts <span class="token keyword">as</span> ua <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> users_profile <span class="token keyword">as</span> up <span class="token keyword">ON</span> ua<span class="token punctuation">.</span>id <span class="token operator">=</span> up<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="order-by-结果排序">ORDER BY - 结果排序</span></h2><p>ORDER BY – 语句用于根据指定的列对结果集进行排序。<br>DESC – 按照降序排序。<br>ASC – 按照升序排序（缺省默认）。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- Company 在表 Orders 中为字母，则会以字母顺序显示公司名称</span>
<span class="token keyword">SELECT</span> Company<span class="token punctuation">,</span> OrderNumber <span class="token keyword">FROM</span> Orders <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Company 
<span class="token comment">-- 后面跟上 DESC 则为降序显示</span>
<span class="token keyword">SELECT</span> Company<span class="token punctuation">,</span> OrderNumber <span class="token keyword">FROM</span> Orders <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Company <span class="token keyword">DESC</span> 
<span class="token comment">-- Company 以降序显示公司名称，并 OrderNumber 以顺序显示</span>
<span class="token keyword">SELECT</span> Company<span class="token punctuation">,</span> OrderNumber <span class="token keyword">FROM</span> Orders <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Company <span class="token keyword">DESC</span><span class="token punctuation">,</span> OrderNumber <span class="token keyword">ASC</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="group-by-结果分组">GROUP BY - 结果分组 </span></h2><p> 用于结果基于某一个属性聚合</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 获取表 station 字段 user_id 相同的总数</span>
<span class="token keyword">SELECT</span> user_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> totals <span class="token keyword">FROM</span> station <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> user_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="join-联合查询">JOIN - 联合查询 </span></h2><p> 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。<br>JOIN：如果表中有至少一个匹配，则返回行<br>INNER JOIN：两表都必须匹配，返回两表的行。<br>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行<br>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行<br>FULL JOIN：只要其中一个表中存在匹配，就返回行</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Persons<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> Persons<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderNo 
<span class="token keyword">FROM</span> PersonsINNER <span class="token keyword">JOIN</span> OrdersON Persons<span class="token punctuation">.</span>Id_P <span class="token operator">=</span> Orders<span class="token punctuation">.</span>Id_PORDER <span class="token keyword">BY</span> Persons<span class="token punctuation">.</span>LastName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="index-索引">INDEX - 索引 </span></h2><h3><span id="普通索引-index"> 普通索引 (INDEX)</span></h3><p> 语法：ALTER TABLE 表名字 ADD INDEX 索引名字 (字段名字)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- –直接创建索引</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> index_user <span class="token keyword">ON</span> <span class="token keyword">user</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
<span class="token comment">-- –修改表结构的方式添加索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">-- 给 user 表中的 name 字段 添加普通索引(INDEX)</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">table</span><span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token comment">-- –创建表的时候同时创建索引</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">table</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>    
    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token punctuation">,</span>    
    <span class="token punctuation">`</span>title<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span>    
    <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token boolean">NULL</span> <span class="token punctuation">,</span>    
    <span class="token punctuation">`</span><span class="token keyword">time</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span>    
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    
    <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>title<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token comment">-- –删除索引</span>
 <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> <span class="token keyword">table</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="主键索引-primary-key"> 主键索引 (PRIMARY key)</span></h3><p> 语法：ALTER TABLE 表名字 ADD PRIMARY KEY (字段名字)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给 user 表中的 id 字段 添加主键索引(PRIMARY key)</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="唯一索引-unique"> 唯一索引 (UNIQUE)</span></h3><p> 语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span>creattime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="全文索引-fulltext"> 全文索引 (FULLTEXT)</span></h3><p> 语法：ALTER TABLE 表名字 ADD FULLTEXT (字段名字)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">ADD</span> FULLTEXT <span class="token punctuation">(</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="添加多列索引">添加多列索引 </span></h3><p> 语法：ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3)</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给 user 表中的 name、city、age 字段添加名字为 name_city_age 的普通索引(INDEX)</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> name_city_age <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>city<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="建立索引的时机">建立索引的时机 </span></h3><p> 在 WHERE 和 JOIN 中出现的列需要建立索引：<br>MySQL 只对 &lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 使用索引 <br> 某些时候的 LIKE 也会使用索引。<br>在 LIKE 以通配符 % 和_开头作查询时，MySQL 不会使用索引</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 此时就需要对 city 和 age 建立索引，</span>
<span class="token comment">-- 由于 mytable 表的 userame 也出现在了 JOIN 子句中，也有对它建立索引的必要。</span>
<span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>Name  <span class="token keyword">FROM</span> mytable t <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> mytable m <span class="token keyword">ON</span> t<span class="token punctuation">.</span>Name<span class="token operator">=</span>m<span class="token punctuation">.</span>username <span class="token keyword">WHERE</span> m<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">20</span> <span class="token operator">AND</span> m<span class="token punctuation">.</span>city<span class="token operator">=</span><span class="token string">'上海'</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable <span class="token keyword">WHERE</span> username <span class="token operator">like</span><span class="token string">'admin%'</span><span class="token punctuation">;</span> 
<span class="token comment">-- 而下句就不会使用：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable WHEREt Name <span class="token operator">like</span><span class="token string">'%admin'</span><span class="token punctuation">;</span> <span class="token comment">-- 因此，在使用 LIKE 时应注意以上的区别。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="使用注意">使用注意</span></h2><ul>
<li>索引不会包含有 NULL 值的列</li>
<li>使用短索引</li>
<li>不要在列上进行运算 索引会失效</li>
</ul>
<h2><span id="表结构修改">表结构修改 </span></h2><h3><span id="添加列"> 添加列 </span></h3><p> 语法：alter table 表名 add 列名 列数据类型 [after 插入位置];<br>示例：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 在表 students 的最后追加列 address: </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students <span class="token keyword">ADD</span> address <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 在名为 age 的列后插入列 birthday: </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students <span class="token keyword">ADD</span> birthday <span class="token keyword">DATE</span> <span class="token keyword">after</span> age<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="修改列">修改列 </span></h3><p> 语法：alter table 表名 change 列名称 列新名称 新数据类型;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将表 tel 列改名为 telphone: </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students CHANGE tel telphone <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"-"</span><span class="token punctuation">;</span>
<span class="token comment">-- 将 name 列的数据类型改为 char(16): </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students CHANGE name name <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="删除列">删除列 </span></h3><p> 语法：alter table 表名 drop 列名称;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除表 students 中的 birthday 列: </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students <span class="token keyword">DROP</span> birthday<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="重命名表">重命名表 </span></h3><p> 语法：alter table 表名 rename 新表名;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 重命名 students 表为 workmates: </span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> students <span class="token keyword">RENAME</span> workmates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="清空表数据">清空表数据 </span></h3><p> 语法：delete from 表名;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 清空表为 workmates 里面的数据，不删除表。 </span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> workmates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="删除整张表">删除整张表 </span></h3><p> 语法：drop table 表名;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除 workmates 表: </span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> workmates<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="删除整个数据库">删除整个数据库 </span></h2><p> 语法：drop database 数据库名;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除 samp_db 数据库: </span>
<span class="token keyword">DROP</span> DATEBASE samp_db<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑记之 Mysql 访问拒绝故障</title>
    <url>/2015/11/01/MySQL/%E8%B8%A9%E5%9D%91%E8%AE%B0%E4%B9%8BMysql%E8%AE%BF%E9%97%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<h2><span id="问题产生">问题产生 </span></h2><p> 今天用命令行登陆 mysql 时出现了 Error。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -uroot -p
ERROR <span class="token number">16958</span><span class="token punctuation">(</span><span class="token number">28000</span><span class="token punctuation">)</span>: Access denied <span class="token keyword">for</span> user <span class="token string">'root'</span>@<span class="token string">'localhost'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>起初我以为是 root 密码错了，于是就去 mysql 官方文档查了下改密码的方法</p>
<p>关闭 mysql 进程然后再建立一个改密码的 sql 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl stop mysql.service

$ <span class="token builtin class-name">cd</span> /tmp <span class="token operator">&amp;&amp;</span> <span class="token function">vim</span> init.sql <span class="token comment">#xxxxxx 代表要修改的密码</span>
alter user <span class="token string">'root'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'xxxxxx'</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>安全模式启动 mysql</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mysqld_safe --defaults-file<span class="token operator">=</span>/etc/mysql/my.cnf --init-file<span class="token operator">=</span>/tmp/init.sql <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后重启 mysql</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl restart mysql.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样把密码改为了<code>xxxxxx</code></p>
<p>然后我再去登陆</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -uroot -p
ERROR <span class="token number">16958</span><span class="token punctuation">(</span><span class="token number">28000</span><span class="token punctuation">)</span>: Access denied <span class="token keyword">for</span> user <span class="token string">'root'</span>@<span class="token string">'localhost'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>=͟͟͞͞(꒪⌓꒪*)</p>
<p>并不是密码错误的锅</p>
<h2><span id="问题关键">问题关键 </span></h2><p> 求助了强大的 google 和 stackoverflow，终于找到了问题。</p>
<blockquote>
<p>The reason is that recent Ubuntu installation (maybe others also), mysql is using by default the <a href="https://dev.mysql.com/doc/mysql-security-excerpt/5.5/en/socket-authentication-plugin.html">UNIX auth_socket plugin</a>.</p>
<p>Basically means that: <em>db_users using it, will be “auth” by *</em>the system user credentias.</p>
</blockquote>
<p>user 表中的用户的 plugin 默认会设置为 auth_socket，这样的话，认证会由系统用户证书来进行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> mysql -u root <span class="token comment"># I had to use "sudo" since is new installation</span>

mysql<span class="token operator">></span> USE mysql<span class="token punctuation">;</span>
mysql<span class="token operator">></span> SELECT User, Host, plugin FROM mysql.user<span class="token punctuation">;</span>

+------------------+-----------------------+
<span class="token operator">|</span> User             <span class="token operator">|</span> plugin                <span class="token operator">|</span>
+------------------+-----------------------+
<span class="token operator">|</span> root             <span class="token operator">|</span> auth_socket           <span class="token operator">|</span>
<span class="token operator">|</span> mysql.sys        <span class="token operator">|</span> mysql_native_password <span class="token operator">|</span>
<span class="token operator">|</span> debian-sys-maint <span class="token operator">|</span> mysql_native_password <span class="token operator">|</span>
+------------------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="解决方案">解决方案 </span></h2><p> 有两种解决方案，但都需要登陆进 mysql，所以需要重启 mysql 开启 <code>--skip-grant-tables</code> 参数，来跳过权限表的加载</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl stop mysql.service
$ mysqld_safe --defaults-file<span class="token operator">=</span>/etc/mysql/my.cnf --skip-grant-tables  --skip-networking <span class="token operator">&amp;</span>
$ <span class="token function">sudo</span> mysql  <span class="token comment"># 这样就可以免登录直接进入 mysql 交互界面</span>

mysql<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="方法-1">方法 1</span></h3><p>把 mysql 的 root 用户的 plugin 字段设置为<code>mysql_native_password</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> USE mysql<span class="token punctuation">;</span>
mysql<span class="token operator">></span> UPDATE user SET <span class="token assign-left variable">plugin</span><span class="token operator">=</span><span class="token string">'mysql_native_password'</span> WHERE <span class="token assign-left variable">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span>

$ systemctl restart mysql.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="方法-2">方法 2</span></h3><p>新建一个 root 用户</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> USE mysql<span class="token punctuation">;</span>
mysql<span class="token operator">></span> CREATE <span class="token environment constant">USER</span> <span class="token string">'YOUR_SYSTEM_USER'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'xxxxxx'</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> GRANT ALL PRIVILEGES ON *.* TO <span class="token string">'root2'</span>@<span class="token string">'localhost'</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> UPDATE user SET <span class="token assign-left variable">plugin</span><span class="token operator">=</span><span class="token string">'auth_socket'</span> WHERE <span class="token assign-left variable">User</span><span class="token operator">=</span><span class="token string">'root2'</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span>

$ <span class="token function">service</span> mysql restart
$ mysql -u root2 -pxxxxxx <span class="token comment"># 用 root2 来登陆</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>bugfix</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GNU-gcc 简明教程</title>
    <url>/2015/10/18/Linux/Linux-gcc%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>gcc/g++ 是 GNU 工具包中强大的 c/c++ 编译工具，结合 make 工具，可以做到自动化编译功能。</p>
<p>一般来说，编译 c 语言使用 gcc，编译 c++ 语言使用 g++，两者的命令几乎相同。</p>
<a id="more"></a>
<h2><span id="编译流程">编译流程 </span></h2><p> 分为四步，预处理、编译、汇编、链接</p>
<p>样例程序</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*************************
		hello.cpp
	*************************/</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;IOSTREAM></span></span>
 
	<span class="token keyword">static</span> <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">T <span class="token number">9</span></span></span>
 
	using namespace std<span class="token punctuation">;</span>
 
	<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
 
	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		Status i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> T <span class="token operator">*</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//Test Cout</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="指定输出文件-o">指定输出文件 -o</span></h3><p>表示指定输出的文件,o 为小写</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ <span class="token punctuation">[</span>- 选项<span class="token punctuation">]</span> inputfile -o outputfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="预处理-e">预处理 -E</span></h3><p>使用预处理器 cpp。输出预处理后的文件，linux 下以 <code>.i</code> 为后缀名。默认不生成文件，可以重定向到一个输出文件中。这一步主要做了这些事情：宏的替换，还有注释的消除，还有找到相关的库文件，可以理解为无关代码的清除。</p>
<p>如果想查看待编译文件的预处理过程，可以用下面的命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -E hello.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样会直接在 terminal 中显示预处理过程，如果 <code>main.cxx</code> 中包含<code>include</code>，例如<code>#include&lt;iostream&gt;</code>, 只能看到部分预处理结果；这个只显示预处理，不生成文件。</p>
<p>也可以吧预处理的过程重定向到一个文件中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -E hello.cpp -o hello.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看 <a href="http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html"> 官方文档 </a> 来了解更多。</p>
<h3><span id="编译-s">编译 -S</span></h3><p>编译就是指使用编译器 egcs 把预处理的代码编译为汇编代码。</p>
<p>例如吧把预处理后的文件 <code>hello.i</code> 编译为汇编代码文件<code>hello.s</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -S hello.i -o hello.s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="汇编-c">汇编 -c</span></h3><p>汇编就是指使用汇编器 as 把汇编代码生成目标代码，目标代码就是二进制机器码。</p>
<p>例如把 <code>hello.s</code> 生成为目标代码<code>hello.o</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -c hello.s -o hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="链接-o">链接 -O</span></h3><p>链接就是指把 <code>.o</code> 文件与所需的库文件链接整合形成可执行文件。 <code>-L</code>表示链接。</p>
<p>注意此处的 <code>-O</code> 为大写不同于指定输出文件的 <code>-o</code> 小写</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -O hello.o lib1.a lib2.a -o main
$ g++ hello.o -L /usr/include/iostream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="常见参数">常见参数 </span></h2><h3><span id="警告相关"> 警告相关</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -pedantic main.cpp -o illcode <span class="token comment"># 显示不符合 ANSI/ISO C 语言标准的警告信息</span>
$ g++ -Wall main.cpp -o illcode <span class="token comment"># 产生尽可能多的警告信息</span>
$ g++ -Werror main.cpp -o illcode <span class="token comment"># 将所有的警告当成错误进行处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="调试信息-g">调试信息 -g</span></h3><p>编译的时候，产生调试信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -g main.cxx -o main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="指定语言-x">指定语言 -x</span></h3><p>支持 c c++ assembler none，‘none’意味着恢复默认行为，即根据文件的扩展名猜测源文件的语言</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -x c++ main.cxx // 指定源代码为 c++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="关联信息-m">关联信息 -M</span></h3><p>生成文件关联信息，包含目标文件依赖的所有源代码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -M main.cxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="优化级别-o0-o1-o2-o3">优化级别 -O0 -O1 -O2 -O3</span></h3><p>编译器的优化选项的 4 个级别，-O0 表示没有优化,-O1 为缺省值，-O3 优化级别最高　　 　　</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cxx -o main -o2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="查看编译过程-v">查看编译过程 -v</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cxx -v -o main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="进阶">进阶 </span></h2><h3><span id="宏"> 宏</span></h3><p>可以使用 -Dname 选项来定义一个宏，或者 -Dname=value 定义一个值 value 的宏。如果该值包含空格，则应包含在双引号中。</p>
<h3><span id="库">库 </span></h3><p> 库是一个预编译的对象文件的集合，可以通过链接器链接到程序中。<br>有两种类型的外部库：静态库和动态库。 </p>
<p>Windows 系统的静态库文件扩展名为<code>*.lib</code>，动态库文件扩展名为<code>*.dll</code></p>
<p>Unix 类系统的静态库文件扩展名为<code>*.a</code>，动态库文件扩展名为<code>*.so</code></p>
<p>当程序与静态库链接时，程序中使用的外部函数的机器代码将被复制到可执行文件中。一个静态库可以通过存档程序”ar.exe”创建。<br>当程序与一个动态库链接时，在可执行文件中创建了一个表。在可执行文件开始运行之前，操作系统加载所需的外部函数 <code>- a</code> 的机器代码，这被称为 <strong> 动态链接 </strong> 的过程。因为一个库的一个副本可以在多个程序之间共享，所以动态链接使可执行文件更小，并 <strong> 节省磁盘空间 </strong>。此外，大多数操作系统允许在内存中的共享库的一个副本被所有的运行程序使用，因此，也<strong> 节省内存 </strong>。动态库的代码可以升级而<strong> 无需重新编译 </strong> 程序。<br>动态链接库的优点非常多，GCC 默认是链接动态库的。 </p>
<h3><span id="搜索头文件和库">搜索头文件和库 </span></h3><p> 编译程序时，编译器需要头文件来编译源代码；链接器需要库来解析来自其他对象文件或库的外部引用。需要合适的设置来告诉编译器和链接器头文件和库的位置。</p>
<p>每一个在源文件里使用的头文件 (<code>#include &lt; 头文件名字 &gt;</code>)，编译器搜索<code>include-paths</code> 来找头文件。<code>include-paths</code> 是通过 <code>-Idir</code> 选项指定，或者是环境变量 <code>CPATH</code>指定。由于头文件的文件名是已知的，所以只需要路径名就可以。 </p>
<p>链接器 搜索 <code>library-paths</code> ，将程序链接到可执行文件所需的库。<code>library-paths</code>是通过 <code>-Ldir</code> 选项指定（或环境变量<code>LIBRARY_PATH</code>。</p>
<p>此外还必须指定库名称，这里和编译器找头文件不同，头文件在源代码就有声明，所以不需要额外再去指定，而库需要使用 <code>-l</code> 选项来告诉链接器。</p>
<h2><span id="工具">工具</span></h2><h3><span id="file-工具">file 工具</span></h3><p>file 工具可以用来显示目标文件和可执行文件的类型</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -c hello.cpp
$ g++ -o hello hello.o
$ <span class="token function">file</span> hello.o
hello.o: ELF <span class="token number">64</span>-bit LSB  relocatable, x86-64, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="nm-工具">nm 工具 </span></h3><p>nm 工具用于列出目标文件的符号表，<br> 常用来检查一个特定的函数是否被定义在一个对象文件中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ nm hello.o
0000000000000000 T _main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="ldd-工具">ldd 工具</span></h3><p>ldd 可以确定程序依赖的动态链接库有哪些。用于可执行文件，并显示它所依赖的共享库的列表。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ldd hello
/media/study/mycode/GCC_test$ ldd hello
linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>0x00007ffe6653a000<span class="token punctuation">)</span>
libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007fd06d171000<span class="token punctuation">)</span>
/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007fd06d536000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的 env 是什么</title>
    <url>/2015/10/22/Linux/Linux%E4%B8%AD%E7%9A%84env/</url>
    <content><![CDATA[<p>env 是环境 Environment 的缩写，正如它的名字一样，它用于 <strong> 显示系统中已存在的环境变量 </strong>，以及<strong> 在定义的环境中执行指令</strong>，一般位于<code>/usr/bin/env</code>。</p>
<a id="more"></a>
<h2><span id="env-作为脚本解释器指定程序">env 作为脚本解释器指定程序 </span></h2><p> 用 env 启动是因为脚本解释器在 linux 可能被安装于不同目录，所以要在 PATH 环境变量中找</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ /usr/bin/env
<span class="token punctuation">..</span>.
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/zsh
<span class="token punctuation">..</span>.
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/Users/maywzh/.pyenv/shims:/Users/maywzh/.pyenv/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="以-python-为例">以 python 为例 </span></h3><p> 在这里我们使用了 pyenv 来管理多版本 python，它的具体可见<a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p>
<p>它可以选用特定环境使用的 python 版本，把 <code>~/.pyenv/shims</code> 作为一个垫片路径，里面是选定的 python 版本的解释器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> /Users/maywzh/.pyenv/shims
2to3              easy_install      idle              idle3.7           pip3              pydoc             pydoc3.7          python-config     python3-config    python3.7-config  python3.7m-config pyvenv-3.7
2to3-3.7          easy_install-3.7  idle3             pip               pip3.7            pydoc3            python            python3           python3.7         python3.7m        pyvenv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在这里选用了 python3.7，可以直接用下面命令来确定使用的版本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">env</span> python
Python <span class="token number">3.7</span>.1 <span class="token punctuation">(</span>default, Oct <span class="token number">22</span> <span class="token number">2018</span>, 04:20:43<span class="token punctuation">)</span>
<span class="token punctuation">[</span>Clang <span class="token number">10.0</span>.0 <span class="token punctuation">(</span>clang-1000.10.44.2<span class="token punctuation">)</span><span class="token punctuation">]</span> on darwin
Type <span class="token string">"help"</span>, <span class="token string">"copyright"</span>, <span class="token string">"credits"</span> or <span class="token string">"license"</span> <span class="token keyword">for</span> <span class="token function">more</span> information.
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用这种方式使用 python 就相当灵活，只需要配置 PATH 变量即可，不会出现因为写死解释器路径而找不到解释器的情况。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding: utf-8 -*-</span>

<span class="token triple-quoted-string string">'''hello.py'''</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要运行该程序</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">chmod</span> +x hello.py <span class="token comment"># 为该脚本程序添加执行权限</span>
$ ./hello.py <span class="token comment"># 因为指定了 #!/usr/bin/env python ， 调用 python 解释器来运行该脚本程序</span>
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的 lsof</title>
    <url>/2015/12/16/Linux/Linux%E4%B8%AD%E7%9A%84lsof/</url>
    <content><![CDATA[<h2><span id="lsof-list-open-files">lsof - list open files</span></h2><p>lsof（list open files）是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<a id="more"></a>
<h2><span id="文件类型">文件类型</span></h2><p>lsof 打开的文件可以是：</p>
<ol>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络 socket，unix 域名 socket）</li>
<li>还有其它类型的文件，等等</li>
</ol>
<h2><span id="命令参数">命令参数</span></h2><ul>
<li>-a 列出打开文件存在的进程</li>
<li>-i&lt; 条件 &gt; 列出符合条件的进程。（4、6、协议、: 端口、 @ip ）</li>
<li>-c&lt; 进程名 &gt; 列出指定进程所打开的文件</li>
<li>-p&lt; 进程号 &gt; 列出指定进程号所打开的文件</li>
<li>-d&lt; 文件号 &gt; 列出占用该文件号的进程</li>
<li>+d&lt; 目录 &gt; 列出目录下被打开的文件</li>
<li>+D&lt; 目录 &gt; 递归列出目录下被打开的文件</li>
<li>-n&lt; 目录 &gt; 列出使用 NFS 的文件</li>
<li>-g 列出 GID 号进程详情</li>
<li>-u 列出 UID 号进程详情</li>
<li>-h 显示帮助信息</li>
<li>-v 显示版本信息</li>
</ul>
<h2><span id="使用实例">使用实例 </span></h2><h3><span id="实例一无任何参数"> 实例一：无任何参数</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span><span class="token operator">|</span> <span class="token function">more</span>
COMMAND     PID      <span class="token environment constant">USER</span>   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
init          <span class="token number">1</span>      root  cwd       DIR              <span class="token number">253,0</span>     <span class="token number">4096</span>          <span class="token number">2</span> /
init          <span class="token number">1</span>      root  rtd       DIR              <span class="token number">253,0</span>     <span class="token number">4096</span>          <span class="token number">2</span> /
init          <span class="token number">1</span>      root  txt       REG              <span class="token number">253,0</span>   <span class="token number">150352</span>    <span class="token number">1310795</span> /sbin/init
init          <span class="token number">1</span>      root  mem       REG              <span class="token number">253,0</span>    <span class="token number">65928</span>    <span class="token number">5505054</span> /lib64/libnss_files-2.12.so
init          <span class="token number">1</span>      root  mem       REG              <span class="token number">253,0</span>  <span class="token number">1918016</span>    <span class="token number">5521405</span> /lib64/libc-2.12.so
init          <span class="token number">1</span>      root  mem       REG              <span class="token number">253,0</span>    <span class="token number">93224</span>    <span class="token number">5521440</span> /lib64/libgcc_s-4.4.6-20120305.so.1
init          <span class="token number">1</span>      root  mem       REG              <span class="token number">253,0</span>    <span class="token number">47064</span>    <span class="token number">5521407</span> /lib64/librt-2.12.so
init          <span class="token number">1</span>      root  mem       REG              <span class="token number">253,0</span>   <span class="token number">145720</span>    <span class="token number">5521406</span> /lib64/libpthread-2.12.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>lsof</code>输出各列信息的意义如下：</p>
<ul>
<li><p>COMMAND：进程的名称</p>
</li>
<li><p>PID：进程标识符</p>
</li>
<li><p>PPID：父进程标识符（需要指定 -R 参数）</p>
</li>
<li><p>USER：进程所有者</p>
</li>
<li><p>PGID：进程所属组</p>
</li>
<li><p>FD：文件描述符，应用程序通过文件描述符识别该文件。如 cwd、txt 等:</p>
</li>
</ul>
<pre class="line-numbers language-md" data-language="md"><code class="language-md">（1）cwd：表示 current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#96;&#x2F;sbin&#x2F;init&#96; 程序
（3）lnn：library references (AIX);
（4）er：FD information error (see NAME column);
（5）jld：jail directory (FreeBSD);
（6）ltx：shared library text (code and data);
（7）mxx ：hex memory-mapped type number xx.
（8）m86：DOS Merge mapped file;
（9）mem：memory-mapped file;
（10）mmap：memory-mapped device;
（11）pd：parent directory;
（12）rtd：root directory;
（13）tr：kernel trace file (OpenBSD);
（14）v86  VP&#x2F;ix mapped file;
（15）0：表示标准输入
（16）1：表示标准输出
（17）2：表示标准错误
一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u 等
（1）u：表示该文件被打开并处于读取 &#x2F; 写入模式
（2）r：表示该文件被打开并处于只读模式
（3）w：表示该文件被打开并处于写入模式
（4）空格：表示该文件的状态模式为 unknow，且没有锁定
（5）-：表示该文件的状态模式为 unknow，且被锁定
同时在文件状态模式后面，还跟着相关的锁
（1）N：for a Solaris NFS lock of unknown type;
（2）r：for read lock on part of the file;
（3）R：for a read lock on the entire file;
（4）w：for a write lock on part of the file;（文件的部分写锁）
（5）W：for a write lock on the entire file;（整个文件的写锁）
（6）u：for a read and write lock of any length;
（7）U：for a lock of unknown type;
（8）x：for an SCO OpenServer Xenix lock on part of the file;
（9）X：for an SCO OpenServer Xenix lock on the entire file;
（10）space：if there is no lock.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>TYPE：文件类型，如 DIR、REG 等，常见的文件类型:</li>
</ul>
<pre class="line-numbers language-md" data-language="md"><code class="language-md">（1）DIR：表示目录
（2）CHR：表示字符类型
（3）BLK：块设备类型
（4）UNIX： UNIX 域套接字
（5）FIFO：先进先出 (FIFO) 队列
（6）IPv4：网际协议 (IP) 套接字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>DEVICE：指定磁盘的名称</p>
</li>
<li><p>SIZE：文件的大小</p>
</li>
<li><p>NODE：索引节点（文件在磁盘上的标识）</p>
</li>
<li><p>NAME：打开文件的确切名称</p>
</li>
</ul>
<h3><span id="实例-2查找某个文件相关的进程">实例 2：查找某个文件相关的进程</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> /bin/bash
COMMAND     PID <span class="token environment constant">USER</span>  FD   TYPE DEVICE SIZE/OFF    NODE NAME
mysqld_sa  <span class="token number">2169</span> root txt    REG  <span class="token number">253,0</span>   <span class="token number">938736</span> <span class="token number">4587562</span> /bin/bash
ksmtuned   <span class="token number">2334</span> root txt    REG  <span class="token number">253,0</span>   <span class="token number">938736</span> <span class="token number">4587562</span> /bin/bash
<span class="token function">bash</span>      <span class="token number">20121</span> root txt    REG  <span class="token number">253,0</span>   <span class="token number">938736</span> <span class="token number">4587562</span> /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-3列出某个用户打开的文件信息">实例 3：列出某个用户打开的文件信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">   <span class="token variable">$lsof</span> -u username

-u 选项，u 是 user 的缩写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-4列出某个程序进程所打开的文件信息">实例 4：列出某个程序进程所打开的文件信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -c mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>-c</code> 选项将会列出所有以 mysql 这个进程开头的程序的文件，其实也可以写成 <code>lsof | grep mysql</code></p>
<h3><span id="实例-5列出某个用户以及某个进程所打开的文件信息">实例 5：列出某个用户以及某个进程所打开的文件信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span>  -u <span class="token builtin class-name">test</span> -c mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-6通过某个进程号显示该进程打开的文件">实例 6：通过某个进程号显示该进程打开的文件</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -p <span class="token number">11968</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-7列出所有的网络连接">实例 7：列出所有的网络连接</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-8列出所有-tcp-网络连接信息">实例 8：列出所有 tcp 网络连接信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -i tcp

<span class="token variable">$lsof</span> -n -i tcp
COMMAND     PID  <span class="token environment constant">USER</span>   FD   TYPE  DEVICE SIZE/OFF NODE NAME
svnserve  <span class="token number">11552</span> weber    3u  IPv4 <span class="token number">3799399</span>      0t0  TCP *:svn <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>
redis-ser <span class="token number">25501</span> weber    4u  IPv4  <span class="token number">113150</span>      0t0  TCP <span class="token number">127.0</span>.0.1:6379 <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-9列出谁在使用某个端口">实例 9：列出谁在使用某个端口</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -i :3306<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-10列出某个用户的所有活跃的网络端口">实例 10：列出某个用户的所有活跃的网络端口</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -a -u <span class="token builtin class-name">test</span> -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-11根据文件描述列出对应的文件信息">实例 11：根据文件描述列出对应的文件信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -d description<span class="token punctuation">(</span>like <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -d <span class="token number">3</span> <span class="token operator">|</span> <span class="token function">grep</span> PARSER1
<span class="token function">tail</span>      <span class="token number">6499</span> tde    3r   REG    <span class="token number">253,3</span>   <span class="token number">4514722</span>     <span class="token number">417798</span> /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>说明： 0 表示标准输入，1 表示标准输出，2 表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<h3><span id="实例-12列出被进程号为-1234-的进程所打开的所有-ipv4-network-files">实例 12：列出被进程号为 1234 的进程所打开的所有 IPV4 network files</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$lsof</span> -i <span class="token number">4</span> -a -p <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-13列出目前连接主机-nf5260i5-td-上端口为202180-相关的所有文件信息且每隔-3-秒重复执行">实例 13：列出目前连接主机 nf5260i5-td 上端口为：20，21，80 相关的所有文件信息，且每隔 3 秒重复执行</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">lsof</span> -i @nf5260i5-td:20,21,80 -r <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的 wget</title>
    <url>/2015/06/21/Linux/Linux%E4%B8%AD%E7%9A%84wget/</url>
    <content><![CDATA[<h2><span id="wget-web-get">wget - web get</span></h2><p>Linux 系统中的 wget 是一个下载文件的工具，它用在命令行下，是最常用的 CLI 工具之一。wget 非常稳定，支持断点续传，支持 HTTP，HTTPS 和 FTP 协议，可以使用 HTTP 代理。</p>
<p>wget 可以跟踪 HTML 页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构，因此可以作为网络爬虫工具。</p>
<a id="more"></a>
<h2><span id="命令格式">命令格式</span></h2><p>wget  参数  URL </p>
<h2><span id="命令参数">命令参数：</span></h2><h3><span id="启动参数">启动参数：</span></h3><ul>
<li>-V, –version 显示 wget 的版本后退出</li>
<li>-h, –help 打印语法帮助</li>
<li>-b, –background 启动后转入后台执行</li>
<li>-e, –execute=COMMAND 执行’.wgetrc’格式的命令，wgetrc 格式参见 /etc/wgetrc 或~/.wgetrc</li>
</ul>
<h3><span id="记录和输入文件参数">记录和输入文件参数</span></h3><ul>
<li>-o, –output-file=FILE 把记录写到 FILE 文件中</li>
<li>-a, –append-output=FILE 把记录追加到 FILE 文件中</li>
<li>-d, –debug 打印调试输出</li>
<li>-q, –quiet 安静模式(没有输出)</li>
<li>-v, –verbose 冗长模式(这是缺省设置)</li>
<li>-nv, –non-verbose 关掉冗长模式，但不是安静模式</li>
<li>-i, –input-file=FILE 下载在 FILE 文件中出现的 URLs</li>
<li>-F, –force-html 把输入文件当作 HTML 格式文件对待</li>
<li>-B, –base=URL 将 URL 作为在 -F -i 参数指定的文件中出现的相对链接的前缀</li>
</ul>
<p>–sslcertfile=FILE 可选客户端证书 –sslcertkey=KEYFILE 可选客户端证书的 KEYFILE –egd-file=FILE 指定 EGD socket 的文件名</p>
<h3><span id="下载参数">下载参数</span></h3><ul>
<li>-bind-address=ADDRESS 指定本地使用地址(主机名或 IP，当本地有多个 IP 或名字时使用)</li>
<li>-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</li>
<li>-O –output-document=FILE 把文档写到 FILE 文件中</li>
<li>-nc, –no-clobber 不要覆盖存在的文件或使用.# 前缀</li>
<li>-c, –continue 接着下载没下载完的文件</li>
<li>-progress=TYPE 设定进程条标记</li>
<li>-N, –timestamping 不要重新下载文件除非比本地文件新</li>
<li>-S, –server-response 打印服务器的回应</li>
<li>-T, –timeout=SECONDS 设定响应超时的秒数</li>
<li>-w, –wait=SECONDS 两次尝试之间间隔 SECONDS 秒</li>
<li>-waitretry=SECONDS 在重新链接之间等待 1…SECONDS 秒</li>
<li>-random-wait 在下载之间等待 0…2*WAIT 秒</li>
<li>-Y, -proxy=on/off 打开或关闭代理</li>
<li>-Q, -quota=NUMBER 设置下载的容量限制</li>
<li>-limit-rate=RATE 限定下载输率</li>
</ul>
<h3><span id="目录参数">目录参数</span></h3><ul>
<li>-nd –no-directories 不创建目录</li>
<li>-x, –force-directories 强制创建目录</li>
<li>-nH, –no-host-directories 不创建主机目录</li>
<li>-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</li>
<li>-cut-dirs=NUMBER 忽略 NUMBER 层远程目录</li>
</ul>
<h3><span id="http-选项参数">HTTP 选项参数</span></h3><ul>
<li>-http-user=USER 设定 HTTP 用户名为 USER.</li>
<li>-http-passwd=PASS 设定 http 密码为 PASS</li>
<li>-C, –cache=on/off 允许 / 不允许服务器端的数据缓存 (一般情况下允许)</li>
<li>-E, –html-extension 将所有 text/html 文档以.html 扩展名保存</li>
<li>-ignore-length 忽略 ‘Content-Length’头域</li>
<li>-header=STRING 在 headers 中插入字符串 STRING</li>
<li>-proxy-user=USER 设定代理的用户名为 USER</li>
<li>proxy-passwd=PASS 设定代理的密码为 PASS</li>
<li>referer=URL 在 HTTP 请求中包含 ‘Referer: URL’头</li>
<li>-s, –save-headers 保存 HTTP 头到文件</li>
<li>-U, –user-agent=AGENT 设定代理的名称为 AGENT 而不是 Wget/VERSION</li>
<li>no-http-keep-alive 关闭 HTTP 活动链接 (永远链接)</li>
<li>cookies=off 不使用 cookies</li>
<li>load-cookies=FILE 在开始会话前从文件 FILE 中加载 cookie</li>
<li>save-cookies=FILE 在会话结束后将 cookies 保存到 FILE 文件中</li>
</ul>
<h3><span id="ftp-选项参数">FTP 选项参数</span></h3><ul>
<li>-nr, –dont-remove-listing 不移走 ‘.listing’文件</li>
<li>-g, –glob=on/off 打开或关闭文件名的 globbing 机制</li>
<li>passive-ftp 使用被动传输模式 (缺省值).</li>
<li>active-ftp 使用主动传输模式</li>
<li>retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</li>
</ul>
<h3><span id="递归下载参数">递归下载参数</span></h3><ul>
<li><p>-r, –recursive 递归下载－－慎用!</p>
</li>
<li><p>-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</p>
</li>
<li><p>-delete-after 在现在完毕后局部删除文件</p>
</li>
<li><p>-k, –convert-links 转换非相对链接为相对链接</p>
</li>
<li><p>-K, –backup-converted 在转换文件 X 之前，将之备份为 X.orig</p>
</li>
<li><p>-m, –mirror 等价于 -r -N -l inf -nr</p>
</li>
<li><p>-p, –page-requisites 下载显示 HTML 文件的所有图片</p>
<p>​    递归下载中的包含和不包含(accept/reject)：</p>
</li>
<li><p>-A, –accept=LIST 分号分隔的被接受扩展名的列表</p>
</li>
<li><p>-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</p>
</li>
<li><p>-D, –domains=LIST 分号分隔的被接受域的列表</p>
</li>
<li><p>-exclude-domains=LIST 分号分隔的不被接受的域的列表</p>
</li>
<li><p>-follow-ftp 跟踪 HTML 文档中的 FTP 链接</p>
</li>
<li><p>-follow-tags=LIST 分号分隔的被跟踪的 HTML 标签的列表</p>
</li>
<li><p>-G, –ignore-tags=LIST 分号分隔的被忽略的 HTML 标签的列表</p>
</li>
<li><p>-H, –span-hosts 当递归时转到外部主机</p>
</li>
<li><p>-L, –relative 仅仅跟踪相对链接</p>
</li>
<li><p>-I, –include-directories=LIST 允许目录的列表</p>
</li>
<li><p>-X, –exclude-directories=LIST 不被包含目录的列表</p>
</li>
<li><p>-np, –no-parent 不要追溯到父目录</p>
</li>
</ul>
<p>wget -S –spider url 不下载只显示过程</p>
<h2><span id="使用实例">使用实例 </span></h2><h3><span id="实例-1使用-wget-下载单个文件"> 实例 1：使用 wget 下载单个文件</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> http://www.xxx.com/wordpress-3.1-zh_CN.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>说明：以上例子从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。</p>
<h3><span id="实例-2使用-wget-o-下载并以不同的文件名保存">实例 2：使用 wget -O 下载并以不同的文件名保存</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> -O wordpress.zip http://www.xxx.com/download.aspx?id<span class="token operator">=</span><span class="token number">1080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>wget 默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。</p>
<h3><span id="实例-3使用-wget-limit-rate-限速下载">实例 3：使用 wget –limit -rate 限速下载</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> --limit-rate<span class="token operator">=</span>300k http://www.xxx.com/wordpress-3.1-zh_CN.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当你执行 wget 的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。</p>
<h3><span id="实例-4使用-wget-c-断点续传">实例 4：使用 wget -c 断点续传</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> -c http://www.xxx.com/wordpress-3.1-zh_CN.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 wget -c 重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用 -c 参数。</p>
<h3><span id="实例-5使用-wget-b-后台下载">实例 5：使用 wget -b 后台下载</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> -b http://www.xxx.com/wordpress-3.1-zh_CN.zip
Continuing <span class="token keyword">in</span> background, pid <span class="token number">1840</span>.
Output will be written to <span class="token string">'wget-log'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对于下载非常大的文件的时候，我们可以使用参数 -b 进行后台下载。</p>
<p>你可以使用以下命令来察看下载进度:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tail</span> -f wget-log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="实例-6伪装代理名称下载">实例 6：伪装代理名称下载</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> --user-agent<span class="token operator">=</span><span class="token string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3497.81 Safari/537.36"</span> http://www.xxx.com/wordpress-3.1-zh_CN.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent 参数伪装。</p>
<h3><span id="实例-7使用-wget-i-下载多个文件">实例 7：使用 wget -i 下载多个文件 </span></h3><p> 首先，保存一份下载链接文件, 接着使用这个文件和参数 -i 下载:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cat</span> <span class="token operator">></span> filelist.txt
url1
url2
url3
url4

<span class="token variable">$wget</span> -i filelist.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-8使用-wget-mirror-镜像网站">实例 8：使用 wget –mirror 镜像网站</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> --mirror -p --convert-links -P ./LOCAL URL
<span class="token comment"># 镜像下载 下载所有为了 html 页面依赖文件 下载后，转换成本地的链接 保存所有文件和目录到本地指定目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> -c -r -np -k -L -p www.xxx.org/pub/path/
<span class="token comment"># 断点续传 递归下载 不搜索上层目录 将绝对链接转为相对链接 递归时不进入其它主机 下载网页所需的所有文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="实例-9-使用-wget-r-a-下载指定格式文件">实例 9: 使用 wget -r -A 下载指定格式文件</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> -r -A.pdf url<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><p>可以在以下情况使用该功能：</p>
<p>下载一个网站的所有图片下载一个网站的所有视频下载一个网站的所有 PDF 文件</p>
</li>
</ul>
<h3><span id="实例-10使用-wget-ftp-下载">实例 10：使用 wget FTP 下载</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> ftp-url
<span class="token variable">$wget</span> --ftp-user<span class="token operator">=</span>USERNAME --ftp-password<span class="token operator">=</span>PASSWORD url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>可以使用 wget 来完成 ftp 链接的下载</p>
<p>使用 wget 匿名 ftp 下载：wget ftp-url 使用 wget 用户名和密码认证的 ftp 下载:wget –ftp-user=USERNAME –ftp-password=PASSWORD url</p>
</li>
</ul>
<h2><span id="编译安装">编译安装 </span></h2><p> 使用如下命令编译安装:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> zxvf wget-1.9.1.tar.gz
<span class="token builtin class-name">cd</span> wget-1.9.1
./configure
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的重定向</title>
    <url>/2015/01/04/Linux/Linux%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2><span id="从一个命令说起">从一个命令说起 </span></h2><p> 经常能从 shell 脚本中看到类似这样的命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmd <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token comment">#cmd 代表一个可以输出结果的命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<a id="more"></a>
<h2><span id="重定向">重定向 </span></h2><p> 在使用 shell 命令的时候，最常见的是键盘输入命令，终端显示处理结果。有的时候需要将 shell 命令的执行结果存储到文件中，或者让 shell 读取某个文件的内容作为输入，那么就需要使用输入输出的重定向功能。</p>
<p>重定向就是指把程序的输入源或者输出地址修改为我们制定的 IO 设备或文件。当打开 shell 命令是，会默认打开 3 个文件。每个文件都有对应的文件描述符方便我们使用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>文件描述符</th>
<th>默认情况</th>
<th>对应文件句柄位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入（standard input）</td>
<td>0</td>
<td>从键盘获得输入</td>
<td>/proc/slef/fd/0</td>
</tr>
<tr>
<td>标准输出（standard output）</td>
<td>1</td>
<td>输出到屏幕（即控制台）</td>
<td>/proc/slef/fd/1</td>
</tr>
<tr>
<td>错误输出（error output）</td>
<td>2</td>
<td>输出到屏幕（即控制台）</td>
<td>/proc/slef/fd/2</td>
</tr>
</tbody>
</table>
</div>
<p>在这里，根据 Linux 一切皆文件的思想，把输入输出设备都视为文件。</p>
<h3><span id="输出重定向">输出重定向 </span></h3><p> 输出重定向基本的一些命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &gt;filename</td>
<td>把标准输出重定向到新文件中</td>
</tr>
<tr>
<td>command 1&gt;filename</td>
<td>同上</td>
</tr>
<tr>
<td>command &gt;&gt;filename</td>
<td>把标准输出追加到文件中</td>
</tr>
<tr>
<td>command 1&gt;&gt;filename</td>
<td>同上</td>
</tr>
<tr>
<td>command 2&gt;filename</td>
<td>把标准错误重定向到新文件中</td>
</tr>
<tr>
<td>command 2&gt;&gt;filename</td>
<td>把标准错误追加到新文件中</td>
</tr>
</tbody>
</table>
</div>
<p>我们使用 <code>&gt;</code> 或者 <code>&gt;&gt;</code> 对输出进行重定向。符号的左边是标准输出或标准错误，右边是输出目标。<code>&gt;</code> 会覆盖原有的文件,<code>&gt;&gt;</code>则是追加输出。用 <code>1</code> 和 <code>2</code> 可以显式指定是标准输出还是标准错误。</p>
<p>例:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token builtin class-name">.</span> <span class="token comment"># 当前目录只有 1.txt 文件</span>
hello.txt  <span class="token comment"># 内容是 hello</span>
$ <span class="token function">cat</span> hello.txt <span class="token operator"><span class="token file-descriptor important">1</span>></span> out <span class="token comment"># 此时 out 的内容是 hello</span>
$ <span class="token function">cat</span> out
hello
$ <span class="token function">cat</span> world.txt <span class="token operator">></span> out
cat: world.txt: No such <span class="token function">file</span> or directory <span class="token comment"># 此时由于不存在 world.txt，屏幕上出现标准错误输出</span>
$ <span class="token function">cat</span> world.txt <span class="token operator"><span class="token file-descriptor important">2</span>></span> err
$ <span class="token function">cat</span> err 
cat: world.txt: No such <span class="token function">file</span> or directory <span class="token comment"># 标准错误被重定向到 err 文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="输入重定向">输入重定向 </span></h3><p> 输入重定向的基本命令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &lt;filename</td>
<td>以 filename 文件作为标准输入</td>
</tr>
<tr>
<td>command 0&lt;filename</td>
<td>同上</td>
</tr>
<tr>
<td>command &lt;&lt;delimiter</td>
<td>从标准输入中读入，直到遇到 delimiter 分隔符</td>
</tr>
</tbody>
</table>
</div>
<p>我们使用 <code>&lt;</code> 对输入做重定向，符号左边缺省默认为 0。</p>
<p>输入重定向其实就是让文件输入代替键盘敲击。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span>  <span class="token comment"># cat 的作用是把输入直接回显到终端里</span>
<span class="token number">111</span>
<span class="token number">111</span>
<span class="token number">222</span>
<span class="token number">222</span>
$ <span class="token function">cat</span> <span class="token operator">&lt;</span>input <span class="token comment">#input 文件内容为 foo bar</span>
foo bar
$ <span class="token function">cat</span> <span class="token operator">></span>output <span class="token operator">&lt;</span>input <span class="token comment"># 重定向输入为 input 文件，重定向输出为 output 文件。</span>
$ <span class="token function">cat</span> output
foo bar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="空设备文件">空设备文件 </span></h2><p>/dev/null 代表 linux 的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了<code>&gt;/dev/null</code> 之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。</p>
<p>有的时候我们并不想输出任何信息，想要抛弃标准输出，就用这种方法。</p>
<h2><span id="扩展用法">扩展用法 </span></h2><h3><span id="重定向绑定"> 重定向绑定 </span></h3><p> 现在来看看这条命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这句话的意思其实就重定向输出到 /dev/null，然后把标准错误重定向到标准输出。</p>
<p>另一种写法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmd <span class="token operator">&amp;></span> output.txt
cmd <span class="token operator">>&amp;</span> output.txt  <span class="token comment"># 两个表达式等价</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过这两者的组合，我们把标准输出和标准错误绑定在一起抛弃掉了，即实现了不输出任何信息。</p>
<h3><span id="交换顺序的-bug">交换顺序的 bug</span></h3><p>能否交换这两者的顺序呢</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> 
<span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">></span>/dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不可以！第二条的命令会把错误输出绑定到依旧是默认输出设备的屏幕上。而标准输出被丢弃。<br>因为 linux 在执行 shell 命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。</p>
<h3><span id="分开写的-bug">分开写的 bug</span></h3><p>能否把错误和输出并行输出到空设备呢？</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span>
<span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也不可以！</p>
<p>试验一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ls a.txt b.txt >out 2>out</span>
<span class="token comment"># cat out</span>
a.txt
txt: No such <span class="token function">file</span> or directory <span class="token comment"># 本来应该是 b.txt: No such file or directory， 出现了字符缺失</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里会丢失字符，为什么？因为这种写法会导致标准输出和错误输出抢占重定向到 out 的管道，导致冲突、覆盖等问题。而且会导致输出效率较低。</p>
<h3><span id="关于-nohup">关于 nohup</span></h3><p>我们经常使用 <code>nohup command &amp;</code> 命令形式来启动一些后台程序，比如 node 服务：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">nohup</span> node server.js <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为了不让一些执行信息输出到前台（控制台），我们还会加上刚才提到的 <code>&gt;/dev/null 2&gt;&amp;1</code> 命令来丢弃所有的输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">nohup</span> node server.js <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 之进程调度管理</title>
    <url>/2017/09/01/Linux/Linux%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Linux 内核可以看作一个服务进程 (管理软硬件资源，响应用户进程的种种合理以及不合理的请求)。</p>
<p>这是因为内核需要并行多个执行流，需要防止阻塞。内核线程可以理解为内核的分身，一个分身处理一项特定任务，内核线程调度由内核负责，一个内核线程阻塞不影响其他内核线程，<strong>内核线程是调度的基本单位</strong>。</p>
<p>作为对比，用户线程可以运行在用户态和内核态，内核线程只在内核态。</p>
<p>它只是用大于 PAGE_OFFSET 的地址空间。</p>
<a id="more"></a>
<h2><span id="linux-的进程和线程">Linux 的进程和线程 </span></h2><p> 对于 Linux 来讲，所有的线程都当作进程来实现，因为没有单独为线程定义特定的调度算法，也没有单独为线程定义特定的数据结构（所有的线程或进程的核心数据结构都是 <code>task_struct</code>）。</p>
<blockquote>
<p>对于一个进程，相当于是它含有一个线程，就是它自身。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。</p>
</blockquote>
<p>进程拥有自己的地址空间，所以每个进程都有自己的页表。而线程却没有，只能和其它线程共享某一个地址空间和同一份页表。这个区别的 根本原因 是，在进程 / 线程创建时，因是否拷贝当前进程的地址空间还是共享当前进程的地址空间，而使得指定的参数不同而导致的。</p>
<p>具体地说，进程和线程的创建都是执行 <code>clone</code> 系统调用进行的。而 clone 系统调用会执行 <code>do_fork</code> 内核函数，而它则又会调用 <code>copy_process</code> 内核函数来完成。主要包括如下操作：</p>
<p>在调用 <code>copy_process</code> 的过程中，会创建并拷贝当前进程的 <code>task_stuct</code>，同时还会创建属于子进程的 <code>thread_info</code> 结构以及内核栈。<br>此后，会为创建好的 <code>task_stuct</code> 指定一个新的 pid（在 <code>task_struct</code> 结构体中）。<br>然后根据传递给 clone 的参数标志，来选择拷贝还是共享打开的文件，文件系统信息，信号处理函数，进程地址空间等。这就是进程和线程不一样地方的本质所在。</p>
<h2><span id="task_struct">task_struct</span></h2><p>每个进程或线程都有三个数据结构，分别是 struct thread_info, struct task_struct 和 内核栈。</p>
<blockquote>
<p>注意，虽然线程与主线程共享地址空间，但是线程也是有自己独立的内核栈的。</p>
</blockquote>
<p><code>thread_info</code> 对象中存放的进程 / 线程的基本信息，它和这个进程 / 线程的内核栈存放在内核空间里的一段 2 倍页长的空间中。其中 thread_info 结构存放在低地址段的末尾，其余空间用作内核栈。内核使用 伙伴系统 为每个进程 / 线程分配这块空间。</p>
<p><code>thread_info</code> 结构体中有一个 <code>struct task_struct *task</code>，task 指向的就是这个进程或线程相关的 <code>task_struct</code> 对象（也在内核空间中），这个对象叫做进程描述符（叫做任务描述符更为贴切，因为每个线程也都有自己的 <code>task_struct</code>）。内核使用 slab 分配器为每个进程 / 线程分配这块空间。</p>
<p><img src="https://i.loli.net/2020/09/01/LGpftydEQbgODMJ.png" alt="2018-01-10-1"></p>
<h2><span id="内核线程">内核线程 </span></h2><p> 内核线程是直接由内核本身启动的进程。<strong>内核线程实际上是将内核函数委托给独立的进程 </strong>，它与内核中的其他进程并行执行。内核线程经常被称之为内核守护进程。<strong> 所有的内核线程共享内核地址空间</strong>（对于 32 位系统来说，就是 3-4GB 的虚拟地址空间），所以也共享同一份内核页表。这也是为什么叫内核线程，而不叫内核进程的原因。</p>
<p>内核线程执行的任务有：</p>
<ul>
<li>周期性地将修改的内存页与页来源块设备同步</li>
<li>如果内存页很少使用，则写入交换区</li>
<li>管理延时动作,　如２号进程接手内核进程的创建</li>
<li>实现文件系统的事务日志</li>
</ul>
<p>内核线程主要有两种类型：</p>
<ol>
<li><p>线程启动后一直等待，直至内核请求线程执行某一特定操作。</p>
</li>
<li><p>线程启动后按周期性间隔运行，检测特定资源的使用，在用量超出或低于预置的限制时采取行动。</p>
</li>
</ol>
<p>内核线程由内核自身生成，其特点在于</p>
<ol>
<li>它们在 CPU 的管态执行，而不是用户态。</li>
<li>它们只可以访问虚拟地址空间的内核部分（高于 TASK_SIZE 的所有地址），但不能访问用户空间</li>
</ol>
<p>系统在正式启动内核时，会执行 <code>start_kernel</code> 函数。在这个函数中，会自动创建一个进程，名为 <code>init_task</code>。其 PID 为 0，运行在内核态中。然后开始执行一系列初始化。</p>
<h3><span id="init-内核线程">init 内核线程</span></h3><p><code>init_task</code> 在执行 <code>rest_init</code> 函数时，会执行 <code>kernel_thread</code> 创建 <code>init</code> 内核线程。它的 PID 为 1，用来完成内核空间初始化。</p>
<p>在内核空间完成初始化后，会调用 <code>exceve</code> 执行 init 可执行程序 (/sbin/init)。之后，init 内核线程变成了一个普通的进程，运行在用户空间中。</p>
<blockquote>
<p>init 内核线程没有地址空间，且它的 task_struct 对象中的 mm 为 NULL。因此，执行 exceve 会使这个 mm 指向一个 mm_struct，而不会影响到 init_task 进程的地址空间。 也正因为此，init 在转变为进程后，其 PID 没变，仍为 1。</p>
</blockquote>
<p>创建完 init 内核线程后，<code>init_task</code> 进程演变为 idle 进程（PID 仍为 0）。</p>
<p>之后，init 进程再根据再启动其它系统进程 (/etc/init.d 目录下的各个可执行文件)。</p>
<h3><span id="kthreadd-内核线程">kthreadd 内核线程</span></h3><p><code>init_task</code> 进程演变为 idle 进程后，idle 进程会执行 <code>kernel_thread</code> 来创建 <code>kthreadd</code> 内核线程（仍然在 <code>rest_init</code> 函数中）。它的 PID 为 2，用来创建并管理其它内核线程（用 <code>kthread_create</code>, <code>kthread_run</code>, <code>kthread_stop</code> 等内核函数）。</p>
<p>系统中有很多内核守护进程 (线程)，可以通过：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -efj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进行查看，其中带有 [] 号的就属于内核守护进程。它们的祖先都是这个 kthreadd 内核线程。</p>
<h3><span id="主内核页全局目录">主内核页全局目录 </span></h3><p> 内核维持着一组自己使用的页表，也即主内核页全局目录。当内核在初始化完成后，其存放在 <code>swapper_pg_dir</code> 中，而且所有的普通进程和内核线程就不再使用它了。</p>
<h3><span id="内核线程访问页表">内核线程访问页表 </span></h3><h4><span id="active_mm">active_mm</span></h4><p> 对于内核线程，虽然它的 <code>task_struct</code> 中的 mm 为 NULL，但是它仍然需要访问内核空间，因此需要知道关于内核空间映射到物理内存的页表。然而不再使用 <code>swapper_pg_dir</code>，因此只能另外想法解决。</p>
<p>由于所有的普通进程的页全局目录中的后面部分为主内核页全局目录，因此内核线程只需要使用某个普通进程的页全局目录就可以了。</p>
<p>在 Linux 中，<code>task_struct</code> 中还有一个很重要的元素为 <code>active_mm</code>，它主要就是用于内核线程访问主内核页全局目录。</p>
<p>对于普通进程来说，<code>task_struct</code> 中的 <code>mm</code> 和 <code>active_mm</code> 指向的是同一片区域； 然而对内核线程来说，<code>task_struct</code> 中的 mm 为 NULL，<code>active_mm</code> 指向的是前一个普通进程的 <code>mm_struct</code> 对象。</p>
<h4><span id="mm_usersmm_count">mm_users/mm_count</span></h4><p>但是这样还是不行，因为如果因为前一个普通进程退出了而导致它的 <code>mm_struct</code> 对象也被释放了，则内核线程就访问不到了。</p>
<p>为此，<code>mm_struct</code> 对象维护了一个计数器 <code>mm_count</code>，专门用来对引用这个 <code>mm_struct</code> 对象的自身及内核线程进行计数。初始时为 1，表示普通进程本身引用了它自己的 <code>mm_struct</code> 对象。只有当这个引用计数为 0 时，才会真正释放这个 <code>mm_struct</code> 对象。</p>
<p>另外，<code>mm_struct</code> 中还定义了一个 <code>mm_users</code> 计数器，它主要是用来对共享地址空间的线程计数。事实上，就是这个主线程所在线程组中线程的总个数。初始时为 1。</p>
<h2><span id="内核线程的退出">内核线程的退出 </span></h2><p> 线程一旦启动起来后，会一直运行，除非该线程主动调用 <code>do_exit</code> 函数，或者其他的进程调用 <code>kthread_stop</code> 函数，结束线程的运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kthread_stop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>kthread_stop()</code> 通过发送信号给线程。</p>
<p>如果线程函数正在处理一个非常重要的任务，它不会被中断的。当然如果线程函数永远不返回并且不检查信号，它将永远都不会停止。</p>
<p>在执行 <code>kthread_stop</code> 的时候，目标线程必须没有退出，否则会 Oops。原因很容易理解，当目标线程退出的时候，其对应的 <code>task</code> 结构也变得无效，<code>kthread_stop</code>引用该无效 task 结构就会出错。</p>
<p>为了避免这种情况，需要确保线程没有退出，其方法如代码中所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// do your work here</span>
    <span class="token comment">// wait to exit</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">thread_could_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
           <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">exit_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
     <span class="token function">kthread_stop</span><span class="token punctuation">(</span>_task<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 发信号给 task，通知其可以退出了</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种退出机制很温和，一切尽在 <code>thread_func()</code> 的掌控之中，线程在退出时可以从容地释放资源，而不是莫名其妙地被人“暗杀”。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存分析工具 - free</title>
    <url>/2015/08/21/Linux/Linux%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%20-%20free/</url>
    <content><![CDATA[<p>free 工具用来查看系统可用内存</p>
<a id="more"></a>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/opt/app/tdev1 $ <span class="token function">free</span>
             total       used       <span class="token function">free</span>     shared    buffers     cached
Mem:       <span class="token number">8175320</span>    <span class="token number">6159248</span>    <span class="token number">2016072</span>          <span class="token number">0</span>     <span class="token number">310208</span>    <span class="token number">5243680</span>
-/+ buffers/cache:     <span class="token number">605360</span>    <span class="token number">7569960</span>
Swap:      <span class="token number">6881272</span>      <span class="token number">16196</span>    <span class="token number">6865076</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解释一下 Linux 上 free 命令的输出。</p>
<p>ree 的输出看成一个二维数组<code>FO(Free Output)</code>。例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FO<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">24677460</span>
FO<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10321516</span>

                   <span class="token number">1</span>          <span class="token number">2</span>          <span class="token number">3</span>          <span class="token number">4</span>          <span class="token number">5</span>          <span class="token number">6</span>
<span class="token number">1</span>              total       used       <span class="token function">free</span>     shared    buffers     cached
<span class="token number">2</span> Mem:      <span class="token number">24677460</span>   <span class="token number">23276064</span>    <span class="token number">1401396</span>          <span class="token number">0</span>     <span class="token number">870540</span>   <span class="token number">12084008</span>
<span class="token number">3</span> -/+ buffers/cache:   <span class="token number">10321516</span>   <span class="token number">14355944</span>
<span class="token number">4</span> Swap:     <span class="token number">25151484</span>     <span class="token number">224188</span>   <span class="token number">24927296</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>free 的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。</p>
<p>free 输出地第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。</p>
<p>　　第一行的输出时从操作系统（OS）来看的。也就是说，从 OS 的角度来看，计算机上一共有:</p>
<p>24677460KB（缺省时 free 的单位为 KB）物理内存，即<code>FO[2][1]</code>； 在这些物理内存中有 23276064KB（即<code>FO[2][2]</code>）被使用了； 还用 1401396KB（即 FO[2][3]）是可用的；</p>
<p>这里得到第一个等式：</p>
<p><code>FO[2][1] = FO[2][2] + FO[2][3]</code></p>
<p><code>FO[2][4]</code>表示被几个进程共享的内存的，现在已经 deprecated，其值总是 0（当然在一些系统上也可能不是 0，主要取决于 free 命令是怎么实现的）。</p>
<p><code>FO[2][5]</code>表示被 OS buffer 住的内存。<code>FO[2][6]</code>表示被 OS cache 的内存。在有些时候 buffer 和 cache 这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">A buffer is something that has yet to be &quot;written&quot; to disk.
A cache is something that has been &quot;read&quot; from the disk and stored for later use.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也就是说 buffer 是用于存放要输出到 disk（块设备）的数据的，而 cache 是存放从 disk 上读出的数据。这二者是为了提高 IO 性能的，并由 OS 管理。</p>
<p>Linux 和其他成熟的操作系统（例如 windows），为了提高 IO read 的性能，总是要多 cache 一些数据，这也就是为什么 <code>FO[2][6]</code>（cached memory）比较大，而 FO[2][3] 比较小的原因。我们可以做一个简单的测试:</p>
<p>释放掉被系统 cache 占用的数据:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token operator"><span class="token file-descriptor important">3</span>></span>/proc/sys/vm/drop_caches<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol>
<li>读一个大文件，并记录时间；</li>
<li>关闭该文件；</li>
<li>重读这个大文件，并记录时间；</li>
</ol>
<p>第二次读应该比第一次快很多。原来我做过一个 BerkeleyDB 的读操作，大概要读 5G 的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快 9 倍左右。</p>
<p>free 输出的第二行是从一个应用程序的角度看系统内存的使用情况。</p>
<ul>
<li>对于<code>FO[3][2]</code>，即<code>-buffers/cache</code>，表示一个应用程序认为系统被用掉多少内存；</li>
<li>对于<code>FO[3][3]</code>，即<code>+buffers/cache</code>，表示一个应用程序认为系统还有多少内存；</li>
</ul>
<p>因为被系统 cache 和 buffer 占用的内存可以被快速回收，所以通常 FO[3][3]比 FO[2][3]会大很多。</p>
<p>这里还用两个等式:</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">FO[3][2] &#x3D; FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] &#x3D; FO[2][3] + FO[2][5] + FO[2][6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这二者都不难理解。</p>
<p>free 命令由 <code>procps.*.rpm</code> 提供（在 Redhat 系列的 OS 上）。free 命令的所有输出值都是从 <code>/proc/meminfo</code> 中读出的。</p>
<p>在系统上可能有 <code>meminfo(2)</code> 这个函数，它就是为了解析 <code>/proc/meminfo</code> 的。procps 这个包自己实现了 <code>meminfo()</code> 这个函数。可以下载一个 procps 的 tar 包看看具体实现，现在最新版式 3.2.8。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 动态库编译指南</title>
    <url>/2015/06/18/Linux/Linux%E5%8A%A8%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Linux 下动态库文件的文件名形如 <code>libxxx.so</code>，其中 so 是 Shared Object 的缩写，即可以共享的目标文件。</p>
<p>在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。</p>
<p>程序执行时，再去加载动态库文件。如果动态库已经加载，则不必重复加载，从而能节省内存空间。</p>
<p>Linux 下生成和使用动态库的步骤如下：</p>
<ol>
<li>编写源文件。</li>
<li>将一个或几个源文件编译链接，生成共享库。</li>
<li>通过 <code>-L&lt;path&gt; -lxxx</code> 的 gcc 选项链接生成的 libxxx.so。</li>
<li>把 libxxx.so 放入链接库的标准路径，或指定 <code>LD_LIBRARY_PATH</code>，才能运行链接了 libxxx.so 的程序。</li>
</ol>
<a id="more"></a>
<h2><span id="源文件">源文件 </span></h2><p> 样例 </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//max.c</span>
<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> <span class="token keyword">int</span> n2<span class="token punctuation">,</span> <span class="token keyword">int</span> n3<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> max_num <span class="token operator">=</span> n1<span class="token punctuation">;</span>
    max_num <span class="token operator">=</span> max_num <span class="token operator">&lt;</span> n2<span class="token operator">?</span> n2<span class="token operator">:</span> max_num<span class="token punctuation">;</span>
    max_num <span class="token operator">=</span> max_num <span class="token operator">&lt;</span> n3<span class="token operator">?</span> n3<span class="token operator">:</span> max_num<span class="token punctuation">;</span>
    <span class="token keyword">return</span> max_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="共享库">共享库 </span></h2><p> 编译生成共享库：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -fPIC -shared -o libmax.so max.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> <code>-fPIC</code>是编译选项，PIC 是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； </p>
<p><code>-shared</code>是链接选项，告诉 gcc 生成动态库而不是可执行文件。</p>
<h2><span id="编写头文件">编写头文件 </span></h2><p> 为了让用户知道我们的动态库中有哪些接口可用，我们需要编写对应的头文件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//max.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MAX_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__MAX_H__</span></span>

<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> <span class="token keyword">int</span> n2<span class="token punctuation">,</span> <span class="token keyword">int</span> n3<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="测试">测试 </span></h2><p> 编写一个测试程序 test.c 引用编译好的 libmax.so</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//test.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"max.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"max among 10, -2 and 100 is %d.\n"</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译命令<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc test.c -L. -lmax -o <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<p><code>-lmax</code>表示要链接<code>libmax.so</code></p>
<p><code>-L.</code>表示搜索要链接的库文件时包含当前路径</p>
<h2><span id="运行">运行</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./test
max among <span class="token number">10</span>, -2 and <span class="token number">100</span> is <span class="token number">100</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="自动化编译">自动化编译 </span></h2><p> 利用 make 来进行自动化编译</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> build test clean

<span class="token symbol">build</span><span class="token punctuation">:</span> libmax.so

<span class="token symbol">libmax.so</span><span class="token punctuation">:</span> max.o
	gcc -o <span class="token variable">$@</span>  -shared <span class="token variable">$&lt;</span>

<span class="token symbol">max.o</span><span class="token punctuation">:</span> max.c
	gcc -c -fPIC <span class="token variable">$&lt;</span>

<span class="token symbol">test</span><span class="token punctuation">:</span> test.c libmax.so
	gcc test.c -L. -lmax -o test
	
<span class="token symbol">clean</span><span class="token punctuation">:</span>
	rm -f *.o *.so a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用法<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> build <span class="token comment"># 编译动态库 libmax.so</span>
$ <span class="token function">make</span> <span class="token builtin class-name">test</span> <span class="token comment"># 生成 test 可执行程序</span>
$ <span class="token function">make</span> clean <span class="token comment"># 清理编译和测试结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
<h2><span id="附录">附录 </span></h2><p> 例程见我的<a href="https://github.com/maywzh/Lab_dylibcompiler">Github</a></p>
<p>相关博文 <a href="/Linux 静态库编译指南 /">Linux 静态库编译指南</a>。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用网络工具</title>
    <url>/2015/05/12/Linux/Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2><span id="网络工具">网络工具</span></h2><p>Linux 中提供了强大的网络工具包，用于监测系统中的网络通信状态。</p>
<a id="more"></a>
<h2><span id="查询网络服务和端口">查询网络服务和端口</span></h2><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p>
<p>列出所有端口 (包括监听和未监听的):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$netstat</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出所有 tcp 端口:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$netstat</span> -at<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出所有有监听的服务状态:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$netstat</span> -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 netstat 工具查询端口:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$netstat</span> -antp <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">6379</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:6379          <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">25501</span>/redis-server

<span class="token variable">$ps</span> <span class="token number">25501</span>
  PID TTY      STAT   TIME COMMAND
<span class="token number">25501</span> ?        Ssl   <span class="token number">28</span>:21 ./redis-server ./redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="查看文件状态">查看文件状态</span></h2><p>lsof（list open files）是一个列出当前系统打开文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等； 在查询网络端口时，经常会用到这个工具。</p>
<p>查询 7902 端口现在运行什么程序:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 分为两步</span>
<span class="token comment"># 第一步，查询使用该端口的进程的 PID；</span>
    <span class="token variable">$lsof</span> -i:7902
    COMMAND   PID   <span class="token environment constant">USER</span>   FD   TYPE    DEVICE SIZE NODE NAME
    WSL     <span class="token number">30294</span> tuapp    4u  IPv4 <span class="token number">447684086</span>       TCP <span class="token number">10.6</span>.50.37:tnos-dp <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>

<span class="token comment"># 查到 30294</span>
<span class="token comment"># 使用 ps 工具查询进程详情：</span>
<span class="token variable">$ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">30294</span>
tdev5  <span class="token number">30294</span> <span class="token number">26160</span>  <span class="token number">0</span> Sep10 ?        01:10:50 tdesl -k <span class="token number">43476</span>
root     <span class="token number">22781</span> <span class="token number">22698</span>  <span class="token number">0</span> 00:54 pts/20   00:00:00 <span class="token function">grep</span> <span class="token number">11554</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>以上介绍 lsof 关于网络方面的应用，这个工具非常强大，需要好好掌握，详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html#lsof">lsof 一切皆文件</a> ;</p>
<h2><span id="网络路由">网络路由 </span></h2><p> 查看路由状态:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$route</span> -n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>发送 ping 包到地址 IP:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ping</span> IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>探测前往地址 IP 的路由路径:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$traceroute</span> IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>DNS 查询，寻找域名 domain 对应的 IP:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$host</span> domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>反向 DNS 查询:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$host</span> IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="镜像下载">镜像下载 </span></h2><p> 直接下载文件或者网页:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$wget</span> url<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>常用选项:</p>
<ul>
<li>–limit-rate : 下载限速</li>
<li>-o：指定日志文件；输出都写入日志；</li>
<li>-c：断点续传</li>
</ul>
<h2><span id="ftp-sftp-lftp-ssh">ftp sftp lftp ssh</span></h2><p>SSH 登陆:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ssh</span> ID@host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ssh 登陆远程服务器 host，ID 为用户名。</p>
<p>ftp/sftp 文件传输:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$sftp</span> ID@host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>登陆服务器 host，ID 为用户名。sftp 登陆后，可以使用下面的命令进一步操作：</p>
<ul>
<li>get filename # 下载文件</li>
<li>put filename # 上传文件</li>
<li>ls # 列出 host 上当前路径的所有文件</li>
<li>cd # 在 host 上更改当前路径</li>
<li>lls # 列出本地主机上当前路径的所有文件</li>
<li>lcd # 在本地主机更改当前路径</li>
</ul>
<p>lftp 同步文件夹(类似 rsync 工具):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lftp -u user:pass <span class="token function">host</span>
lftp user@host:~<span class="token operator">></span> mirror -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="网络复制">网络复制 </span></h2><p> 将本地 localpath 指向的文件上传到远程主机的 path 路径:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$scp</span> localpath ID@host:path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以 ssh 协议，遍历下载 path 路径下的整个文件系统，到本地的 localpath:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$scp</span> -r ID@site:path localpath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析工具 - sar</title>
    <url>/2015/08/26/Linux/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%20-%20sar/</url>
    <content><![CDATA[<p>sar 是 System Activity Reporter（系统活动情况报告）的缩写。sar 工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar 是目前 Linux 上最为全面的系统性能分析工具之一，可以从 14 个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU 效率、内存使用状况、进程活动及 IPC 有关的活动等，使用也是较为复杂。</p>
<p>sar 是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；</p>
<ol>
<li>追溯过去的统计数据（默认）</li>
<li>周期性的查看当前数据</li>
</ol>
<a id="more"></a>
<h2><span id="安装">安装 </span></h2><p> 有的 linux 系统下，默认可能没有安装这个包，使用 <code>apt-get</code> 来安装；</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt-get</span> <span class="token function">install</span> sysstat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装完毕，将性能收集工具的开关打开：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> /etc/default/sysstat
<span class="token assign-left variable">ENABLED</span><span class="token operator">=</span><span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动这个工具来收集系统性能数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ /etc/init.d/sysstat start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="用法">用法 </span></h2><h3><span id="参数"> 参数</span></h3><ul>
<li>-A 汇总所有的报告</li>
<li>-a 报告文件读写使用情况</li>
<li>-B 报告附加的缓存的使用情况</li>
<li>-b 报告缓存的使用情况</li>
<li>-c 报告系统调用的使用情况</li>
<li>-d 报告磁盘的使用情况</li>
<li>-g 报告串口的使用情况</li>
<li>-h 报告关于 buffer 使用的统计数据</li>
<li>-m 报告 IPC 消息队列和信号量的使用情况</li>
<li>-n 报告命名 cache 的使用情况</li>
<li>-p 报告调页活动的使用情况</li>
<li>-q 报告运行队列和交换队列的平均长度</li>
<li>-R 报告进程的活动情况</li>
<li>-r 报告没有使用的内存页面和硬盘块</li>
<li>-u 报告 CPU 的利用率</li>
<li>-v 报告进程、i 节点、文件和锁表状态</li>
<li>-w 报告系统交换活动状况</li>
<li>-y 报告 TTY 设备活动状况</li>
</ul>
<h3><span id="追溯过去的统计数据-f">追溯过去的统计数据 -f</span></h3><p>默认情况下，sar 从最近的 0 点 0 分开始显示数据；如果想继续查看一天前的报告；可以查看保存在 /var/log/sysstat/ 下的 sa 日志； 使用 sar 工具查看:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$sar</span> -f /var/log/sysstat/sa28 <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">head</span> sar -r -f
/var/log/sysstat/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="查看-cpu-使用率-u">查看 CPU 使用率 -u</span></h3><p><code>sar -u</code> : 显示的 cpu 使用率等信息</p>
<p>可以看到这台机器使用了虚拟化技术，有相应的时间消耗； 各列的指标分别是:</p>
<ul>
<li><p><code>%user</code> 用户模式下消耗的 CPU 时间的比例；</p>
</li>
<li><p><code>%nice</code> 通过 nice 改变了进程调度优先级的进程，在用户模式下消耗的 CPU 时间的比例</p>
</li>
<li><p><code>%system</code> 系统模式下消耗的 CPU 时间的比例；</p>
</li>
<li><p><code>%iowait</code> CPU 等待磁盘 I/O 导致空闲状态消耗的时间比例；</p>
</li>
<li><p><code>%steal</code> 利用 Xen 等操作系统虚拟化技术，等待其它虚拟 CPU 计算占用的时间比例；</p>
</li>
<li><p><code>%idle</code> CPU 空闲时间比例；</p>
</li>
</ul>
<h3><span id="查看平均负载-q">查看平均负载 -q</span></h3><p><code>sar -q</code>: 查看平均负载</p>
<p>指定 -q 后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；与其它命令相比，它能查看各项指标随时间变化的情况；</p>
<ul>
<li><code>runq-sz</code>：运行队列的长度（等待运行的进程数）</li>
<li><code>plist-sz</code>：进程列表中进程（processes）和线程（threads）的数量</li>
<li><code>ldavg-1</code>：最后 1 分钟的系统平均负载 ldavg-5：过去 5 分钟的系统平均负载</li>
<li><code>ldavg-15</code>：过去 15 分钟的系统平均负载</li>
</ul>
<h3><span id="查看内存使用状况-r">查看内存使用状况 -r</span></h3><p><code>sar -r</code>： 可查看物理内存使用状况；</p>
<ul>
<li><code>kbmemfree</code>：这个值和 free 命令中的 free 值基本一致, 所以它不包括 buffer 和 cache 的空间.</li>
<li><code>kbmemused</code>：这个值和 free 命令中的 used 值基本一致, 所以它包括 buffer 和 cache 的空间.</li>
<li><code>%memused</code>：物理内存使用率，这个值是 kbmemused 和内存总量 (不包括 swap) 的一个百分比.</li>
<li><code>kbbuffers</code>和<code>kbcached</code>：这两个值就是 free 命令中的 buffer 和 cache.</li>
<li><code>kbcommit</code>：保证当前系统所需要的内存, 即为了确保不溢出而需要的内存(RAM+swap).</li>
<li><code>%commit</code>：这个值是 kbcommit 与内存总量 (包括 swap) 的一个百分比.</li>
</ul>
<h3><span id="查看页面交换发生状况-w">查看页面交换发生状况 -W</span></h3><p><code>sar -W</code>：查看页面交换发生状况</p>
<p>页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换；</p>
<ul>
<li><code>pswpin/s</code>：每秒系统换入的交换页面（swap page）数量</li>
<li><code>pswpout/s</code>：每秒系统换出的交换页面（swap page）数量</li>
</ul>
<h3><span id="综合分析">综合分析 </span></h3><p> 要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来；</p>
<ul>
<li>怀疑 CPU 存在瓶颈，可用 <code>sar -u</code> 和 <code>sar -q</code> 等来查看</li>
<li>怀疑内存存在瓶颈，可用<code>sar -B</code>、<code>sar -r</code> 和 <code>sar -W</code> 等来查看</li>
<li>怀疑 I/O 存在瓶颈，可用 <code>sar -b</code>、<code>sar -u</code> 和 <code>sar -d</code> 等来查看</li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解 Linux 权限系统</title>
    <url>/2015/04/09/Linux/Linux%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>最近一直在处理服务器上的 issue，中间遇到最多的的就是 <code>Permission denied</code> 问题，这就是权限问题。今天就来整理一下 Linux 文件权限系统的知识，从根本上填掉这个坑。</p>
<h2><span id="linux-文件权限">Linux 文件权限 </span></h2><p><strong>Linux 中，目录和文件都被视为文件。</strong>Linux 中每个文件都有其属性与权限。我们可以使用<code>ls</code> 命令来查看</p>
<a id="more"></a>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -al<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到，每个文件的最前面都有一个文件类型和权限描述。后面分别是文件链接数，文件拥有者，文件用户组，文件最后修改日期和名称。<code>.</code> 代表当前目录 <code>..</code> 代表上一级目录。</p>
<h3><span id="第一栏-文件类型和权限">第一栏： 文件类型和权限</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> maywzh@M-Ubuntu  /bin  <span class="token function">ls</span> -al
total <span class="token number">13412</span>
drwxr-xr-x  <span class="token number">2</span> root root    <span class="token number">4096</span> Sep <span class="token number">24</span> <span class="token number">19</span>:19 <span class="token builtin class-name">.</span>
drwxr-xr-x <span class="token number">24</span> root root    <span class="token number">4096</span> Oct  <span class="token number">4</span> 06:12 <span class="token punctuation">..</span>
-rwxr-xr-x  <span class="token number">1</span> root root <span class="token number">1113504</span> Apr  <span class="token number">5</span> 02:30 <span class="token function">bash</span>
-rwxr-xr-x  <span class="token number">1</span> root root  <span class="token number">748968</span> Aug <span class="token number">29</span> <span class="token number">15</span>:57 brltty
-rwxr-xr-x  <span class="token number">1</span> root root   <span class="token number">34888</span> Jan <span class="token number">30</span>  <span class="token number">2017</span> bunzip2
-rwxr-xr-x  <span class="token number">1</span> root root <span class="token number">2022480</span> Dec <span class="token number">13</span>  <span class="token number">2017</span> busybox
-rwxr-xr-x  <span class="token number">1</span> root root   <span class="token number">34888</span> Jan <span class="token number">30</span>  <span class="token number">2017</span> bzcat
lrwxrwxrwx  <span class="token number">1</span> root root       <span class="token number">6</span> Sep <span class="token number">13</span> <span class="token number">18</span>:35 bzcmp -<span class="token operator">></span> bzdiff
-rwxr-xr-x  <span class="token number">1</span> root root    <span class="token number">2140</span> Jan <span class="token number">30</span>  <span class="token number">2017</span> bzdiff
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来观察一下第一栏的类型权限描述符，总共有 10 个字符。</p>
<ul>
<li><p>第一个字符代表文件的类型: 目录、文件、链接文件、设备等等。</p>
<ul>
<li>当为 [d] 则是目录，例如 <a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/Text/index.html#table2.1.1"> 上表 </a> 文件名为“.config”的那一行；</li>
<li>当为 [-] 则是文件，例如 <a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/Text/index.html#table2.1.1"> 上表 </a> 文件名为“initial-setup-ks.cfg”那一行；</li>
<li>若是 [l] 则表示为链接文件（link file）；</li>
<li>若是 [b] 则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；</li>
<li>若是 [c] 则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</li>
</ul>
</li>
<li><p>接下来的字符，三个为一组，分为三组。为 <code>[r/-][w/-][x/-]</code> 的组合。<code>[r]</code>代表可读（read）、<code>[w]</code>代表可写（write）、<code>[x]</code>代表可执行（execute）。 这三个权限的位置不会改变，如果没有权限，就会出现减号<code>[-]</code>。</p>
<ul>
<li>第一组为“文件拥有者权限”，例如上面的 <code>bash</code> 的文件拥有者为<code>root</code>。</li>
<li>第二组为“本群组账号权限”，例如上面的 <code>bash</code> 的文件群组为<code>root</code>。</li>
<li>第三组为“非本人非本群组其他帐号的权限”。</li>
</ul>
</li>
<li><p><strong>也可以用三个数字来代表权限，我们可以把每组的权限组合写成一个二进制数字，1 代表有权限，0 代表无权限。</strong></p>
<p><strong>例如 <code>r-x</code>-&gt;<code>101</code>，再把这个 101 二进制数转换为十进制的 5，这样我们用三个十进制数即可代表一个文件的权限配置。例如 rw-r-xr—就可以写成<code>654</code>。</strong></p>
<h4><span id> </span></h4></li>
</ul>
<h3><span id="第二栏-文件名链接数">第二栏： 文件名链接数 </span></h3><p> 每个文件的元信息实际上是记录在 i-node 中的，文件名只是别名而已。目录树却使用文件名来记录。每个文件名都会连接到一个 i-node，但每个 i-node 却可以链接不止一个文件名。</p>
<p>这一栏记录的就是对应的 i-node 连接到了多少个不同的文件名。</p>
<h3><span id="第三-四栏-文件拥有者和群组">第三、四栏： 文件拥有者和群组 </span></h3><h3><span id="第五栏文件容量大小"> 第五栏：文件容量大小 </span></h3><p> 默认单位为 Byte</p>
<h3><span id="第六栏文件创建日期或最新修改日期">第六栏：文件创建日期或最新修改日期 </span></h3><h3><span id="第七栏文件名"> 第七栏：文件名 </span></h3><p> 如果文件名前面多一个 <code>.</code> 则代表该文件为隐藏文件。可用 <code>ls -a</code> 来显示隐藏文件</p>
<h2><span id="改变文件属性与权限">改变文件属性与权限 </span></h2><h3><span id="改变文件的权限-chmod命令"> 改变文件的权限 - <code>chmod</code>命令</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#u-user g-group o-others a-all + 添加 - 去除 = 设定 </span>
<span class="token function">chmod</span> u+x,g+w <span class="token function">file</span> <span class="token comment"># 为 file 的拥有者加上可执行的权限，群组加上可写的权限</span>
<span class="token function">chmod</span> <span class="token assign-left variable">u</span><span class="token operator">=</span>rwx,g<span class="token operator">=</span>rw,o<span class="token operator">=</span>r <span class="token function">file</span> <span class="token comment"># 设置 file 的拥有者可读可写可执行，群组可读可写，其他人可读</span>
<span class="token function">chmod</span> <span class="token assign-left variable">u</span><span class="token operator">=</span><span class="token number">764</span> <span class="token function">file</span> <span class="token comment"># 设置 file 的拥有者可读可写可执行(7=rwx), 群组可读可栖(6=rw-)，其他人可读(4=r--)</span>
<span class="token function">chmod</span> a+x <span class="token comment"># 设置 u g o 都可以执行</span>
<span class="token function">chmod</span> o-r <span class="token comment"># 去除其他人的读权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="改变文件的拥有者和群组-chown命令">改变文件的拥有者和群组 - <code>chown</code>命令 </span></h3><p> 用法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> user1 <span class="token function">file</span> <span class="token comment"># 把 file 的拥有者设定为 user1 </span>
<span class="token function">chown</span> -R user1 <span class="token function">dir</span> <span class="token comment"># 把 dir 目录下所有文件以及次目录文件的拥有者都设置为 user1</span>
<span class="token function">chown</span> -R user1:group1 <span class="token function">file</span> <span class="token comment"># 把 file 的拥有者设定为 user1 群组设置为 group1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>被改变的用户必须在用户账户配置文件 <code>/etc/passed</code> 中存在</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>maywzh@M-Ubuntu<span class="token punctuation">]</span> ~$ <span class="token function">cat</span> /etc/passwd
scin:x:4:534:sync:/bin:/bin/sync
games:x:5:34:games:/usr/games:/usr/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>/etc/passwd</code>的每个用户组一条记录占据一行，记录格式 <code> 用户名: 口令: 用户标识号: 组标识号: 注释性描述: 主目录: 登录 Shell</code></p>
<ul>
<li><p>用户名(login_name)：是代表用户账号的字符串</p>
</li>
<li><p>口令 (passwd)：这个字段存放是用户口令的加密串。为了安全起见，目前许多 Linux 系统（如 SVR4）都使用了 shadow 技术，把真正的加密后的用户口令字存放到<code>/etc/shadow</code> 文件中，而在 <code>/etc/passwd</code> 文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
</li>
<li><p>用户标识号(UID)：系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录 Shell 等。取值范围是 0-65535。0 是超级用户 root 的标识号，1-99 由系统保留，作为管理账号，普通用户的标识号从 100 开始。在 Linux 系统中，这个界限是 500。</p>
</li>
<li><p>组标识号(GID)：字段记录的是用户所属的用户组。它对应着 /etc/group 文件中的一条记录。</p>
</li>
<li><p>注释性描述(users)：字段记录着用户的一些个人情况。</p>
</li>
<li><p>主目录(home_directory)：也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
</li>
<li><p>登录 Shell(Shell)：用户登录后，要启动一个 Shell 进程，负责将用户的操作传给内核，常见有 sh,bash,zsh 等。不指定 Shell，那么系统使用 /bin/sh。用户的登录 Shell 可以指定为某个特定的程序。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些 Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。例如可以为 git 只配置 git 程序的权限。</p>
</li>
</ul>
<h3><span id="改变文件所属群组-chgrp-命令">改变文件所属群组 - chgrp 命令 </span></h3><p> 用法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chgrp</span> group1 <span class="token function">file</span> <span class="token comment"># 把 file 的群组设定为 group1</span>
<span class="token function">chgrp</span> -R group1 <span class="token function">dir</span> <span class="token comment"># 把 dir 目录下所有文件以及次目录文件的群组都设置为 group1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>被改变的群组必须在群组配置文件 <code>/etc/group</code> 中存在</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>maywzh@M-Ubuntu<span class="token punctuation">]</span> ~$ <span class="token function">cat</span> /etc/group
tester:x:500:linuxsir
charger:x:134:syslog,maywzh
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>/etc/group</code>的每个用户组一条记录占据一行，记录格式<code>group_name:passwd:GID:user_list</code></p>
<p>第一字段：用户组名称；<br>第二字段：用户组密码； x 表示未设密码 <br> 第三字段：GID 该用户组下的用户包括用户列表中的用户 GID 为该 GID 的用户, 通过 <code>/etc/passwd</code> 查看 <br> 第四字段：用户列表，每个用户之间用, 号分割；本字段可以为空；如果字段为空表示用户组为 GID 的用户名； </p>
<p>对应的命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gpasswd –a username groupname <span class="token comment"># 把某用户加入到某个组中</span>
gpasswd –d username groupname <span class="token comment"># 把组中的某个用户删除</span>
smbpasswd –a username          <span class="token comment"># 在 SMB 中加入用户</span>
smbpasswd –x username          <span class="token comment"># 在 SMB 中删除用户</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="详解权限">详解权限 </span></h2><h3><span id="读-r"> 读 - r</span></h3><p>文件：读取文件的实际内容。</p>
<p>目录：可以查询该目录下的文件名数据，使用 <code>ls</code> 命令把该目录内容列表显示出来。</p>
<h3><span id="写-w">写 - w</span></h3><p>文件: 可以编辑、新增或者是修改该文件的内容但不含删除该文件。<code>w</code>主要都是针对“文件的内容”而言，与文件文件名的存在与否没有关系，因为文件记录的是实际的数据。</p>
<p>目录：表示可以修改目录结构清单的权限，即</p>
<ul>
<li>创建新的文件与目录；</li>
<li>删除已经存在的文件与目录（不论该文件的权限为何）</li>
<li>将已存在的文件或目录进行更名；</li>
<li>搬移该目录内的文件、目录位置。</li>
</ul>
<h3><span id="执行-x">执行 - x</span></h3><p>文件：Linux 中文件是否能被执行就是由 <code>x</code> 这个字段来指定。</p>
<p>目录：代表使用者是否能进入该目录作为工作目录，即 <code>cd</code> 到这个目录的权限。</p>
<p>例：假设现在在系统使用 may 这个帐号，那么这个帐号针对 /dir1, /dir1/file1, /dir2 这三个文件名来说，分别需要“哪些最小的权限”才能达成各项任务？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作动作</th>
<th>/dir1</th>
<th>/dir1/file1</th>
<th>/dir2</th>
<th>重点</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取 file1 内容</td>
<td>x</td>
<td>r</td>
<td>-</td>
<td>要能够进入 /dir1 才能读到里面的文件数据</td>
</tr>
<tr>
<td>修改 file1 内容</td>
<td>x</td>
<td>rw</td>
<td>-</td>
<td>能够进入 /dir1 且修改 file1 才行</td>
</tr>
<tr>
<td>执行 file1 内容</td>
<td>x</td>
<td>rx</td>
<td>-</td>
<td>能够进入 /dir1 且 file1 能运行才行</td>
</tr>
<tr>
<td>删除 file1 文件</td>
<td>wx</td>
<td>-</td>
<td>-</td>
<td>能够进入 /dir1 具有目录修改的权限即可</td>
</tr>
<tr>
<td>将 file1 复制到 /dir2</td>
<td>x</td>
<td>r</td>
<td>wx</td>
<td>要能够读 file1 且能够修改 /dir2 内的数据</td>
</tr>
</tbody>
</table>
</div>
<p>上面的表格当中，很多时候 /dir1 都不必有 r 。这是因为我们知道 /dir1 是个目录，类似于抽屉。那个抽屉的 r 代表“这个抽屉里面有灯光”， 所以能看到抽屉内的所有数据名称 （非内容）。但我们已经知道里面的数据放在哪个地方，所以可以不需要灯光摸黑拿到该数据。 因此，上面很多动作中，你只要具有 x 即可。r 是非必备的！只是，没有 r 的话，使用 [tab] 时，就无法自动补全文件名。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>实践 Linux 编程之叁 - 优化</title>
    <url>/2015/08/01/Linux/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%81%20-%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>根据木桶效应，一个程序瓶颈决定它的性能，所以性能优化的核心是找出系统的瓶颈点。</p>
<a id="more"></a>
<h2><span id="分析系统瓶颈">分析系统瓶颈 </span></h2><p> 系统响应变慢，首先得定位大致的问题出在哪里，是 IO 瓶颈、CPU 瓶颈、内存瓶颈还是程序导致的系统问题；</p>
<p>使用 top 工具能够比较全面的查看我们关注的点:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$top</span>
    <span class="token function">top</span> - 09:14:56 up <span class="token number">264</span> days, <span class="token number">20</span>:56,  <span class="token number">1</span> user,  load average: <span class="token number">0.02</span>, <span class="token number">0.04</span>, <span class="token number">0.00</span>
    Tasks:  <span class="token number">87</span> total,   <span class="token number">1</span> running,  <span class="token number">86</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
    Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.0</span>%us,  <span class="token number">0.2</span>%sy,  <span class="token number">0.0</span>%ni, <span class="token number">99.7</span>%id,  <span class="token number">0.0</span>%wa,  <span class="token number">0.0</span>%hi,  <span class="token number">0.0</span>%si,  <span class="token number">0.2</span>%st
    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
    Swap:   397308k total,    67192k used,   330116k free,    71900k cached
    PID <span class="token environment constant">USER</span>      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">2856</span>  <span class="token number">656</span>  <span class="token number">388</span> S  <span class="token number">0.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:49.40 init
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> S  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kthreadd
    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> S  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">7</span>:15.20 ksoftirqd/0
    <span class="token number">4</span> root      RT   <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> S  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 migration/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>进入交互模式后:</p>
<p>输入<code>M</code>，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）; 输入<code>P</code>，进程列表按 CPU 使用大小降序排序，便于我们观察最耗 CPU 资源的使用者是否有问题；</p>
</li>
<li><p><code>top</code>第三行显示当前系统的，其中有两个值很关键:</p>
<p><code>%id</code>：空闲 CPU 时间百分比，如果这个值过低，表明系统 CPU 存在瓶颈；</p>
<p><code>%wa</code>：等待 I/O 的 CPU 时间百分比，如果这个值过高，表明 IO 存在瓶颈；</p>
</li>
</ul>
<h2><span id="分析内存瓶颈">分析内存瓶颈 </span></h2><p> 查看内存是否存在瓶颈，使用 <code>top</code> 指令看比较麻烦，而 <code>free</code> 命令更为直观:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">free</span>
             total       used       <span class="token function">free</span>     shared    buffers     cached
Mem:        <span class="token number">501820</span>     <span class="token number">452028</span>      <span class="token number">49792</span>      <span class="token number">37064</span>       <span class="token number">5056</span>     <span class="token number">136732</span>
-/+ buffers/cache:     <span class="token number">310240</span>     <span class="token number">191580</span>
Swap:            <span class="token number">0</span>          <span class="token number">0</span>          <span class="token number">0</span>
$ <span class="token function">top</span>
<span class="token function">top</span> - <span class="token number">17</span>:52:17 up <span class="token number">42</span> days,  <span class="token number">7</span>:10,  <span class="token number">1</span> user,  load average: <span class="token number">0.02</span>, <span class="token number">0.02</span>, <span class="token number">0.05</span>
Tasks:  <span class="token number">80</span> total,   <span class="token number">1</span> running,  <span class="token number">79</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni,100.0 id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem:    <span class="token number">501820</span> total,   <span class="token number">452548</span> used,    <span class="token number">49272</span> free,     <span class="token number">5144</span> buffers
KiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> used,        <span class="token number">0</span> free.   <span class="token number">136988</span> cached Mem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>top</code>工具显示了 <code>free</code> 工具的第一行所有信息，但真实可用的内存，还需要自己计算才知道; 系统实际可用的内存为 <code>free</code> 工具输出第二行的 <code>free+buffer+cached</code>；也就是第三行的<code>free</code> 值 191580；关于 <code>free</code> 命令各个值的详情解读，请参考这篇文章 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/free.html#free">free 查询可用内存</a> ;</p>
<p>如果是因为缺少内存，系统响应变慢很明显，因为这使得系统不停的做换入换出的工作;</p>
<p>进一步的监视内存使用情况，可使用 <code>vmstat</code> 工具，实时动态监视操作系统的内存和虚拟内存的动态变化。 参考： <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/vmstat.html#vmstat">vmstat 监视内存使用情况</a> ;</p>
<h2><span id="分析-io-瓶颈">分析 IO 瓶颈 </span></h2><p> 如果 IO 存在性能瓶颈，<code>top</code>工具中的 <code>%wa</code> 会偏高；</p>
<p>进一步分析使用 <code>iostat</code> 工具:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iostat -d -x -k <span class="token number">1</span> <span class="token number">1</span>
Linux <span class="token number">2.6</span>.32-279.el6.x86_64 <span class="token punctuation">(</span>colin<span class="token punctuation">)</span>   07/16/2014      _x86_64_        <span class="token punctuation">(</span><span class="token number">4</span> CPU<span class="token punctuation">)</span>

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
sda               <span class="token number">0.02</span>     <span class="token number">7.25</span>    <span class="token number">0.04</span>    <span class="token number">1.90</span>     <span class="token number">0.74</span>    <span class="token number">35.47</span>    <span class="token number">37.15</span>     <span class="token number">0.04</span>   <span class="token number">19.13</span>   <span class="token number">5.58</span>   <span class="token number">1.09</span>
dm-0              <span class="token number">0.00</span>     <span class="token number">0.00</span>    <span class="token number">0.04</span>    <span class="token number">3.05</span>     <span class="token number">0.28</span>    <span class="token number">12.18</span>     <span class="token number">8.07</span>     <span class="token number">0.65</span>  <span class="token number">209.01</span>   <span class="token number">1.11</span>   <span class="token number">0.34</span>
dm-1              <span class="token number">0.00</span>     <span class="token number">0.00</span>    <span class="token number">0.02</span>    <span class="token number">5.82</span>     <span class="token number">0.46</span>    <span class="token number">23.26</span>     <span class="token number">8.13</span>     <span class="token number">0.43</span>   <span class="token number">74.33</span>   <span class="token number">1.30</span>   <span class="token number">0.76</span>
dm-2              <span class="token number">0.00</span>     <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.01</span>     <span class="token number">0.00</span>     <span class="token number">0.02</span>     <span class="token number">8.00</span>     <span class="token number">0.00</span>    <span class="token number">5.41</span>   <span class="token number">3.28</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果 <code>%iowait</code> 的值过高，表示硬盘存在 I/O 瓶颈。</li>
<li>如果 <code>%util</code> 接近 100%，说明产生的 I/O 请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈。</li>
<li>如果 <code>svctm</code> 比较接近 <code>await</code>，说明 I/O 几乎没有等待时间；</li>
<li>如果 <code>await</code> 远大于 <code>svctm</code>，说明 I/O 队列太长，io 响应太慢，则需要进行必要优化。</li>
<li>如果 <code>avgqu-sz</code> 比较大，也表示有大量 io 在等待。</li>
</ul>
<p>更多参数说明请参考 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/iostat.html#iostat">iostat 监视 I/O 子系统</a> ;</p>
<h2><span id="分析进程调用">分析进程调用 </span></h2><p> 通过 <code>top</code> 等工具发现系统性能问题是由某个进程导致的之后，接下来我们就需要分析这个进程；继续 查询问题在哪；</p>
<p>这里我们有两个好用的工具： <code>pstack</code>和<code>pstrace</code></p>
<p>pstack 用来跟踪进程栈，这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于 work 状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次 pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p>
<p>示例：查看 bash 程序进程栈:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/opt/app/tdev1<span class="token variable">$ps</span> -fe<span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">bash</span>
tdev1   <span class="token number">7013</span>  <span class="token number">7012</span>  <span class="token number">0</span> <span class="token number">19</span>:42 pts/1    00:00:00 -bash
tdev1  <span class="token number">11402</span> <span class="token number">11401</span>  <span class="token number">0</span> <span class="token number">20</span>:31 pts/2    00:00:00 -bash
tdev1  <span class="token number">11474</span> <span class="token number">11402</span>  <span class="token number">0</span> <span class="token number">20</span>:32 pts/2    00:00:00 <span class="token function">grep</span> <span class="token function">bash</span>
/opt/app/tdev1<span class="token variable">$pstack</span> <span class="token number">7013</span>
<span class="token comment">#0  0x00000039958c5620 in __read_nocancel () from /lib64/libc.so.6</span>
<span class="token comment">#1  0x000000000047dafe in rl_getc ()</span>
<span class="token comment">#2  0x000000000047def6 in rl_read_key ()</span>
<span class="token comment">#3  0x000000000046d0f5 in readline_internal_char ()</span>
<span class="token comment">#4  0x000000000046d4e5 in readline ()</span>
<span class="token comment">#5  0x00000000004213cf in ?? ()</span>
<span class="token comment">#6  0x000000000041d685 in ?? ()</span>
<span class="token comment">#7  0x000000000041e89e in ?? ()</span>
<span class="token comment">#8  0x00000000004218dc in yyparse ()</span>
<span class="token comment">#9  0x000000000041b507 in parse_command ()</span>
<span class="token comment">#10 0x000000000041b5c6 in read_command ()</span>
<span class="token comment">#11 0x000000000041b74e in reader_loop ()</span>
<span class="token comment">#12 0x000000000041b2aa in main ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而 <code>strace</code> 用来跟踪进程中的系统调用；这个工具能够动态的跟踪进程执行时的系统调用和所接收的信号。是一个非常有效的检测、指导和调试工具。系统管理员可以通过该命令容易地解决程序问题。</p>
<p>参考： <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html#strace">strace 跟踪进程中的系统调用</a> ;</p>
<h2><span id="优化程序代码">优化程序代码 </span></h2><p> 优化自己开发的程序，建议采用以下准则:</p>
<ol>
<li>二八法则：在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80% 的尽管是多数，却是次要的；在优化实践中，我们将精力集中在优化那 20% 最耗时的代码上，整体性能将有显著的提升；这个很好理解。函数 A 虽然代码量大，但在一次正常执行流程中，只调用了一次。而另一个函数 B 代码量比 A 小很多，但被调用了 1000 次。显然，我们更应关注 B 的优化。</li>
<li>先编码后优化；编码的时候总是考虑最佳性能未必总是好的；在强调最佳性能的编码方式的同时，可能就损失了代码的可读性和开发效率；</li>
</ol>
<h3><span id="gprof-使用步骤"></span></h3><ol>
<li>用 gcc、g++、xlC 编译程序时，使用 <code>-pg</code> 参数，如：<code>g++ -pg -o test.exe test.cpp</code>编译器会自动在目标代码中插入用于性能测试的代码片断，这些代码在程序运行时采集并记录函数的调用关系和调用次数，并记录函数自身执行时间和被调用函数的执行时间。</li>
<li>执行编译后的可执行程序，如：<code>./test.exe</code>。该步骤运行程序的时间会稍慢于正常编译的可执行程序的运行时间。程序运行结束后，会在程序所在路径下生成一个缺省文件名为 <code>gmon.out</code> 的文件，这个文件就是记录程序运行的性能、调用关系、调用次数等信息的数据文件。</li>
<li>使用 <code>gprof</code> 命令来分析记录程序运行信息的 gmon.out 文件，如：<code>gprof test.exe gmon.out</code>则可以在显示器上看到函数调用相关的统计、分析信息。上述信息也可以采用 <code>gprof test.exe gmon.out&gt; gprofresult.txt</code> 重定向到文本文件以便于后续分析。</li>
</ol>
<p>关于 <code>gprof</code> 的使用案例，请参考 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/advance/03_optimization.html#f1">[f1]</a> ;</p>
<h2><span id="其它工具">其它工具 </span></h2><p> 可以使用 <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/index.html">valgrind</a> 来分析内存泄漏问题。</p>
<p>使用 <a href="http://www.ibm.com/developerworks/cn/linux/l-oprof/">OProfile</a> 或 sar 来分析程序性能。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>实践 Linux 编程之壹 - 构建</title>
    <url>/2015/07/16/Linux/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A3%B9%20-%20%E6%9E%84%E5%BB%BA%20/</url>
    <content><![CDATA[<p>一般源代码提供的程序安装需要通过配置、编译、安装三个步骤；</p>
<ol>
<li>配置做的工作主要是检查当前环境是否满足要安装软件的依赖关系，以及设置程序安装所需要的初始化信息，比如安装路径，需要安装哪些组件；配置完成，会生成 makefile 文件供第二步 make 使用；</li>
<li>编译是对源文件进行编译链接生成可执行程序；</li>
<li>安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下；</li>
</ol>
<a id="more"></a>
<h3><span id="配置">配置 </span></h3><p> 查询可用的配置选项:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>配置路径:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/usr/local/snmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>–prefix</code>是配置使用的最常用选项，设置程序安装的路径；</p>
<h3><span id="编译">编译 </span></h3><p> 编译使用 make 编译:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> -f myMakefile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过 <code>-f</code> 选项显示指定需要编译的 makefile；如果待使用 makefile 文件在当前路径，且文件名为以下几个，则不用显示指定：</p>
<p>makefile Makefile</p>
<h4><span id="makefile-编写的要点">makefile 编写的要点</span></h4><ul>
<li>必须满足第一条规则，满足后停止</li>
<li>除第一条规则，其他无顺序</li>
</ul>
<h4><span id="makefile-中的全局自变量">makefile 中的全局自变量</span></h4><ul>
<li><code>$@</code>目标文件名</li>
<li><code>@^</code>所有前提名，除副本</li>
<li><code>@＋</code>所有前提名，含副本</li>
<li><code>@＜</code>一个前提名</li>
<li><code>@？</code>所有新于目标文件的前提名</li>
<li><code>@*</code>目标文件的基名称</li>
</ul>
<p>要系统学习 makefile 可以参考 <a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf">跟我一起学 makefile</a></p>
<h4><span id="cmake-工具">CMake 工具</span></h4><p>CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 makefile 或者 project 文件。使用 CMake，能够使程序员从复杂的编译连接过程中解脱出来。它使用一个名为 CMakeLists.txt 的文件来描述构建过程, 可以生成标准的构建文件, 如 Unix/Linux 的 Makefile 或 Windows Visual C++ 的 projects/workspaces 。</p>
<h4><span id="编译依赖的库">编译依赖的库</span></h4><p>makefile 编译过程中所依赖的非标准库和头文件路径需要显示指明:</p>
<pre class="line-numbers language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText">CPPFLAGS -I 标记非标准头文件存放路径
LDFLAGS  -L 标记非标准库存放路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果 CPPFLAGS 和 LDFLAGS 已在用户环境变量中设置并且导出（使用 export 关键字），就不用再显示指定；</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">make -f myMakefile LDFLAGS<span class="token operator">=</span><span class="token string">'-L/var/xxx/lib -L/opt/mysql/lib'</span>
    CPPFLAGS<span class="token operator">=</span><span class="token string">'-I/usr/local/libcom/include -I/usr/local/libpng/include'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意：<strong>链接多库时，多个库之间如果有依赖，需要注意书写的顺序，右边是左边的前提；</strong></p>
<h4><span id="g-编译">g++ 编译</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ -o unixApp unixApp.o a.o b.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>选项说明：</p>
<ul>
<li><code>-o</code>: 指明生成的目标文件</li>
<li><code>-g</code>：添加调试信息</li>
<li><code>-E</code>: 查看中间文件</li>
</ul>
<p>应用：查询宏展开的中间文件：</p>
<p>在 g++ 的编译选项中，添加 <code>-E</code>选项，然后去掉 <code>-o</code> 选项 ，重定向到一个文件中即可:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -g -E unixApp.cpp  -I/opt/app/source <span class="token operator">></span> midfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查询应用程序需要链接的库:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ldd myprogrammer
    libstdc++.so.6 <span class="token operator">=</span><span class="token operator">></span> /usr/lib64/libstdc++.so.6 <span class="token punctuation">(</span>0x00000039a7e00000<span class="token punctuation">)</span>
    libm.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libm.so.6 <span class="token punctuation">(</span>0x0000003996400000<span class="token punctuation">)</span>
    libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">></span> /lib64/libgcc_s.so.1 <span class="token punctuation">(</span>0x00000039a5600000<span class="token punctuation">)</span>
    libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libc.so.6 <span class="token punctuation">(</span>0x0000003995800000<span class="token punctuation">)</span>
    /lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x0000003995400000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>关于 ldd 的使用细节，参见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html#ldd">ldd 查看程序依赖库</a></p>
<h3><span id="安装">安装 </span></h3><p> 安装就是将生成的可执行文件拷贝到配置时设置的初始路径下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其实 <strong>install</strong> 就是 makefile 中的一个规则，打开 makefile 文件后可以查看程序安装的所做的工作；</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程管理之 ipcs</title>
    <url>/2015/10/16/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8Bipcs/</url>
    <content><![CDATA[<h2><span id="ipcs-查询进程间通信状态">ipcs - 查询进程间通信状态</span></h2><p>ipcs 是 Linux 下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。可以为程序员提供大量信息来分析程序运行状态。</p>
<a id="more"></a>
<h2><span id="ipc-资源查询">IPC 资源查询 </span></h2><h3><span id="查看系统使用的-ipc-资源"> 查看系统使用的 IPC 资源</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ipcs</span>

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x00000000 <span class="token number">229376</span>     weber      <span class="token number">600</span>        <span class="token number">1</span>

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分别查询 IPC 资源:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ipcs</span> -m <span class="token comment"># 查看系统使用的 IPC 共享内存资源</span>
<span class="token variable">$ipcs</span> -q <span class="token comment"># 查看系统使用的 IPC 队列资源</span>
<span class="token variable">$ipcs</span> -s <span class="token comment"># 查看系统使用的 IPC 信号量资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="查看-ipc-资源被谁占用">查看 IPC 资源被谁占用 </span></h3><p> 示例：有个 IPCKEY(51036)，需要查询其是否被占用；</p>
<ol>
<li><p>首先通过计算器将其转为十六进制:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">printf</span> %x <span class="token number">51036</span>
c75c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>如果知道是被共享内存占用:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs -m <span class="token operator">|</span> <span class="token function">grep</span> c75c
0x0000c75c <span class="token number">40403197</span>   tdea3    <span class="token number">666</span>        <span class="token number">536870912</span>  <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>如果不确定，则直接查找:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ipcs</span> <span class="token operator">|</span> <span class="token function">grep</span> c75c
0x0000c75c <span class="token number">40403197</span>   tdea3    <span class="token number">666</span>        <span class="token number">536870912</span>  <span class="token number">2</span>
0x0000c75c <span class="token number">5079070</span>    tdea3    <span class="token number">666</span>        <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2><span id="系统-ipc-参数查询">系统 IPC 参数查询</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs -l
------ Messages Limits --------
max queues system wide <span class="token operator">=</span> <span class="token number">32000</span>
max size of message <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8192</span>
default max size of queue <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16384</span>

------ Shared Memory Limits --------
max number of segments <span class="token operator">=</span> <span class="token number">4096</span>
max seg size <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">18014398509465599</span>
max total shared memory <span class="token punctuation">(</span>kbytes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">18014398509481980</span>
min seg size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>

------ Semaphore Limits --------
max number of arrays <span class="token operator">=</span> <span class="token number">32000</span>
max semaphores per array <span class="token operator">=</span> <span class="token number">32000</span>
max semaphores system wide <span class="token operator">=</span> <span class="token number">1024000000</span>
max ops per semop call <span class="token operator">=</span> <span class="token number">500</span>
semaphore max value <span class="token operator">=</span> <span class="token number">32767</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上输出显示，目前这个系统的允许的最大内存为 18014398509481980kb；最大可使用 32000 个信号量，每个消息的最大长度为 16384bytes；</p>
<h2><span id="修改-ipc-系统参数">修改 IPC 系统参数 </span></h2><p> 以 linux 系统为例，在 root 用户下修改 /etc/sysctl.conf 文件，保存后使用 sysctl -p 生效:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/sysctl.conf
<span class="token comment"># 一个消息的最大长度</span>
kernel.msgmax <span class="token operator">=</span> <span class="token number">524288</span>

<span class="token comment"># 一个消息队列上的最大字节数</span>
<span class="token comment"># 524288*10</span>
kernel.msgmnb <span class="token operator">=</span> <span class="token number">5242880</span>

<span class="token comment"># 最大消息队列的个数</span>
kernel.msgmni<span class="token operator">=</span><span class="token number">2048</span>

<span class="token comment"># 一个共享内存区的最大字节数</span>
kernel.shmmax <span class="token operator">=</span> <span class="token number">17179869184</span>

<span class="token comment"># 系统范围内最大共享内存标识数</span>
kernel.shmmni<span class="token operator">=</span><span class="token number">4096</span>

<span class="token comment"># 每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数</span>
<span class="token comment"># 此参数为系统默认，可以不用修改</span>
<span class="token comment">#kernel.sem = &lt;semmsl> &lt;semmni>*&lt;semmsl> &lt;semopm> &lt;semmni></span>
kernel.sem <span class="token operator">=</span> <span class="token number">250</span> <span class="token number">32000</span> <span class="token number">32</span> <span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示输入不带标志的 ipcs：的输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs
IPC status from /dev/mem as of Mon Aug <span class="token number">14</span> <span class="token number">15</span>:03:46 <span class="token number">1989</span>
T    ID         KEY        MODE       OWNER     GROUP
Message Queues:
q       <span class="token number">0</span>    0x00010381 -Rrw-rw-rw-   root      system
q   <span class="token number">65537</span>    0x00010307 -Rrw-rw-rw-   root      system
q   <span class="token number">65538</span>    0x00010311 -Rrw-rw-rw-   root      system
q   <span class="token number">65539</span>    0x0001032f -Rrw-rw-rw-   root      system
q   <span class="token number">65540</span>    0x0001031b -Rrw-rw-rw-   root      system
q   <span class="token number">65541</span>    0x00010339--rw-rw-rw-    root      system
q       <span class="token number">6</span>    0x0002fe03 -Rrw-rw-rw-   root      system
Shared Memory:
m   <span class="token number">65537</span>    0x00000000 DCrw-------   root      system
m  <span class="token number">720898</span>    0x00010300 -Crw-rw-rw-   root      system
m   <span class="token number">65539</span>    0x00000000 DCrw-------   root      system
Semaphores:
s  <span class="token number">131072</span>    0x4d02086a --ra-ra----   root      system
s   <span class="token number">65537</span>    0x00000000 --ra-------   root      system
s <span class="token number">1310722</span>    0x000133d0 --ra-------   <span class="token number">7003</span>      <span class="token number">30720</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="清除-ipc-资源">清除 IPC 资源 </span></h2><p> 使用 ipcrm 命令来清除 IPC 资源：这个命令同时会将与 ipc 对象相关联的数据也一起移除。当然，只有 root 用户，或者 ipc 对象的创建者才有这项权利；</p>
<p>ipcrm 用法:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipcrm -M shmkey  <span class="token comment"># 移除用 shmkey 创建的共享内存段</span>
ipcrm -m shmid    <span class="token comment"># 移除用 shmid 标识的共享内存段</span>
ipcrm -Q msgkey  <span class="token comment"># 移除用 msqkey 创建的消息队列</span>
ipcrm -q msqid  <span class="token comment"># 移除用 msqid 标识的消息队列</span>
ipcrm -S semkey  <span class="token comment"># 移除用 semkey 创建的信号</span>
ipcrm -s semid  <span class="token comment"># 移除用 semid 标识的信号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>清除当前用户创建的所有的 IPC 资源:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipcs -q <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123; print"ipcrm -q "<span class="token variable">$2</span>&#125;'</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token punctuation">;</span>
ipcs -m <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123; print"ipcrm -m "<span class="token variable">$2</span>&#125;'</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token punctuation">;</span>
ipcs -s <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123; print"ipcrm -s "<span class="token variable">$2</span>&#125;'</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="综合应用">综合应用 </span></h2><h3><span id="查询-user1-用户环境上是否存在积-queue-现象"> 查询 user1 用户环境上是否存在积 Queue 现象</span></h3><ol>
<li><p>查询队列 Queue:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0x49060005 <span class="token number">58261504</span>   user1    <span class="token number">660</span>        <span class="token number">0</span>            <span class="token number">0</span>
0x4f060005 <span class="token number">58294273</span>   user1    <span class="token number">660</span>        <span class="token number">0</span>            <span class="token number">0</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>找出第 6 列大于 0 的服务:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs -q <span class="token operator">|</span><span class="token function">grep</span> user1 <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'&#123;if(<span class="token variable">$5</span>>0) print <span class="token variable">$0</span>&#125;'</span>
0x00000000 <span class="token number">1071579324</span> user1       <span class="token number">644</span>        <span class="token number">1954530</span>      <span class="token number">4826</span>
0x00000000 <span class="token number">1071644862</span> user1       <span class="token number">644</span>        <span class="token number">1961820</span>      <span class="token number">4844</span>
0x00000000 <span class="token number">1071677631</span> user1       <span class="token number">644</span>        <span class="token number">1944810</span>      <span class="token number">4802</span>
0x00000000 <span class="token number">1071710400</span> user1       <span class="token number">644</span>        <span class="token number">1961820</span>      <span class="token number">4844</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程管理之 ps</title>
    <url>/2015/10/14/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8Bps/</url>
    <content><![CDATA[<h2><span id="ps-进程查看器">ps - 进程查看器</span></h2><p>Linux 中的 ps 命令是 Process Status 的缩写。ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。</p>
<a id="more"></a>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html#top">top linux 下的任务管理器</a> 工具。</p>
<p>注：kill 命令用于杀死进程。</p>
<h2><span id="进程状态">进程状态</span></h2><p>linux 上进程有 5 种状态:</p>
<ol>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死 (进程已终止, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放)</li>
<li>停止(进程收到 SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 信号后停止运行运行)</li>
</ol>
<p>ps 工具标识进程的 5 种状态码:</p>
<ul>
<li>D 不可中断 uninterruptible sleep (usually IO)</li>
<li>R 运行 runnable (on run queue)</li>
<li>S 中断 sleeping</li>
<li>T 停止 traced or stopped</li>
<li>Z 僵死 a defunct (”zombie”) process</li>
</ul>
<h2><span id="命令参数">命令参数</span></h2><ul>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c 显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e 显示环境变量</li>
<li>f 显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r 显示当前终端的进程</li>
<li>T 显示当前终端的所有程序</li>
<li>u 指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>-C&lt; 命令 &gt; 列出指定命令的状况</li>
<li>–lines&lt; 行数 &gt; 每页显示的行数</li>
<li>–width&lt; 字符数 &gt; 每页显示的字符数</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本显示</li>
</ul>
<h2><span id="输出列的含义">输出列的含义</span></h2><ul>
<li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>
<li>S 代表这个程序的状态 (STAT)</li>
<li>UID 程序被该 UID 所拥有</li>
<li>PID 进程的 ID</li>
<li>PPID 则是其上级父程序的 ID</li>
<li>C CPU 使用的资源百分比</li>
<li>PRI 这个是 Priority (优先执行序) 的缩写</li>
<li>NI Nice 值</li>
<li>ADDR 这个是 kernel function，指出该程序在内存的哪个部分。如果是个 running 的程序，一般就是 “-“</li>
<li>SZ 使用掉的内存大小</li>
<li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>
<li>TTY 登入者的终端机位置</li>
<li>TIME 使用掉的 CPU 时间。</li>
<li>CMD 所下达的指令为何</li>
</ul>
<h2><span id="使用实例">使用实例 </span></h2><h3><span id="实例-1显示所有进程信息"> 实例 1：显示所有进程信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -A
PID TTY          TIME CMD
<span class="token number">1</span> ?        00:00:00 init
<span class="token number">2</span> ?        00:00:01 migration/0
<span class="token number">3</span> ?        00:00:00 ksoftirqd/0
<span class="token number">4</span> ?        00:00:01 migration/1
<span class="token number">5</span> ?        00:00:00 ksoftirqd/1
<span class="token number">6</span> ?        00:29:57 events/0
<span class="token number">7</span> ?        00:00:00 events/1
<span class="token number">8</span> ?        00:00:00 khelper
<span class="token number">49</span> ?        00:00:00 kthread
<span class="token number">54</span> ?        00:00:00 kblockd/0
<span class="token number">55</span> ?        00:00:00 kblockd/1
<span class="token number">56</span> ?        00:00:00 kacpid
<span class="token number">217</span> ?        00:00:00 cqueue/0
……省略部分结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-2显示指定用户信息">实例 2：显示指定用户信息</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -u root
PID TTY          TIME CMD
<span class="token number">1</span> ?        00:00:00 init
<span class="token number">2</span> ?        00:00:01 migration/0
<span class="token number">3</span> ?        00:00:00 ksoftirqd/0
<span class="token number">4</span> ?        00:00:01 migration/1
<span class="token number">5</span> ?        00:00:00 ksoftirqd/1
<span class="token number">6</span> ?        00:29:57 events/0
<span class="token number">7</span> ?        00:00:00 events/1
<span class="token number">8</span> ?        00:00:00 khelper
<span class="token number">49</span> ?        00:00:00 kthread
<span class="token number">54</span> ?        00:00:00 kblockd/0
<span class="token number">55</span> ?        00:00:00 kblockd/1
<span class="token number">56</span> ?        00:00:00 kacpid
……省略部分结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-3显示所有进程信息连同命令行">实例 3：显示所有进程信息，连同命令行</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> Nov02 ?        00:00:00 init <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
root         <span class="token number">2</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:01 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">4</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:01 <span class="token punctuation">[</span>migration/1<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>ksoftirqd/1<span class="token punctuation">]</span>
root         <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:29:57 <span class="token punctuation">[</span>events/0<span class="token punctuation">]</span>
root         <span class="token number">7</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>events/1<span class="token punctuation">]</span>
root         <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>khelper<span class="token punctuation">]</span>
root        <span class="token number">49</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>kthread<span class="token punctuation">]</span>
root        <span class="token number">54</span>    <span class="token number">49</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>kblockd/0<span class="token punctuation">]</span>
root        <span class="token number">55</span>    <span class="token number">49</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>kblockd/1<span class="token punctuation">]</span>
root        <span class="token number">56</span>    <span class="token number">49</span>  <span class="token number">0</span> Nov02 ?        00:00:00 <span class="token punctuation">[</span>kacpid<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-4-ps-与-grep-组合使用查找特定进程">实例 4： ps 与 grep 组合使用，查找特定进程</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> <span class="token function">ssh</span>
root      <span class="token number">2720</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov02 ?        00:00:00 /usr/sbin/sshd
root     <span class="token number">17394</span>  <span class="token number">2720</span>  <span class="token number">0</span> <span class="token number">14</span>:58 ?        00:00:00 sshd: root@pts/0
root     <span class="token number">17465</span> <span class="token number">17398</span>  <span class="token number">0</span> <span class="token number">15</span>:57 pts/0    00:00:00 <span class="token function">grep</span> <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-5将与这次登入的-pid-与相关信息列示出来">实例 5：将与这次登入的 PID 与相关信息列示出来</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -l
F S   <span class="token environment constant">UID</span>   PID  <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
<span class="token number">4</span> S     <span class="token number">0</span> <span class="token number">17398</span> <span class="token number">17394</span>  <span class="token number">0</span>  <span class="token number">75</span>   <span class="token number">0</span> - <span class="token number">16543</span> <span class="token function">wait</span>   pts/0    00:00:00 <span class="token function">bash</span>
<span class="token number">4</span> R     <span class="token number">0</span> <span class="token number">17469</span> <span class="token number">17398</span>  <span class="token number">0</span>  <span class="token number">77</span>   <span class="token number">0</span> - <span class="token number">15877</span> -      pts/0    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实例-6列出目前所有的正在内存中的程序">实例 6：列出目前所有的正在内存中的程序</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">10368</span>   <span class="token number">676</span> ?        Ss   Nov02   <span class="token number">0</span>:00 init <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
root         <span class="token number">2</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:01 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span>
root         <span class="token number">3</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        SN   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">4</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:01 <span class="token punctuation">[</span>migration/1<span class="token punctuation">]</span>
root         <span class="token number">5</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        SN   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>ksoftirqd/1<span class="token punctuation">]</span>
root         <span class="token number">6</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02  <span class="token number">29</span>:57 <span class="token punctuation">[</span>events/0<span class="token punctuation">]</span>
root         <span class="token number">7</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>events/1<span class="token punctuation">]</span>
root         <span class="token number">8</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>khelper<span class="token punctuation">]</span>
root        <span class="token number">49</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kthread<span class="token punctuation">]</span>
root        <span class="token number">54</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kblockd/0<span class="token punctuation">]</span>
root        <span class="token number">55</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kblockd/1<span class="token punctuation">]</span>
root        <span class="token number">56</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S<span class="token operator">&lt;</span>   Nov02   <span class="token number">0</span>:00 <span class="token punctuation">[</span>kacpid<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 抓包 mysql 验证三次握手</title>
    <url>/2016/01/16/Linux/Linux%E9%87%8D%E7%9A%84tcpdump%E6%8A%93%E5%8C%85mysql%E9%AA%8C%E8%AF%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<p><code>TCP</code>的三次握手、4 次挥手是老生常谈的东西，那么具体的包数据传输过程你是否真正的试过呢？我们今天就通过具体的 <code>mysql</code> 建联实践来看看是怎么传递数据包的。</p>
<a id="more"></a>
<h2><span id="网络嗅探器和-tcpdump">网络嗅探器和 <code>tcpdump</code></span></h2><p> 在共享式的网络中，数据的传输是怎么完成的呢？又是怎么找到对应的机器来进行数据交互的呢？</p>
<p>一般来说，在网络中，信息报会广播到网络中所有主机的网络接口，主机的网络设备通过 IP 和 MAC 地址等信息判断该信息包是否应该接收，通过抛弃与自己无关的数据包，这样就达到互联网中我们与指定机器通信的目的。</p>
<p>但是在众多的黑客技术中，嗅探器 <code>（sniffer）</code> 是一种很常见的技术，它使主机的网络设备接收所有到达的信息包，从而达到网络监听的目的。在共享式的局域网中，嗅探器可以对该网络中的流量一览无余。除了黑客，网络管理员也应该学会使用嗅探器来随时掌握网络的使用情况，在网络性能急剧下降时，找到网络阻塞和问题的根源。</p>
<p>具体的嗅探器工具在 <code>Windows</code> 平台上有 <code>netxray</code> 和<code>sniffer pro</code>软件，在 <code>Linux</code> 平台上有 <code>tcpdump</code>。我们今天要介绍的就是<code>tcpdump sniffer</code> 嗅探器工具。</p>
<h2><span id="安装-tcpdump">安装 <code>tcpdump</code></span></h2><p><code>tcpdump</code> 是<code>Linux</code>平台一个以命令行方式运行的网络流量检测工具，它能截获网卡上收到的数据包，并通过一定的配置来完成对内容的解析和分析。</p>
<p>检测系统中是否已经安装了 <code>tcpdump</code> 的方法非常简单，就是直接执行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tcpdump
<span class="token comment"># 如果没有安装</span>
tcpdump: no suitable device found
<span class="token comment"># 如果已经安装，则当有网络请求时会出现许多的这种网络解析数据</span>
<span class="token number">21</span>:44:14.109590 IP client.host <span class="token operator">></span> server.host: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">1031520</span>:1031984, ack <span class="token number">1393</span>, win <span class="token number">95</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2242702304</span> ecr <span class="token number">3381086780</span><span class="token punctuation">]</span>, length <span class="token number">464</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最新的 <code>tcpdump</code> 源码下载地址：<a href="http://www.tcpdump.org/">http://www.tcpdump.org</a> （tcpdump 官网）</p>
<blockquote>
<p><code>tcpdump</code>的运行需要 <code>pcap</code> 的支持，请同时下载这两个内容并安装，一般最新版本的两者是互相兼容的。</p>
</blockquote>
<p>笔者本次下载的是最新的版本，直接在命令行里使用 wget 下载即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 tcpdump 文件</span>
$ <span class="token function">wget</span> www.tcpdump.org/release/tcpdump-4.9.2.tar.gz

<span class="token comment"># 下载 pcap 文件</span>
$ <span class="token function">wget</span> www.tcpdump.org/release/libpcap-1.9.0.tar.gz

<span class="token comment"># 安装 libpcap，make install 的时候可能需要 root 权限</span>
$ <span class="token function">tar</span> -zxvf libpcap-1.9.0.tar.gz
$ <span class="token builtin class-name">cd</span> libpcap-1.9.0.tar.gz
$ ./configure
$ <span class="token function">make</span>
$ <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 安装 tcpdump 的过程</span>
$ <span class="token function">tar</span> -zxvf tcpdump-4.9.2
$ <span class="token builtin class-name">cd</span> tcpdump-4.9.2
$ ./configure
$ <span class="token function">make</span>
$ <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装完成后跟上面一样输入 <code>tcpdump</code> 判断是否成功安装了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tcpdump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="tcpdump的命令行参数和过滤规则"><code>tcpdump</code>的命令行参数和过滤规则 </span></h2><p><code>tcpdump</code> 是个命令行方式的网络嗅探器，如果不使用任何参数，会持续捕获所有的网络请求内容，无法有效分析，可以针对自己的需求使用合适的参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看所有的参数内容</span>
$ tcpdump --help
tcpdump version <span class="token number">4.9</span>.2
libpcap version <span class="token number">1.9</span>.0-PRE-GIT <span class="token punctuation">(</span>with TPACKET_V2<span class="token punctuation">)</span>
OpenSSL <span class="token number">1.0</span>.0-fips <span class="token number">29</span> Mar <span class="token number">2010</span>
Usage: tcpdump <span class="token punctuation">[</span>-aAbdDefhHIJKlLnNOpqStuUvxX<span class="token comment">#] [-B size] [-c count]</span>
                <span class="token punctuation">[</span> -C file_size <span class="token punctuation">]</span> <span class="token punctuation">[</span> -E algo:secret <span class="token punctuation">]</span> <span class="token punctuation">[</span> -F <span class="token function">file</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> -G seconds <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> -i interface <span class="token punctuation">]</span> <span class="token punctuation">[</span> -j tstamptype <span class="token punctuation">]</span> <span class="token punctuation">[</span> -M secret <span class="token punctuation">]</span> <span class="token punctuation">[</span> --number <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> -Q <span class="token keyword">in</span><span class="token operator">|</span>out<span class="token operator">|</span>inout <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> -r <span class="token function">file</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> -s snaplen <span class="token punctuation">]</span> <span class="token punctuation">[</span> --time-stamp-precision precision <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> --immediate-mode <span class="token punctuation">]</span> <span class="token punctuation">[</span> -T <span class="token builtin class-name">type</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> --version <span class="token punctuation">]</span> <span class="token punctuation">[</span> -V <span class="token function">file</span> <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> -w <span class="token function">file</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> -W filecount <span class="token punctuation">]</span> <span class="token punctuation">[</span> -y datalinktype <span class="token punctuation">]</span> <span class="token punctuation">[</span> -z postrotate-command <span class="token punctuation">]</span>
                <span class="token punctuation">[</span> -Z user <span class="token punctuation">]</span> <span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用的参数含义：</p>
<ul>
<li><code>-a</code> 将网络地址转变为易识别的主机名（默认）</li>
<li><code>-n</code> 不将网络地址转变为易识别的主机名，即直接显示 IP 地址，可以省略 DNS 查询</li>
<li><code>-nn</code> 不进行端口名称的转换</li>
<li><code>-t</code> 不显示时间戳</li>
<li><code>-tttt</code> 输出由 date 处理后的时间戳</li>
<li><code>-c</code> 捕获指定数量的数据包后退出</li>
<li><code>-e</code> 显示数据链路层的头部信息，即 MAC 地址信息：<code>00:8c:fa:f3:e3:04 (oui Unknown) &gt; 00:e0:ec:3e:8d:39 (oui Unknown), ethertype IPv4 (0x0800), length 71</code></li>
<li><code>-f</code> 将目标的 internet 地址以 IP 形式展示</li>
<li><code>-i</code> 监听指定的网络接口</li>
<li><code>-S</code> 将 tcp 的序号以绝对值形式输出，而不是相对值</li>
<li><code>-r</code> 从指定文档中读取数据包</li>
<li><code>-w</code> 不分析和输出，将截获的数据包写入指定文档</li>
<li><code>-T</code> 将截获的数据包按指定类型报文解析，如：<code>cnfp/rpc/rtp/snmp/vat/wb</code></li>
<li><code>-F</code> 从指定文档读取过滤规则，忽略命令行的其他参数指定的过滤规则</li>
<li><code>-v</code> 输出较详细的信息，如 IP 包的 TTL 和协议类型</li>
<li><code>-vv</code> 输出详细的信息</li>
<li><code>-l</code> 将标准输出转变为行缓冲方式</li>
<li><code>-d</code> 将上次捕获的信息包以汇编格式显示</li>
<li><code>-dd</code> 将上次捕获的信息包以 C 语言格式显示</li>
<li><code>-ddd</code> 将上次捕获的信息包以十进制格式显示</li>
</ul>
<p>除了参数之外，更重要的是过滤表达式，包含三个类型关键字：</p>
<ul>
<li><code>host: 10.10.13.15</code> 监听的主机</li>
<li><code>net: 10.10.0.0</code> 监听的网络</li>
<li><code>port: 21</code> 监听的端口</li>
</ul>
<p>四个截获方向关键字：</p>
<ul>
<li><code>dst: 10.10.13.15</code> 目标主机</li>
<li><code>src: 10.10.0.0</code> 源网络</li>
<li><code>dst and src</code></li>
<li><code>dst or src</code>（缺省值）</li>
</ul>
<p>多个协议关键字：<code>ether/fddi/tr/ip/ip6/rarp/decnet/tcp/udp</code>。</p>
<p>还支持组合表达式：<code>not/!/and/&amp;&amp;/or/||</code>。</p>
<p>举几个常用的例子：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 只捕获指定 IP 的数据包</span>
$ tcpdump <span class="token function">host</span> <span class="token number">10.10</span>.13.15
<span class="token comment"># 捕获两个 IP 的数据包</span>
$ tcpdump <span class="token function">host</span> <span class="token number">1010.13</span>.15 and <span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token number">10.10</span>.13.47<span class="token punctuation">\</span><span class="token punctuation">)</span>
<span class="token comment"># 捕获指定端口和协议的数据包</span>
$ tcpdump tcp port <span class="token number">21</span> and <span class="token function">host</span> <span class="token number">10.10</span>.13.15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="实例测试">实例测试</span></h2><blockquote>
<p>这个实例是 A 机器 <code>（client）</code> 向 B 机器 <code>（server）</code> 发起 <code>mysql</code> 实例连接，并立刻 <code>exit</code> 的场景。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>A 机器启动嗅探器：<code>tcpdump host 10.92.143.15 -tttt -S -nn</code></li>
<li>A 机器执行<code>mysql -u root -h 10.92.143.15 -p</code></li>
<li>A 机器数据库连接成功后，立刻 <code>exit;</code> 退出 <code>mysql</code> 实例连接</li>
</ol>
<p>报文：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 三次握手，其中 S 代表 Syn，. 代表 Ack，S. 代表 Syn, Ack</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.768100 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">864854527</span>, win <span class="token number">14600</span>, options <span class="token punctuation">[</span>mss <span class="token number">1460</span>,sackOK,TS val <span class="token number">2246810963</span> ecr <span class="token number">0</span>,nop,wscale <span class="token number">8</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.810055 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>S.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">4288771247</span>, ack <span class="token number">864854528</span>, win <span class="token number">14480</span>, options <span class="token punctuation">[</span>mss <span class="token number">1460</span>,sackOK,TS val <span class="token number">2062159250</span> ecr <span class="token number">2246810963</span>,nop,wscale <span class="token number">8</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.810065 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">4288771248</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811005</span> ecr <span class="token number">2062159250</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token comment"># 登录校验，传输用户名和密码验证阶段，其中 P 代表 Push，传输数据需要。这里包含登录验证和版本信息等元数据的交换</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.852102 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">4288771248</span>:4288771308, ack <span class="token number">864854528</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062159292</span> ecr <span class="token number">2246811005</span><span class="token punctuation">]</span>, length <span class="token number">60</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.852118 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">4288771308</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811047</span> ecr <span class="token number">2062159292</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.853251 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">864854528</span>:864854590, ack <span class="token number">4288771308</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811048</span> ecr <span class="token number">2062159292</span><span class="token punctuation">]</span>, length <span class="token number">62</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.895198 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">864854590</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062159335</span> ecr <span class="token number">2246811048</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.895256 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">4288771308</span>:4288771319, ack <span class="token number">864854590</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062159335</span> ecr <span class="token number">2246811048</span><span class="token punctuation">]</span>, length <span class="token number">11</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.895264 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">4288771319</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811090</span> ecr <span class="token number">2062159335</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.895312 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">864854590</span>:864854627, ack <span class="token number">4288771319</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811090</span> ecr <span class="token number">2062159335</span><span class="token punctuation">]</span>, length <span class="token number">37</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.937268 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">864854627</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062159377</span> ecr <span class="token number">2246811090</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.937405 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">4288771319</span>:4288771409, ack <span class="token number">864854627</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062159377</span> ecr <span class="token number">2246811090</span><span class="token punctuation">]</span>, length <span class="token number">90</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:42.937414 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">4288771409</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246811132</span> ecr <span class="token number">2062159377</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token comment"># 发送 exit；正好 5 个字符</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.366633 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>P.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">864854627</span>:864854632, ack <span class="token number">4288771409</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246812561</span> ecr <span class="token number">2062159377</span><span class="token punctuation">]</span>, length <span class="token number">5</span>
<span class="token comment"># 四次挥手，其中 F 代表 FIN，完成数据发送</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.366649 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>F.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">864854632</span>, ack <span class="token number">4288771409</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246812561</span> ecr <span class="token number">2062159377</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token comment">## 这个是 exit 的答复</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.408575 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">864854632</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062160848</span> ecr <span class="token number">2246812561</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.408618 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">864854633</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062160848</span> ecr <span class="token number">2246812561</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.408652 IP <span class="token number">10.92</span>.143.15.3306 <span class="token operator">></span> <span class="token number">10.119</span>.124.24.45298: Flags <span class="token punctuation">[</span>F.<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">4288771409</span>, ack <span class="token number">864854633</span>, win <span class="token number">57</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2062160848</span> ecr <span class="token number">2246812561</span><span class="token punctuation">]</span>, length <span class="token number">0</span>
<span class="token number">2018</span>-08-19 <span class="token number">22</span>:52:44.408657 IP <span class="token number">10.119</span>.124.24.45298 <span class="token operator">></span> <span class="token number">10.92</span>.143.15.3306: Flags <span class="token punctuation">[</span>.<span class="token punctuation">]</span>, ack <span class="token number">4288771410</span>, win <span class="token number">58</span>, options <span class="token punctuation">[</span>nop,nop,TS val <span class="token number">2246812603</span> ecr <span class="token number">2062160848</span><span class="token punctuation">]</span>, length <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>具体的 <code>mysql</code> 通信内容可以查看这篇文章：<a href="https://jin-yang.github.io/post/mysql-protocol.html">https://jin-yang.github.io/po…</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mysql</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 静态库编译指南</title>
    <url>/2015/01/17/Linux/Linux%E9%9D%99%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Linux 上的静态库，其实是目标文件的归档文件。<br>在 Linux 上创建静态库的步骤如下：</p>
<ol>
<li>写源文件，通过 <code>gcc -c xxx.c</code> 生成目标文件。</li>
<li>用 <code>ar</code> 归档目标文件，生成静态库。</li>
<li>配合静态库，写一个使用静态库中函数的头文件。</li>
<li>使用静态库时，在源码中包含对应的头文件，链接时记得链接自己的库。</li>
</ol>
<h2><span id="源文件">源文件</span></h2><p>print.c 和 math.c</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//print.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">cout</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> message<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//math.c</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成目标文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -c print.c math.c
$ <span class="token function">ls</span>
math.c  math.o  print.c print.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="归档">归档 </span></h2><p> 使用 <code>ar</code> 归档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ar crv libmylib.a my_print.o my_math.o
a - print.o
a - math.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上述命令中 crv 是 ar 的命令选项：</p>
<ul>
<li>c 如果需要生成新的库文件，不要警告</li>
<li>r 代替库中现有的文件或者插入新的文件</li>
<li>v 输出详细信息</li>
</ul>
<p>通过 <code>ar t libmylib.a</code> 可以查看 <code>libmylib.a</code> 中包含的目标文件。</p>
<p>我们要生成的库的文件名必须形如 <code>libxxx.a</code> ，这样我们在链接这个库时，就可以用 <code>-lxxx</code>。<br>反过来讲，当我们告诉编译器 <code>-lxxx</code>时，编译器就会在指定的目录中搜索 <code>libxxx.a</code> 或是 <code>libxxx.so</code>。</p>
<h2><span id="头文件">头文件 </span></h2><p> 头文件定义了 libmylib.a 的接口，也就是告诉用户怎么使用 libmylib.a。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//my_lib.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MY_LIB_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__MY_LIB_H__</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">cout</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="测试">测试 </span></h2><p> 在同一目录下建立 test.c</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"my_lib.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cout</span><span class="token punctuation">(</span><span class="token string">"I am a func from mylib ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc test.c -L. -lmylib -o <span class="token builtin class-name">test</span> <span class="token comment"># 在. 目录搜索 libmylib.a 或 libmylib.so 文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面的命令中 <code>-L.</code> 告诉 gcc 搜索链接库时包含当前路径， <code>-lmylib</code> 告诉 gcc 生成可执行程序时要链接 <code>libmylib.a</code>。</p>
<p>运行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./test
I am a func from mylib <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="自动化编译">自动化编译 </span></h2><p> 利用 make 来进行自动化编译</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> build test clean

<span class="token symbol">build</span><span class="token punctuation">:</span> libmylib.a

<span class="token symbol">libmylib.a</span><span class="token punctuation">:</span> math.o print.o
	ar crv <span class="token variable">$@</span> math.o print.o

<span class="token symbol">math.o</span><span class="token punctuation">:</span> math.c
	gcc -c math.c

<span class="token symbol">print.o</span><span class="token punctuation">:</span> print.c
	gcc -c print.c

<span class="token symbol">test</span><span class="token punctuation">:</span> test.c
	gcc test.c -L. -lmylib -o test
<span class="token symbol">clean</span><span class="token punctuation">:</span> 
	rm -f *.o *.so *.a test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>make build</code> 将会构建 libmylib.a， </p>
<p><code>make test</code> 将会生成链接 libmylib.a 的程序,</p>
<p><code>make clean</code> 将清理所有的编译中间文件和目标文件</p>
<h2><span id="附录">附录 </span></h2><p> 例程见<a href="https://github.com/maywzh/Lab_stlib_compiler">Github</a></p>
<p>相关博文 <a href="/Linux 动态库编译指南 /">Linux 动态库编译指南</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>简明 tmux 玩法教程</title>
    <url>/2017/01/09/Linux/%E5%B7%A5%E5%85%B7%E4%B9%8B%E7%AE%80%E6%98%8Etmux%E7%8E%A9%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1><span id="猫哥_kaiye-编程笔记"></span></h1><h2><span id> </span></h2><h1><span id="十分钟学会-tmux"></span></h1><p>tmux 是一款终端复用命令行工具，一般用于 Terminal 的窗口管理。在 macOS 下，使用 iTerm2 能应付绝大多数窗口管理的需求。</p>
<p><img src="https://images2015.cnblogs.com/blog/520689/201701/520689-20170111205923853-1701606139.png" alt="img"></p>
<p>如上图所示，iTerm2 能新建多个标签页（快捷键 ⌘T），也能在同一个窗口中分割出多个窗格（快捷键 ⌘D 或 ⌘⇧D）。</p>
<p>tmux 相比 iTerm2 的优势在于：</p>
<ul>
<li>iTerm2 的窗格切换快捷键（⌘⌥→）容易与其他软件全局快捷键冲突（例如 Spectacle 的窗口分割快捷键），tmux 由于存在前缀快捷键，所以不存在快捷键冲突问题；</li>
<li>tmux 可以在终端软件重启后通过命令行恢复上次的 session ，而终端软件则不行；</li>
<li>tmux 简洁优雅、订制性强，学会之后也能在 Linux 上使用，有助于逼格提升。</li>
</ul>
<p>接下来我们花十分钟来掌握下 tmux 的基础用法：</p>
<h2><span id="安装运行">安装运行</span></h2><p>macOS 上使用 Homebrew 安装即可：</p>
<pre class="line-numbers language-none"><code class="language-none">brew install tmux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装完成后，运行 <code>tmux</code> 新建一个 tmux 的会话（session），此时窗口唯一的变化是在底部会出现一个 tmux 的状态栏。我们先按下 tmux 默认的前缀快捷键 <code>⌃b</code> 将其激活为快捷键接收模式，再按下 <code>%</code> ，即可将当前窗口切分为左右两个窗格。</p>
<p><img src="https://images2015.cnblogs.com/blog/520689/201701/520689-20170111205933322-578444111.png" alt="img"></p>
<h2><span id="快捷键">快捷键 </span></h2><p> 一般情况下 tmux 中所有的快捷键都需要和前缀快捷键 <code>⌃b</code> 来组合使用（注：⌃ 为 Mac 的 control 键），以下是常用的窗格（pane）快捷键列表，大家可以依次尝试下：</p>
<h3><span id="窗格操作">窗格操作</span></h3><ul>
<li><code>%</code> 左右平分出两个窗格</li>
<li><code>&quot;</code> 上下平分出两个窗格</li>
<li><code>x</code> 关闭当前窗格</li>
<li><code>&#123;</code> 当前窗格前移</li>
<li><code>&#125;</code> 当前窗格后移</li>
<li><code>;</code> 选择上次使用的窗格</li>
<li><code>o</code> 选择下一个窗格，也可以使用上下左右方向键来选择</li>
<li><code>space</code> 切换窗格布局，tmux 内置了五种窗格布局，也可以通过 <code>⌥1</code> 至 <code>⌥5</code>来切换</li>
<li><code>z</code> 最大化当前窗格，再次执行可恢复原来大小</li>
<li><code>q</code> 显示所有窗格的序号，在序号出现期间按下对应的数字，即可跳转至对应的窗格</li>
</ul>
<h3><span id="窗口操作">窗口操作</span></h3><p>tmux 除了窗格以外，还有窗口（window） 的概念。依次使用以下快捷键来熟悉 tmux 的窗口操作：</p>
<ul>
<li><code>c</code> 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>w</code> 窗口列表选择，注意 macOS 下使用 <code>⌃p</code> 和 <code>⌃n</code> 进行上下选择</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>,</code> 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id</li>
<li><code>0</code> 切换至 0 号窗口，使用其他数字 id 切换至对应窗口</li>
<li><code>f</code> 根据窗口名搜索选择窗口，可模糊匹配</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/520689/201701/520689-20170111205944010-1132178011.png" alt="img"></p>
<h3><span id="会话操作">会话操作 </span></h3><p> 如果运行了多次 <code>tmux</code> 命令则会开启多个 tmux 会话（session）。在 tmux 会话中，使用前缀快捷键 <code>⌃b</code> 配合以下快捷键可操作会话：</p>
<ul>
<li><code>$</code> 重命名当前会话</li>
<li><code>s</code> 选择会话列表</li>
<li><code>d</code> detach 当前会话，运行后将会退出 tmux 进程，返回至 shell 主进程</li>
</ul>
<p>在 shell 主进程下运行以下命令可以操作 tmux 会话：</p>
<pre class="line-numbers language-none"><code class="language-none">tmux new -s foo # 新建名称为 foo 的会话
tmux ls # 列出所有 tmux 会话
tmux a # 恢复至上一次的会话
tmux a -t foo # 恢复名称为 foo 的会话，会话默认名称为数字
tmux kill-session -t foo # 删除名称为 foo 的会话
tmux kill-server # 删除所有的会话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除以上提到的快捷键以外，tmux 还有许多其他的快捷键和命令，使用前缀快捷键 <code>⌃b</code> 加 <code>?</code> 可以查看所有的快捷键列表，该列表视图为 <strong>tmux copy 模式</strong>，该模式下可使用以下快捷键（无需加 <code>⌃b</code> 前缀）：</p>
<ul>
<li><code>⌃v</code> 下一页</li>
<li><code>Meta v</code> 上一页 （tmux 快捷键为 Emacs 风格，这里的 Meta 键可用 Esc 模拟）</li>
<li><code>⌃s</code> 向前搜索</li>
<li><code>q</code> 退出 copy 模式</li>
</ul>
<h2><span id="常见配置与问题">常见配置与问题</span></h2><h3><span id="1-鼠标滚屏">1、鼠标滚屏</span></h3><p>tmux 默认配置中最糟糕的体验就是滚屏查看和文本复制（大家可以先试试看）。你需要先使用 <code>⌃b</code> <code>[</code> 快捷键进入 copy 模式，然后使用翻页、字符定位来选择需要的字符，效率远没有鼠标选择来的快。</p>
<p>因此 tmux 提供了一些个性化配置项来优化这些配置，首先在 shell 中运行 <code>touch ~/.tmux.conf</code> 新建用户配置文件。在文件中增加以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none"># 开启鼠标模式
set -g mode-mouse on

# 允许鼠标选择窗格
set -g mouse-select-pane on

# 如果喜欢给窗口自定义命名，那么需要关闭窗口的自动命名
set-option -g allow-rename off

# 如果对 vim 比较熟悉，可以将 copy mode 的快捷键换成 vi 模式
set-window-option -g mode-keys vi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件修改完成后，可以 <code>tmux kill-server</code> 重启所有 tmux 进程，或者在 tmux 会话中使用 <code>⌃b</code> <code>:</code> 进入控制台模式，输入 <code>source-file ~/.tmux.conf</code> 命令重新加载配置。</p>
<h3><span id="2-鼠标复制">2、鼠标复制</span></h3><p>tmux 下开启鼠标滚屏后，复制文本有两种方式：</p>
<ul>
<li>方法 1：使用 <code>⌃b</code> <code>z</code> 进入窗格全屏模式，鼠标选择文本的同时按住 option 键 <code>⌥</code>，然后使用 <code>⌘c</code> 进行复制；</li>
<li>方法 2：开启 iTerm2 「在选择时复制」选项，即可实现自动选择复制。如下图：</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/520689/201701/520689-20170111210013541-836018258.png" alt="img"></p>
<h3><span id="3-tips">3、tips</span></h3><ul>
<li><a href="http://hyperpolyglot.org/multiplexers">screen</a> 是另外一款终端复用命令行，但他没有 tmux 好看好用；</li>
<li><a href="https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard#mac-os-x-pasteboard-access-under-tmux-and-screen">tmux 有个 bug</a> ，导致从它启动的 vscode 的复制粘贴快捷键会失效；</li>
<li>iTerm2 可以通过 「Preferences -&gt; Profiles -&gt; Keyboard Behavior -&gt; Left option key acts as +Esc」将键盘的左侧 option 键映射为 Meta 键</li>
</ul>
<p>另外，最近看到两篇不错的 <a href="https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9AAWK.md">awk</a>、<a href="https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9ASED.md">sed</a> 命令入门，感兴趣的同学可以自己看一下。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Ubuntu 上搭建 TimeCapsule 服务</title>
    <url>/2016/03/30/Linux/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E4%B9%8BUbuntu%E6%90%AD%E5%BB%BAAFP%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ETimeMachine%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>一直是使用 samba 服务作为 NAS，移动硬盘插在 mac 上作为 TimeMachine 备份盘，但这样还是太笨拙了。</p>
<p>为了实现无线备份，一种方法是购买 Apple TimeCapsule，另一种则是利用 Linux 设备来搭建 <a href="http://netatalk.sourceforge.net/">Netatalk</a> 服务器。正好又一台闲置的 Ubuntu 机器，于是就决定采用这种方式。</p>
<p><a href="http://netatalk.sourceforge.net/">Netatalk</a>是一个开源的 AppleTalk 通信协议的实现，可以通过在 Linux 系统上搭建 Netatalk 服务来作为 macOS 设备的 AFP 服务器、AppleTalk 路由等等。结合 <a href="https://github.com/lathiat/avahi">avahi</a> 服务，可以达到 Apple 原生设备的效果。</p>
<p>本文基于 Ubuntu 18.04 环境搭建，其他环境配置类似。</p>
<a id="more"></a>
<h2><span id="硬盘挂载与配置">硬盘挂载与配置 </span></h2><h3><span id="查看已连接的硬盘"> 查看已连接的硬盘</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">fdisk</span> -l   								<span class="token comment"># 查看系统连接的磁盘信息</span>
<span class="token punctuation">..</span>.
/dev/sdb3  <span class="token number">649940992</span> <span class="token number">976773119</span> <span class="token number">326832128</span> <span class="token number">155</span>.9G Apple HFS/HFS+  
											<span class="token comment"># 显示需要挂载的 HFS+ 分区在 /dev/sdb3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="hfs-分区关闭-journal">HFS+ 分区关闭 journal</span></h3><p>Mac 的 HFS+ 分区一般都默认开启 journal 功能，因为 Linux 不支持读写 journaled HFS+，所以必须关闭这个功能。</p>
<p>可以把硬盘连接到 mac 操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 关闭 Journal</span>
$ diskutil disableJournal disk0s2       <span class="token comment"># 假设 disk0s2 为需要挂载到 linux 上的磁盘分区</span>
Journaling has been disabled on disk0s2
 
<span class="token comment"># 打开 Journal  </span>
$ diskutil enableJournal disk0s2
Journaling has been enabled on disk0s2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者直接在 linux 上操作，通过下载 <code>journalling_off.c</code> 源码编译运行来关闭</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /tmp
$ <span class="token function">curl</span> https://pastebin.com/raw/W8pfgHRe -o journalling_off.c
$ gcc journalling_off.c -o journalling_off
$ <span class="token function">sudo</span> ./journalling_off /dev/sdb3   	<span class="token comment"># 根据 fdisk 的结果 /dev/sdb3 为对应 HFS+ 分区</span>
<span class="token operator">&lt;</span>/code<span class="token operator">></span>sudo ./journalling_off /dev/sdb3
attributes <span class="token operator">=</span> 0x80002100 
journal has been disabled.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果网速不好，源码如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// journalling_off.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;byteswap.h></span></span>
 
 
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
       
        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> PROT_READ<span class="token operator">|</span>PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xffffffff</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
       
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'H'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span><span class="token number">1025</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s: HFS+ signature not found -- aborting.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
       
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> attributes <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">[</span><span class="token number">1028</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        attributes <span class="token operator">=</span> <span class="token function">bswap_32</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"attributes = 0x%8.8lx\n"</span><span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>
       
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>attributes <span class="token operator">&amp;</span> <span class="token number">0x00002000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"kHFSVolumeJournaledBit not currently set in the volume attributes field.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
       
        attributes <span class="token operator">&amp;=</span> <span class="token number">0xffffdfff</span><span class="token punctuation">;</span>
        attributes <span class="token operator">=</span> <span class="token function">bswap_32</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">[</span><span class="token number">1028</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> attributes<span class="token punctuation">;</span>
       
        buffer<span class="token punctuation">[</span><span class="token number">1032</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1033</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1034</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1035</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
       
        buffer<span class="token punctuation">[</span><span class="token number">1036</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1037</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1038</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span><span class="token number">1039</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"journal has been disabled.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="挂载">挂载</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mkdir</span> /mnt/timemachine					<span class="token comment"># 创建挂载点</span>
$ <span class="token function">sudo</span> <span class="token function">mount</span>  -t hfsplus -o force,rw /dev/sdb3 /mnt/timemachine   		
												<span class="token comment"># 挂载点设置为 /mnt/timemachine</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="netatalk-编译安装与配置">Netatalk 编译安装与配置 </span></h2><p> 由于 apt 上的 Netatalk 的版本太老，所以选择编译安装。 </p>
<h3><span id="编译">编译 </span></h3><p> 安装依赖库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> -y <span class="token punctuation">\</span>
build-essential <span class="token punctuation">\</span>
libevent-dev <span class="token punctuation">\</span>
libssl-dev <span class="token punctuation">\</span>
libgcrypt-dev <span class="token punctuation">\</span>
libkrb5-dev <span class="token punctuation">\</span>
libpam0g-dev <span class="token punctuation">\</span>
libwrap0-dev <span class="token punctuation">\</span>
libdb-dev <span class="token punctuation">\</span>
libtdb-dev <span class="token punctuation">\</span>
avahi-daemon <span class="token punctuation">\</span>
libavahi-client-dev <span class="token punctuation">\</span>
libacl1-dev <span class="token punctuation">\</span>
libldap2-dev <span class="token punctuation">\</span>
libcrack2-dev <span class="token punctuation">\</span>
libdbus-1-dev <span class="token punctuation">\</span>
libdbus-glib-1-dev <span class="token punctuation">\</span>
libglib2.0-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装<a href="https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/checkinstall_1.6.2-4ubuntu2_amd64.deb.html">checkinstall</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> --yes checkinstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以通过 <a href="https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/checkinstall_1.6.2-4ubuntu2_amd64.deb.html"> 下载 deb 包 </a> 来安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /tmp <span class="token operator">&amp;&amp;</span> <span class="token function">curl</span> http://archive.ubuntu.com/ubuntu/pool/universe/c/checkinstall/checkinstall_1.6.2-4ubuntu2_amd64.deb
$ <span class="token function">sudo</span> dpkg -i checkinstall_1.6.2-4ubuntu2_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>设置环境变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">NETATALK_VERSION</span><span class="token operator">=</span><span class="token string">'3.1.11'</span>
$ <span class="token assign-left variable">MAINTAINER</span><span class="token operator">=</span><span class="token string">'maywzh \&lt;maywzh@gamil.com\>'</span> <span class="token comment"># 这里换成 自己的名字和邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>下载 netatalk 源码</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wget</span> http://prdownloads.sourceforge.net/netatalk/netatalk-<span class="token variable">$&#123;NETATALK_VERSION&#125;</span>.tar.gz -P /tmp
<span class="token function">tar</span> -xzf /tmp/netatalk-<span class="token variable">$&#123;NETATALK_VERSION&#125;</span>.tar.gz -C /tmp
$ <span class="token builtin class-name">cd</span> /tmp/netatalk-<span class="token variable">$&#123;NETATALK_VERSION&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编译</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./configure <span class="token punctuation">\</span>
--with-init-style<span class="token operator">=</span>debian-systemd <span class="token punctuation">\</span>
--without-libevent <span class="token punctuation">\</span>
--with-cracklib <span class="token punctuation">\</span>
--enable-krbV-uam <span class="token punctuation">\</span>
--with-pam-confdir<span class="token operator">=</span>/etc/pam.d <span class="token punctuation">\</span>
--with-dbus-daemon<span class="token operator">=</span>/usr/bin/dbus-daemon <span class="token punctuation">\</span>
--with-dbus-sysconf-dir<span class="token operator">=</span>/etc/dbus-1/system.d
$ <span class="token function">make</span>
$ <span class="token function">sudo</span> checkinstall -D <span class="token punctuation">\</span>
--pkgname<span class="token operator">=</span><span class="token string">'netatalk'</span> <span class="token punctuation">\</span>
--pkgversion<span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;NETATALK_VERSION&#125;</span>"</span> <span class="token punctuation">\</span>
--maintainer<span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;MAINTAINER&#125;</span>"</span> <span class="token punctuation">\</span>
$ <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="安装">安装 </span></h3><p> 安装依赖</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> -y <span class="token punctuation">\</span>
avahi-daemon <span class="token punctuation">\</span>
cracklib-runtime <span class="token punctuation">\</span>
db-util <span class="token punctuation">\</span>
db5.3-util <span class="token punctuation">\</span>
libtdb1 <span class="token punctuation">\</span>
libavahi-client3 <span class="token punctuation">\</span>
libcrack2 <span class="token punctuation">\</span>
libcups2 <span class="token punctuation">\</span>
libpam-cracklib <span class="token punctuation">\</span>
libdbus-glib-1-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装编译包</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> dpkg -i netatalk_3.1.11-1_amd64.deb
$ <span class="token function">sudo</span> ldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>检查安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ netatalk -v
netatalk <span class="token number">3.1</span>.11 - Netatalk AFP server <span class="token function">service</span> controller daemon

This program is <span class="token function">free</span> software<span class="token punctuation">;</span> you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation<span class="token punctuation">;</span> either version <span class="token number">2</span> of the License, or <span class="token punctuation">(</span>at your option<span class="token punctuation">)</span> any later
version. Please see the <span class="token function">file</span> COPYING <span class="token keyword">for</span> further information and details.

netatalk has been compiled with support <span class="token keyword">for</span> these features:

      Zeroconf support:	Avahi
     Spotlight support:	No

                  afpd:	/usr/local/sbin/afpd
            cnid_metad:	/usr/local/sbin/cnid_metad
              afp.conf:	/usr/local/etc/afp.conf
    netatalk lock file:	/var/lock/netatalk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="配置">配置 </span></h3><h4><span id="配置文件"> 配置文件</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> /usr/local/etc/afp.conf  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>想深入了解配置请参考 <a href="http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html"> 官方文档</a>。</p>
<pre class="line-numbers language-config" data-language="config"><code class="language-config">[Global]  
mimic model &#x3D; AirPort               #指定在 macOS 的 Finder 显示的图标  
log level &#x3D; default:warn  
log file &#x3D; &#x2F;var&#x2F;log&#x2F;afpd.log  
hosts allow &#x3D; 192.168.50.0&#x2F;24       #子网 允许访问的主机地址, 根据需要自行修改  
hostname &#x3D; M-AFP             		#主机名 随意设置
uam list &#x3D; uams_dhx.so uams_dhx2.so #默认认证方式 用户名密码登录 参看官方文档  

[Homes]  
basedir regex &#x3D; &#x2F;home               #用户的 Home 目录  

[TimeMachine]  
path &#x3D; &#x2F;mnt&#x2F;TimeMachine             #数据目录  
time machine &#x3D; yes                  #yes 才支持 TimeMachine  
spotlight &#x3D; no                      #关闭 spotlight 索引  
vol size limit &#x3D; 155000             #限制 TimeMachine 存储容量，单位为 MB

;[Files]  							# ; 注释
;path &#x3D; &#x2F;mnt&#x2F;files                  #设置普通 afp 目录
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="权限设置">权限设置 </span></h4><p> 创建一个新用户，用于访问 AFP 服务</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">useradd</span> afp    <span class="token comment"># 创建新用户 afp  </span>
$ paaswd afp     <span class="token comment"># 修改 afp 用户密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="avahi-配置安装">Avahi 配置安装</span></h2><p>Avahi 是一个开源项目，用于让 mac 在局域网自动发现 Linux AFP 服务器，具体可参看项目地址<a href="https://github.com/lathiat/avahi。">https://github.com/lathiat/avahi。</a></p>
<h3><span id="安装">安装 </span></h3><p> 这个简单，直接 yum 就行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> avahi -y  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="配置">配置 </span></h3><p> 配置文件位置在 <code>/etc/avahi/services/afpd.service</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> /etc/avahi/services/afpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改为以下内容</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" standalone='no'?></span>   
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">service-group</span> <span class="token name">SYSTEM</span> <span class="token string">"avahi-service.dtd"</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service-group</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span> <span class="token attr-name">replace-wildcards</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DUKE-NAS-AFP<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>_afpovertcp._tcp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>548<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>_device-info._tcp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>txt-record</span><span class="token punctuation">></span></span>model=Xserve<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>txt-record</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service-group</span><span class="token punctuation">></span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="服务启动">服务启动</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl start avahi-daemon  
$ <span class="token function">sudo</span> systemctl start netatalk  
$ <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> avahi-daemon  
$ <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> netatalk  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看 netatalk 和 avahi 端口是否启动监听, afp 监听 548 端口 <br> 请注意 Linux 防火墙问题，将对应端口放行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">netstat</span> -tulpn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此， netatalk 部署完成。</p>
<h2><span id="参考">参考</span></h2><ol>
<li><a href="http://netatalk.sourceforge.net/wiki/index.php/Install_Netatalk_3.1.11_on_Ubuntu_18.04_Bionic">Install Netatalk 3.1.11 on Ubuntu 18.04 Bionic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Zero-configuration_networking">Zero-configuration networking</a></li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 docker 容器方式搭建 gitlab 服务</title>
    <url>/2017/02/17/Linux/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%90%AD%E5%BB%BAgitlab%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>一直使用 git 来做项目版本控制，但每次新建项目都要去服务器上操作，比较麻烦，所以选用开源的 gitlab 就相当合适了。</p>
<p>gitlab 的自带组件比较多，例如 redis、postgresql 还有自带的 nginx 等等，中间的坑也很多，综合考量还是选用懒方法 docker 容器来安装。安全、快速。</p>
<p>部署环境为 Ubuntu 18.04 的局域网机器，由于是 Docker 方式部署，理论上各个环境的部署方式都是类似的。</p>
<a id="more"></a>
<h2><span id="环境准备">环境准备 </span></h2><h3><span id="性能要求"> 性能要求 </span></h3><p> 最好是 4GB 内存以上，至少要 2GB 内存，否则卡的你怀疑人生。</p>
<h3><span id="安装-docker">安装 Docker</span></h3><p>我们从阿里源安装。</p>
<p>安装必要的一些系统工具</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt-get</span> update
$ <span class="token function">apt-get</span> -y <span class="token function">install</span> apt-transport-https ca-certificates <span class="token function">curl</span> software-properties-common<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安装 GPG 证书</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 写入软件源信息</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ add-apt-repository <span class="token string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="token variable"><span class="token variable">$(</span>lsb_release -cs<span class="token variable">)</span></span> stable"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更新并安装 Docker-CE</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt-get</span> -y update
$ <span class="token function">apt-get</span> -y <span class="token function">install</span> docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>安装好之后，来看看 Docker 的版本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker version
Client:
 Version:           <span class="token number">18.06</span>.1-ce
 API version:       <span class="token number">1.38</span>
 Go version:        go1.10.3
 Git commit:        e68fc7a
 Built:             Tue Aug <span class="token number">21</span> <span class="token number">17</span>:24:51 <span class="token number">2018</span>
 OS/Arch:           linux/amd64
 Experimental:      <span class="token boolean">false</span>

Server:
 Engine:
  Version:          <span class="token number">18.06</span>.1-ce
  API version:      <span class="token number">1.38</span> <span class="token punctuation">(</span>minimum version <span class="token number">1.12</span><span class="token punctuation">)</span>
  Go version:       go1.10.3
  Git commit:       e68fc7a
  Built:            Tue Aug <span class="token number">21</span> <span class="token number">17</span>:23:15 <span class="token number">2018</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="安装-gitlab-ce">安装 gitlab-ce</span></h2><h3><span id="镜像拉取">镜像拉取</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull gitlab-ce <span class="token comment"># 大约 1.5GB 耐心等待</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="容器创建">容器创建</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d <span class="token punctuation">\</span>
--hostname gitlab.maywzh.com <span class="token punctuation">\</span> 	  <span class="token comment"># 指定容器域名, 未知功能: 创建镜像仓库的时候使用到</span>
-p <span class="token number">8880</span>:80 <span class="token punctuation">\</span>                        	  <span class="token comment"># 将容器内 80 端口映射到主机 8880, 提供 http 服务</span>
-p <span class="token number">8222</span>:22 <span class="token punctuation">\</span>                        	  <span class="token comment"># 将容器内 22 端口映射到主机 8222, 提供 ssh 服务</span>
-p <span class="token number">9090</span>:9090 <span class="token punctuation">\</span>                            <span class="token comment"># 将容器内 9090 端口映射到主机 9090, 提供 prometheus 服务</span>
--name gitlab <span class="token punctuation">\</span>                           <span class="token comment"># 指定容器名称</span>
--restart always <span class="token punctuation">\</span>                        <span class="token comment"># 容器退出时, 自动重启</span>
-v /srv/gitlab/config:/etc/gitlab <span class="token punctuation">\</span>       <span class="token comment"># 将本地 /srv/gitlab/config 挂载到容器内 /etc/gitlab</span>
-v /srv/gitlab/logs:/var/log/gitlab <span class="token punctuation">\</span>     <span class="token comment"># 将本地 /srv/gitlab/logs 挂载到容器内 /var/log/gitlab</span>
-v /srv/gitlab/data:/var/opt/gitlab <span class="token punctuation">\</span>     <span class="token comment"># 将本地 /srv/gitlab/data 挂载到容器内 /var/opt/gitlab</span>
gitlab/gitlab-ce:latest                   <span class="token comment"># 镜像名称: 版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看容器运行状况</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker inspect gitlab --format <span class="token string">"&#123;&#123;.State.Status&#125;&#125;"</span>
running <span class="token comment"># 表示正常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="配置">配置 </span></h2><p> 我们把 docker 容器的 gitlab 配置目录挂载在本地的 <code>/srv/gitlab/</code> 中。所以，需要改动这里的配置文件。</p>
<p>先备份<code>gitlab.rb</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /srv/gitlab/config      
$ <span class="token function">cp</span> gitlab.rb gitlab.rb.default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="配置文件示例">配置文件示例</span></h3><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment">### gitlab.rb 把以下内容加在原 gitlab.rb 的最下面 有些配置项需要视情况改动</span>
<span class="token comment">## 域名设置 这个影响 git clone 的地址</span>
external_url <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>maywzh<span class="token punctuation">.</span>com
<span class="token comment">## gitlab 镜像自带 nginx 配置</span>
nginx<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
nginx<span class="token punctuation">[</span><span class="token string">'client_max_body_size'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'250m'</span>
nginx<span class="token punctuation">[</span><span class="token string">'redirect_http_to_https'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
nginx<span class="token punctuation">[</span><span class="token string">'listen_addresses'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> <span class="token string">'[::]'</span><span class="token punctuation">]</span>
nginx<span class="token punctuation">[</span><span class="token string">'listen_port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">80</span>
nginx<span class="token punctuation">[</span><span class="token string">'listen_https'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
nginx<span class="token punctuation">[</span><span class="token string">'custom_gitlab_server_config'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"location ^~ /foo-namespace/bar-project/raw/ &#123;\n deny all;\n&#125;\n"</span>
nginx<span class="token punctuation">[</span><span class="token string">'custom_nginx_config'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"include /etc/nginx/conf.d/*.conf;"</span>
nginx<span class="token punctuation">[</span><span class="token string">'proxy_read_timeout'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3600</span>
nginx<span class="token punctuation">[</span><span class="token string">'proxy_connect_timeout'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">300</span>
nginx<span class="token punctuation">[</span><span class="token string">'proxy_set_headers'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
 <span class="token string">"Host"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"$http_host_with_default"</span><span class="token punctuation">,</span>
 <span class="token string">"X-Real-IP"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"$remote_addr"</span><span class="token punctuation">,</span>
 <span class="token string">"X-Forwarded-For"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"$proxy_add_x_forwarded_for"</span><span class="token punctuation">,</span>
 <span class="token string">"Upgrade"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"$http_upgrade"</span><span class="token punctuation">,</span>
 <span class="token string">"Connection"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"$connection_upgrade"</span>
<span class="token punctuation">&#125;</span>
nginx<span class="token punctuation">[</span><span class="token string">'proxy_cache_path'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'proxy_cache keys_zone=gitlab:10m max_size=1g levels=1:2'</span>
nginx<span class="token punctuation">[</span><span class="token string">'proxy_cache'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'gitlab'</span>
nginx<span class="token punctuation">[</span><span class="token string">'http2_enabled'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment"># nginx['real_ip_trusted_addresses'] = ['172.16.0.0/16'] #需要改动</span>
nginx<span class="token punctuation">[</span><span class="token string">'real_ip_header'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X-Real-IP'</span>
nginx<span class="token punctuation">[</span><span class="token string">'real_ip_recursive'</span><span class="token punctuation">]</span> <span class="token operator">=</span> on
nginx<span class="token punctuation">[</span><span class="token string">'custom_error_pages'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token string">'404'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token string">'title'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Example title'</span><span class="token punctuation">,</span>
    <span class="token string">'header'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Example header'</span><span class="token punctuation">,</span>
    <span class="token string">'message'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Example message'</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
nginx<span class="token punctuation">[</span><span class="token string">'dir'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"/var/opt/gitlab/nginx"</span>
nginx<span class="token punctuation">[</span><span class="token string">'log_directory'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"/var/log/gitlab/nginx"</span>
nginx<span class="token punctuation">[</span><span class="token string">'worker_processes'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
nginx<span class="token punctuation">[</span><span class="token string">'worker_connections'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10240</span>
nginx<span class="token punctuation">[</span><span class="token string">'log_format'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'$remote_addr - $remote_user [$time_local]"$request"$status $body_bytes_sent"$http_referer""$http_user_agent"'</span>
nginx<span class="token punctuation">[</span><span class="token string">'sendfile'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'on'</span>
nginx<span class="token punctuation">[</span><span class="token string">'tcp_nopush'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'on'</span>
nginx<span class="token punctuation">[</span><span class="token string">'tcp_nodelay'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'on'</span>
nginx<span class="token punctuation">[</span><span class="token string">'gzip'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"on"</span>
nginx<span class="token punctuation">[</span><span class="token string">'gzip_http_version'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1.0"</span>
nginx<span class="token punctuation">[</span><span class="token string">'gzip_comp_level'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"2"</span>
nginx<span class="token punctuation">[</span><span class="token string">'gzip_proxied'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"any"</span>
nginx<span class="token punctuation">[</span><span class="token string">'gzip_types'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">"text/plain"</span><span class="token punctuation">,</span> <span class="token string">"text/css"</span><span class="token punctuation">,</span> <span class="token string">"application/x-javascript"</span><span class="token punctuation">,</span> <span class="token string">"text/xml"</span><span class="token punctuation">,</span> <span class="token string">"application/xml"</span><span class="token punctuation">,</span> <span class="token string">"application/xml+rss"</span><span class="token punctuation">,</span> <span class="token string">"text/javascript"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span> <span class="token punctuation">]</span>
nginx<span class="token punctuation">[</span><span class="token string">'keepalive_timeout'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">65</span>
nginx<span class="token punctuation">[</span><span class="token string">'cache_max_size'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'5000m'</span>
nginx<span class="token punctuation">[</span><span class="token string">'server_names_hash_bucket_size'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">64</span>
nginx<span class="token punctuation">[</span><span class="token string">'status'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
 <span class="token string">"enable"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">## 邮件服务 以 qq 邮箱为例 需要改动</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'time_zone'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Asia/Shanghai'</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_address'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"smtp.qq.com"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">465</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xxxxxx@qq.com"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span> <span class="token comment">#qq 邮箱的独立密码</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_domain'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"smtp.qq.com"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_authentication'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">:</span>plain
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable_starttls_auto'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_email_from'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xxxxxx@qq.com"</span>
<span class="token keyword">user</span><span class="token punctuation">[</span><span class="token string">'git_user_email'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xxxxxx@qq.com"</span>
<span class="token keyword">user</span><span class="token punctuation">[</span><span class="token string">'git_user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"gitlab"</span>

<span class="token comment">## gitlab 自带 Postgresql 配置</span>
postgresql<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
postgresql<span class="token punctuation">[</span><span class="token string">'ssl'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'off'</span>

<span class="token comment">## gitlab 自带 Redis 配置</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'redis_host'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'redis_port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6379</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'redis_password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0340fg2340jk342302342l'</span> <span class="token comment"># 需要改动</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'redis_database'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
redis<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
redis<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"gitlab-redis"</span>
redis<span class="token punctuation">[</span><span class="token string">'maxclients'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"10000"</span>
redis<span class="token punctuation">[</span><span class="token string">'maxmemory'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1gb"</span>
redis<span class="token punctuation">[</span><span class="token string">'maxmemory_policy'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"allkeys-lru"</span>
redis<span class="token punctuation">[</span><span class="token string">'maxmemory_samples'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"5"</span>
redis<span class="token punctuation">[</span><span class="token string">'tcp_timeout'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"60"</span>
redis<span class="token punctuation">[</span><span class="token string">'tcp_keepalive'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"300"</span>
redis<span class="token punctuation">[</span><span class="token string">'port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6379</span>
redis<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0340fg2340jk342302342l'</span> <span class="token comment"># 需要改动</span>

<span class="token comment">## gitlab 备份路径</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'manage_backup_path'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'backup_path'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"/var/opt/gitlab/backups"</span>

<span class="token comment">## 监控 Prometheus 配置</span>
prometheus<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
prometheus<span class="token punctuation">[</span><span class="token string">'monitor_kubernetes'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
prometheus<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'gitlab-prometheus'</span>
prometheus<span class="token punctuation">[</span><span class="token string">'uid'</span><span class="token punctuation">]</span> <span class="token operator">=</span> nil
prometheus<span class="token punctuation">[</span><span class="token string">'gid'</span><span class="token punctuation">]</span> <span class="token operator">=</span> nil
prometheus<span class="token punctuation">[</span><span class="token string">'shell'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'/bin/sh'</span>
prometheus<span class="token punctuation">[</span><span class="token string">'home'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'/var/opt/gitlab/prometheus'</span>
prometheus<span class="token punctuation">[</span><span class="token string">'log_directory'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'/var/log/gitlab/prometheus'</span>
prometheus<span class="token punctuation">[</span><span class="token string">'scrape_interval'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span>
prometheus<span class="token punctuation">[</span><span class="token string">'scrape_timeout'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span>
prometheus<span class="token punctuation">[</span><span class="token string">'chunk_encoding_version'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
prometheus<span class="token punctuation">[</span><span class="token string">'listen_address'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0.0.0.0:9090'</span>
prometheus_monitoring<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
node_exporter<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
redis_exporter<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
redis_exporter<span class="token punctuation">[</span><span class="token string">'log_directory'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'/var/log/gitlab/redis-exporter'</span>
redis_exporter<span class="token punctuation">[</span><span class="token string">'flags'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token string">'redis.addr'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"127.0.0.1:6379"</span><span class="token punctuation">,</span>
  <span class="token string">'redis.password'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'0340fg2340jk342302342l'</span> <span class="token comment"># 需要改动</span>
<span class="token punctuation">&#125;</span>
postgres_exporter<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_monitor<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>                                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改好配置文件后，重载配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -t gitlab gitlab-ctl reconfigure
$ docker <span class="token builtin class-name">exec</span> -t gitlab gitlab-ctl restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="nginx-反向代理">nginx 反向代理 </span></h3><p> 由于容器内部的 http 服务端口是 8880，为了能够直接输入域名来访问，需要设置 nginx 反向代理代理容器内部的 nginx 服务。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/nginx/conf.d/gitlab.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改<code>/etc/nginx/conf.d/gitlab.conf</code></p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span>
<span class="token punctuation">&#123;</span> 
    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">server_name</span> gitlab<span class="token punctuation">.</span>maywzh<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

    <span class="token keyword">location</span> <span class="token operator">/</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>
        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>
        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>
        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8880</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改<code>/etc/nginx/nginx.conf</code></p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">http</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">include</span> <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token punctuation">.</span>d<span class="token operator">/</span>gitlab<span class="token punctuation">.</span>conf<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重启 nginx<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<p>这样就部署完成了～</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑记之 zsh 不兼容通配符查找</title>
    <url>/2017/09/01/Linux/%E8%B8%A9%E5%9D%91%E8%AE%B0%E4%B9%8Bzsh%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p> 这是在进行 certbot 通配符 ssl 证书申请时候发生的坑。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">certbot certonly --nginx --preferred-challenges dns --manual  -d *.maywzh.com --server https://acme-v02.api.letsencrypt.org/directory
zsh: no matches found: *.maywzh.com
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 后来发现，在 zsh 下使用 find 命令查找指定目录下所有头文件时也出现问题：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">find . -name *.h

no matches <span class="token property">found</span><span class="token punctuation">:</span> *.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 后来查看了一些资料才知道，这是由于 zsh 导致的。</p>
<a id="more"></a>
<p> 具体原因：</p>
<p> 因为 zsh 缺省情况下始终自己解释这个 *.h，而不会传递给 find 来解释。</p>
<p> 解决办法：</p>
<p> 在~/.zshrc 中加入:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setopt no_nomatch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 然后运行 </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 然后恢复正常 </p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中的 select、poll、epoll 机制</title>
    <url>/2018/01/29/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程。与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程 / 线程，也不必维护这些进程 / 线程，从而大大减小了系统的开销。</p>
<p>目前支持 I/O 多路复用的系统调用有 select，pselect，poll，epoll，I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，但 select，pselect，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。</p>
<a id="more"></a>
<p>IO 多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用 I/O 复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个 TCP 服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用。</li>
<li>如果一个服务器即要处理 TCP，又要处理 UDP，一般要使用 I/O 复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用。</li>
</ol>
<h2><span id="从-c10k-引述-select-poll-epoll">从 C10k 引述 select、poll、epoll</span></h2><h3><span id="c10k-问题">C10k 问题 </span></h3><p> 随着互联网的普及，应用的用户群体几何倍增长，此时服务器性能问题就出现。最初的服务器是基于进程 / 线程模型。新到来一个 TCP 连接，就需要分配一个进程。假如有 C10K，就需要创建 1W 个进程，可想而知单机是无法承受的。那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为 C10K 问题，最早是由 Dan Kegel 进行归纳和总结的，并且他也系统的分析和提出解决方案。</p>
<p>C10K 问题的本质上是操作系统的问题。对于 Web 1.0/2.0 时代的操作系统，传统的同步阻塞 I/O 模型处理方式都是 requests per second。当创建的进程或线程多了，数据拷贝频繁（缓存 I/O、内核将数据拷贝到用户进程空间、阻塞，进程 / 线程上下文切换消耗大， 导致操作系统崩溃，这就是 C10K 问题的本质。</p>
<p>可见, 解决 C10K 问题的关键就是尽可能减少这些 CPU 资源消耗。</p>
<h4><span id="解决方案">解决方案 </span></h4><p> 从网络编程技术的角度来说，主要思路：</p>
<ol>
<li>每个连接分配一个独立的线程 / 进程</li>
<li>同一个线程 / 进程同时处理多个连接</li>
</ol>
<h4><span id="每个进程-线程处理一个连接">每个进程 / 线程处理一个连接 </span></h4><p> 该思路最为直接，但是申请进程 / 线程是需要系统资源的，且系统需要管理这些进程 / 线程，所以会使资源占用过多，可扩展性差</p>
<h4><span id="每个进程-线程同时处理-多个连接io-多路复用"> 每个进程 / 线程同时处理 多个连接(I/O 多路复用)</span></h4><ol>
<li><strong>select 方式</strong>：使用 fd_set 结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化 fd_set。</li>
<li><strong>poll 方式 </strong>：该方式主要解决了 select 方式的 2 个缺点，文件句柄上限问题(链表方式存储) 以及重复初始化问题(不同字段标注关注事件和发生事件)，但是逐个去检查文件句柄是否就绪的问题仍然没有解决。</li>
<li><strong>epoll 方式</strong>：该方式可以说是 C10K 问题的 killer，他不去轮询监听所有文件句柄是否已经就绪。epoll 只对发生变化的文件句柄感兴趣。其工作机制是，使用”事件”的就绪通知方式，通过 epoll_ctl 注册文件描述符 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd, epoll_wait 便可以收到通知, 并通知应用程序。而且 epoll 使用一个文件描述符管理多个描述符, 将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且 epoll 是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是 epoll 是依赖系统的(Linux)。</li>
<li><strong>异步 I/O</strong>以及 Windows，该方式在 windows 上支持很好。</li>
</ol>
<h4><span id="传统思路">传统思路 </span></h4><p> 最简单的方法是循环挨个处理各个连接，每个连接对应一个 socket，当所有 socket 都有数据的时候，这种方法是可行的。</p>
<p>但是当应用读取某个 socket 的文件数据不 ready 的时候，整个应用会阻塞在这里等待该文件句柄，即使别的文件句柄 ready，也无法往下处理。</p>
<p><strong>思路</strong>：直接循环处理多个连接。</p>
<p><strong>问题</strong>：任一文件句柄的不成功会阻塞住整个应用。</p>
<h3><span id="select">select</span></h3><p>要解决上面阻塞的问题，思路很简单，如果我在读取文件句柄之前，先查下它的状态，ready 了就进行处理，不 ready 就不进行处理，这不就解决了这个问题了嘛？</p>
<p>于是有了 select 方案。用一个 fd_set 结构体来告诉内核同时监控多个文件句柄，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回。之后应用可以使用 <code>FD_ISSET</code> 来逐个查看是哪个文件句柄的状态发生了变化。</p>
<p>这样做，小规模的连接问题不大，但当连接数很多（文件句柄个数很多）的时候，逐个检查状态就很慢了。因此，select 往往存在管理的句柄上限（<code>FD_SETSIZE</code>）。同时，在使用上，因为只有一个字段记录关注和发生事件，每次调用之前要重新初始化 <code>fd_set</code> 结构体。</p>
<blockquote>
<p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/29/ubzW8CDimwPQrA4.png" alt="21155028_QOj2"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>思路</strong>：有连接请求抵达了再检查处理。</p>
<p><strong>问题</strong>：句柄上限 + 重复初始化 + 逐个排查所有文件句柄状态效率不高。</p>
<h4><span id="工作过程">工作过程 </span></h4><p> 一个典型的用户应用调用 select 机制请求数据过程：</p>
<ol>
<li><p>使用 <code>copy_from_user</code> 从用户空间拷贝 fd_set 到内核空间</p>
</li>
<li><p>注册回调函数<code>__pollwait</code></p>
</li>
<li><p>遍历所有 fd，调用其对应的 poll 方法（对于 socket，这个 poll 方法是 <code>sock_poll</code>，<code>sock_poll</code> 根据情况会调用到 <code>tcp_poll</code>,<code>udp_poll</code> 或者<code>datagram_poll</code>）</p>
</li>
<li><p>以 <code>tcp_poll</code> 为例，其核心实现就是<code>__pollwait</code>，也就是上面注册的回调函数。</p>
</li>
<li><p><code>__pollwait</code>的主要工作就是把 current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于 tcp_poll 来说，其等待队列是 sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒了。</p>
</li>
<li><p><code>poll</code>方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值。</p>
</li>
<li><p>如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout 是调用 select 的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（<code>schedule_timeout</code>指定），还是没人唤醒，则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd。</p>
</li>
<li><p>把 <code>fd_set</code> 从内核空间拷贝到用户空间。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/08/29/JWBwCQ1XHP8mpld.png" alt="137084-20180611142415772-1018872947"></p>
<h3><span id="poll">poll</span></h3><p>poll 主要解决 select 的前两个问题：通过一个 pollfd 数组向内核传递需要关注的事件消除文件句柄上限，同时使用不同字段分别标注关注事件和发生事件，来避免重复初始化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_t nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>思路</strong>：设计新的数据结构提供使用效率。</p>
<p><strong>问题</strong>：逐个排查所有文件句柄状态效率不高。</p>
<h3><span id="epoll">epoll</span></h3><p>既然逐个排查所有文件句柄状态效率不高，很自然的，如果调用返回的时候只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄，进行排查的效率不就高多了么。</p>
<p>epoll 采用了这种设计，适用于大规模的应用场景。</p>
<p>实验表明，当文件句柄数目超过 10 之后，epoll 性能将优于 select 和 poll；当文件句柄数目达到 10K 的时候，epoll 已经超过 select 和 poll 两个数量级。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>思路</strong>：只返回状态变化的文件句柄。</p>
<p><strong>问题</strong>：依赖特定平台（Linux）。</p>
<p>因为 Linux 是互联网企业中使用率最高的操作系统，epoll 就成为 C10K killer、高并发、高性能、异步非阻塞这些技术的代名词了。FreeBSD 推出了<code>kqueue</code>，Linux 推出了<code>epoll</code>，Windows 推出了<code>IOCP</code>，Solaris 推出了<code>/dev/poll</code>。这些操作系统提供的功能就是为了解决 C10K 问题。epoll 技术的编程模型就是异步非阻塞回调，也可以叫做<code>Reactor</code>，事件驱动，事件轮循（EventLoop）。Nginx，libevent，node.js 这些就是 Epoll 时代的产物。</p>
<h3><span id="libevent">libevent</span></h3><p>由于 epoll, kqueue, IOCP 每个接口都有自己的特点，程序移植非常困难，于是需要对这些接口进行封装，以让它们易于使用和移植，其中 libevent 库就是其中之一。跨平台，封装底层平台的调用，提供统一的 API，但底层在不同平台上自动选择合适的调用。</p>
<p>按照 libevent 的官方网站，libevent 库提供了以下功能：当一个文件描述符的特定事件（如可读，可写或出错）发生了，或一个定时事件发生了，libevent 就会自动执行用户指定的回调函数，来处理事件。目前，libevent 已支持以下接口 /dev/poll, kqueue, event ports, select, poll 和 epoll。Libevent 的内部事件机制完全是基于所使用的接口的。因此 libevent 非常容易移植，也使它的扩展性非常容易。目前，libevent 已在以下操作系统中编译通过：Linux，BSD，Mac OS X，Solaris 和 Windows。</p>
<p>使用 libevent 库进行开发非常简单，也很容易在各种 unix 平台上移植。一个简单的使用 libevent 库的程序如下：</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的编译、链接和装入</title>
    <url>/2017/10/13/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E5%85%A5%20/</url>
    <content><![CDATA[<p>在多道程序环境下，要使程序运行，必须先为之创建进程。而创建进程的第一件事，便是将程序和数据装入内存。如何将一个用户源程序变为一个可在内存中执行的程序，通常都要经过以下几个步骤：</p>
<p>编译、链接和装入。</p>
<p><img src="https://i.loli.net/2020/08/24/Ns5epoAd6GafEyX.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTEvMTM0OTkzNjcyMF80NzYzLmpwZw"></p>
<a id="more"></a>
<h2><span id="程序从编译到运行过程">程序从编译到运行过程 </span></h2><h3><span id="编译"> 编译 </span></h3><p> 编译：源程序 -&gt; 目标模块（Object modules）————Compiler</p>
<p>由编译程序 (Compiler) 将用户源代码编译成 cpu 可执行的目标代码，产生了若干个目标模块(Object Module)（即若干程序段）。形成的目标代码，每个目标代码都是以 0 为基址顺序进行编址，原来用符号名访问的单元用具体的数据——单元号取代。这样生成的目标程序占据一定的地址空间，称为作业的逻辑地址空间，简称逻辑空间。</p>
<p>在逻辑空间中每条指令的地址和指令中要访问的操作数地址统称为 <strong> 逻辑地址 </strong> 。很简单，<strong> 逻辑地址 </strong> 就是你源程序里使用的地址，或者源代码经过编译以后编译器将一些标号，变量转换成的地址。</p>
<h3><span id="链接">链接 </span></h3><p> 链接：一组目标模块 -&gt; 装入模块 （Load Module）—————Linker</p>
<p>由链接程序 (Linker) 将编译后形成的一组目标模块（程序段），以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)；</p>
<h3><span id="装入">装入 </span></h3><p> 装入：装入模块 -&gt; 内存  ————Loader</p>
<p>由装入程序 (Loader) 将装入模块装入 <strong> 物理内存 </strong>。<strong> 物理内存 </strong> 是真实存在的插在主板内存槽上的内存条的容量的大小。</p>
<p><strong>物理内存 </strong> 内存是由若干个存储单元组成的，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，称为 <strong> 内存地址（或物理地址）。</strong>我们可以把内存看成一个从 0 字节一直到内存最大容量逐字节编号的存储单元数组，即每个存储单元与内存地址的编号相对应。</p>
<p>装入模块虽然具有统一的地址空间，但它仍是以“0”作为参考地址，即是浮动的。要把它装入内存执行，就要确定装入内存的 <strong> 实际物理地址 </strong>，并修改程序中与 地址有关的代码，这一过程叫<strong> 做地址重定位</strong>。地址重定位主要是把逻辑地址转换成物理内存绝对地址，这个工作又称为地址映射。</p>
<h2><span id="程序的链接">程序的链接 </span></h2><p> 源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。根据链接时间的不同，可把链接分成如下三种：</p>
<ol>
<li>静态链接。在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。</li>
<li>装入时动态链接。这是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</li>
<li>运行时动态链接。这是指对某些目标模块的链接，是在程序执行中需要该 (目标) 模块时，才对它进行的链接。</li>
</ol>
<h3><span id="静态链接方式-static-linking">静态链接方式 Static Linking</span></h3><p>我们通过一个例子来说明在实现静态链接时应解决的一些问题。下图中，经过编译后所得到的三个目标模块 A、B、C，它们的长度分别为 L、M 和 N。在模块 A 中有一条语句 CALL B，用于调用模块 B。在模块 B 中有一条语句 CALL C，用于调用模块 C。B 和 C 都属于外部调用符号，在将这几个目标模块装配成一个装入模块时，须解决以下两个问题：</p>
<ol>
<li>对相对地址进行修改。在由编译程序所产生的所有目标模块中，使用的都是相对地址，其起始地址都为 0，每个模块中的地址都是相对于起始地址计算的。在链接成一个装入模块后，原模块 B 和 C 在装入模块的起始地址不再是 0，而分别是 L 和 L+M，所以此时须修改模块 B 和 C 中的相对地址，即把原 B 中的所有相对地址都加上 L，把原 C 中的所有相对地址都加上 L+M。 </li>
<li>变换外部调用符号。将每个模块中所用的外部调用符号也都变换为相对地址，如把 B 的起始地址变换为 L，把 C 的起始地址变换为 L+M，如图 4-4(b)所示。这种先进行链接所形成的一个完整的装入模块，又称为可执行文件。通常都不再拆开它，要运行时可直接将它装入内存。这种事先进行链接，以后不再拆开的链接方式，称为静态链接方式。</li>
</ol>
<p><img src="https://i.loli.net/2020/08/24/cN7RFWCGxUlyv1P.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTEvMTM0OTkzODE4Ml83MzIxLmpwZw"></p>
<h3><span id="装入时动态链接-load-time-dynamic-linking">装入时动态链接 Load-time Dynamic Linking</span></h3><p>用户源程序经编译后所得的目标模块，是在装入内存时边装入边链接的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要按照图 4-4 所示的方式来修改目标模块中的相对地址。装入时动态链接方式有以下优点：</p>
<ol>
<li>便于修改和更新。对于经静态链接装配在一起的装入模块，如果要修改或更新其中的某个目标模块，则要求重新打开装入模块。这不仅是低效的，而且有时是不可能的。若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目标模块是件非常容易的事。</li>
<li>便于实现对目标模块的共享。在采用静态链接方式时，每个应用模块都必须含有其目标模块的拷贝，无法实现对目标模块的共享。但采用装入时动态链接方式，OS 则很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。</li>
</ol>
<h3><span id="运行时动态链接-runtime-dynamic-linking">运行时动态链接 Runtime Dynamic Linking</span></h3><p>动态链接是虚拟存储的基础。在许多情况下，应用程序在运行时，每次要运行的模块可能是不相同的。但由于事先无法知道本次要运行哪些模块，故只能是将所有可能要运行到的模块都全部装入内存，并在装入时全部链接在一起。显然这是低效的，因为往往会有些目标模块根本就不运行。比较典型的例子是作为错误处理用的目标模块，如果程序在整个运行过程中都不出现错误，则显然就不会用到该模块。运行时动态链接这种链接方式是将对某些模块的链接推迟到程序执行时才进行链接，亦即，在执行过程中，当发现一个被调用模块尚未装入内存时，立即由 OS 去找到该模块并将之装入内存，把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p>
<h2><span id="程序装入">程序装入 </span></h2><p> 为了阐述上的方便，我们先介绍一个无需进行链接的单个目标模块的装入过程。该目标模块也就是装入模块。在将一个装入模块装入内存时，可以有绝对装入方式、可重定位装入方式和动态运行时装入方式，下面分别简述之。</p>
<h3><span id="绝对装入模式-absolute-loading-mode">绝对装入模式 Absolute Loading Mode</span></h3><p>在编译时，如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。即按照物理内存的位置赋予实际的物理地址。例如，事先已知用户程序（进程）驻留在从 R 处开始的位置，则编译程序所产生的目标模块（即装入模块）便从 R 处开始向上扩展。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不须对程序和数据的地址进行修改。程序中所使用的绝对地址，既可在编译或汇编时给出，也可由程序员直接赋予。</p>
<p>这个方式的优点是 CPU 执行目标代码快。缺点有二：一是由于内存大小限制，能装入内存并发执行的进程数大大减少，二是编译程序必须知道内存的当前空闲地址部分和其地址，并且把进程的不同程序段连续地存放起来，编译非常复杂。</p>
<p>因此，通常是宁可在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。</p>
<p>把虚拟内存地址空间变换到内存唯一的一维物理线性空间？涉及到两个问题：一是虚拟空间的划分问题，二是把虚拟空间中已经链接和划分好的内容装入内存，并将虚拟空间地址映射内存地址的问题。即地址映射。映射就是建立虚拟地址与内存地址的关系。</p>
<h3><span id="静态地址重定位-relocation-loading-mode">静态地址重定位 Relocation Loading Mode</span></h3><p>绝对装入方式只能将目标模块装入到内存中事先指定的位置。在多道程序环境下，编译程序不可能预知所编译的目标模块应放在内存的何处，因此，<strong>绝对装入方式只适用于单道程序环境</strong>。在多道程序环境下，所得到的目标模块的起始地址通常是从 0 开始的，程序中的其它地址也都是相对于起始地址计算的。此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。 </p>
<p><strong>静态地址重定位 </strong>：即在程序装入对目标代码装入内存的过程中完成，是指在程序开始运行前，程序中<strong> 指令和数据 </strong> 的各个地址均已完成重定位，即完成虚拟地址到内存地址映射。地址变换通常是在装入时一次完成的，以后不再改变。</p>
<p>值得注意的是， 在采用可重定位 <strong> 装入程序 </strong> 将装入模块装入内存后， 会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同，下图表示了这一情况。</p>
<p><img src="https://i.loli.net/2020/08/24/QPvraXxkWZ8fdq9.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTEvMTM0OTkzNjY4N185NDQxLmpwZw"></p>
<p>在用户程序的 1000 号单元处有一条指令 LOAD 1，2500，该指令的功能是将 2500 单元中的整数 365 取至寄存器 1。但若将该用户程序装入到内存的 10000～15000 号单元而不进行地址变换， 则在执行 11000 号单元中的指令时，它将仍从 2500 号单元中把数据取至寄存器 1 而导致数据错误。由图 4-3 可见，正确的方法应该是将取数指令中的地址 2500 修改成 12500，即把指令中的相对地址 2500 与本程序在内存中的起始地址 10000 相加，才得到正确的物理地址 12500。除了数据地址应修改外，指令地址也须做同样的修改，即将指令的相对地址 1000 与起始地址 10000 相加，得到绝对地址 11000。</p>
<p><strong>优点：</strong>无需硬件支持</p>
<p><strong>缺点：</strong></p>
<ol>
<li>程序重定位之后就不能在内存中搬动了；</li>
<li>要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域中。</li>
</ol>
<h3><span id="动态运行时装入方式-dynamic-run-time-loading">动态运行时装入方式 Dynamic Run-time Loading</span></h3><p>可重定位装入方式可将装入模块装入到内存中任何允许的位置，故可用于多道程序环境；但这种方式并不允许程序运行时在内存中移动位置。因为，程序在内存中的移动，意味着它的物理位置发生了变化， 这时必须对程序和数据的地址 (是绝对地址) 进行修改后方能运行。然而，实际情况是，在运行过程中它在内存中的位置可能经常要改变，此时就应采用动态运行时装入的方式。</p>
<p>   <strong>动态地址重定位：</strong>不是在程序执行之前而是在程序执行过程中进行地址变换。更确切的说，是把这种地址转换推迟到程序真正要执行时才进行，即在每次访问内存单元前才将要访问的程序或数据地址变换成内存地址。动态重定位可使装配模块不加任何修改而装入内存。为使地址转换不影响指令的执行速度，这种方式需要一个重定位寄存器的支持，</p>
<p><strong>优点</strong>：</p>
<ol>
<li>目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的；</li>
<li>一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。</li>
</ol>
<p><strong>缺点：</strong>需要硬件支持。</p>
<h2><span id="总结">总结 </span></h2><p> 程序从源程序到装入内存运行分为三步：<strong>编译、链接和装入</strong>。</p>
<p>链接有 <strong> 静态链接、装入时动态链接和运行时动态链接 </strong> 三种方式。</p>
<p>装入有 <strong> 绝对装入、静态地址重定位和动态运行时装入 </strong> 三种方式。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之缺页中断及置换</title>
    <url>/2017/10/16/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%8F%8A%E7%BD%AE%E6%8D%A2/</url>
    <content><![CDATA[<p>缺页中断（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。</p>
<p>通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。</p>
<p>虽然其名为“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用虚拟内存来增加程序可用内存空间的操作系统（比如 Microsoft Windows 和各种类 Unix 系统）中都是常见且有必要的。</p>
<p>微软在较新版 Windows 的资源监视器中使用“硬错误”（Windows Vista 及以上）、“硬中断”（Windows 8 及以上）这一术语来指代“页缺失”。</p>
<a id="more"></a>
<h2><span id="缺页分类">缺页分类 </span></h2><h3><span id="软性页缺失"> 软性页缺失 </span></h3><p> 软性页缺失指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU 注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。</p>
<p>发生这种情况的可能性之一，是一块物理内存被两个或多个程序共享，操作系统已经为其中的一个装载并注册了相应的页，但是没有为另一个程序注册。</p>
<p>可能性之二，是该页已被从 CPU 的工作集中移除，但是尚未被交换到磁盘上。比如 OpenVMS 这样的使用次级页缓存的系统，就有可能会在工作集过大的情况下，将某页从工作集中去除，但是不写入硬盘也不擦除（比如说这一页被读出硬盘后没被修改过），只是放入空闲页表。除非有其他程序需要，导致这一页被分配出去了，不然这一页的内容不会被修改。当原程序再次需要该页内的数据时，如果这一页确实没有被分配出去，那么系统只需要重新为该页在 MMU 内注册映射即可。</p>
<h3><span id="硬性页缺失">硬性页缺失 </span></h3><p> 与软性页缺失相反，硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。这时操作系统需要：</p>
<ol>
<li>寻找到一个空闲的页。或者把另外一个使用中的页写到磁盘上（如果其在最后一次写入后发生了变化的话），并注销在 MMU 内的记录</li>
<li>将数据读入被选定的页</li>
<li>向 MMU 注册该页</li>
</ol>
<p>硬性页缺失导致的性能损失是很大的。以一块 7200rpm 的主流机械硬盘为例，其平均寻道时间为 8.5 毫秒，读入内存需要 0.05 毫秒。相对的，DDR3 内存的访问延迟通常在数十到 100 纳秒之间，性能差距可能会达到 8 万到 22 万倍。</p>
<p>另外，有些操作系统会将程序的一部分延迟到需要使用的时候再加载入内存执行，以此来提升性能。这一特性也是通过捕获硬性页缺失达到的。</p>
<p>当硬性页缺失过于频繁的发生时，称发生 <strong> 系统颠簸</strong>。</p>
<h3><span id="无效页缺失">无效页缺失 </span></h3><p> 当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。一般来说这是个软件问题，但是也不排除硬件可能，比如因为内存故障而损坏了一个正确的指针。</p>
<p>具体动作与所使用的操作系统有关，比如 Windows 会使用异常机制向程序报告，而类 Unix 系统则会使用信号机制。如果程序未处理相关问题，那么操作系统会执行默认处理方式，通常是转储内存、终止相关的程序，然后向用户报告。</p>
<h2><span id="缺页中断">缺页中断 </span></h2><p> 中断是指是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。</p>
<p>对于缺页中断而言：</p>
<p>中断次数 = 进程的物理块数×页面置换次数。</p>
<h3><span id="过程">过程 </span></h3><p> 缺页中断发生时的事件顺序如下：</p>
<ol>
<li>硬件陷入内核，在内核堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的 CPU 寄存器中。</li>
<li>启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。</li>
<li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。</li>
<li>一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。</li>
<li>如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。</li>
<li>一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</li>
<li>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。</li>
<li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。</li>
<li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。</li>
<li>该例程恢复寄存器和其他状态信息</li>
</ol>
<h3><span id="与其他中断区别">与其他中断区别 </span></h3><p> 在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。<br>缺页本身是一种中断，与一般的中断一样，需要经过 4 个处理步骤： </p>
<ol>
<li>保护 CPU 现场 </li>
<li>分析中断原因 </li>
<li>转入缺页中断处理程序进行处理 </li>
<li>恢复 CPU 现场，继续执行 </li>
</ol>
<p>但是缺页中断时由于所要访问的页面不存在于内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别： </p>
<ol>
<li>在指令执行期间产生和处理缺页中断信号 </li>
<li>一条指令在执行期间，可能产生多次缺页中断 </li>
<li>缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</li>
</ol>
<h2><span id="页面置换算法">页面置换算法 </span></h2><p> 进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的页面置换算法（Page Replacement Algorithm)来确定。</p>
<h3><span id="最佳置换optimal-opt">最佳置换（Optimal， OPT)</span></h3><p>置换以后不再被访问，或者在将来最迟才被回访的页面，缺页中断率最低。但是该算法需要依据以后各业的使用情况，而当一个进程还未运行完成是，很难估计哪一个页面是以后不再使用或在最长时间以后才会用到的页面。所以该算法是不能实现的。但该算法仍然有意义，作为很亮其他算法优劣的一个标准。</p>
<p>最佳置换采用固定分配局部置换的策略，嘉定系统为某进程在内存中分配了 3 个物理块，页面访问顺序为 2、3、2、1、5、2、4、5、3、2、5、2。假定系统未采用预调页策略，即未事先调入任何页面。进程运行时，一次将 2、3、1 三个页面调入内存，发生 3 次缺页中断。当第一次访问页面 5 时，产生第 4 次缺页中断，根据 OPT 算法，淘汰页面 1，因为它在以后不会在使用了；第 5 次缺页中断时，淘汰页面 2，因为它在 5、3、2 三个页面中，是在将来最迟才会被页面访问的页面。以此类推：<br>注意：第 4 次中断时将最后不会访问的 1 剔除，将最后才访问的 3 放入最下面的内存块中，以后的调度过程中，最后不会访问或最后才被访问的页面总是放在最下面的内存块中。内存块从上到下依次存放最先访问的页面。<br>中断次数为 6，缺页中断率为 6/12*100% = 50%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">P:</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M=3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">F=5</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h3><span id="先进先出置换算法first-in-first-out-fifo">先进先出置换算法（First In First Out, FIFO)</span></h3><p>FIFO 置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经很少使用。</p>
<p>以 OPT 算例为例子。 中断次数为 6，缺页中断率为 9/12*100% = 75%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">P:</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M=3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F=9</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
</div>
<h4><span id="belady-异常">Belady 异常 </span></h4><p> 一般来说，分配给进程的物理块越多，运行时的缺页次数应该越少，使用 FIFO 时，可能存在相反情况，分配 4 个物理块的缺页竟然比 3 个物理块的缺页次数还多！<br>例如：进程访问顺序为 0、2、1、3、0、2、4、0、2、1、3、4。<br>M=3 时，缺页中断 9 次。缺页中断率 9/12*100% = 75%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">P:</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M=3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">F=9</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
</div>
<p>Ｍ=4 时，缺页中断 10 次。缺页中断率 10/12*100% = 83.3%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">P:</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">0</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M=4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">F=10</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="最近最久未使用置换算法least-recently-used-lru">最近最久未使用置换算法（Least Recently Used， LRU）</span></h3><p>LRU 的思想是置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 LRU 算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此 LRU 算法必须要有硬件的支持。</p>
<p>以 OPT 算例为例子。中断次数为 6，缺页中断率为 7/12*100% = 58.3%。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">P:</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">5</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M=3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F=7</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>堆栈实现 LRU：<br>系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号，栈底始终是最近最久未被访问的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统虚拟存储器机制</title>
    <url>/2017/10/15/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<p>每当我们安心的使用 LINUX 系统或者在编写 C 语言的时候，安心的使用 malloc 或者 free 的时候，我们很少关注过其底层的内存是怎么工作的，CPU 是如何获取从主存中获取数据的，我们的寻址是不是可以直接寻找到对应的数据，还是通过某种转化机制。实际上，对于每一个进程，它所能接触到的地址都不是实际的物理地址，而是通过虚拟地址进行映射而来的。这里来研究一下虚拟存储器的技术细节。</p>
<a id="more"></a>
<h3><span id="物理内存和虚拟内存">物理内存和虚拟内存 </span></h3><h4><span id="物理内存"> 物理内存 </span></h4><p> 物理内存就是我们电脑上的 RAM 提供的内存。他是固定的，内存条的容量多大，物理内存就有多大（集成显卡系统除外）。但是如果程序运行很多或者程序本身很大的话，就会导致大量的物理内存占用，甚至导致物理内存消耗殆尽。</p>
<h4><span id="虚拟内存">虚拟内存 </span></h4><p> 简明的说，虚拟内存就是在硬盘上划分一块页面文件，充当内存。当程序在运行时，有一部分资源还没有用上或者同时打开几个程序却只操作其中一个程序时，系统没必要将程序所有的资源都塞在物理内存中，于是，系统将这些暂时不用的资源放在虚拟内存上，等到需要时在调出来用。</p>
<p>值得一提的是，虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从 0 字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与 地址总线相对应”，是更贴切一些，为了理解方便，这种模型的理解也不算错误。</p>
<h3><span id="物理地址与逻辑地址">物理地址与逻辑地址 </span></h3><p><strong> 物理地址 (physical address)</strong>：用于内存芯片级的单元寻址，与处理器和 CPU 连接的地址总线相对应。它是加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从 0 开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip) 映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。</p>
<p><strong>逻辑地址 (logical address)</strong>：是指由程序产生的与段相关的偏移地址部分。例如，你在进行 C 语言指针<a href="http://www.2cto.com/kf"> 编程 </a> 中，可以读取指针变量本身值 (&amp; 操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。<br><strong> 线性地址 (linear address) 或也叫虚拟地址 (virtual address)</strong><br> 跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。</p>
<h4><span id="为什么需要虚拟地址">为什么需要虚拟地址</span></h4><ul>
<li>主存的容量有限。虽然我们现在的主存容量在不断上升，4G，8G，16G 的主存都出现在市面上。但是我们的进程是无限，如果计算机上的每一个进程都独占一块物理存储器(即物理地址空间)。那么，主存就会很快被用完。但是，实际上，每个进程在不同的时刻都是只会用同一块主存的数据，这就说明了其实只要在进程想要主存数据的时候我们把需要的主存加载上就好，换进换出。针对这样的需求，直接提供一整块主存的物理地址就明显不符合。</li>
<li>进程间通信的需求。如果每个进程都 独占一块物理地址，这样就只能通过 socket 这样的手段进行进程通信，但如果进程间能使用同一块物理地址就可以解决这个问题。</li>
<li>主存的保护问题。对于主存来说，需要说明这段内存是可读的，可写的，还是可执行的。针对这点，光用物理地址也是很难做到的。</li>
</ul>
<p>针对物理地址的直接映射的许多弊端，计算机的设计中就采取了一个虚拟化设计，就是虚拟内存。CPU 通过发出虚拟地址，虚拟地址再通过 MMU 翻译成物理地址，最后获得数据，具体的操作如下所示：</p>
<p><img src="https://i.loli.net/2020/08/26/VNLy6mGz5qMOX3h.jpg" alt="20171106142548425 (2)"></p>
<p>利用了虚拟内存就可以比较有效的解决以上三个问题，在每一个进程开始创建的时候，都会分配一个虚拟存储器（就是一段虚拟地址）然后通过虚拟地址和物理地址的映射来获取真实数据，这样进程就不会直接接触到物理地址，甚至不知道自己调用的那块物理地址的数据。</p>
<h4><span id="虚拟地址空间">虚拟地址空间 </span></h4><p> 当处理器读取或写入内存位置时，它会使用虚拟地址。 在读取或写入操作过程中，处理器会将虚拟地址转换为物理地址。 通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列连续的虚拟地址来访问物理内存中不连续的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。 当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。 数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。 一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<p>进程可用的虚拟地址范围称为该进程的“虚拟地址空间” 。 每个用户模式进程都有其各自的专用虚拟地址空间。 对于 32 位进程，虚拟地址空间通常为 2 GB，范围从 0x00000000 至 0x7FFFFFFF。 对于 64 位 Windows 上的 64 位进程，虚拟地址空间为 128 TB，范围从 0x000’00000000 至 0x7FFF’FFFFFFFF。 一系列虚拟地址有时称为一系列“虚拟内存” 。</p>
<p><img src="https://i.loli.net/2020/08/26/SupEMq4Jgi6Waol.png" alt="图：两个进程的虚拟地址空间"></p>
<p>该图显示了两个 64 位进程的虚拟地址空间：Notepad.exe 和 MyApp.exe。 每个进程都有其各自的虚拟地址空间，范围从 0x000’0000000 至 0x7FF’FFFFFFFF。 每个阴影块都表示虚拟内存或物理内存的一个页（大小为 4 KB）。 注意，Notepad 进程使用从 0x7F7’93950000 开始的虚拟地址的三个连续页面。 但虚拟地址的这三个连续页面会映射到物理内存中的非连续页面。 另请注意，两个进程都使用从 0x7F7’93950000 开始的虚拟内存页面，但这些虚拟页面映射到物理内存的不同页面。</p>
<h4><span id="地址分页">地址分页 </span></h4><p> 对于一整块连续的内存，直接连续使用也是不太符合实际的。于是，就有分页的概念。将 1024 个地址分成一页，通过访问页来访问数据。那么有了页就要有如何寻找页的概念了。我们通过每一页的首地址作为页入口，即 (PTE) 来检索页。那么，对于这些 PTE，我们也需要一个专门的数据结构来进行管理，这样的数据结构就是页表(page table)。</p>
<h3><span id="虚拟存储器缓存">虚拟存储器缓存 </span></h3><p> 静态随机存储器 （SRAM） 的速度是动态随机存储器（DRAM）的 10 倍，DRAM 是磁盘速度的百来倍，所以 SRAM 常作为 CPU 上 L1，L2，L3 缓存的材料，DRAM 作为主存，针对于 SRAM 和 DRAM，cache MISS 的惩罚而言，DRAM 的惩罚更大，因为 DRAM 的读写速度是磁盘的几百倍，所以利用在 DRAM 的缓存的作用就更大了，针对于虚拟存储器的缓存作用可以用下图所示：</p>
<p><img src="https://i.loli.net/2020/08/26/aEXmFkuPO1Y8v7f.png" alt="20171106150701652"></p>
<h4><span id="缺页中断">缺页中断 </span></h4><p> 虚拟存储器中的块分为：未分配的，缓存的，未缓存的。<br>未分配的：顾名思义，这一块的虚拟存储器不映射于任何块。<br>缓存的：这一块的虚拟存储器映射于已经存在于 DRAM 中的物理页。<br>未缓存的：这一块的虚拟存储器映射于存在于磁盘中的虚拟页。（也就是要使用就要把磁盘中的虚拟页替换到 DRAM 中的物理页，会发生 Page Fault ）<br>有效和无效通过一个 valid bit(有效位)来进行判断。</p>
<p><img src="https://i.loli.net/2020/08/26/hf9zc1nRVw6BSLG.png" alt="20171106151241526"></p>
<p>上图中，VM 缺页，对 VP3 中的字的引用不命中，触发缺页。</p>
<h4><span id="缺页置换">缺页置换 </span></h4><p>DRAM 里面有：页表，PTE（页表入口），物理存储器<br> 磁盘里面：虚拟页表</p>
<p>那么对于缓存来说：就有页命中，和页不命中两种情况 <br> 页命中：在图中就类似于 VP1,VP2, 这类的页表，直接缓存在 DRAM 中的物理存储器中，可以直接从 DRAM 中获取速度就快了。<br>页不命中：就是访问页表中未缓存的 PTE，如 VP3,VP6 之类，如下图所说明的情况</p>
<p><img src="https://i.loli.net/2020/08/26/JimQ8bnewxrafUG.png" alt="20171106151903458"></p>
<p>虚拟地址想访问 VP3 的时候，发现 VP3 未在缓存中，发生缺页错误，利用替换算法 (替换算法可能是 FIFO，或者 LRU) 将物理存储器中的一个 VP3 从物理存储器中导出，VP4 从磁盘导入 DRAM 中。此时,PTE3 就变成了已缓存，PTE4 变成了未缓存。这时候在进行地址翻译，就变成页命中了。<br>可见，缺页错误从磁盘导入的效率是非常低的，但是由于局部性原理，进程往往更多的在较小的活动页面上工作，很少有大跨度的访问内存，使得缺页错误产生的可能性降低。页命中的可能性提高。获取数据的效率就快了很多。</p>
<h3><span id="虚拟存储器作用">虚拟存储器作用 </span></h3><p> 虚拟存储器的作用有如下几点：</p>
<ol>
<li><p>简化共享：利用虚拟地址来映射物理地址，使得可以让多个进程的不同虚拟地址映射同一块物理地址，比如类似于 printf，这一类常用的库，不会把 printf 的代码拷贝到每一个进程，而是让不同进程都使用同一块 printf.</p>
</li>
<li><p>虚拟存储器作为存储器保护的工具，在虚拟存储器里面可以设计该 PTE 是可读，可写，还是可执行的。如果一旦出现只读的 PTE 被写入了，CPU 就会发送出现 segmentation fault(段错误)但并不会影响到实际存放数据的物理内存，</p>
<p><img src="https://i.loli.net/2020/08/26/mzVwEvieXfNkrLS.png" alt="20171106154635188"></p>
</li>
</ol>
<h3><span id="地址转换">地址转换 </span></h3><p> 地址翻译的目的是通过 MMU 将虚拟地址翻译成物理地址。</p>
<h4><span id="虚拟地址的地址位">虚拟地址的地址位</span></h4><p><img src="https://i.loli.net/2020/08/26/Z6IApWlGDs5ca8X.png" alt="20171106165015337"></p>
<h4><span id="一级页表地址转换">一级页表地址转换 </span></h4><p> 无论是虚拟地址还是物理地址都被分成两个部分，一个页号 (PN)，用来寻找对应的存储页，还有一个偏移量(PO) 用来寻找在对应页中的偏移量。对于偏移量来说，虚拟页的偏移量和物理页的偏移量是相同的。那么，说明我们所需要的转化就是从虚拟页号转化到物理页号。</p>
<p>   <img src="https://i.loli.net/2020/08/26/v1X839J2wiKNW5Q.png" alt="20171106165756623"></p>
<p>这也就意味着我们可以使用一个小 trick 加速翻译的速度，分别将 VPN,VPO 分开传输，VPN 传输到 MMU 进行翻译，VPO 直接传输到 L1 cache 进行偏移检索，而不是等到 VPN 翻译成 PPN 再进行翻译，这个称作是 <strong> 优化地址翻译</strong></p>
<h5><span id="翻译页号">翻译页号 </span></h5><p> 翻译页号的步骤就是通过 VPN 在页表中进行寻找找到对应的 PTE, 如果发现 PTE 的有效位为 0, 说明页面不存在，就出现缺页错误，重新加载页面到物理存储器中，然后设有效位为 1（上面的缺页错误说的就是这个问题）。反之，有效位为 1，说明页命中，取出 PPN 和 VPO 一合，得到物理地址，下图分别说明了，页命中与缺页异常两种情况的翻译情况：</p>
<p><img src="https://i.loli.net/2020/08/26/lxEHDnFzj3g5wGL.png" alt="20171106171923231"></p>
<p><img src="https://i.loli.net/2020/08/26/BJYeXUE5OIsSrdA.png" alt="20171106171934562"></p>
<h4><span id="tlb-加速地址翻译">TLB 加速地址翻译 </span></h4><p> 通过 DRAM 中的页表来进行地址翻译的速度有可能太慢了，无法满足速度的需求。这个时候就要 TLB 中派上用场了，TLB 实际位于 CPU 缓存寄存器 Cache 中，作为 SRAM 的一部分，速度是快于页表查询的。TLB 的实际作用，做一个映射，将 VPN 在 TLB 中寻找，找到对应的 PPN。那么问题来了，TLB 是怎么做的映射的呢？这时候就要说明一下 VPN 对于 TLB 来说可以分成那几块，请看下图</p>
<p><img src="https://i.loli.net/2020/08/26/tWgEMXiYOsorfln.png" alt="20171106173628712"></p>
<p>可以看见 VPN 被分为 (TLBT:TLB 标记，TLBI:TLB 索引)<br> 这时候再来看看 TLB 构成是什么样的呢？<br>这里展示的是一个四路组相连的一个 TLB</p>
<p><img src="https://i.loli.net/2020/08/26/W1QKoHsaiVGC89F.png" alt="20171106174024990"></p>
<p>TLBI 的两位就说明该选 TLB 的那一组，前面的 6 位 TLBT 说明标记位。</p>
<h4><span id="二级和多级页表地址转换">二级和多级页表地址转换 </span></h4><p> 二级页表或者多级页表都是为了更快的检索和更节约空间，请先看下面一个二级页表的例子：</p>
<p><img src="https://i.loli.net/2020/08/26/i3vRDMFNL1JjVSa.png" alt="20171106174828443"></p>
<p>首先二级页表并不复杂，就相当于多了一次映射，我们做一个简单的计算来说明二级页表容量关系，在一级页表中，一个 PTE 指向的是二级页表中，1024 个 PTE 的一页，那么二级页表中的一个 PTE 也就指向虚拟存储器中的一页，也就是 1KB 的地址空间，一个地址中有 32 位，也就是 4 个字节，那么在二级页表中的一个 PTE 所包含的容量就为 4KB 字节。对于一级页表而言，一个 PTE 就代表着 4MB 字节的空间，1K 的一级页表就代表了 4GB 字节的空间，4GB 已经是现在很多内存条的容量了。</p>
<p>那么对于多级页表，一个 VPN 又是怎么分配和映射的呢。相信下面的一张图就可以说明清楚。</p>
<p><img src="https://i.loli.net/2020/08/26/sqMklVFunyQ46oe.png" alt="20171106180207151"></p>
<h4><span id="物理地址处理">物理地址处理 </span></h4><p> 那么，现在我们得到了物理地址，那么通过物理地址又怎么在物理存储器中寻找到我们想要的数据呢？<br>先来看一下我们的物理地址分成那几个部分</p>
<p><img src="https://i.loli.net/2020/08/26/8v37wVRaNFrnZWS.png" alt="20171106180519329"></p>
<p>可以看到物理地址被分成了三个部分：CO(块偏移)，CI（索引），CT（标签）三个部分 <br> 那么物理存储器又长什么样子呢？请看下图：</p>
<p><img src="/Users/maywzh/Downloads/v2-d0aff2a40985bcb402b9335e07e05eaf_r.jpg" alt="v2-d0aff2a40985bcb402b9335e07e05eaf_r"></p>
<p>物理地址先找到 CI 索引，找到对应的 set 集合，然后判断这个集合的 valid bit 是否等于一并且 tag 是否与 CT 一致。如果这些条件都符合，在通过 CO 偏移找到想要的数据。</p>
<h4><span id="实例">实例 </span></h4><p> 首先，我们的翻译实例是基于一级页表之间的转换，关于虚拟地址以及物理地址的长度及位置如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/26/1HfOaQLxwrEyAhd.png" alt="20171106182322110"></p>
<p><img src="https://i.loli.net/2020/08/26/Ou8KtNv6jRTIrCi.png" alt="20171106182336973"><br>接下来，我们就来实际翻译的虚拟地址。<br>我们翻译的地址为:0x03d4</p>
<p><img src="https://i.loli.net/2020/08/26/WtzSrwiD7NgKu8b.jpg" alt="实例 1"></p>
<p><img src="https://i.loli.net/2020/08/26/jGdLQOwtuEeP5Za.jpg" alt="fd59ed9f-db1b-3ee3-8f7e-2d6e4935645c"></p>
<p>我们得到了 CO=0x0, CI=0x5, CT=0x0d<br>我们先通过 CI 找索引，然后再通过 CT 对照，很高兴，我们发现标记位相同，都为 0x0D, 且有效位为 1，于是乎我们再通过 CO=0 的偏移，取出了数据 0x36。<br>这个就是翻译的全过程。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 的全局解释器锁是什么</title>
    <url>/2018/09/08/Python/Python%E7%9A%84%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>全局解释性锁，简称 GIL(Global Interpreter Lock)，它是什么，官方有如下解释：</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<p>我们可以得出：</p>
<ul>
<li><code>GIL</code>在执行 Python 字节码时保护访问 Python 对象而阻止多个线程执行的互斥锁，主要因为 CPython 的解释器非线程安全。</li>
<li><code>GIL</code>非 Python 语言特性，而是依赖于解释器的实现，<code>CPython</code>实现了 <code>GIL</code> 机制</li>
<li><code>GIL</code>保证 Python 解释器运行时，同一时刻只有一个线程运行，保证内存管理安全</li>
<li>目前已经有许多功能依赖<code>GIL</code></li>
</ul>
<a id="more"></a>
<p>常见的 Python 解释器有如下几种，以及这些解释器是否存在<code>GIL</code>：</p>
<ul>
<li><code>CPython</code>：<code>C</code>语言开发的解释器，默认官方版本，使用最为广泛，有<code>GIL</code></li>
<li><code>IPython</code>：基于 <code>CPython</code> 开发的交互式解释器，只是增强了交互功能，执行功能与 <code>CPython</code> 完全一样</li>
<li><code>PyPy</code>：目标是加快执行速度，采用 JIT 技术，对 Python 代码进行动态编译（不是解释），可显著提高执行速度，但执行结果可能与 <code>CPython</code> 不同。有 <code>GIL</code>，但其开发者宣布发布去掉<code>GIL</code> 的版本</li>
<li><code>Jython</code>：运行在 Java 平台上的 Python 解释器，可以把 Python 代码编译成 <code>Java</code> 字节码，依赖 <code>Java</code> 平台，没有<code>GIL</code></li>
<li><code>IronPython</code>：和 <code>Jython</code> 类似，执行在微软 <code>.Net</code> 平台的 Python 解释器，可以把 Python 代码编译成 <code>.Net</code> 字节码依赖 <code>.Net</code> 平台，没有<code>GIL</code></li>
</ul>
<h2><span id="gil-problem">GIL Problem:</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading

<span class="token keyword">def</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> count <span class="token operator">&lt;=</span> <span class="token number">1000000000</span><span class="token punctuation">:</span>
        count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token comment"># 2 个线程执行 loop 方法</span>
t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>loop<span class="token punctuation">)</span>
t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>loop<span class="token punctuation">)</span>

t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这段代码，虽然开了 2 个线程执行，但我们观察 CPU 使用情况，发现其只能跑满一个核心。</p>
<p>由于 <code>GIL</code> 的存在，当线程被操作系统唤醒后，必须拿到 <code>GIL</code> 锁后才能执行代码，也就是说同一时刻永远只有一个线程在执行，这就导致如果我们的程序是 CPU 密集运算型的任务，那么使用 Python 多线程是不能提高效率的。</p>
<p>但即使有 <code>GIL</code> 的存在，理论来上来说，只要 <code>GIL</code> 释放的够勤快，多线程执行怎么也要比单线程效率高吧？</p>
<p>现实结果是：效率比我们想象的更糟糕！</p>
<ul>
<li>串行执行 2 次 CPU 密集型任务：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">import time
import threading

def loop():
    count &#x3D; 0
    while count &lt;&#x3D; 5000000000:
        count +&#x3D; 1


def main():
    # 串行执行 2 次 CPU 密集型任务
    start &#x3D; time.time()
    loop()
    loop()
    print time.time() - start

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    main()

# 540.302778006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>2 个线程同时执行 CPU 密集型任务：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">import time
import threading

def loop():
    count &#x3D; 0
    while count &lt;&#x3D; 5000000000:
        count +&#x3D; 1


def main():
    # 2 个线程同时执行 CPU 密集型任务
    start &#x3D; time.time()
    
    t1 &#x3D; threading.Thread(target&#x3D;loop)
    t2 &#x3D; threading.Thread(target&#x3D;loop)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    
    print time.time() - start

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    main()
    
# 573.972337961<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码分别模拟了一个 CPU 密集型任务在串行执行 2 次和 2 个线程同时执行的场景，执行结果发现，多线程的效率还不如串行效率高！</p>
<p>为什么会导致这种情况？我们来分析其背后的工作原理。</p>
<h2><span id="how-gil">How GIL?</span></h2><p>由于 Python 的线程就是 C 语言的 <code>pthread</code>，它是通过操作系统调度算法调度执行。而 Python 的执行是基于<code>opcode</code> 数量的调度方式，简单来说就是每执行一定数量的字节码，或遇到系统 IO 时，会强制释放<code>GIL</code>，然后触发一次操作系统的线程调度。</p>
<h3><span id="单核-cpu-下的多线程">单核 CPU 下的多线程 </span></h3><p> 如果是单核 CPU 情况下，在多线程执行时，每次线程 A 释放 <code>GIL</code> 后，被唤醒的线程 B 能够立即拿到<code>GIL</code>，能够无缝执行，执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/PH9e8qMihbvyTDz.png" alt="1524717396"></p>
<h3><span id="多核-cpu-下的多线程">多核 CPU 下的多线程 </span></h3><p> 但在多核 CPU 情况下多线程执行时，一个线程在 CPU0 执行完之后释放 <code>GIL</code>，其他 CPU 上的线程都会进行竞争，但 CPU0 可能又马上获取到了<code>GIL</code>，这就导致其他 CPU 上被唤醒的线程只能眼巴巴地看着 CPU0 上的线程欢快地执行着，而自己只能等待，直到又被切换到待调度的状态，这就会产生多核 CPU 频繁进行线程切换，消耗着资源，但只有一个线程能够拿到<code>GIL</code> 真正执行 Python 代码，这就导致多线程在多核 CPU 情况下，效率还不如单线程执行效率高。执行流程如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/hGA8qPFcK2Vezr7.png" alt="1524709489"></p>
<p>绿色部分是线程获得了 <code>GIL</code> 并进行有效的 CPU 运算，红色部分是被唤醒的线程由于没有争夺到<code>GIL</code>，只能无效地等待，无法充分利用 CPU 的并行运算能力。这就是多线程在多核 CPU 下，执行效率还不如单线程或单核 CPU 效率高的原因。</p>
<h3><span id="多线程-io-密集型任务">多线程 IO 密集型任务 </span></h3><p> 我们再进一步试想，如果多线程执行 IO 密集型任务，效率如何？</p>
<p>答案是比单线程效率要高。</p>
<p>这是由于 IO 密集型的任务，大部分时间都在等待 IO 上，很少消耗 CPU 的资源，所以在 IO 密集型任务的场景下，使用多线程是可以提升效率的。</p>
<h2><span id="why-gil">Why GIL?</span></h2><p>既然 <code>GIL</code> 的影响这么大，那为什么 Python 的解释器 <code>CPython</code> 在设计时要采用这种方式呢？</p>
<p>这就要追溯历史原因，2000 年以前，各个 CPU 厂商都在努力提升核心频率从而提高计算机的性能，但到 2000 年以后逐渐遇到天花板，之后提升方向改为多核心方向。</p>
<p>为了更有效的利用多核心 CPU，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。</p>
<p>Python 设计者在设计解释器时，可能没有想到 CPU 的性能提升会这么快转为多核心方向发展，所以在当时的场景下，设计一个全局锁是那个时代保护多线程资源一致性的最简单经济的设计方案。</p>
<p>而随着多核心时代来临，当大家试图去拆分和去除 <code>GIL</code> 的时候，发现大量库的代码开发者已经重度依赖 <code>GIL</code>（默认 Pythonn 内部对象是线程安全的，无需在开发时额外加锁），所以这个去除<code>GIL</code> 的任务变得复杂且难以实现。</p>
<p>所以简单来说 <code>GIL</code> 的存在更多的是历史原因，如果推倒重来重新设计，面对多线程问题可能设计得会更为优雅。</p>
<h2><span id="how-to-solve">How to solve?</span></h2><p>既然 <code>GIL</code> 存在会导致这么多问题，那我们有什么方式可以绕开这些问题，提高程序性能？总结如下：</p>
<ul>
<li>IO 密集型任务场景，多线程可以提高运行效率（推荐）</li>
<li>使用没有 <code>GIL</code> 的 Python 解释器（不推荐）</li>
<li>CPU 密集型任务场景，可改为多进程执行（推荐）</li>
<li>编写 Python 的 C 扩展模块，把 CPU 密集型任务交给 C 模块处理（编码复杂，不推荐）</li>
<li>更换其他语言实现 CPU 密集型任务</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何比较 Redis 与 Memcached</title>
    <url>/2017/05/04/Redis/Redis%E8%AF%A6%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94%E4%B8%8EMemcached%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2><span id="引">引</span></h2><p>Redis 与 Memcached 的比较相当多，首先我们比较一下他们的介绍。</p>
<blockquote>
<p>Memcached：一款完全开源、高性能的、分布式的内存系统；</p>
<p>Redis：一个开源的、Key-Value 型、基于内存运行并支持持久化的 NoSQL 数据库；</p>
</blockquote>
<a id="more"></a>
<p>可以发现，Memcached 更侧重于高性能内存 / 缓存系统，而 Redis 则支持持久化，主打数据库功能，兼可作缓存系统（性能也很高）。</p>
<p>下面有一个更加详细的比较表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">对比参数</th>
<th style="text-align:left">Redis</th>
<th style="text-align:left">Memcached</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型</td>
<td style="text-align:left">1. 支持内存 <br>2. 非关系型数据库</td>
<td style="text-align:left">1. 支持内存 <br>2. key-value 形式<br>3. 缓存系统</td>
</tr>
<tr>
<td style="text-align:left">数据存储类型</td>
<td style="text-align:left">String、List、Set、Hash、Sort Set</td>
<td style="text-align:left">文本型、二进制型</td>
</tr>
<tr>
<td style="text-align:left">查询操作</td>
<td style="text-align:left">1. 批量操作<br>2. 支持事务<br>3. 每个类型 CRUD 不同</td>
<td style="text-align:left">CRUD 和少量其他命令</td>
</tr>
<tr>
<td style="text-align:left">附加功能</td>
<td style="text-align:left">1. 发布 / 订阅模式<br>2. 主从分区<br>3. 序列化支持<br>4. 脚本支持</td>
<td style="text-align:left">多线程服务支持</td>
</tr>
<tr>
<td style="text-align:left">网络模型</td>
<td style="text-align:left">单进程 IO 复用模型</td>
<td style="text-align:left">多进程非阻塞 IO 模型</td>
</tr>
<tr>
<td style="text-align:left">事件库</td>
<td style="text-align:left">AeEvent</td>
<td style="text-align:left">LibEvent</td>
</tr>
<tr>
<td style="text-align:left">持久化支持</td>
<td style="text-align:left">RDB、AOF</td>
<td style="text-align:left">不支持</td>
</tr>
</tbody>
</table>
</div>
<h2><span id="网络模型">网络模型</span></h2><p><strong>Memcached 是多线程非阻塞 IO 复用的网络模型</strong>，它由负责监听的主线程和子线程 worker 组成。主线程监听网络连接，每当接受到网络请求，将连接描述字传递给 worker 线程进行读写 IO 操作。Memcached 的网络层使用 libevent 封装的事件库。但多线程不可避免地会有缓存一致性和锁等问题，这里面带来了性能损耗。</p>
<p><strong>Redis 是单线程 IO 复用模型</strong>，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select，对于单纯只有 IO 操作的业务场景来说，单线程可以将速度优势发挥到最大，但对于一些消耗 CPU 资源的计算性的操作例如 redis 提供的排序和聚合等，单线程模型施加会严重影响整体吞吐量，CPU 计算过程中，整个 IO 调度都是被阻塞的。</p>
<p>我们可以粗略得出结论，<strong>在高并发场景的压力下，多线程非阻塞式 IO 的 Memcached 表现会更加优异。</strong></p>
<h2><span id="内存管理机制">内存管理机制</span></h2><p>Memcached 和 Redis 都是由 C 语言开发，他们都是自主实现内存模型。</p>
<p>Memcached 的内存模式是 Slab Allocation。它有以下几个特点：</p>
<ol>
<li>Memcached 存储数据的最小单位是 chunk，这种设计是为了避免内存碎片的问题。chunk 的大小可以通过 Factor 来管理。</li>
<li><p>Slab 和 Page 用于承装不同尺寸的 chunk。</p>
</li>
<li><p>不同尺寸 chunk 最终进入一个 slab_class 进行管理，便于访问。</p>
</li>
</ol>
<p>数据访问流程，用户在 slab_class 找到合适尺寸的 slab，再通过某种方式找到 chunk，保证数据进入一个合适大小的 chunk 中存储，防止内存浪费。</p>
<p>相对于 Memecached，Redis 的内存管理要相对简单。</p>
<p>Redis 每一个数据块都是根据数据类型和大小来分配，每一块数据的元数据存入内存块头部。分配内存时，redis 调用 malloc 后返回首地址指针 <code>real_ptr</code>。redis 将内存块的大小 size 存入头部，size 本身所占据的内存大小是固定为 sizeof(typeof(size))。根据这个可以推算存储的数据的内存指针<code>ret_ptr</code>。释放内存时，通过<code>ret_ptr</code> 来推算 <code>real_ptr</code> 再调用 free 函数释放内存。</p>
<h3><span id="结论">结论</span></h3><p>Memcacehd 预分配内存池，用不同大小的内存单元来管理内存，数据选择合适的内存单元来存储。这样节省了申请 / 释放内存的开销，减少了内存碎片产生，但依然会带来内存空间浪费。Memcached 通过这种方式来最大化内存管理性能，是时间优先策略。</p>
<p>Redis 按需申请内存，Redis 会把带过期时间的数据单独存放在一起，这些数据是临时数据，临时数据会根据缓存过期策略来进行剔除。非临时数据则永远不会剔除。Redis 更好地利用了内存空间，是空间优先策略。</p>
<h2><span id="数据一致性">数据一致性</span></h2><p>Redis 提供了事务，这种事务并非真正的事务实现。而且这种事务性操作容易造成线程阻塞。Memcached 会返回操作的结果，不会影响其他数据。</p>
<h2><span id="集群">集群</span></h2><p>Memcached 本身不支持集群，但它可以通过客户端来实现集群操作。它通过客户端上的程序库来封装了对集群服务器访问的接口，使得用户看起来似乎是在操作一个节点。客户端的程序通过 hash 算法来选择 memcached 节点，然后去访问对应的节点。</p>
<p>Redis 支持集群。各个节点之间通过二进制协议进行通信，节点与客户端之间通过 ascii 协议进行通信。</p>
<h2><span id="总结">总结</span></h2><ol>
<li><p>如果业务更加侧重性能的高效性，对持久化要求不高，那么应该优先选择 Memcached。</p>
<p>具体到业务有服务器的实时配置、存储 json 字符串等等。</p>
</li>
<li><p>对持久化有高需求，追求多类型数据支持，选择 Redis。</p>
<p>具体到业务有排行榜类应用、社交关系存储、数据排重等等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 详解之——单线程高并发</title>
    <url>/2018/03/01/Redis/Redis%E8%AF%A6%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>redis 最基本的一个内部原理和特点，就是 redis 实际上是个单线程工作模型。如今在各大互联网公司已经大面积取代了 memcached 的应用。它可以承载相当大的 QPS。在这里，我们通过对 Redis 的线程模型和并发模型对它的高性能进行分析。</p>
<a id="more"></a>
<h2><span id="redis-线程模型">Redis 线程模型</span></h2><p>redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="https://i.loli.net/2020/08/28/IEtOiXKdgDWRGos.png" alt="fv69yaxxd9"></p>
<p>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p>
<p>假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。</p>
<p>这样便完成了一次通信。</p>
<h3><span id="几种-io-模型">几种 I/O 模型 </span></h3><p> 为什么 Redis 要采用 I/O 多路复用技术？</p>
<p>Redis 是单线程的，所以所有的操作都是线性执行的，由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 IO 阻塞导致整个进程无法对其他客户提供服务，而 IO 多路复用就是为了解决这个问题。</p>
<h4><span id="回顾-io-多路复用">回顾 IO 多路复用 </span></h4><p> 多路复用的特点是通过一种机制一个进程能同时等待 IO 文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，<code>select</code>， <code>poll</code>，<code>epoll</code>函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll 三种方式。</p>
<p><img src="https://i.loli.net/2020/08/28/T1hwz5douryFOXb.png" alt="20164149_LD8E"></p>
<h4><span id="reactor-设计模式">Reactor 设计模式 </span></h4><p>reactor 设计模式，是一种<strong> 基于事件驱动 </strong> 的设计模式。Reactor 框架是 ACE 各个框架中最基础的一个框架，其他框架都或多或少地用到了 Reactor 框架。在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。reactor 模式与外观模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>
<p><img src="https://i.loli.net/2020/08/28/piHkn5ALthX34BR.png" alt="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMTAzMTAxMzAyMzMx"></p>
<blockquote>
<p>Handles ：表示操作系统管理的资源，我们可以理解为 fd。</p>
<p>Synchronous Event Demultiplexer ：同步事件分离器，阻塞等待 Handles 中的事件发生。</p>
<p>Initiation Dispatcher ：初始分派器，作用为添加 Event handler（事件处理器）、删除 Event handler 以及分派事件给 Event handler。也就是说，Synchronous Event Demultiplexer 负责等待新事件发生，事件发生时通知 Initiation Dispatcher，然后 Initiation Dispatcher 调用 event handler 处理事件。</p>
<p>Event Handler ：事件处理器的接口</p>
<p>Concrete Event Handler ：事件处理器的实际实现，而且绑定了一个 Handle。因为在实际情况中，我们往往不止一种事件处理器，因此这里将事件处理器接口和实现分开，与 C++、Java 这些高级语言中的多态类似。</p>
</blockquote>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>
<p>虽然整个文件事件处理器在单线程上运行，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务的实现的简单。</p>
<h4><span id="io-多路复用模块">I/O 多路复用模块</span></h4>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 详解之——特性与用途</title>
    <url>/2018/03/04/Redis/Redis%E8%AF%A6%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<p><code>Redis</code> 是一个使用 <code>ANSI C</code> 编写的开源、支持 <strong>网络 </strong>、基于 <strong> 内存 </strong>、<strong> 单线程模型 </strong>、<strong> 可选持久性 </strong> 的 <strong> 键值对存储数据库</strong>。Redis 是一个 K-V 的非关系型数据库（NoSQL），常见的 NoSQL 数据库有：K-V 数据库如 Redis、Memcached，列式数据库如大数据组件 HBase，文档数据库如 mongoDB。Redis 应用广泛，尤其是被作为缓存使用。</p>
<a id="more"></a>
<h2><span id="特性">特性</span></h2><ol>
<li><strong>速度快 </strong>，最快可达到 <code>10w QPS</code>（基于 <strong> 内存 </strong>，<code>C</code> 语言，<strong> 单线程</strong> 架构）；</li>
<li>基于 <strong>键值对 </strong> (<code>key/value</code>) 的数据结构服务器。全称 <code>Remote Dictionary Server</code>。包括 <code>string</code>(<strong> 字符串 </strong>)、<code>hash</code>(<strong> 哈希 </strong>)、<code>list</code>(<strong> 列表 </strong>)、<code>set</code>(<strong> 集合 </strong>)、<code>zset</code>(<strong> 有序集合 </strong>)、<code>bitmap</code>(<strong> 位图 </strong>)。同时在 <strong> 字符串 </strong> 的基础上演变出 <strong> 位图 </strong>（<code>BitMaps</code>）和 <code>HyperLogLog</code> 两种数据结构。<code>3.2</code> 版本中加入 <code>GEO</code>（<strong> 地理信息位置</strong>）。</li>
<li>丰富的功能。例如：<strong>键过期 </strong>（缓存），<strong> 发布订阅 </strong>（消息队列）， <code>Lua</code> 脚本（自己实现 <code>Redis</code> 命令），<strong> 事务 </strong>，<strong> 流水线</strong>（<code>Pipeline</code>，用于减少网络开销）。</li>
<li>简单稳定。无外部库依赖，单线程模型。</li>
<li>客户端语言多。</li>
<li><strong>持久化 </strong>（支持两种 <strong> 持久化</strong> 方式 <code>RDB</code> 和 <code>AOF</code>）。</li>
<li><strong>主从复制</strong>（分布式的基础）。</li>
<li><strong>高可用 </strong>（<code>Redis Sentinel</code>），<strong> 分布式 </strong>（<code>Redis Cluster</code>）和 <strong> 水平扩容</strong>。</li>
</ol>
<h2><span id="应用场景">应用场景 </span></h2><h3><span id="缓存"> 缓存 </span></h3><p> 合理的使用 <strong>缓存 </strong> 能够明显加快访问的速度，同时降低数据源的压力。这也是 <code>Redis</code> 最常用的功能。<code>Redis</code> 提供了 <strong> 键值过期时间 </strong>（<code>EXPIRE key seconds</code>）设置，并且也提供了灵活控制 <strong> 最大内存 </strong> 和 <strong> 内存溢出 </strong> 后的 <strong> 淘汰策略</strong>。</p>
<h4><span id="缓存穿透">缓存穿透 </span></h4><p> 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p>
<p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4><span id="缓存雪崩">缓存雪崩 </span></h4><p> 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</p>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h4><span id="缓存击穿">缓存击穿 </span></h4><p> 对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一 key 缓存，前者则是很多 key。缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>
<h5><span id="解决方案">解决方案</span></h5><ol>
<li><p>互斥锁</p>
<p>业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。所以这里给出代码参考：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Redis</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name">String</span> value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 代表缓存值过期</span>
          <span class="token comment">// 设置 3min 的超时，防止 del 操作失败的时候，下次缓存过期一直不能 load db</span>
		  <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 代表设置成功</span>
               value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expire_secs<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 这个时候代表同时候的其他线程已经 load db 并回设到缓存了，这时候重试获取缓存值即可</span>
                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重试</span>
              <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
              <span class="token keyword">return</span> value<span class="token punctuation">;</span>      
          <span class="token punctuation">&#125;</span>
 <span class="token punctuation">&#125;</span>

<span class="token comment">//Memcache</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>memcache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    <span class="token comment">// 3 min timeout to avoid mutex holder crash  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memcache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
        value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        memcache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        memcache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">retry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>提前使用互斥锁</p>
<p>在 value 内部设置 1 个超时值 (timeout1), timeout1 比实际的 memcache timeout(timeout2) 小。当从 cache 读取到 timeout1 发现它已经过期时候，马上延长 timeout1 并重新设置到 cache。然后再从数据库加载数据并设置到 cache 中。伪代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
v <span class="token operator">=</span> memcache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memcache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
        value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        memcache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        memcache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">retry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span>timeout <span class="token operator">&lt;=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>memcache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
            <span class="token comment">// extend the timeout for other threads  </span>
            v<span class="token punctuation">.</span>timeout <span class="token operator">+=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>  
            memcache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">,</span> KEY_TIMEOUT <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
            <span class="token comment">// load the latest value from db  </span>
            v <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">.</span>timeout <span class="token operator">=</span> KEY_TIMEOUT<span class="token punctuation">;</span>  
            memcache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> KEY_TIMEOUT <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            memcache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token function">retry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">&#125;</span>  
    <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>永远不过期</p>
<p>这里的“永远不过期”包含两层意思：</p>
<blockquote>
<p>(1) 从 redis 上看，确实没有设置过期时间，这就保证了，不会出现热点 key 过期问题，也就是“物理”不过期。</p>
<p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p>
</blockquote>
<p>​    从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程 (非构建缓存的线程) 可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token class-name">String</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
        <span class="token class-name">V</span> v <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">String</span> value <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">long</span> timeout <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span>timeout <span class="token operator">&lt;=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
            <span class="token comment">// 异步更新后台异常执行  </span>
            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
                    <span class="token class-name">String</span> keyMutex <span class="token operator">=</span> <span class="token string">"mutex:"</span> <span class="token operator">+</span> key<span class="token punctuation">;</span>  
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>keyMutex<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
                        <span class="token comment">// 3 min timeout to avoid mutex holder crash  </span>
                        redis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>keyMutex<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                        <span class="token class-name">String</span> dbValue <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                        redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> dbValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                        redis<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>keyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                    <span class="token punctuation">&#125;</span>  
                <span class="token punctuation">&#125;</span>  
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">&#125;</span>  
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol>
<li><p>资源保护</p>
<p>采用 netflix 的 hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</p>
<p>四种解决方案：没有最佳只有最合适</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单分布式互斥锁（mutex key）</td>
<td>1. 思路简单 2. 保证一致性</td>
<td>1. 代码复杂度增大 2. 存在死锁的风险 3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td>“提前”使用互斥锁</td>
<td>1. 保证一致性</td>
<td>同上</td>
</tr>
<tr>
<td>不过期(本文)</td>
<td>1. 异步构建缓存，不会阻塞线程池</td>
<td>1. 不保证一致性。2. 代码复杂度增大(每个 value 都要维护一个 timekey)。3. 占用一定的内存空间(每个 value 都要维护一个 timekey)。</td>
</tr>
<tr>
<td>资源隔离组件 hystrix(本文)</td>
<td>1. hystrix 技术成熟，有效保证后端。2. hystrix 监控强大。</td>
<td>1. 部分访问存在降级策略。</td>
</tr>
</tbody>
</table>
</div>
<h4><span id="过期策略">过期策略 </span></h4><p> 大部分场景 <code> 不适合缓存一致存在 </code>，首先，你的 sql 数据库的内容可能很多就不说了，另外，返回给你的对象如果是完整的 pojo 对象还好，但是如果是使用不同参数各种关联查询出来的结果那么 redis 中会储存太多冷数据。占用资源而得不到销毁。我们学过<code> 操作系统 </code> 也知道在计算机的 <code> 缓存实现 </code> 中有）先进先出的算法（<strong>FIFO</strong>）；最近最少使用算法（<strong>LRU</strong>）；最佳淘汰算法（<strong>OPT</strong>）；最少访问页面算法（<strong>LFR</strong>）等磁盘调度算法。对于 web 开发也可以借鉴。根据时间来的 FIFO 是最好实现的。因为 redis 在 <code> 全局 key</code>支持过期策略。</p>
<p>而开发中可能还会遇到 <code> 其他问题</code>。比如过期时间的选择上，如果过久会导致数据聚集。而过少可能导致频繁查询数据库甚至可能会导致缓存雪崩等问题。</p>
<p>所以，过期策略一定要设置。并且对于 <code> 关键 key</code>一定要 <code> 小心谨慎设计</code>。</p>
<h3><span id="排行榜">排行榜 </span></h3><p> 每个网站都有自己的排行榜，例如按照 <strong>热度排名 </strong> 的排行榜，<strong> 发布时间 </strong> 的排行榜，<strong> 答题排行榜 </strong> 等等。<code>Redis</code> 提供了 <strong> 列表 </strong>（<code>list</code>）和 <strong> 有序集合</strong>（<code>zset</code>）数据结构，合理的使用这些数据结构，可以很方便的构建各种排行榜系统。</p>
<h3><span id="计数器">计数器 </span></h3><p><strong> 计数器 </strong> 在网站应用中非常重要。例如：<strong> 点赞数 </strong> 加 <code>1</code>，<strong>浏览数 </strong> 加 <code>1</code>。还有常用的 <strong> 限流操作 </strong>，限制每个用户每秒 <strong> 访问系统的次数 </strong> 等等。<code>Redis</code> 支持 <strong> 计数功能 </strong>（<code>INCR key</code>），而且计数的 <strong> 性能 </strong> 也非常好，计数的同时也可以设置 <strong> 超时时间 </strong>，这样就可以 <strong> 实现限流</strong>。</p>
<h3><span id="社交网络">社交网络 </span></h3><p> 赞 / 踩，粉丝，共同好友 / 喜好，推送，下拉刷新等是社交网站必备的功能。由于社交网站 <strong>访问量通常比较大 </strong>，而且 <strong> 传统的数据库 </strong> 不太适合保存这类数据，<code>Redis</code> 提供的 <strong> 数据结构</strong> 可以相对比较容易实现这些功能。</p>
<h3><span id="消息队列">消息队列 </span></h3><p><code>Redis</code> 提供的 <strong> 发布订阅 </strong>（<code>PUB/SUB</code>）和 <strong> 阻塞队列 </strong> 的功能，虽然和专业的消息队列比，还 <strong> 不够强大</strong>，但对于一般的消息队列功能基本满足。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) 阿里 Redis 开发规范笔记</title>
    <url>/2017/01/08/Redis/%E9%98%BF%E9%87%8CRedis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文主要介绍在使用阿里云 Redis 的开发规范，从下面几个方面进行说明。</p>
<ul>
<li>键值设计</li>
<li>命令使用</li>
<li>客户端使用</li>
<li>相关工具</li>
</ul>
<p>通过本文的介绍可以减少使用 Redis 过程带来的问题。</p>
<a id="more"></a>
<h2><span id="键值设计">键值设计 </span></h2><h3><span id="key-名设计">key 名设计</span></h3><h4><span id="可读性和可管理性"> 可读性和可管理性 </span></h4><p> 以业务名 (或数据库名) 为前缀(防止 key 冲突)，用冒号分隔，比如业务名: 表名:id</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ugc<span class="token operator">:</span>video<span class="token operator">:</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="简洁性">简洁性 </span></h4><p> 保证语义的前提下，控制 key 的长度，当 key 较多时，内存占用也不容忽视，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">user<span class="token operator">:</span><span class="token punctuation">&#123;</span>uid<span class="token punctuation">&#125;</span><span class="token operator">:</span>friends<span class="token operator">:</span>messages<span class="token operator">:</span><span class="token punctuation">&#123;</span>mid<span class="token punctuation">&#125;</span>简化为 u<span class="token operator">:</span><span class="token punctuation">&#123;</span>uid<span class="token punctuation">&#125;</span><span class="token operator">:</span>fr<span class="token operator">:</span>m<span class="token operator">:</span><span class="token punctuation">&#123;</span>mid<span class="token punctuation">&#125;</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="不要包含特殊字符">不要包含特殊字符 </span></h4><p> 反例：包含空格、换行、单双引号以及其他转义字符</p>
<h3><span id="value-设计">value 设计 </span></h3><h4><span id="拒绝-bigkey"> 拒绝 bigkey</span></h4><p>防止网卡流量、慢查询，string 类型控制在 10KB 以内，hash、list、set、zset 元素个数不要超过 5000。反例：一个包含 200 万个元素的 list。非字符串的 bigkey，不要使用 del 删除，使用 hscan、sscan、zscan 方式渐进式删除，同时要注意防止 bigkey 过期时间自动删除问题(例如一个 200 万的 zset 设置 1 小时过期，会触发 del 操作，造成阻塞，而且该操作不会不出现在慢查询中(latency 可查))，查找方法和删除方法</p>
<h4><span id="选择适合的数据类型">选择适合的数据类型 </span></h4><p> 例如：实体类型(要合理控制和使用数据结构内存编码优化配置, 例如 ziplist，但也要注意节省内存和性能之间的平衡)</p>
<p>反例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">set user<span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span>name tom
set user<span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span>age <span class="token number">19</span>
set user<span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span>favor football<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>正例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">hmset user<span class="token operator">:</span><span class="token number">1</span> name tom age <span class="token number">19</span> favor football<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="控制-key-的生命周期">控制 key 的生命周期</span></h4><p>redis 不是垃圾桶，建议使用 expire 设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注 idletime。</p>
<h2><span id="命令使用">命令使用 </span></h2><h3><span id="on命令关注-n-的数量">O(N)命令关注 N 的数量 </span></h3><p> 例如 hgetall、lrange、smembers、zrange、sinter 等并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 hscan、sscan、zscan 代替。</p>
<h3><span id="禁用命令">禁用命令 </span></h3><p> 禁止线上使用 keys、flushall、flushdb 等，通过 redis 的 rename 机制禁掉命令，或者使用 scan 的方式渐进式处理。</p>
<h3><span id="合理使用-select">合理使用 select*</span></h3><p>redis 的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p>
<h3><span id="使用批量操作提高效率">使用批量操作提高效率</span></h3><ul>
<li>原生命令：例如 mget、mset。</li>
<li>非原生命令：可以使用 pipeline 提高效率。</li>
</ul>
<p>但要注意控制一次批量操作的元素个数(例如 500 以内，实际也和元素字节数有关)。</p>
<p>注意两者不同：</p>
<ul>
<li>原生是原子操作，pipeline 是非原子操作。</li>
<li>pipeline 可以打包不同的命令，原生做不到</li>
<li>pipeline 需要客户端和服务端同时支持。</li>
</ul>
<h3><span id="不建议过多使用-redis-事务功能">不建议过多使用 Redis 事务功能 </span></h3><p>Redis 的事务功能较弱(不支持回滚)，而且集群版本(自研和官方) 要求一次事务操作的 key 必须在一个 slot 上(可以使用 hashtag 功能解决)</p>
<h3><span id="redis-集群版本在使用-lua-上有特殊要求">Redis 集群版本在使用 Lua 上有特殊要求</span></h3><p>1、所有 key 都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的 redis 命令，key 的位置，必须是 KEYS array, 否则直接返回 error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn”2、所有 key，必须在 1 个 slot 上，否则直接返回 error, “-ERR eval/evalsha command keys must in same slotrn”</p>
<h3><span id="monitor-命令">monitor 命令 </span></h3><p> 必要情况下使用 monitor 命令时，要注意不要长时间使用。</p>
<h2><span id="客户端使用">客户端使用 </span></h2><h3><span id="避免多个应用使用一个-redis-实例"> 避免多个应用使用一个 Redis 实例 </span></h3><p> 不相干的业务拆分，公共数据做服务化。</p>
<h3><span id="使用连接池">使用连接池 </span></h3><p> 可以有效控制连接，同时提高效率，标准使用方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">执行命令如下：
<span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    jedis <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 具体的命令</span>
    jedis<span class="token punctuation">.</span><span class="token function">executeCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"op key &#123;&#125; error:"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
 <span class="token comment">// 注意这里不是关闭连接，在 JedisPool 模式下，Jedis 会被归还给资源池。</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="熔断功能">熔断功能 </span></h3><p> 高并发下建议客户端添加熔断功能(例如 netflix hystrix)</p>
<h3><span id="合理的加密">合理的加密 </span></h3><p> 设置合理的密码，如有必要可以使用 SSL 加密访问（阿里云 Redis 支持）</p>
<h3><span id="淘汰策略">淘汰策略 </span></h3><p> 根据自身业务类型，选好 maxmemory-policy(最大内存淘汰策略)，设置好过期时间。默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。</p>
<p>其他策略如下：</p>
<ul>
<li>allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li>
<li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li>
<li>volatile-random: 随机删除过期键，直到腾出足够空间为止。</li>
<li>volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。</li>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时 Redis 只响应读操作。</li>
</ul>
<h2><span id="相关工具">相关工具 </span></h2><h3><span id="数据同步"> 数据同步</span></h3><p>redis 间数据同步可以使用：redis-port</p>
<h3><span id="big-key-搜索">big key 搜索</span></h3><p>redis 大 key 搜索工具</p>
<h3><span id="热点-key-寻找">热点 key 寻找 </span></h3><p> 内部实现使用 monitor，所以建议短时间使用 facebook 的 redis-faina 阿里云 Redis 已经在内核层面解决热点 key 问题</p>
<h2><span id="删除-bigkey">删除 bigkey</span></h2><ul>
<li>下面操作可以使用 pipeline 加速。</li>
<li>redis 4.0 已经支持 key 的异步删除，欢迎使用。</li>
</ul>
<h3><span id="hash-删除-hscan-hdel">Hash 删除: hscan + hdel</span></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigHash</span><span class="token punctuation">(</span><span class="token class-name">String</span> host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> bigHashKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 <span class="token class-name">ScanParams</span> scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">String</span> cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>
 <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">ScanResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hscan</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entryList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>entryList <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>entryList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> entryList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                jedis<span class="token punctuation">.</span><span class="token function">hdel</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 删除 bigkey</span>
    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigHashKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="list-删除-ltrim">List 删除: ltrim</span></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigList</span><span class="token punctuation">(</span><span class="token class-name">String</span> host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> bigListKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 <span class="token keyword">long</span> llen <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">llen</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> llen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token comment">// 每次从左侧截掉 100 个</span>
        jedis<span class="token punctuation">.</span><span class="token function">ltrim</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">,</span> left<span class="token punctuation">,</span> llen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        counter <span class="token operator">+=</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 <span class="token comment">// 最终删除 key</span>
    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigListKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="set-删除-sscan-srem">Set 删除: sscan + srem</span></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> bigSetKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 <span class="token class-name">ScanParams</span> scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">String</span> cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>
 <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">ScanResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">sscan</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> memberList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>memberList <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>memberList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> member <span class="token operator">:</span> memberList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                jedis<span class="token punctuation">.</span><span class="token function">srem</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 删除 bigkey</span>
    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigSetKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="sortedset-删除-zscan-zrem">SortedSet 删除: zscan + zrem</span></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delBigZset</span><span class="token punctuation">(</span><span class="token class-name">String</span> host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> bigZsetKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>password <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 <span class="token class-name">ScanParams</span> scanParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScanParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">String</span> cursor <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>
 <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
 <span class="token class-name">ScanResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple</span><span class="token punctuation">></span></span> scanResult <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">zscan</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">,</span> cursor<span class="token punctuation">,</span> scanParams<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple</span><span class="token punctuation">></span></span> tupleList <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>tupleList <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tupleList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Tuple</span> tuple <span class="token operator">:</span> tupleList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                jedis<span class="token punctuation">.</span><span class="token function">zrem</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">,</span> tuple<span class="token punctuation">.</span><span class="token function">getElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        cursor <span class="token operator">=</span> scanResult<span class="token punctuation">.</span><span class="token function">getStringCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 删除 bigkey</span>
    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>bigZsetKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>原作者：付磊 - 起扬 <br> 原文链接：<a href="https://link.zhihu.com/?target=https%3A//yq.aliyun.com/articles/531067">阿里云 Redis 开发规范 - 云栖社区 - 阿里云 </a><br> 原出处：阿里云</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 管理常用命令</title>
    <url>/2017/09/08/docker/Docker%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Docker 的常用命令一般分为：镜像管理、容器管理。</p>
<a id="more"></a>
<h2><span id="镜像管理命令">镜像管理命令 </span></h2><p> 下面使用 busybox 软件作为示例，busybox 软件是一个集成了非常多最常用的 Linux 命令和工具的软件集合。</p>
<h3><span id="查看所有镜像">查看所有镜像</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>REPOSITORY：镜像来自哪个仓库</li>
<li>TAG：镜像的标签信息，版本之类的信息</li>
<li>IMAGE ID：镜像创建时的 id</li>
<li>CREATED：镜像创建的时间</li>
<li>SIZE：镜像文件大小</li>
<li>下载软件镜像</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">docker pull busybox:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：latest 表示使用 busybox 软件的最新版本，所以软件默认下载都是 latest 版本。</p>
<h3><span id="导出镜像">导出镜像</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker save busybox &gt; busybox.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：把 busybox 镜像导出为 busybox.tar 文件，可以把 busybox.tar 文件复制到别的操作系统上使用，免除下载时网络慢的问题。</p>
<h3><span id="删除镜像">删除镜像</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker rmi busybox:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：镜像一般都会根据版本打包，如果有下载一个软件的多个版本就需要指定具体版本信息。如 busybox:1.26 就会删除 busybox 软件的 1.26 版本的镜像，不会删除 latest 版本的镜像。</p>
<h3><span id="导入镜像">导入镜像</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker load &lt; busybox.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：使用导出命令导出的镜像，可以通过此命令导入到没有下载此软件的操作系统，方便网络条件差的情况使用。</p>
<h3><span id="更改镜像名">更改镜像名</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker tag busybox:latest busybox:test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：busybox:latest 原镜像名，busybox:test 要改成的镜像名</p>
<h2><span id="容器管理命令">容器管理命令 </span></h2><h3><span id="运行容器"> 运行容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker run -d --name&#x3D;busybox busybox:latest ping 114.114.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>run</code>：run 参数代表启动容器</li>
<li><code>-d</code>：以后台 daemon 的方式运行</li>
<li><code>--name</code>：指定一个容器的名字，此后操作都需要使用这个名字来定位容器。</li>
<li><code>busybox:latest</code>：容器所使用的镜像名字</li>
<li><code>ping 114.114.114.114</code>：启动容器执行的命令</li>
<li>查看运行的容器</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="查看所有容器">查看所有容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>CONTAINER ID</code>：容器启动的 id</li>
<li><code>IMAGE</code>：使用哪个镜像启动的容器</li>
<li><code>COMMAND</code>：启动容器的命令</li>
<li><code>CREATED</code>：创建容器的时间</li>
<li><code>STATUS</code>：容器启动时间</li>
<li><code>PORTS</code>：容器映射到宿主机的端口</li>
<li><code>NAMES</code>：容器启动的名字</li>
<li>启动容器</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">docker start busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="重新启动容器">。重新启动容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker restart busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="停止容器">停止容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker stop busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="杀死容器">杀死容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker kill busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="删除运行中的容器">删除运行中的容器</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker rm -f busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="执行容器内命令">执行容器内命令</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker exec -it busybox ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备注：-it 交互终端</p>
<h3><span id="复制容器内文件">复制容器内文件</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker cp busybox:&#x2F;etc&#x2F;hosts hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="查看容器日志">查看容器日志</span></h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">docker logs -f busybox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实践 - 原理和创建镜像</title>
    <url>/2017/02/13/docker/docker%E5%AE%9E%E8%B7%B5%20-%20%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>你是否遇到过这种问题，在一个开发环境下面运行完全正常的程序，到了生产环境就会出现种种问题。因为生产环境的种种配置、库与环境变量等依赖项都与开发环境不尽相同，所以部署到生产环境之前，必须提前将生产环境配置好，才能保证服务正常运行。</p>
<p>但这样十分麻烦，尤其是要迁移服务器的话，环境配置又要重新来一遍。最理想的状况是，部署到生产环境可以自带环境配置，把运行正常的环境直接复制到生产机器上。<a href="https://www.docker.com/">Docker</a>为这种需求提供了解决方案。</p>
<a id="more"></a>
<h2><span id="docker-是什么">Docker 是什么 </span></h2><p>Docker 是一种 Linux 容器的封装， 由<a href="https://www.docker.com/company">Docker Inc.</a> 开发，它把应用程序和依赖打包为一个文件，docker 基于这个文件生成一个虚拟容器，应用程序在这个虚拟容器里面运行，与在真实物理机上运行无异。它解决了环境配置问题。</p>
<p>Docker 目前提供了企业版 (Docker Enterprise Edition, Docker EE) 和社区版 (Docker Community Edition, Docker CE) 两种版本。</p>
<h2><span id="docker-安装">Docker 安装</span></h2><p>Docker EE 是面向企业的，一般只需要使用 Docker CE 即可，我们选择安装 Docker CE 版本。在此以 Ubuntu18.04 为例：</p>
<h3><span id="卸载老版本的-docker">卸载老版本的 Docker</span></h3><p>如果安装过老版本的 docker(docker<code>or</code>docker-engine)，要先卸载掉</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> remove docker docker-engine docker.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="安装-docker">安装 Docker</span></h3><p>采用官方推荐的通过 Docker‘s repositories 方式来安装。</p>
<h4><span id="设置-dockers-repository">设置 Docker’s repository</span></h4><ol>
<li><p>先更新 apt 索引</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>安装必要的包，这是为了 apt 能够通过 HTTPS 的方式访问 Docker repositories</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token punctuation">\</span>
 apt-transport-https <span class="token punctuation">\</span>
 ca-certificates <span class="token punctuation">\</span>
 <span class="token function">curl</span> <span class="token punctuation">\</span>
 software-properties-common<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>添加 Docker 的官方 GPG key</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -fsSL https://download.docker.com/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>确认是否有带有 <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code> 指纹的 key。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> apt-key fingerprint 0EBFCD88

pub   4096R/0EBFCD88 <span class="token number">2017</span>-02-22
      Key fingerprint <span class="token operator">=</span> 9DC8 <span class="token number">5822</span> 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid                  Docker Release <span class="token punctuation">(</span>CE deb<span class="token punctuation">)</span> <span class="token operator">&lt;</span>docker@docker.com<span class="token operator">></span>
sub   4096R/F273FCD8 <span class="token number">2017</span>-02-22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>安装 <code>stable</code> 版本的 repository。如果想安装 <code>edge</code> 或<code>test</code>版本，在 <code>stable</code> 后面添加 <code>edge</code> 或<code>test</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> add-apt-repository <span class="token punctuation">\</span>
   <span class="token string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   <span class="token variable"><span class="token variable">$(</span>lsb_release -cs<span class="token variable">)</span></span> \
   stable"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h4><span id="安装-docker-ce">安装 Docker CE</span></h4><ol>
<li><p>先更新 apt 索引</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>安装最新版的 Docker CE</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>* 如果想安装特定版本 Docker CE，则可以列出 repo 中可用的版本，选择安装</p>
<p>a. 列出 repo 中可用版本<br>​    <code>bash
​    $ apt-cache madison docker-ce
​    docker-ce | 18.03.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages
​</code></p>
<p>b. 安装特定版本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>确定是否安装成功，下载一个测试镜像并在容器中运行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run hello-world
Hello from Docker<span class="token operator">!</span>
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 <span class="token number">1</span>. The Docker client contacted the Docker daemon.
 <span class="token number">2</span>. The Docker daemon pulled the <span class="token string">"hello-world"</span> image from the Docker Hub.
    <span class="token punctuation">(</span>amd64<span class="token punctuation">)</span>
 <span class="token number">3</span>. The Docker daemon created a new container from that image <span class="token function">which</span> runs the
    executable that produces the output you are currently reading.
 <span class="token number">4</span>. The Docker daemon streamed that output to the Docker client, <span class="token function">which</span> sent it
    to your terminal.

To try something <span class="token function">more</span> ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu <span class="token function">bash</span>

Share images, automate workflows, and <span class="token function">more</span> with a <span class="token function">free</span> Docker ID:
 https://hub.docker.com/

For <span class="token function">more</span> examples and ideas, visit:
 https://docs.docker.com/get-started/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果出现如上信息就安装成功了，如果是在 linux 下安装的还需要设置用户权限。</p>
</li>
</ol>
<h3><span id="设置用户权限linux-安装">设置用户权限（linux 安装）</span></h3><p>Docker daemon 进程与 Unix socket 绑定。默认状况下 Unix socket 权限由 <code>root</code> 用户拥有，其他用户必须用 <code>sudo</code> 才可以访问。Docker daemon 必须以 <code>root</code> 用户身份运行。想要省掉输入 <code>sudo</code> 就必须设置当前用户权限。</p>
<p>我们可以创建一个 <code>docker</code> 用户组并把当前用户加到这个组里面去，Docker daemon 启动时就创建一个可以被 <code>docker</code> 用户组访问的 Unix socket。</p>
<ol>
<li><p>创建 <code>docker</code> 用户组</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">groupadd</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>把当前用户加入 <code>docker</code> 用户组</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker <span class="token environment constant">$USER</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>重新登陆当前用户来使用户组生效</p>
</li>
<li><p>此时就可以不加 <code>sudo</code> 运行 <code>docker</code> 了</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h3><span id="设置-docker-开机启动">设置 Docker 开机启动 </span></h3><p>Ubuntu16.04 开始都用<code>systemd</code> 来管理开机启动服务。如果 Ubuntu14.10 以下则使用<code>upstart</code>。</p>
<h4><span id="ubuntu1604-及以上-systemd">Ubuntu16.04 及以上 - systemd</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> docker// 设置 docker 开机启动
$ <span class="token function">sudo</span> systemctl disable docker// 取消 docker 开机启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4><span id="ubuntu1410-及以下-upstart">Ubuntu14.10 及以下 - upstart</span></h4><p>Docker 被 upstart 自动配置为开机启动，取消开机启动则使用下面的命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> manual <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/init/docker.override<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="docker-image">Docker image</span></h2><p>Docker 容器 (container) 是通过运行镜像 (image) 文件来生成的。image 是一个可执行的包，它包含了运行一个应用程序所需要的所有东西—运行时、库、环境变量和配置文件。一个 image 可以生成多个同时运行的 container。</p>
<h2><span id="docker-container">Docker container</span></h2><p>Docker 容器是 image 的一个运行时实例。image 被执行并被加载到内存就变成一个 container，也就是一个具有状态的 image 或用户进程。可以通过 <code>docker ps</code> 来查看正在运行的 container 的列表。</p>
<h2><span id="容器与虚拟机的区别">容器与虚拟机的区别 </span></h2><p> 一个容器在 Linux 上 <strong> 原生 </strong> 运行，并于其他容器共享主机的内核。容器运行轻量级的独立的进程，占据资源相当少。而虚拟机则运行在一个客户操作系统 (Guest OS) 上，它通过虚拟机控制器技术来虚拟访问访问主机的资源，相对其他的进程，虚拟机要占据较多的机器资源。</p>
<h2><span id="docker-启动服务">Docker 启动服务</span></h2><p>Docker 是 C/S 架构，运行 docker 命令时，相当于把传递指令给监听特定 Unix socket 的 Docker 服务，所以必须启动 Docker 服务。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># service 方式</span>
$ <span class="token function">sudo</span> <span class="token function">service</span> docker start

<span class="token comment"># systemctl 方式</span>
$ <span class="token function">sudo</span> systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="实战-构建一个-app-并创建-docker-镜像">实战 - 构建一个 app 并创建 docker 镜像。</span></h2><p>如果我们想要开发一个 python app，第一步就是安装一个 python 的 runtime 到开发机上，而这个配置必须完美契合 app 的配置要求，生产环境也必须这样。</p>
<p>使用 Docker，就可以把所需 Python runtime 打包为一个镜像(image)，无需安装。然后在 app 的代码包含这个 image 即可。我们就算把 app 的环境打包好了。</p>
<h3><span id="步骤-1-通过-dockerfile-来定义容器-container"> 步骤 1: 通过 <code>Dockerfile</code> 来定义容器 (<code>container</code>)</span></h3><p><code>Dockerfile</code> 定义了 <code>container</code> 内的行为。在 <code>container</code> 环境中，所有对环境资源的访问，例如网络接口和磁盘驱动，都被虚拟化了，并与 <code>container</code> 外的操作系统隔离。因此需要定义到容器外的端口，并确定想要“拷贝”到这个环境的文件。做完这个以后，就可以确保在 <code>Dockerfile</code> 中运行的 app 在任何外部环境都能完全相同地运行。</p>
<h4><span id="创建dockerfile">创建<code>Dockerfile</code></span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/Workspace/dockerdemo
<span class="token function">touch</span> Dockerfile
<span class="token function">vim</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># ~&#x2F;Workspace&#x2F;dockerdemo&#x2F;Dockerfile
# 用一个官方的 Python runtime 作为父 image
FROM python:2.7-slim

# 设置工作目录为 &#x2F;app
WORKDIR &#x2F;app

# 把当前的目录内容拷贝到 &#x2F;app 中的容器
COPY . &#x2F;app

# 安装 requirements.txt 定义的依赖包
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# 把 80 端口对容器外开放
EXPOSE 80

# 定义环境变量
ENV NAME World

# 容器启动时运行 app.py
CMD [&quot;python&quot;, &quot;app.py&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>Dockerfile</code> 被构建为为一个 <code>image</code>，COPY<code> 命令把 </code>requirements.txt<code> 和</code>app.py<code>拷贝到容器内，EXPOSE 命令让</code>app.py` 的输出可以通过 HTTP 来访问。</p>
<h3><span id="步骤-2-构建示例-demo">步骤 2: 构建示例 demo</span></h3><h4><span id="编写-demo-app-代码">编写 demo app 代码 </span></h4><p> 编写 <code>requirements.txt</code> 和<code>app.py</code>，把它们放在 Dockerfile 的同一目录下。</p>
<p><code>requirements.txt</code></p>
<pre class="line-numbers language-none"><code class="language-none">Flask
Redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>app.py</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
<span class="token keyword">from</span> redis <span class="token keyword">import</span> Redis<span class="token punctuation">,</span> RedisError
<span class="token keyword">import</span> os
<span class="token keyword">import</span> socket

<span class="token comment"># Connect to Redis</span>
redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"redis"</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> socket_connect_timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> socket_timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        visits <span class="token operator">=</span> redis<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">"counter"</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> RedisError<span class="token punctuation">:</span>
        visits <span class="token operator">=</span> <span class="token string">"&lt;i>cannot connect to Redis, counter disabled&lt;/i>"</span>

    html <span class="token operator">=</span> <span class="token string">"&lt;h3>Hello &#123;name&#125;!&lt;/h3>"</span> \
           <span class="token string">"&lt;b>Hostname:&lt;/b> &#123;hostname&#125;&lt;br/>"</span> \
           <span class="token string">"&lt;b>Visits:&lt;/b> &#123;visits&#125;"</span>
    <span class="token keyword">return</span> html<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token operator">=</span>os<span class="token punctuation">.</span>getenv<span class="token punctuation">(</span><span class="token string">"NAME"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hostname<span class="token operator">=</span>socket<span class="token punctuation">.</span>gethostname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> visits<span class="token operator">=</span>visits<span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此 app 就编写完毕了。我们可以看到 <code>pip install -r requirements.txt</code> 这个命令安装了 Flask 和 Redis，而 app 打印了环境变量 <code>NAME</code> 和<code>socket.gethostname()</code>的输出。由于 Redis 安装之后并没有运行，所以预期 app 会运行失败，打印错误信息。</p>
<h4><span id="构建-app">构建 app</span></h4><p>查看当前目录的文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span>
Dockerfile		app.py			requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>运行 <code>build</code> 命令，建立 Docker image，我们也可以用 <code>-t</code> 选项来为之创建一个标签。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t friendlyhello <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以查看注册的 image</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image <span class="token function">ls</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
friendlyhello       latest              cfb6345425ed        <span class="token number">41</span> seconds ago      132MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4><span id="运行-app">运行 app</span></h4><p><code>docker run</code> 命令运行 app，<code>-p</code>选项把机器上的 4000 端口绑定到 container 发布的 80 端口</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p <span class="token number">4000</span>:80 friendlyhello
 * Serving Flask app <span class="token string">"app"</span> <span class="token punctuation">(</span>lazy loading<span class="token punctuation">)</span>
 * Environment: production
   WARNING: Do not use the development server <span class="token keyword">in</span> a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:80/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示信息访问<code>http://0.0.0.0:80</code>。但实际上，这条信息来自于容器内部，容器内部的 app 并不知道它正运行于容器内部，所以它在实体机上显示虚拟环境的地址<code>http://0.0.0.0:80</code>，实际上我们已经把容器的 80 端口映射到了物理机的 4000 端口，所以真实地址是<code>http://localhost:4000</code></p>
<p>点击 <code>CTRL+C</code>退出进程。</p>
<p>也可以添加 <code>-d</code> 选项在后台运行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p <span class="token number">4000</span>:80 friendlyhello
6b514ac64d134b52a35394c82839da468dcb94b56123109bd33113e5fdb36d7b <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>输入该命令后，得到了一个 container ID，例如上面的 <code>6b514ac64d134b52a35394c82839da468dcb94b56123109bd33113e5fdb36d7b</code>，此时我们的 container 在后台运行。也可以通过<code>docker container ls</code> 来查看 container ID 的缩写。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container <span class="token function">ls</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
6b514ac64d13        friendlyhello       <span class="token string">"python app.py"</span>     <span class="token number">3</span> minutes ago       Up <span class="token number">3</span> minutes        <span class="token number">0.0</span>.0.0:4000-<span class="token operator">></span><span class="token number">80</span>/tcp   compassionate_shannon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>运行 docker container stop 命令来停止 container 进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container stop 6b514ac64d13<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="步骤-3-分享-image">步骤 3: 分享 image</span></h3><p>我们想要我们的 image 可以随处运行。我们可以把自己的 image 推送到 Docker 仓库 (repository) 中。Docker 仓库类似于 Github 仓库，只是代码已经被构建好了。可以注册一个 Docker ID 来创建自己的 repository。Docker 命令行默认使用公有仓库。</p>
<h4><span id="登陆-docker-公有仓库">登陆 Docker 公有仓库 </span></h4><p> 我们需要去 <a href="docker.com">Docker 官网</a> 注册一个 Docker ID，在本机输入</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接着输入 Docker ID 和密码即可登录。</p>
<h4><span id="为-image-添加标签">为 image 添加标签 </span></h4><p> 一个仓库中的 image 的格式是<code>username/repository:tag</code>。这个 Tag 是可选的，但一般推荐添加上，因为仓库可以用 tag 来设定 Docker image 版本号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker tag image user/repository:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>例如</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker tag helloworld maywzh/maywzhrepo:part2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过 <code>docker image ls</code> 来查看新的添加了标签的 image:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image <span class="token function">ls</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
friendlyhello       latest              cfb6345425ed        <span class="token number">2</span> days ago          132MB
koa-demo            <span class="token number">0.0</span>.1               628b71e7fc7d        <span class="token number">2</span> weeks ago         675MB
hello-world         latest              4ab4c602aa5e        <span class="token number">3</span> weeks ago         <span class="token number">1</span>.84kB
python              <span class="token number">2.7</span>-slim            c9cde4658340        <span class="token number">4</span> weeks ago         120MB
node                <span class="token number">8.4</span>                 386940f92d24        <span class="token number">13</span> months ago       673MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="发布-image">发布 image</span></h4><p>可以把标签过的 image 发布到仓库中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker push username/repository:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一旦完成，那么上传的东西就可以被可以被公开访问了，也可以上 <a href="https://hub.docker.com/">Docker Hub</a> 来查看 image 上传的 image。</p>
<h4><span id="从远端仓库拉取-image">从远端仓库拉取 image</span></h4><p>经过之前的步骤，我们可以通过<code>docker run</code> 在任何机器上来运行我们的 app</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -p <span class="token number">4000</span>:80 username/repository:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果 image 在本机不可用，就会把它拉回到本地:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -p <span class="token number">4000</span>:40 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="总结">总结 </span></h2><p>Docker 提供了一种虚拟化容器的方式来打包 app 以及它的运行环境，该容器(container) 通过镜像 (image) 创建，而镜像通过编写 <code>dockerfile</code> 的方式来定义。我们也可以把为 docker 镜像添加标签，并推送到 docker 远程仓库中。这样就可以通过远程仓库直接运行镜像。</p>
<h2><span id="附录-所用的所有命令">附录 所用的所有命令</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t friendlyhello <span class="token builtin class-name">.</span>  <span class="token comment"># 用 dockerfile 来构建镜像</span>
docker run -p <span class="token number">4000</span>:80 friendlyhello  <span class="token comment"># 运行 friendlyhello 把容器端口 80 导航到到运行机端口 4000</span>
docker run -d -p <span class="token number">4000</span>:80 friendlyhello         <span class="token comment"># 后台运行模式</span>
docker container <span class="token function">ls</span>                                <span class="token comment"># 列出所有的容器</span>
docker container <span class="token function">ls</span> -a             <span class="token comment"># 列出所有的容器包括为未运行的</span>
docker container stop <span class="token operator">&lt;</span>hash<span class="token operator">></span>           <span class="token comment"># 优雅的方式关闭容器</span>
docker container <span class="token function">kill</span> <span class="token operator">&lt;</span>hash<span class="token operator">></span>         <span class="token comment"># 强制杀掉容器进程</span>
docker container <span class="token function">rm</span> <span class="token operator">&lt;</span>hash<span class="token operator">></span>        <span class="token comment"># 删除容器</span>
docker container <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker container <span class="token function">ls</span> -a -q<span class="token variable">)</span></span>         <span class="token comment"># 删除所有容器</span>
docker image <span class="token function">ls</span> -a                             <span class="token comment"># 列出所有的镜像</span>
docker image <span class="token function">rm</span> <span class="token operator">&lt;</span>image id<span class="token operator">></span>            <span class="token comment"># 删除特定镜像</span>
docker image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker image <span class="token function">ls</span> -a -q<span class="token variable">)</span></span>   <span class="token comment"># 删除所有镜像</span>
docker login             <span class="token comment"># 登陆到 docker CLI session</span>
docker tag <span class="token operator">&lt;</span>image<span class="token operator">></span> username/repository:tag  <span class="token comment"># 为镜像添加标签来上传到公有库</span>
docker push username/repository:tag            <span class="token comment"># 上传镜像到公有库</span>
docker run username/repository:tag                   <span class="token comment"># 从仓库运行镜像</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git 笔记之 ignore</title>
    <url>/2015/08/29/git/git%E7%AC%94%E8%AE%B0%E4%B9%8Bignore/</url>
    <content><![CDATA[<p>在 push 到远程仓库中，往往要忽略中间文件和开发环境配置文件等文件的提交，这时就要设置相应的忽略规则，来自动忽略这些文件。</p>
<h2><span id="原则">原则</span></h2><p><strong>Git 忽略文件的原则</strong></p>
<ul>
<li>忽略操作系统自动生成的文件，例如 macOS 中的<code>.DS_Store</code></li>
<li>忽略编译生成的中间文件、可执行文件等，如果一个文件是通过另一个文件自动生成的，那么就没必要放进版本库，比如 Java 编译产生的 <code>.class</code> 文件</li>
<li>忽略带有敏感信息的配置文件，比如存放口令的配置文件</li>
</ul>
<h2><span id="方式">方式 </span></h2><p><strong> 有三种方法可以实现忽略 Git 中不想提交的文件</strong>：</p>
<ol>
<li>在项目中定义.gitignore 文件 <br> 在项目根目录下定义.gitignore 文件，它往往要提交到公有仓库中，为该项目下的所有开发者都预设定义好的忽略规则。.gitingore 文件每一行指定一个忽略规则。如：</li>
</ol>
<pre class="line-numbers language-ignore" data-language="ignore"><code class="language-ignore"><span class="token entry string"><span class="token operator">*</span>.log</span>
<span class="token entry string"><span class="token operator">*</span>.temp</span>
<span class="token entry string"><span class="token punctuation">/</span>vendor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li><p>在项目的设置中临时指定排除文件 <br> 这种方式只是临时指定该项目的行为，需要编辑当前项目下的 <code>.git/info/exclude</code>文件，然后将需要忽略提交的文件写入其中。这种方式指定的忽略文件的根目录是项目根目录。</p>
</li>
<li><p>定义全局的 .gitignore 文件 <br> 除了可以在项目中定义 <code>.gitignore</code> 文件外，还可以设置全局的 git <code>.gitignore</code>文件来管理所有由 git 版本控制项目的行为。这种方式是定义个人开发机的全局环境，不在项目成员中共享。这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置：</p>
</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global core.excludesfile ~/.gitignore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="语法">语法 </span></h2><h3><span id="匹配语法"> 匹配语法</span></h3><ol>
<li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li>
<li><code>#</code>开头的行代表注释，git 忽略，可以使用反斜杠进行转义</li>
<li><code>.gitignore</code>使用标准的 glob 模式匹配。<a href="https://en.wikipedia.org/wiki/Glob_(programming">glob 模式 </a>) 往往用于在类 UNIX 系统中匹配文件路径。</li>
<li>斜杠 <code>/</code> 开头表示目录，<code>/</code>结束的模式只匹配文件夹和该文件夹路径下的内容，<code>/</code>开始的模式匹配项目根目录</li>
<li>星号 <code>*</code> 通配多个字符，问号 <code>?</code> 通配单个字符， 使用两个星号 <code>**</code> 表示匹配任意中间目录</li>
<li>方括号 <code>[]</code> 包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。</li>
<li>感叹号 <code>!</code> 表示不忽略 (跟踪) 匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号 <code>（!）</code> 取反。<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li>
<li>.git 对于.ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效！</li>
</ol>
<h3><span id="优先级">优先级 </span></h3><p> 在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p>
<ol>
<li>从命令行中读取可用的忽略规则</li>
<li>当前目录定义的规则</li>
<li>父级目录定义的规则，依次递推</li>
<li>$GIT_DIR/info/exclude 文件中定义的规则</li>
<li>core.excludesfile 中定义的全局规则</li>
</ol>
<p>例：</p>
<pre class="line-numbers language-none"><code class="language-none">*.a             #忽略所有目录中所有 .a 结尾的文件
&#x2F;*.b            #忽略根目录中所有 .b 结尾的文件
**&#x2F;*.c          #忽略所有目录中子目录中的 .c 结尾的文件
!&#x2F;1.b           #不忽略根目录下的 1.b 文件
bin&#x2F;            #忽略当前路径下的 bin 文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件
&#x2F;bin            #表示忽略根目录下的 bin 文件
a&#x2F;**&#x2F;b          #表示忽略 a 目录下所有目录及其子目录中的 b 文件，例如 a&#x2F;b， a&#x2F;c&#x2F;b ， a&#x2F;c&#x2F;d&#x2F;b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>⚠️<br>如果如果在版本库中写 <code>.gitignore</code> 文件之前就已经提交了要忽略的文件，那么 Git 仍然会对这些文件进行版本管理。例如已经 commit 了 <code>1.a</code> 这个文件到版本库，再写入 <code>1.a</code> 这条忽略规则到 <code>.gitignore</code> 文件，那么这条规则就失效了。对 <code>1.a</code> 文件的修改仍然会被版本控制。这种情况的解决方式可以参看<a href="https://maywzh.com/git 笔记之 rm/">git rm 删除版本控制</a>。<br><a id="more"></a></p>
<h2><span id="查看规则">查看规则 </span></h2><p> 我们可以用 <code>git check-ignore</code> 命令检查忽略规则：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> check-ignore -v ./bin/root-bin.a
.gitignore:2:/bin	./bin/root-bin.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看到 <code>./bin/root-bin.a</code> 匹配到了我们的第二行 <code>/bin</code> 的忽略规则，所以文件被忽略了。</p>
<h2><span id="删除本地缓存">删除本地缓存 </span></h2><p> 有的时候已经在.gitignore 中标明忽略的文件，但 git status 中该文件依旧处于 tracted 状态，这是因为在 git 忽略目录中，新建的文件会有缓存，如果某文件已经被纳入版本管理，那么再在.gitignore 中声明也是无效的，此时需要删除本地缓存，这样不会直接删除文件。如果去掉 <code>--cached</code> 选项则是直接删除对应文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token builtin class-name">.</span>
$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
$ <span class="token function">git</span> commit -m <span class="token string">".gitignore updated"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="远程仓库中删除版本控制">远程仓库中删除版本控制 </span></h2><p> 有的时候想移除远程仓库中的某些文件的版本控制，但依旧在本地保留该文件。这时候不可以直接使用 <code>git rm directory</code>，这样会删除本地仓库的文件。可以使用<code>git rm -r –cached directory</code> 来删除本地缓存，然后进行 commit 和 push，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用 <code>git add -A</code> 来添加修改的内容，上传的文件就会受到.gitignore 文件的内容约束。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token number">1</span>.a
$ <span class="token function">git</span> <span class="token function">add</span> -A
$ <span class="token function">git</span> commit -m <span class="token string">"update .gitignore"</span>
$ <span class="token function">git</span> push origin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 笔记之 rm</title>
    <url>/2015/08/15/git/git%E7%AC%94%E8%AE%B0%E4%B9%8Brm/</url>
    <content><![CDATA[<h2><span id="一个gitignore-的常见问题">一个.gitignore 的常见问题</span></h2><blockquote>
<p>明明我在.gitignore 上写了这个规则啊，为毛它还是被 git 版本控制了</p>
</blockquote>
<p>今天就遇到了这个蛋疼的问题，.vscode 文件夹中的调试配置也被提交到版本库了，但它并不需要版本控制。我尝试在.gitignore 里写上.vscode 这个规则，但依旧不起作用。</p>
<a id="more"></a>
<p>Google 之，原来这是因为，该文件已经存在于远程目录。难道泼出去的水还能收回来吗。</p>
<p>⚈้̤͡ ˌ̫̮ ⚈้̤͡” 是可以的！git 为我们提供了这样的工具—<code>git rm</code></p>
<h2><span id="git-rm">git rm</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它的作用时把相应文件从当前的版本移除出工作树。</p>
<p>好的我们想要吧.vscode 中的所有文件都移除出去，所以应当</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r .vscode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>输入，回车，肿么文件都没了！！！我们只是想要移除版本控制而已，并不想移除文件啊。回复</p>
<p>仔细看看，原来有个—cached 选项，这个选项移除版本控制，但是不把文件移除出工作区。</p>
<p>所以输入</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r --cached .vscode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="检查要被移除的文件">检查要被移除的文件 </span></h2><p> 等等，我不放心！我要看看移除的是哪些文件！打开文件夹看看…</p>
<p>STOP！ git 早为你们这些强迫症准备好了这个神器<code>-n</code> 选项，它不对文件移除，只是显示出这条命令会移除的文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r -n --cached  .vscode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ok，这就是要移除的文件，删除 <code>-n</code> 命令，再执行一次吧</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r --cached .vscode
<span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>很好，要移除的文件都变成了 untracked，然后 commit，push 到远程服务器。搞定！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 使用代理</title>
    <url>/2015/12/25/git/git%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<ol>
<li><p>https 访问 <br> 仅为 github.com 设置 socks5 代理 (推荐这种方式, 公司内网就不用设代理了, 多此一举):<br><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</code><br> 其中 1086 是 socks5 的监听端口, 这个可以配置的, 每个人不同, 在 macOS 上一般为 1086.<br>设置完成后, ~/.gitconfig 文件中会增加以下条目:</p>
<pre class="line-numbers language-none"><code class="language-none">[http &quot;https:&#x2F;&#x2F;github.com&quot;]
    proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1086<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>ssh 访问 <br> 需要修改~/.ssh/config 文件, 没有的话新建一个. 同样仅为 github.com 设置代理:</p>
<pre class="line-numbers language-none"><code class="language-none">Host github.com
    User git
    ProxyCommand nc -v -x 127.0.0.1:1086 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果是在 Windows 下, 则需要个性 %home%.ssh\config, 其中内容类似于:</p>
<pre class="line-numbers language-none"><code class="language-none">Host github.com
    User git
    ProxyCommand connect -S 127.0.0.1:1086 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里 -S 表示使用 socks5 代理, 如果是 http 代理则为 -H. connect 工具 git 自带, 在<git>\mingw64\bin\ 下面.</git></p>
</li>
</ol>
<a id="more"></a>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的字符串</title>
    <url>/2020/01/06/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串是 Go 语言中最常用的基础数据类型之一，虽然字符串往往被看做一个整体，但是实际上字符串是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本文就会详细介绍字符串的实现原理、相关转换过程以及常见操作的实现。</p>
<a id="more"></a>
<p>字符串虽然在 Go 语言中是基本类型 <code>string</code>，但是它实际上是由字符组成的数组，C 语言中的字符串就使用字符数组 <code>char[]</code> 表示，作为数组会占用一片连续的内存空间，这片内存空间存储了的字节共同组成了字符串，Go 语言中的字符串其实是一个只读的字节数组，下图展示了 <code>&quot;hello&quot;</code> 字符串在内存中的存储方式：</p>
<p><img src="https://i.loli.net/2020/09/04/D6RhWCdKk7oXeOp.png" alt="in-memory-string"></p>
<p>如果是代码中存在的字符串，会在编译期间被标记成只读数据 <code>SRODATA</code> 符号，假设我们有以下的一段代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> main.go
package main

func <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	str :<span class="token operator">=</span> <span class="token string">"hello"</span>
	println<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">(</span>str<span class="token punctuation">))</span>
<span class="token punctuation">&#125;</span>

$ <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go tool compile -S main.go
<span class="token punctuation">..</span>.
go.string.<span class="token string">"hello"</span> SRODATA dupok <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">5</span>
	0x0000 <span class="token number">68</span> <span class="token number">65</span> 6c 6c 6f                                   hello
<span class="token punctuation">..</span>. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只读只意味着字符串会分配到只读的内存空间并且这块内存不会被修改，但是在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 <code>[]byte</code> 之后就可以进行，修改后通过类型转换就可以变回 <code>string</code>，Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间。</p>
<h2><span id="数据结构">数据结构 </span></h2><p> 字符串在 Go 语言中的接口其实非常简单，每一个字符串在运行时都会使用如下的 <code>StringHeader</code> 结构体表示，在运行时包的内部其实有一个私有的结构 <code>stringHeader</code>，它有着完全相同的结构只是用于存储数据的 <code>Data</code> 字段使用了 <code>unsafe.Pointer</code> 类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> StringHeader <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Data <span class="token builtin">uintptr</span>
	Len  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们会经常会说字符串是一个只读的 <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/"> 切片 </a> 类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> SliceHeader <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Data <span class="token builtin">uintptr</span>
	Len  <span class="token builtin">int</span>
	Cap  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与切片的结构体相比，字符串少了一个表示容量的 <code>Cap</code> 字段，因为字符串作为只读的类型，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上执行的写入操作实际都是通过拷贝实现的。</p>
<h2><span id="解析过程">解析过程 </span></h2><p> 字符串的解析一定是解析器在词法分析时就完成的，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列，在 Go 语言中，有两种字面量方式可以声明一个字符串，一种是使用双引号，另一种是使用反引号:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">str1 <span class="token operator">:=</span> <span class="token string">"this is a string"</span>
str2 <span class="token operator">:=</span> <span class="token string">`this is another 
string`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而反引号声明的字符串就可以摆脱单行的限制，因为双引号不再负责标记字符串的开始和结束，我们可以在字符串内部直接使用 <code>&quot;</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">json <span class="token operator">:=</span> <span class="token string">`&#123;"author": "draven", "tags": ["golang"]&#125;`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>两种不同的声明方式其实也意味着 Go 语言的编译器需要在解析的阶段能够区分并且正确解析这两种不同的字符串格式，解析字符串使用的 <code>scanner</code> 扫描器，它的功能就是将输入的字符流转换成 Token 流，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L641-L669"><code>cmd/compile/internal/syntax.scanner.stdString</code></a> 方法就是它用来解析使用双引号包裹的标准字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>scanner<span class="token punctuation">)</span> <span class="token function">stdString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s<span class="token punctuation">.</span><span class="token function">startLit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		r <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">getr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token string">'"'</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token string">'\\'</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">escape</span><span class="token punctuation">(</span><span class="token string">'"'</span><span class="token punctuation">)</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">ungetr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			s<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"newline in string"</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">errh</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>line<span class="token punctuation">,</span> s<span class="token punctuation">.</span>col<span class="token punctuation">,</span> <span class="token string">"string not terminated"</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	s<span class="token punctuation">.</span>nlsemi <span class="token operator">=</span> <span class="token boolean">true</span>
	s<span class="token punctuation">.</span>lit <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">stopLit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	s<span class="token punctuation">.</span>kind <span class="token operator">=</span> StringLit
	s<span class="token punctuation">.</span>tok <span class="token operator">=</span> _Literal
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p>
<ol>
<li>标准字符串使用双引号表示开头和结尾；</li>
<li>标准字符串中需要使用反斜杠 <code>\</code> 来 <code>escape</code> 双引号；</li>
<li>标准字符串中不能出现如下所示的隐式换行符号 <code>\n</code>；</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">str <span class="token operator">:=</span> <span class="token string">"start
end"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用反引号声明的原始字符串的解析规则就非常简单了，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L671-L693"><code>cmd/compile/internal/syntax.scanner.rawString</code></a> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它来支持复杂的多行字符串：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>scanner<span class="token punctuation">)</span> <span class="token function">rawString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s<span class="token punctuation">.</span><span class="token function">startLit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		r <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">getr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> r <span class="token operator">==</span> <span class="token string">'`'</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">errh</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>line<span class="token punctuation">,</span> s<span class="token punctuation">.</span>col<span class="token punctuation">,</span> <span class="token string">"string not terminated"</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	s<span class="token punctuation">.</span>nlsemi <span class="token operator">=</span> <span class="token boolean">true</span>
	s<span class="token punctuation">.</span>lit <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">stopLit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	s<span class="token punctuation">.</span>kind <span class="token operator">=</span> StringLit
	s<span class="token punctuation">.</span>tok <span class="token operator">=</span> _Literal
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是标准字符串还是原始字符串最终都会被标记成 <code>StringLit</code> 类型的 Token 并传递到编译的下一个阶段 — <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/">语法分析</a>，在语法分析阶段，与字符串相关的表达式都会使用如下的方法 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/noder.go#L1349-L1408"><code>cmd/compile/internal/gc.noder.basicLit</code></a> 处理：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>noder<span class="token punctuation">)</span> <span class="token function">basicLit</span><span class="token punctuation">(</span>lit <span class="token operator">*</span>syntax<span class="token punctuation">.</span>BasicLit<span class="token punctuation">)</span> Val <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> s <span class="token operator">:=</span> lit<span class="token punctuation">.</span>Value<span class="token punctuation">;</span> lit<span class="token punctuation">.</span>Kind <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> syntax<span class="token punctuation">.</span>StringLit<span class="token punctuation">:</span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'`'</span> <span class="token punctuation">&#123;</span>
			s <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"\r"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		u<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Unquote</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
		<span class="token keyword">return</span> Val<span class="token punctuation">&#123;</span>U<span class="token punctuation">:</span> u<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两遍的引号等无关干扰，还原其本来的面目。</p>
<p><code>strconv.Unquote</code> 方法处理了很多边界条件导致整个函数非常复杂，不仅包括各种不同引号的处理，还包括 UTF-8 等编码的相关问题，所以在这里也就不展开介绍了。</p>
<h2><span id="拼接">拼接</span></h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中调用 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586"><code>cmd/compile/internal/gc.addstr</code></a> 函数生成用于拼接字符串的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">walkexpr</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">case</span> OADDSTR<span class="token punctuation">:</span>
		n <span class="token operator">=</span> <span class="token function">addstr</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> init<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586"><code>cmd/compile/internal/gc.addstr</code></a> 函数能帮助我们在编译期间选择合适的函数对字符串进行拼接，如果需要拼接的字符串小于或者等于 5 个，那么就会直接调用 <code>concatstring&#123;2,3,4,5&#125;</code> 等一系列函数，如果超过 5 个就会直接选择 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55"><code>runtime.concatstrings</code></a> 传入一个数组切片。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">addstr</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	buf <span class="token operator">:=</span> <span class="token function">nodnil</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	args <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">&#123;</span>buf<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> n2 <span class="token operator">:=</span> <span class="token keyword">range</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		args <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token function">conv</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> types<span class="token punctuation">.</span>Types<span class="token punctuation">[</span>TSTRING<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">var</span> fn <span class="token builtin">string</span>
	<span class="token keyword">if</span> c <span class="token operator">&lt;=</span> <span class="token number">5</span> <span class="token punctuation">&#123;</span>
		fn <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"concatstring%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		fn <span class="token operator">=</span> <span class="token string">"concatstrings"</span>

		t <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">NewSlice</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span>Types<span class="token punctuation">[</span>TSTRING<span class="token punctuation">]</span><span class="token punctuation">)</span>
		slice <span class="token operator">:=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OCOMPLIT<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token function">typenod</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
		slice<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">&#123;</span>buf<span class="token punctuation">,</span> slice<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	cat <span class="token operator">:=</span> <span class="token function">syslook</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
	r <span class="token operator">:=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OCALL<span class="token punctuation">,</span> cat<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	r<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
	<span class="token operator">...</span>

	<span class="token keyword">return</span> r
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实无论使用 <code>concatstring&#123;2,3,4,5&#125;</code> 中的哪一个，最终都会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55"><code>runtime.concatstrings</code></a>，该函数会先对传入的切片参数进行遍历，先过滤空字符串并计算拼接后字符串的长度。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">concatstrings</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>tmpBuf<span class="token punctuation">,</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	idx <span class="token operator">:=</span> <span class="token number">0</span>
	l <span class="token operator">:=</span> <span class="token number">0</span>
	count <span class="token operator">:=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>
		n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">&#125;</span>
		l <span class="token operator">+=</span> n
		count<span class="token operator">++</span>
		idx <span class="token operator">=</span> i
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">stringDataOnStack</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>
	s<span class="token punctuation">,</span> b <span class="token operator">:=</span> <span class="token function">rawstringtmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> l<span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>
		<span class="token function">copy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
		b <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> s
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果非空字符串的数量为 1 并且当前的字符串不在栈上就可以直接返回该字符串，不需要进行额外的任何操作。</p>
<p><img src="https://i.loli.net/2020/09/04/vroRD3qW15dKuHh.png" alt="string-concat-and-copy"></p>
<p>但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间中，新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，<strong>一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的</strong>。</p>
<h2><span id="类型转换">类型转换 </span></h2><p> 当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销并没有想象的那么小，我们经常会看到 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108"><code>runtime.slicebytetostring</code></a> 等函数出现在火焰图中，成为程序的性能热点。</p>
<p>从字节数组到字符串的转换就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108"><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是字节数组的长度为 0 或者 1，这两个情况处理起来都非常简单：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">slicebytetostring</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>tmpBuf<span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	l <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
		<span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>staticbytes<span class="token punctuation">[</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">var</span> p unsafe<span class="token punctuation">.</span>Pointer
	<span class="token keyword">if</span> buf <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		p <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> p
	<span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>slice<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>array<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>处理过后会根据传入的缓冲区大小决定是否需要为新的字符串分配一片内存空间，<a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L229-L231"><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <code>stringStruct</code> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <code>memmove</code> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p>
<p>当我们想要将字符串转换成 <code>[]byte</code> 类型时，就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L155-L165"><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">stringtoslicebyte</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>tmpBuf<span class="token punctuation">,</span> s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	<span class="token keyword">if</span> buf <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">*</span>buf <span class="token operator">=</span> tmpBuf<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		b <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		b <span class="token operator">=</span> <span class="token function">rawbyteslice</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">copy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
	<span class="token keyword">return</span> b
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果向该函数传入了缓冲区，那么它会使用传入的缓冲区存储 <code>[]byte</code>，没有传入缓冲区时，运行时会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L270-L279"><code>runtime.rawbyteslice</code></a> 创建一个新的字节切片，<code>copy</code> 就会将字符串中的内容拷贝到新的 <code>[]byte</code> 中。</p>
<p><img src="https://i.loli.net/2020/09/04/DVsZNaPgfWS75dX.png" alt="string-bytes-conversion"></p>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的，无论从哪种类型转换到另一种都需要对其中的内容进行拷贝，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p>
<h2><span id="小结">小结 </span></h2><p> 字符串是 Go 语言中相对来说比较简单的一种数据结构，我们在本文中详细分析了字符串与 <code>[]byte</code> 类型的关系，从词法分析阶段理解字符串是如何被解析的，作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://go101.org/article/string.html">Strings in Go</a></li>
<li><a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a></li>
<li><a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 · Wikipedia</a></li>
<li><a href="https://stackoverflow.com/questions/29255746/how-encode-rune-into-byte-using-utf8-in-golang">How encode []rune into []byte using utf8 in golang?</a></li>
<li><a href="https://golang.org/ref/spec#Conversions_to_and_from_a_string_type">Conversions to and from a string type</a></li>
<li><a href="http://cenalulu.github.io/linux/character-encoding/">十分钟搞清字符集和字符编码</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的并发原理</title>
    <url>/2020/01/16/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Go 语言是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者。</p>
<a id="more"></a>
<h1><span id="并发和并行">并发和并行 </span></h1><p><strong> 并发(concurrency)</strong>：两个或两个以上的任务在一段时间内被执行。我们不必 care 这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。</p>
<p><strong>并行 (parallellism)：</strong> 两个或两个以上的任务在同一时刻被同时执行。</p>
<p>并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。</p>
<p>（详情请见：Rob Pike 的<a href="https://talks.golang.org/2012/concurrency.slide#1">PPT</a>）</p>
<h1><span id="go-的-csp-并发模型">Go 的 CSP 并发模型</span></h1><p>Go 实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是 Java 或者 C++ 等语言中的多线程开发。另外一种是 Go 语言特有的，也是 Go 语言推荐的：CSP（communicating sequential processes）并发模型。</p>
<p>CSP 并发模型是在 1970 年左右提出的概念，属于比较新的概念，不同于传统的多线程通过共享内存来通信，CSP 讲究的是“以通信的方式来共享内存”。</p>
<p>请记住下面这句话：<br><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong><br>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p>
<p>普通的线程并发模型，就是像 Java、C++、或者 Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如 Java 提供的包”java.util.concurrent”中的数据结构。Go 中也实现了传统的线程并发模型。</p>
<p>Go 的 CSP 并发模型，是通过 <code>goroutine</code> 和<code>channel</code>来实现的。</p>
<ul>
<li><code>goroutine</code> 是 Go 语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li>
<li><code>channel</code>是 Go 语言中各个并发结构体 (<code>goroutine</code>) 之前的通信机制。 通俗的讲，就是各个 <code>goroutine</code> 之间通信的”管道“，有点类似于 Linux 中的管道。</li>
</ul>
<p>生成一个 <code>goroutine</code> 的方式非常的简单：Go 一下，就生成了。</p>
<pre class="line-numbers language-none"><code class="language-none">go f();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通信机制 <code>channel</code> 也很方便，传数据用<code>channel &lt;- data</code>，取数据用<code>&lt;-channel</code>。</p>
<p>在通信过程中，传数据 <code>channel &lt;- data</code> 和取数据 <code>&lt;-channel</code> 必然会成对出现，因为这边传，那边取，两个 <code>goroutine</code> 之间才会实现通信。</p>
<p>而且不管传还是取，必阻塞，直到另外的 <code>goroutine</code> 传或者取为止。</p>
<p>有两个 <code>goroutine</code>，其中一个发起了向<code>channel</code> 中发起了传值操作。（<code>goroutine</code>为矩形，<code>channel</code>为箭头）</p>
<p><img src="https://i6448038.github.io/img/csp/send.png" alt="img"></p>
<p>左边的 <code>goroutine</code> 开始阻塞，等待有人接收。</p>
<p>这时候，右边的 <code>goroutine</code> 发起了接收操作。</p>
<p><img src="https://i6448038.github.io/img/csp/accept.png" alt="img"></p>
<p>右边的 <code>goroutine</code> 也开始阻塞，等待别人传送。</p>
<p>这时候，两边 <code>goroutine</code> 都发现了对方，于是两个 <code>goroutine</code> 开始一传，一收。</p>
<p><img src="https://i6448038.github.io/img/csp/communicate.png" alt="img"></p>
<p>这便是 Golang CSP 并发模型最基本的形式。</p>
<h1><span id="go-并发模型的实现原理">Go 并发模型的实现原理 </span></h1><p> 我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问 CPU 资源、I/O 资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell 脚本”来调用内核空间提供的资源。</p>
<p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称 KSE），还是有区别的。</p>
<p>线程模型的实现，可以分为以下几种方式：</p>
<h3><span id="用户级线程模型">用户级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/yonghutai.png" alt="img"></p>
<p>如图所示，多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。</p>
<h3><span id="内核级线程模型">内核级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/neiheji.png" alt="img"></p>
<p>这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++ 就是这种。</p>
<h3><span id="两级线程模型">两级线程模型</span></h3><p><img src="https://i6448038.github.io/img/csp/liangji.png" alt="img"></p>
<p>这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。</p>
<p>Go 语言的线程模型就是一种特殊的两级线程模型。暂且叫它“MPG”模型吧。</p>
<h2><span id="go-线程实现模型-mpg">Go 线程实现模型 MPG</span></h2><p><code>M</code>指的是 <code>Machine</code>，一个<code>M</code> 直接关联了一个内核线程。<br><code>P</code>指的是”processor”，代表了 <code>M</code> 所需的上下文环境，也是处理用户级代码逻辑的处理器。<br><code>G</code>指的是<code>Goroutine</code>，其实本质上也是一种轻量级的线程。</p>
<p>三者关系如下图所示：</p>
<p><img src="https://i6448038.github.io/img/csp/GMPrelation.png" alt="img"></p>
<p>以上这个图讲的是两个线程 (内核线程) 的情况。一个 M 会对应一个内核线程，一个 M 也会连接一个上下文 P，一个上下文 P 相当于一个“处理器”，一个上下文连接一个或者多个 Goroutine。P(Processor)的数量是在启动时被设置为环境变量 GOMAXPROCS 的值，或者通过运行时调用函数 <code>runtime.GOMAXPROCS()</code> 进行设置。Processor 数量固定意味着任意时刻只有固定数量的线程在运行 go 代码。Goroutine 中就是我们要执行并发的代码。图中 P 正在执行的 <code>Goroutine</code> 为蓝色的；处于待执行状态的 <code>Goroutine</code> 为灰色的，灰色的 <code>Goroutine</code> 形成了一个队列<code>runqueues</code></p>
<p>三者关系的宏观的图为：</p>
<p><img src="https://i6448038.github.io/img/csp/total.png" alt="img"></p>
<h4><span id="抛弃-pprocessor">抛弃 P(Processor)</span></h4><p>你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让 <code>Goroutine</code> 的<code>runqueues</code>挂到 M 上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。</p>
<p>一个很简单的例子就是系统调用 <code>sysall</code>，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程 M 需要放弃当前的上下文环境 P，以便可以让其他的<code>Goroutine</code> 被调度执行。</p>
<p><img src="https://i6448038.github.io/img/csp/giveupP.png" alt="img"></p>
<p>如上图左图所示，M0 中的 G0 执行了 syscall，然后就创建了一个 M1(也有可能本身就存在，没创建)，（转向右图）然后 M0 丢弃了 P，等待 syscall 的返回值，M1 接受了 P，将·继续执行 <code>Goroutine</code> 队列中的其他<code>Goroutine</code>。</p>
<p>当系统调用 syscall 结束后，M0 会“偷”一个上下文，如果不成功，M0 就把它的 Gouroutine G0 放到一个全局的 runqueue 中，然后自己放到线程池或者转入休眠状态。全局 runqueue 是各个 P 在运行完自己的本地的 Goroutine runqueue 后用来拉取新 goroutine 的地方。P 也会周期性的检查这个全局 runqueue 上的 goroutine，否则，全局 runqueue 上的 goroutines 可能得不到执行而饿死。</p>
<h4><span id="均衡的分配工作">均衡的分配工作 </span></h4><p> 按照以上的说法，上下文 P 会定期的检查全局的 goroutine 队列中的 goroutine，以便自己在消费掉自身 Goroutine 队列的时候有事可做。假如全局 goroutine 队列中的 goroutine 也没了呢？就从其他运行的中的 P 的 runqueue 里偷。</p>
<p>每个 P 中的 <code>Goroutine</code> 不同导致他们运行的效率和时间也不同，在一个有很多 P 和 M 的环境中，不能让一个 P 跑完自身的 <code>Goroutine</code> 就没事可做了，因为或许其他的 P 有很长的 <code>goroutine</code> 队列要跑，得需要均衡。<br>该如何解决呢？</p>
<p>Go 的做法倒也直接，从其他 P 中偷一半！</p>
<p><img src="https://i6448038.github.io/img/csp/stealwork.png" alt="img"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言编译过程</title>
    <url>/2020/01/04/go/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Go 语言需要编译才能够运行，为了理解 Go 的执行过程，我们从编译原理的一些基础概念出发，对 Go 的编译过程进行探讨。</p>
<a id="more"></a>
<h2><span id="编译原理预备知识">编译原理预备知识 </span></h2><h3><span id="抽象语法树"> 抽象语法树</span></h3><p>（AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:1">1</a>。抽象语法树中的每一个节点都表示源代码中的一个元素，每一颗子树都表示一个语法元素，例如一个 if else 语句，我们可以从 <code>2 * 3 + 7</code> 这一表达式中解析出下图所示的抽象语法树。</p>
<p><img src="/Users/maywzh/Downloads/2019-12-20-15768548776645-abstract-syntax-tree.png" alt="2019-12-20-15768548776645-abstract-syntax-tree"></p>
<p>作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序是否存在一些类型不匹配或不一致的问题。</p>
<h3><span id="静态单赋值">静态单赋值 </span></h3><p><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form"> 静态单赋值</a>（Static Single Assignment, SSA）是中间代码的一个特性，如果一个中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:2">2</a>。在实践中我们通常会用添加下标的方式实现每个变量只能被赋值一次的特性，这里以下面的代码举个例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token number">1</span>
x <span class="token operator">:=</span> <span class="token number">2</span>
y <span class="token operator">:=</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>根据分析，我们其实能够发现上述的代码其实并不需要第一个将 <code>1</code> 赋值给 <code>x</code> 的表达式，也就是 <code>x := 1</code> 这一表达式在上述的代码片段中是没有作用的。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x1 <span class="token operator">:=</span> <span class="token number">1</span>
x2 <span class="token operator">:=</span> <span class="token number">2</span>
y1 <span class="token operator">:=</span> x2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当我们使用具有 SSA 特性的中间代码时，就可以非常清晰地发现变量 <code>y1</code> 的值和 <code>x1</code> 是完全没有任何关系的，所以在机器码生成时其实就可以省略第一步，这样就能减少需要执行的指令来优化这一段代码。</p>
<p>在中间代码中使用 SSA 的特性能够为整个程序实现以下的优化：</p>
<ol>
<li>常数传播（constant propagation）</li>
<li>值域传播（value range propagation）</li>
<li>稀疏有条件的常数传播（sparse conditional constant propagation）</li>
<li>消除无用的程式码（dead code elimination）</li>
<li>全域数值编号（global value numbering）</li>
<li>消除部分的冗余（partial redundancy elimination）</li>
<li>强度折减（strength reduction）</li>
<li>寄存器分配（register allocation）</li>
</ol>
<p>因为 SSA 的主要作用是对代码进行优化，所以它是编译器后端 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:3">3</a> 的一部分；当然代码编译领域除了 SSA 还有很多中间代码的优化方法。</p>
<h3><span id="指令集">指令集 </span></h3><p> 最后要介绍的一个预备知识就是 <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture"> 指令集 </a> 了，很多开发者都会遇到在生产环境运行的结果和本地不同的问题，导致这种情况的原因其实非常复杂，不同机器使用不同的指令也是可能的原因之一。</p>
<p>我们在命令行中输入 <code>uname -m</code> 就能够获得当前机器上硬件的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uname</span> -m
x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>x86 是目前比较常见的指令集，除了 x86 之外，还有很多其他的指令集，不同的处理器使用了不同的架构和机器语言，所以很多编程语言为了在不同的机器上运行需要将源代码根据架构翻译成不同的机器代码。</p>
<p>复杂指令集计算机（CISC）和精简指令集计算机（RISC）是目前的两种 CPU 区别，它们在设计理念上会有一些不同，从名字我们就能看出来这两种不同的设计有什么区别：</p>
<ul>
<li>复杂指令集通过增加指令的数量减少需要执行的指令数；</li>
<li>精简指令集能使用更少的指令完成目标的计算任务；</li>
</ul>
<p>早期的 CPU 为了减少机器语言指令的数量使用复杂指令集完成计算任务，这两者其实并没有绝对的好坏，它们只是在一些设计上的选择不同以达到不同的目的。</p>
<h2><span id="go-编译">Go 编译</span></h2><p>Go 语言编译器的源代码在 <code>src/cmd/compile</code> 目录中，目录下的文件共同组成了 Go 语言的编译器。编译器有前端和后端，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的二进制机器码。</p>
<p><img src="https://i.loli.net/2020/09/04/aVgqxoZyL265X8m.png" alt="complication-process"></p>
<p>Go 的编译器在逻辑上可以被分成四个阶段：<strong>词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成</strong>。</p>
<h3><span id="词法与语法分析">词法与语法分析 </span></h3><p> 所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。</p>
<p>而语法分析的输入就是词法分析器输出的 Token 序列，这些序列会按照顺序被语法分析器进行解析，语法的解析过程就是将词法分析生成的 Token 按照语言定义好的文法（Grammar）自下而上或者自上而下的进行规约，每一个 Go 的源代码文件最终会被归纳成一个 <a href="https://golang.org/ref/spec#Source_file_organization"><code>SourceFile</code></a> 结构：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">SourceFile <span class="token operator">=</span> PackageClause <span class="token string">";"</span> <span class="token punctuation">&#123;</span> ImportDecl <span class="token string">";"</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span> TopLevelDecl <span class="token string">";"</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>词法分析会返回一个不包含空格、换行等字符的 Token 序列，例如：<code>package</code>, <code>json</code>, <code>import</code>, <code>(</code>, <code>io</code>, <code>)</code>, …，而语法分析会把 Token 序列转换成有意义的结构体，也就是语法树：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token string">"json.go"</span><span class="token punctuation">:</span> SourceFile <span class="token punctuation">&#123;</span>
    PackageName<span class="token punctuation">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span>
    ImportDecl<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Import<span class="token punctuation">&#123;</span>
        <span class="token string">"io"</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    TopLevelDecl<span class="token punctuation">:</span> <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 Token 转换成上述语法树就会使用语法解析器，语法解析的结果其实就是上面介绍过的抽象语法树（AST），每一个 AST 都对应着一个单独的 Go 语言文件，这个抽象语法树中包括当前文件属于的包名、定义的常量、结构体和函数等。</p>
<p><img src="https://i.loli.net/2020/09/04/uniNRZGjIfKcF43.png" alt="golang-files-and-ast"></p>
<p><strong>图 2-3 从源文件到语法树</strong></p>
<p>如果在语法解析的过程中发生了任何语法错误，都会被语法解析器发现并将消息打印到标准输出上，整个编译过程也会随着错误的出现而被中止。</p>
<h3><span id="类型检查">类型检查 </span></h3><p> 当拿到一组文件的抽象语法树之后，Go 语言的编译器会对语法树中定义和使用的类型进行检查，类型检查分别会按照以下的顺序对不同类型的节点进行验证和处理：</p>
<ol>
<li>常量、类型和函数名及类型；</li>
<li>变量的赋值和初始化；</li>
<li>函数和闭包的主体；</li>
<li>哈希键值对的类型；</li>
<li>导入函数体；</li>
<li>外部的声明；</li>
</ol>
<p>通过对整颗抽象语法树的遍历，我们在每一个节点上都会对当前子树的类型进行验证，以保证当前节点上不会出现类型错误的问题，所有的类型错误和不匹配都会在这一个阶段被发现和暴露出来，结构体是否实现了某些接口也会在这一阶段被检查出来。</p>
<p>类型检查阶段不止会对节点的类型进行验证，还会展开和改写一些内建的函数，例如 <code>make</code> 关键字在这个阶段会根据子树的结构被替换成 <code>makeslice</code> 或者 <code>makechan</code> 等函数。类型检查这一过程在整个编译流程中还是非常重要的，Go 语言的很多关键字都依赖类型检查期间的展开和改写。</p>
<h3><span id="中间代码生成">中间代码生成 </span></h3><p> 当我们将源文件转换成了抽象语法树、对整棵树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码不存在语法错误和类型错误的问题了，Go 语言的编译器就会将输入的抽象语法树转换成中间代码。</p>
<p>在类型检查之后，就会通过一个名为 <code>compileFunctions</code> 的函数开始对整个 Go 语言项目中的全部函数进行编译，这些函数会在一个编译队列中等待几个后端工作协程的消费，这些并发执行的 Goroutine 会将所有函数对应的抽象语法树转换成中间代码。<br><img src="https://i.loli.net/2020/09/04/GYENCH8jIwcRxmT.png" alt="concurrency-compiling"></p>
<p>由于 Go 语言编译器的中间代码使用了 SSA 的特性，所以在这一阶段我们就能够分析出代码中的无用变量和片段并对代码进行优化。</p>
<p>Go 语言源代码的 <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal"><code>src/cmd/compile/internal</code></a> 目录中包含了很多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包生成机器码，其中包括 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，其中比较有趣的就是 WebAssembly（Wasm）<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:7">7</a>了。</p>
<p>作为一种在栈虚拟机上使用的二进制指令格式，它的设计的主要目标就是在 Web 浏览器上提供一种具有高可移植性的目标语言。Go 语言的编译器既然能够生成 Wasm 格式的指令，那么就能够运行在常见的主流浏览器中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>wasm <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>js go build -o lib.wasm main.go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以使用上述的命令将 Go 的源代码编译成能够在浏览器上运行 WebAssembly 文件，当然除了这种新兴的二进制指令格式之外，Go 语言经过编译还可以运行在几乎全部的主流机器上，不过对于除了 Linux 和 Darwin 之外的机器上兼容性上可能还是有一些问题，例如：Go Plugin 至今仍然不支持 Windows<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:8">8</a>。</p>
<p><img src="https://i.loli.net/2020/09/04/sCoQZ6vRiTbduF7.png" alt="supported-hardware"></p>
<h3><span id="编译器入口">编译器入口</span></h3><p>Go 语言的编译器入口在 <a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go"><code>src/cmd/compile/internal/gc/main.go</code></a> 文件中，这个 600 多行的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/main.go#L144-L796"><code>Main</code></a> 函数就是 Go 语言编译器的主程序，该函数会先获取命令行传入的参数并更新编译选项和配置，随后就会开始运行 <code>parseFiles</code> 函数对输入的所有文件进行词法与语法分析得到文件对应的抽象语法树：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Main</span><span class="token punctuation">(</span>archInit <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Arch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>

	lines <span class="token operator">:=</span> <span class="token function">parseFiles</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就会分九个阶段对抽象语法树进行更新和编译，就像我们在上面介绍的，整个过程会经历类型检查、SSA 中间代码生成以及机器码生成三个部分：</p>
<ol>
<li>检查常量、类型和函数的类型；</li>
<li>处理变量的赋值；</li>
<li>对函数的主体进行类型检查；</li>
<li>决定如何捕获变量；</li>
<li>检查内联函数的类型；</li>
<li>进行逃逸分析；</li>
<li>将闭包的主体转换成引用的捕获变量；</li>
<li>编译顶层函数；</li>
<li>检查外部依赖的声明；</li>
</ol>
<p>对整个编译过程有一个顶层的认识之后，我们重新回到词法和语法分析后的具体流程，在这里编译器会对生成语法树中的节点执行类型检查，除了常量、类型和函数这些顶层声明之外，它还会对变量的赋值语句、函数主体等结构进行检查：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>xtop<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
	n <span class="token operator">:=</span> xtop<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token keyword">if</span> op <span class="token operator">:=</span> n<span class="token punctuation">.</span>Op<span class="token punctuation">;</span> op <span class="token operator">!=</span> ODCL <span class="token operator">&amp;&amp;</span> op <span class="token operator">!=</span> OAS <span class="token operator">&amp;&amp;</span> op <span class="token operator">!=</span> OAS2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>op <span class="token operator">!=</span> ODCLTYPE <span class="token operator">||</span> <span class="token operator">!</span>n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Name<span class="token punctuation">.</span>Param<span class="token punctuation">.</span>Alias<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		xtop<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ctxStmt<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>xtop<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
	n <span class="token operator">:=</span> xtop<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token keyword">if</span> op <span class="token operator">:=</span> n<span class="token punctuation">.</span>Op<span class="token punctuation">;</span> op <span class="token operator">==</span> ODCL <span class="token operator">||</span> op <span class="token operator">==</span> OAS <span class="token operator">||</span> op <span class="token operator">==</span> OAS2 <span class="token operator">||</span> op <span class="token operator">==</span> ODCLTYPE <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Name<span class="token punctuation">.</span>Param<span class="token punctuation">.</span>Alias <span class="token punctuation">&#123;</span>
		xtop<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ctxStmt<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类型检查会遍历传入节点的全部子节点，这个过程会对 <code>make</code> 等关键字进行展开和重写，在类型检查会改变语法树中的一些节点，不会生成新的变量或者语法树，这个过程的结束也意味着源代码中已经不存在语法错误和类型错误，中间代码和机器码都可以根据抽象语法树正常生成了。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token function">initssaconfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">peekitabs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>xtop<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		n <span class="token operator">:=</span> xtop<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> n<span class="token punctuation">.</span>Op <span class="token operator">==</span> ODCLFUNC <span class="token punctuation">&#123;</span>
			<span class="token function">funccompile</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">compileFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> i<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> externdcl <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> n<span class="token punctuation">.</span>Op <span class="token operator">==</span> ONAME <span class="token punctuation">&#123;</span>
			externdcl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>externdcl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ctxExpr<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">checkMapKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在主程序运行的最后，会将顶层的函数编译成中间代码并根据目标的 CPU 架构生成机器码，不过在这一阶段也有可能会再次对外部依赖进行类型检查以验证正确性。</p>
<h2><span id="参考">参考</span></h2><ol>
<li><p>抽象语法树 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:1">↩︎</a></p>
</li>
<li><p>静态单赋值 <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:2">↩︎</a></p>
</li>
<li><p>编译器一般分为前端和后端，其中前端的主要工作是将源代码翻译成编程语言无关的中间表示，而后端主要负责目标代码的优化和生成。 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:3">↩︎</a></p>
</li>
<li><p>指令集架构是计算机的抽象模型，也被称作架构或者计算架架构 <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">https://en.wikipedia.org/wiki/Instruction_set_architecture</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:4">↩︎</a></p>
</li>
<li><p><code>SourceFile</code> 表示一个 Go 语言源文件，它由 <code>package</code> 定义、多个 <code>import</code> 语句以及顶层的声明组成 <a href="https://golang.org/ref/spec#Source_file_organization">https://golang.org/ref/spec#Source_file_organization</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:5">↩︎</a></p>
</li>
<li><p>关于 Go 语言文法的是不是 LALR(1) 的讨论 <a href="https://groups.google.com/forum/#!msg/golang-nuts/jVjbH2-emMQ/UdZlSNhd3DwJ">https://groups.google.com/forum/#!msg/golang-nuts/jVjbH2-emMQ/UdZlSNhd3DwJ</a></p>
<p>LALR 的全称是 Look-Ahead LR，大多数的通用编程语言都会使用 LALR 的文法 <a href="https://en.wikipedia.org/wiki/LALR_parser">https://en.wikipedia.org/wiki/LALR_parser</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:6">↩︎</a></p>
</li>
<li><p>WebAssembly 是基于栈的虚拟机的二进制指令，简称 Wasm <a href="https://webassembly.org/">https://webassembly.org/</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:7">↩︎</a></p>
</li>
<li><p>plugin: add Windows support #19282 <a href="https://github.com/golang/go/issues/19282">https://github.com/golang/go/issues/19282</a> <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fnref:8">↩︎</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this</title>
    <url>/2016/10/30/javascript/JavaScript%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[<p>我们由一段代码开始本文的主题。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span> 
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
foo <span class="token operator">===</span> obj<span class="token punctuation">.</span>foo <span class="token comment">//true</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，<code>foo</code>和 <code>obj.foo</code> 实际上是严格相等的，它们是指向同一个代码段。由于 <strong> 上下文环境 </strong> 不同，所以他们运行的结果也不一样。<code>obj.foo</code>的上下文环境就是 <code>this</code> 指向的 <code>obj</code>，而<code>foo</code> 的上下文环境是全局环境。</p>
<a id="more"></a>
<h2><span id="javascript-的内存数据结构">JavaScript 的内存数据结构 </span></h2><p> 我们需要深入到 JavaScript 的内存数据结构去寻找答案。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> foo<span class="token operator">:</span><span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们把一个对象 <code>&#123; foo:1 &#125;</code> 赋值给对象 <code>obj</code>。这个过程实际上是 JavaScript 引擎在内存中生成一个<code>&#123; foo:1 &#125;</code> 然后再把这个对象的内存地址赋值给<code>obj</code>。</p>
<p>这其实就跟 C 语言中的指针概念相似，先分配一块内存，初始化后，把内存的地址赋给一个指针。<code>obj</code>起的就是一个指针的作用，它保存一个地址，JavaScript 引擎读取它时是直接从 <code>obj</code> 中取内存地址，然后再去改地址取原始对象。</p>
<p>原始对象以字典结构存储。对象的每一个属性也都对应一个属性描述对象。<code>value</code>保存的是属性的值。</p>
<h2><span id="函数的内存结构">函数的内存结构 </span></h2><p> 如果属性是一个函数，内存中的数据结构是怎样的？</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个时候函数其实就是属性的值，函数在计算机中实际上就是一段代码段，它占据着一段内存。此时属性的值并不是直接保存这段代码段，而是保存它对应的内存地址，属性是指向这个函数的指针。</p>
<p>那么运行 <code>bar=obj.bar</code> 会发生什么呢？只是把 <code>bar</code> 这个变量也指向了 <code>obj.bar</code> 指向的函数所占据的内存的地址。</p>
<p>所以我们知道了，函数只是一个内存中存储的代码段（执行逻辑），它可以在不同的上下文 (运行环境) 中执行。</p>
<h2><span id="环境变量">环境变量 </span></h2><p> 函数如何获得上下文 (context) 呢？<code>this</code>正是起这个作用。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token comment">// 该代码段被保存于一个内存区域 A</span>

<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  f<span class="token operator">:</span> f<span class="token punctuation">,</span> <span class="token comment">// 指向 A</span>
  x<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// this 指代当前上下文 即全局环境</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// this.x==(global).x==1</span>

<span class="token comment">// this 指代 obj</span>
obj<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// this.x==obj.x==2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行函数的时候会检查调用函数的指针的上下文，而函数中的 <code>this</code> 指代的正是这个函数指针所在的上下文。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的事件模型</title>
    <url>/2016/12/03/javascript/JavaScript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2><span id="监听函数">监听函数 </span></h2><p> 浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h3><span id="html-的-on-属性">HTML 的 on- 属性</span></h3><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>doSomething()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>console.log(<span class="token punctuation">'</span>触发事件<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面代码为 <code>body</code> 节点的 <code>load</code> 事件、<code>div</code>节点的 <code>click</code> 事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是 <code>on</code> 加上事件名，比如 <code>onload</code> 就是 <code>on + load</code>，表示<code>load</code> 事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 正确 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>doSomething()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

<span class="token comment">&lt;!-- 错误 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>doSomething<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>console.log(2)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>console.log(1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>&lt;button&gt;</code>是 <code>&lt;div&gt;</code> 的子元素。<code>&lt;button&gt;</code>的 <code>click</code> 事件，也会触发 <code>&lt;div&gt;</code> 的<code>click</code>事件。由于 <code>on-</code> 属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置 <code>on-</code> 属性，与通过元素节点的 <code>setAttribute</code> 方法设置 <code>on-</code> 属性，效果是一样的。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'onclick'</span><span class="token punctuation">,</span> <span class="token string">'doSomething()'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token comment">// &lt;Element onclick="doSomething()"></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="元素节点的事件属性">元素节点的事件属性 </span></h3><p> 元素节点对象的事件属性，同样可以指定监听函数。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> doSomething<span class="token punctuation">;</span>

div<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'触发事件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p>注意，这种方法与 HTML 的 <code>on-</code> 属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h3><span id="eventtargetaddeventlistener">EventTarget.addEventListener()</span></h3><p>所有 DOM 节点实例都有 <code>addEventListener</code> 方法，用来为该节点定义事件的监听函数。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>addEventListener</code>方法的详细介绍，参见 <code>EventTarget</code> 章节。</p>
<h3><span id="小结">小结 </span></h3><p> 上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次 <code>onclick</code> 属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种 <code>EventTarget.addEventListener</code> 是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如 <code>window</code>、<code>XMLHttpRequest</code> 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h2><span id="this-的指向">this 的指向 </span></h2><p> 监听函数内部的 <code>this</code> 指向触发事件的那个元素节点。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"btn"</span> onclick<span class="token operator">=</span><span class="token string">"console.log(this.id)"</span><span class="token operator">></span>点击<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// HTML 代码如下</span>
<span class="token comment">// &lt;button id="btn">点击 &lt;/button></span>
<span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 写法一</span>
btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h2><span id="事件的传播">事件的传播 </span></h2><p> 一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段 </strong>：从<code>window</code> 对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li><strong>第三阶段 </strong>：从目标节点传导回<code>window</code> 对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个 <code>&lt;p&gt;</code> 节点。</p>
<p>如果对这两个节点，都设置 <code>click</code> 事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对 <code>&lt;p&gt;</code> 点击，<code>click</code>事件会触发四次。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> phases <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'capture'</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span>
  <span class="token number">3</span><span class="token operator">:</span> <span class="token string">'bubble'</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

div<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> tag <span class="token operator">=</span> event<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>tagName<span class="token punctuation">;</span>
  <span class="token keyword">var</span> phase <span class="token operator">=</span> phases<span class="token punctuation">[</span>event<span class="token punctuation">.</span>eventPhase<span class="token punctuation">]</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Tag:'"</span> <span class="token operator">+</span> tag <span class="token operator">+</span> <span class="token string">"'. EventPhase:'"</span> <span class="token operator">+</span> phase <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 点击以后的结果</span>
<span class="token comment">// Tag: 'DIV'. EventPhase: 'capture'</span>
<span class="token comment">// Tag: 'P'. EventPhase: 'target'</span>
<span class="token comment">// Tag: 'P'. EventPhase: 'target'</span>
<span class="token comment">// Tag: 'DIV'. EventPhase: 'bubble'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各 1 次，<code>&lt;p&gt;</code>节点的目标阶段触发了 2 次。</p>
<ol>
<li>捕获阶段：事件从 <code>&lt;div&gt;</code> 向<code>&lt;p&gt;</code>传播时，触发 <code>&lt;div&gt;</code> 的<code>click</code>事件；</li>
<li>目标阶段：事件从 <code>&lt;div&gt;</code> 到达 <code>&lt;p&gt;</code> 时，触发 <code>&lt;p&gt;</code> 的<code>click</code>事件；</li>
<li>冒泡阶段：事件从 <code>&lt;p&gt;</code> 传回 <code>&lt;div&gt;</code> 时，再次触发 <code>&lt;div&gt;</code> 的<code>click</code>事件。</li>
</ol>
<p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为 <code>click</code> 事件触发一次。所以，<code>&lt;p&gt;</code>会在 <code>target</code> 阶段有两次输出。</p>
<p>注意，浏览器总是假定 <code>click</code> 事件的目标节点，就是点击位置嵌套最深的那个节点（本例是 <code>&lt;div&gt;</code> 节点里面的 <code>&lt;p&gt;</code> 节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为 <code>target</code> 阶段。</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<h2><span id="事件的代理">事件的代理 </span></h2><p> 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// some code</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>click</code>事件的监听函数定义在 <code>&lt;ul&gt;</code> 节点，但是实际上，它处理的是子节点 <code>&lt;li&gt;</code> 的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个 <code>&lt;li&gt;</code> 节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的 <code>stopPropagation</code> 方法。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 事件传播到 p 元素后，就不再向下传播了</span>
p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span>
p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发 <code>&lt;p&gt;</code> 节点的其他 <code>click</code> 事件的监听函数。也就是说，不是彻底取消 <code>click</code> 事件。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 会触发</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>p</code>元素绑定了两个 <code>click</code> 事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是 1，然后是 2。</p>
<p>如果想要彻底取消该事件，不再触发后面所有 <code>click</code> 的监听函数，可以使用 <code>stopImmediatePropagation</code> 方法。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  event<span class="token punctuation">.</span><span class="token function">stopImmediatePropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 不会被触发</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有 <code>click</code> 监听函数都不再触发。所以，只会输出 1，不会输出 2。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的原型继承</title>
    <url>/2017/07/12/javascript/JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2><span id="javascript-继承">JavaScript 继承 </span></h2><p> 一般的面向对象的语言对继承的处理方式都是 class-based，即基于类的继承。一般是说子类继承了父类，继承的主体是类。而类的对象之间的继承体现于类的继承中。</p>
<p>以 Java 为例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 父类 A</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 子类 B 继承了父类 A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 JavaScript 的世界中则并非如此。JS 通过原型链的方式来实现继承，是基于对象的继承。下例中 b 对象继承了 a 对象的所有属性和方法。</p>
<a id="more"></a>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function People(sex) &#123;
    this.sex &#x3D; sex;
    this.say &#x3D; function () &#123;
        console.log(this.sex);
    &#125;
&#125;
let a &#x3D; new People(&quot;man&quot;); &#x2F;&#x2F; 实例化 a 对象
let b &#x3D; Object.create(a);  &#x2F;&#x2F;b 对象继承 a 对象，继承了 a 的属性和方法
console.log(b.sex); &#x2F;&#x2F;man
b.say(); &#x2F;&#x2F;man<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里我们可以说，a 对象是 b 对象的原型。这样的继承方法不需要类，继承在对象之间完成。</p>
<h2><span id="原型继承机制">原型继承机制 </span></h2><p> 对象进行属性查找时，优先查找自己的属性，如果没有查找到再去查找对象的原型上的属性。如果原型对象依旧没有找到，那么递归查找指导原型根部，如果依旧没有找到那么返回<code>undefined</code>。</p>
<pre class="line-numbers language-flow" data-language="flow"><code class="language-flow">st<span class="token operator">=></span>start<span class="token operator">:</span> 对象 a
op<span class="token operator">=></span>operation<span class="token operator">:</span> 查找属性 p
cond<span class="token operator">=></span>condition<span class="token operator">:</span> 是否有属性 p
sub1<span class="token operator">=></span>subroutine<span class="token operator">:</span> 转到对象 a 的继承的原型对象
io<span class="token operator">=></span>inputoutput<span class="token operator">:</span> 返回属性 p
e<span class="token operator">=></span>end<span class="token operator">:</span> 结束

st<span class="token operator">-</span><span class="token operator">></span>op<span class="token operator">-</span><span class="token operator">></span>cond
<span class="token function">cond</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>io<span class="token operator">-</span><span class="token operator">></span>e
<span class="token function">cond</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">sub1</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是原型链的思想，层层往上一级链条上查找。</p>
<p>ES5 中，可以通过 <code>Object.getPrototypeOf(obj)</code> 来获取<code>obj</code> 对象的原型，在 Chrome 浏览器中也可以使用非标准的<code>obj.__proto__</code>。</p>
<p>JS 中定义一个类的是通过声明一个函数来实现，这个函数也称为构造器。JS 中的构造器有一个特殊的属性(函数也是对象，所以也有属性) ———— <code>prototype</code>。此 <code>prototype</code> 用来定义通过构造器构造出来的对象的原型，构造器内部的代码用来给对象初始化。如下</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function People(name) &#123;
    this.name &#x3D; name;
&#125;
console.log(People.prototype); 
&#x2F;&#x2F;&#123;constructor: People&#125; People.prototype 的构造器为 People
People.prototype.say &#x3D; function() &#123;
    console.log(this.name);
&#125;
People.prototype.sex &#x3D; &quot;female&quot;;
let p1 &#x3D; new People(&quot;soda&quot;);
p1.constructor &#x2F;&#x2F;People
p1.sex &#x2F;&#x2F;female
p1.say(); &#x2F;&#x2F;soda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看出 <code>p1</code> 对象获得了 <code>People.prototype</code> 的属性和方法。实际上，通过 <code>new People()</code>，<code>p1</code> 以<code>People</code>的 <code>prototype</code> 为原型来创建了一个新对象，并获得了该原型的全部属性和方法。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">p1 &#x3D; new People() &#x2F;&#x2F; 等价于
p1 &#x3D; Object.create(People.prototype) &#x2F;&#x2F; 用 People 的 prototype 作为原型来创建一个新对象
People.apply(p1, &quot;soda&quot;) &#x2F;&#x2F; 执行构造器用来初始化，构造器中的 this 指向 p1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>p1</code>的原型是 <code>People.prototype</code>，<code>p1</code> 是<code>People</code>构造 (new) 出来的。</p>
<p>为了让 <code>p1.constructor</code> 能构正确执行 <code>p1</code> 的构造器，一个构造器默认的 <code>prototype</code> 上已经存在 <code>constructor</code> 属性，并且指向构造器本身。</p>
<p>⚠️ <code>People.prototype</code>并非 <code>People</code> 的原型，而是 <code>People</code> 构造的对象的原型，即 <code>p1</code> 的原型。<code>People</code>本身是一个 <code>Function</code> 类型，你可以把它理解为一个 <code>Function</code> 构造出来的对象，它的原型是 <code>Object.getPrototypeOf(People)</code> 或<code>People.__proto__</code>。 因为 <code>People</code> 是一个函数对象，所有函数都构造自 <code>Function</code>，原型是 <code>Function.prototype</code>。<code>People.prototype</code> 是 <code>People</code> 构造出来的实例的原型，不是 <code>People</code> 的原型。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">People.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype
&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="探究-constructor">探究 constructor</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Foo() &#123;&#125;
let foo &#x3D; new Foo();
foo.constructor &#x3D;&#x3D;&#x3D; Foo.prototype.constructor &#x2F;&#x2F;true
foo.constructor &#x3D;&#x3D;&#x3D; Foo &#x2F;&#x2F; true
Foo.constructor &#x3D;&#x3D;&#x3D; Object.constructor &#x2F;&#x2F; true
Object.constructor &#x3D;&#x3D;&#x3D; Function.constructor &#x2F;&#x2F; true
Function.constructor &#x3D;&#x3D;&#x3D; Function &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个样例我们可以得知三个信息，</p>
<ul>
<li><p><strong>对于 <code>foo</code> 对象而言，<code>Foo</code>函数是其构造器，<code>foo</code>是 <code>Foo</code> 函数构造的对象。</strong></p>
</li>
<li><p><strong>对于一切函数 <code>fn</code> 而言，<code>Function</code>是它们的构造器，<code>fn</code>是 <code>Function</code> 函数构造的对象，函数也是一种特殊的对象。</strong></p>
</li>
<li><p><strong><code>Function</code>的构造器是 <code>Function</code> 本身。<code>Function</code>既是对象，又是函数。</strong></p>
</li>
</ul>
<p>那么我们可以推断出什么？</p>
<p>因为所有的函数都有同一个构造器，所以所有的函数都有同一个原型，这个原型就是 <code>Function</code> 类的原型<code>Function.prototype</code></p>
<p>即 <code>Object.getPrototypeOf(fn) === Function.prototype</code>，<strong> 所有的函数都是一个类</strong>。</p>
<h2><span id="function-的双重性">Function 的双重性</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">Function.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true
Object.getPrototypeOf(Function) &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等式的左边的 <code>Function</code> 作为对象，求 <code>Function</code> 对象继承的原型</p>
<p>等式的右边的 <code>Funciton</code> 作为构造器，求 <code>Function</code> 类的原型</p>
<p>而对于一般的函数来说则不能这么比较</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Flower()&#123;&#125;
let flower &#x3D; new Flower()
flower.__proto__ &#x3D;&#x3D;&#x3D; Flower.prototype  &#x2F;&#x2F;true
Flower.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以 <code>Function</code> 是一种特殊的函数，也是一种特殊的对象。</p>
<ul>
<li>它的构造器是它的自身。</li>
<li>它与所有的函数继承同一个原型。</li>
<li>所有的函数都由 <code>Function</code> 来构造。</li>
</ul>
<h2><span id="object-与-function">Object 与 Function</span></h2><p>聊完 <code>Function</code> 再来聊聊 <code>Object</code>，JavaScript 原生提供<code>Object</code> 对象。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Foo()&#123;&#125;
let foo &#x3D; new Foo();
let obj &#x3D; new Object();
foo.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F;true
foo.__proto__.__proto__ &#x3D;&#x3D;&#x3D; obj.__proto__ &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，所有的对象都继承自 <code>Object</code> 对象。</p>
<p><code>Object</code>是所有 <code>Object</code> 对象的构造器，而根据 <code>Function</code> 的有趣性质，我们可以获得下面的结果</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">Object instanceof Function &#x2F;&#x2F; true
Function instanceof Object &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>首先，我们需要弄清楚 <code>instanceof</code> 的原理</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">instance instanceof People &#x2F;&#x2F; 等价于

function instanceOf(instance, prototype) &#123;
    var proto &#x3D; Object.getPrototype(instance); &#x2F;&#x2F; 取对象原型
    if(proto &#x3D;&#x3D;&#x3D; null) return false; &#x2F;&#x2F; 空
    if(proto &#x3D;&#x3D;&#x3D; prototype) return true; &#x2F;&#x2F; 原型匹配
    return instanceOf(proto, prototype); &#x2F;&#x2F; 递归检查原型的原型
&#125;

instance(instance, People.prototype);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JavaScript 中的继承概念归根到底是原型的继承，那么 <code>instanceof</code> 实际上就是将 <code>instance</code> 的原型与构造器的 <code>prototype</code> 进行递归检查。</p>
<p><code>Object</code>是一个构造器，一个函数，而函数也是一个对象，这个对象由 <code>Function</code> 这个构造器构造，所以</p>
<p><code>Object.__proto__ === Function.prototype</code> 上式成立</p>
<p> <code>Function</code>是一个函数，一个对象，而所有的对象都是继承于 <code>Object</code> 对象的原型，</p>
<p><code>Function.__proto__ === Object.prototype</code> 下式成立</p>
<h2><span id="总结">总结</span></h2><ul>
<li>JavaScript 的继承是通过原型链继承来实现的</li>
<li>所有的函数都是对象，它们的构造器是<code>Function</code></li>
<li><code>Function</code>是自身的构造器</li>
<li>所有的对象的最终原型是 <code>Object.prototype</code>，即所有的对象都继承于<code>Object</code> 对象</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的变量提升</title>
    <url>/2017/07/20/javascript/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>JavaScript 的设计不同于传统编程语言，它自成一派，有很多的奇妙特性。</p>
<p>今天就来聊聊变量提升。</p>
<h2><span id="变量提升是什么">变量提升是什么 </span></h2><p>ES5 之前，JavaScript 实际上并不存在块级作用域。JavaScript 引擎对 JavaScript 中<code>var</code> 类型变量的声明的处理方式是：</p>
<ul>
<li>如果变量在函数外部声明，那么该变量会被提到全局作用域顶端</li>
<li>如果变量在函数内部声明，那么该变量会被提到函数作用域顶端<a id="more"></a>
</li>
</ul>
<h3><span id="函数外部作用域">函数外部作用域</span></h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OUTPUT : undefined</span>
<span class="token keyword">var</span> shape <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OUTPUT : square</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果按照 C 语言的逻辑，第 1 行的 <code>console.log</code> 引用了未声明的变量，应该发生错误。但实际上却输出 <code>undefined</code>，也就是说实际上这里<code>shape</code> 已经被声明了，只是没有初始化赋值而已。</p>
<p>这就是变量提升。实际上上面的代码会被 JS 引擎识别为这样</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> shape<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OUTPUT : undefined</span>
shape <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OUTPUT : square</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="函数内部作用域">函数内部作用域</span></h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token parameter">condition</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OUTPUT : undefined</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">var</span> shape <span class="token operator">=</span> square<span class="token punctuation">;</span>
        <span class="token keyword">return</span> shape<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，JS 没有块级作用域，所以与 C 语言不同，在 <code>if</code> 语句中声明的 <code>shape</code> 变量会由于变量提升，而被提到 <code>getShape</code> 的顶端。变成下面这样</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token parameter">condition</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> shape<span class="token punctuation">;</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OUTPUT : undefined</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        shape <span class="token operator">=</span> square<span class="token punctuation">;</span>
        <span class="token keyword">return</span> shape<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="es6-块级作用域">ES6 块级作用域 </span></h2><p>ES6 引入了块级作用域，这让开发者对变量有了更多的控制，且让变量有灵活的生命周期。<br> 块级声明在块级 / 词法作用域里面声明，他们在“<code>&#123;&#125;</code>”中被创建。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token parameter">condition</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// shape doesn't exist here</span>
  <span class="token comment">// console.log(shape); ReferenceError: shape is not defined</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> shape <span class="token operator">=</span> square<span class="token punctuation">;</span>
    <span class="token comment">// some other code</span>
    <span class="token keyword">return</span> shape<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// shape doesn't exist here as well</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里我们不用 <code>var</code> 而用 <code>let</code> 来声明我们的变量，<code>let</code>就更类似于传统编程语言中的变量声明，它具有块级作用域。</p>
<blockquote>
<p>在同一个作用域内，如果已经使用 var 标识符声明了变量，同时又用 let 标识符声明同名变量时会抛出错误。但是，如果在 let 声明的变量作用域外，声明同名变量是不会报错的。（这种情况也同样适用于我们即将谈论的 const 声明。）</p>
</blockquote>
<p>这其实可以用局部作用域来理解，<code>let</code>只在它声明的那个块级作用域有效，这与 C/C++ 这类传统编程语言中的局部作用域的特性很类似。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> shape <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> shape <span class="token operator">=</span> <span class="token string">"rectangle"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> shape <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// doesn't throw an error</span>
  <span class="token keyword">let</span> shape <span class="token operator">=</span> <span class="token string">"rectangle"</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>
<span class="token comment">// No error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="const">const</span></h2><p><code>const</code>声明语法与 <code>let</code> 和<code>var</code>相似，生命周期与 <code>let</code> 相同，但你还要注意一些规则。<br>用 <code>const</code> 声明的变量将像 <strong> 常量 </strong> 看待，因此 <strong> 它们的值在定义后是不可以修改的 </strong>。由于这样，每个<code>const</code> 变量都 <strong> 必须在声明的同时进行初始化</strong>。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token string">"triangle"</span><span class="token punctuation">;</span><span class="token comment">// valid </span>
<span class="token keyword">const</span> color<span class="token punctuation">;</span> <span class="token comment">// syntax error: missing initialization</span>
shape <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Assignment to constant variable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但在声明对象时，对象的属性可以被修改。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">"triangle"</span><span class="token punctuation">,</span>
    sides<span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span>
shape<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"square"</span><span class="token punctuation">;</span> <span class="token comment">// ok </span>
shape<span class="token punctuation">.</span>sides <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> hexagon<span class="token punctuation">,</span>
    sides<span class="token operator">:</span> <span class="token number">6</span>
<span class="token punctuation">&#125;</span> <span class="token comment">// SyntaxError: Invalid shorthand property initializer</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以 <code>const</code> 可以防止整个绑定的修改，而不是绑定的值。</p>
<h2><span id="暂时性死区">暂时性死区 </span></h2><p><strong> 使用 <code>let</code> 或<code>const</code>声明的时候，它们并不会变量提升 </strong>，所以在它们被声明之前，使用它们会抛出<code>ReferenceError</code> 错误。</p>
<p>在进入作用域和不能访问的这段时间，我们称为暂时性死区。<br>提示：“暂时性死区”不是 ECMAScript 规范里的正式定义，它只是在程序员中广为流行而已。</p>
<h2><span id="建议">建议 </span></h2><p> 如果你对 <code>var</code> 的特性十分了解，那么可以在项目中使用它，但不推荐，因为不利于维护。</p>
<p><code>let</code>和 <code>const</code> 已经完全可以代替 <code>var</code> 的使用，这是更加符合程序员认知的用法。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 JavaScript 异步编程</title>
    <url>/2017/01/04/javascript/JavaScript%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="一-单线程">一. 单线程 </span></h2><p> 我们常说“JavaScript 是单线程的”。</p>
<p>所谓单线程，是指在 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个。不妨叫它 <strong> 主线程</strong>。</p>
<p>但是实际上还存在其他的线程。例如：处理 AJAX 请求的线程、处理 DOM 事件的线程、定时器线程、读写文件的线程 (例如在 Node.js 中) 等等。这些线程可能存在于 JS 引擎之内，也可能存在于 JS 引擎之外，在此我们不做区分。不妨叫它们 <strong> 工作线程</strong>。</p>
<a id="more"></a>
<h2><span id="二-同步和异步">二. 同步和异步 </span></h2><p> 假设存在一个函数 A：</p>
<pre class="line-numbers language-none"><code class="language-none">A(args...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>同步</strong>：如果在函数 A 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Math.sqrt(2);
console.log(&#39;Hi&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>第一个函数返回时，就拿到了预期的返回值：2 的平方根。</li>
<li>第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。</li>
</ul>
<p>所以这两个函数都是同步的。</p>
<p><strong>异步</strong>：如果在函数 A 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">fs.readFile(&#39;foo.txt&#39;, &#39;utf8&#39;, function(err, data) &#123;
    console.log(data);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们希望通过 <code>fs.readFile</code> 函数读取文件 foo.txt 中的内容，并打印出来。<br>但是在 <code>fs.readFile</code> 函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。</p>
<p>下面以 AJAX 请求为例，来看一下同步和异步的区别：</p>
<ul>
<li>异步 AJAX：</li>
</ul>
<blockquote>
<ul>
<li><strong>主线程：</strong>“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。”</li>
<li><strong>AJAX 线程：</strong>“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。”</li>
<li><strong>主线程：</strong>：“谢谢，你拿到响应后告诉我一声啊。”</li>
<li>(接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。)</li>
</ul>
</blockquote>
<ul>
<li>同步 AJAX：</li>
</ul>
<blockquote>
<ul>
<li><strong>主线程：</strong>“你好，AJAX 线程。请你帮我发个 HTTP 请求吧，我把请求地址和参数都给你了。”</li>
<li><strong>AJAX 线程：</strong>“……”</li>
<li><strong>主线程：</strong>：“喂，AJAX 线程，你怎么不说话？”</li>
<li><strong>AJAX 线程：</strong>“……”</li>
<li><strong>主线程：</strong>：“喂！喂喂喂！”</li>
<li><strong>AJAX 线程：</strong>“……”</li>
<li>(一炷香的时间后)</li>
<li><strong>主线程：</strong>：“喂！求你说句话吧！”</li>
<li><strong>AJAX 线程：</strong>“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。”</li>
</ul>
</blockquote>
<p>正是由于 JavaScript 是单线程的，而异步容易实现非阻塞，所以在 JavaScript 中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。异步是这篇文章关注的重点。</p>
<h2><span id="三-异步过程的构成要素">三. 异步过程的构成要素 </span></h2><p> 从上文可以看出，<code>异步函数 </code> 实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做 <code> 异步过程</code>。异步函数的调用在整个异步过程中，只是一小部分。</p>
<p>总结一下，一个异步过程通常是这样的：</p>
<blockquote>
<p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
</blockquote>
<p>异步函数通常具有以下的形式：</p>
<pre class="line-numbers language-none"><code class="language-none">A(args..., callbackFn)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数)<code>A</code></li>
<li>回调函数<code>callbackFn</code></li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p>
<p>举个具体的例子：</p>
<pre class="line-numbers language-none"><code class="language-none">setTimeout(fn, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中的 <code>setTimeout</code> 就是异步过程的发起函数，<code>fn</code>是回调函数。</p>
<p>注意：前面说的形式 <code>A(args..., callbackFn)</code> 只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">var xhr &#x3D; new XMLHttpRequest();
xhr.onreadystatechange &#x3D; xxx; &#x2F;&#x2F; 添加回调函数
xhr.open(&#39;GET&#39;, url);
xhr.send(); &#x2F;&#x2F; 发起函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>发起函数和回调函数就是分离的。</p>
<h2><span id="四-消息队列和事件循环">四. 消息队列和事件循环 </span></h2><p> 上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个 <strong> 通知机制 </strong> 是怎样实现的呢？答案是利用消息队列和事件循环。</p>
<p>用一句话概括：</p>
<blockquote>
<p>工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。</p>
</blockquote>
<ul>
<li><strong>消息队列</strong>：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li><strong>事件循环</strong>：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>
</ul>
<p>实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。</p>
<p>事件循环用代码表示大概是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">while(true) &#123;
    var message &#x3D; queue.get();
    execute(message);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么，消息队列中放的 <strong> 消息 </strong> 具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为：</p>
<blockquote>
<p>消息就是注册异步任务时添加的回调函数。</p>
</blockquote>
<p>再次以异步 AJAX 为例，假设存在如下的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">$.ajax(&#39;http:&#x2F;&#x2F;segmentfault.com&#39;, function(resp) &#123;
    console.log(&#39; 我是响应：&#39;, resp);
&#125;);

&#x2F;&#x2F; 其他代码
...
...
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主线程在发起 AJAX 请求后，会继续执行其他代码。AJAX 线程负责请求 segmentfault.com，拿到响应后，它会把响应封装成一个 JavaScript 对象，然后构造一条消息：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 消息队列中的消息就长这个样子
var message &#x3D; function () &#123;
    callbackFn(response);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中的 <code>callbackFn</code> 就是前面代码中得到成功响应时的回调函数。</p>
<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息 (也就是<code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code> 通知</code>，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>
<p>用图表示这个过程就是：</p>
<p><img src="https://segmentfault.com/img/bVxLvF" alt="图片描述"></p>
<p>从上文中我们也可以得到这样一个明显的结论，就是：</p>
<blockquote>
<p>异步过程的回调函数，一定不在当前这一轮事件循环中执行。</p>
</blockquote>
<h2><span id="五-异步与事件">五. 异步与事件 </span></h2><p> 上文中说的“事件循环”，为什么里面有个 <code> 事件 </code> 呢？那是因为：</p>
<blockquote>
<p>消息队列中的每条消息实际上都对应着一个事件。</p>
</blockquote>
<p>上文中一直没有提到一类很重要的异步过程：<strong>DOM 事件</strong>。</p>
<p>举例来说：</p>
<pre class="line-numbers language-none"><code class="language-none">var button &#x3D; document.getElement(&#39;#btn&#39;);
button.addEventListener(&#39;click&#39;, function(e) &#123;
    console.log();
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。</p>
<p>从异步过程的角度看，<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。</p>
<p><strong>事件 </strong> 的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。</p>
<p>另一方面，所有的异步过程也都可以用事件来描述。例如：<code>setTimeout</code>可以看成对应一个 <code> 时间到了！</code>的事件。前文的 <code>setTimeout(fn, 1000);</code> 可以看成：</p>
<pre class="line-numbers language-none"><code class="language-none">timer.addEventListener(&#39;timeout&#39;, 1000, fn);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="六-生产者与消费者">六. 生产者与消费者 </span></h2><p> 从生产者与消费者的角度看，异步过程是这样的：</p>
<blockquote>
<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>
</blockquote>
<h2><span id="七-总结一下">七. 总结一下 </span></h2><p> 最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p>
<p>这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 :)</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 词法分析</title>
    <url>/2017/01/23/javascript/JavaScript%E4%B9%8B%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>JavaScript 引擎在代码执行前会进行词法分析，词法分析主要有三个步骤：</p>
<p>分析参数 -&gt; 分析变量的声明 -&gt; 分析函数声明</p>
<h2><span id="词法分析过程">词法分析过程</span></h2><p>JavaScript 函数在运行的瞬间，会生成一个活动对象 AO（Active Object），举个例子</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'mary'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>第一步：分析参数：</strong></p>
<ol>
<li>函数接收形式参数，添加到 AO 的属性，并且这个时候值为<code>undefined</code>, 即<code>AO.name=undefined</code></li>
<li>接收实参<code>&quot;abc&quot;</code>，添加到 AO 的属性，覆盖之前的<code>undefined</code>，即<code>AO.name=&#39;abc&#39;</code></li>
</ol>
<p><strong>第二步：分析变量声明：</strong>如 <code>var name;</code> 或<code>var name=&#39;mary&#39;</code>;</p>
<ol>
<li>如果上一步分析参数中 AO 还没有 name 属性，则添加 AO 属性为<code>undefined</code>，即<code>AO.name=undefined</code></li>
<li>如果 AO 上面已经有 name 属性了，则不作任何修改，此时<code>AO.name===&#39;mary&#39;</code></li>
</ol>
<p><strong>第三步：分析函数的声明：</strong></p>
<p>如果有 <code>function name()&#123;&#125;</code> 把函数赋给<code>AO.name</code> , 覆盖上一步分析的值</p>
<h2><span id="实例">实例 </span></h2><p> 分析下面这个栗子：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//function a ()&#123;&#125;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//20</span>
    <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//20</span>
<span class="token punctuation">&#125;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一步，分析函数参数：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">AO.a &#x3D; undefined &#x2F;&#x2F; 形式参数
AO.a &#x3D; 100 &#x2F;&#x2F; 接收实参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第二步，分析局部变量：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">第 4 行代码有 var a, 但是此时已有 AO.a &#x3D; 100, 所以不做任何修改，即 AO.a &#x3D; 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第三步，分析函数声明：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">第 6 行代码有函数 a, 则将 function a()&#123;&#125; 赋给 AO.a, 即 AO.a &#x3D; function a()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行代码时：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">第 3 行代码运行时拿到的 a 时词法分析后的 AO.a，即 AO.a &#x3D; function a()&#123;&#125;；
第 4 行代码：将 20 赋值给 a, 此时 a&#x3D;20;
第 5 行代码运行时 a 已经被赋值为 20, 结果 20；
第 6 行代码是一个函数表达式，所以不做任何操作；
第 7 行代码运行时仍是 20；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ps:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span>var a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token number">2.</span>function <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token number">3.</span>    <span class="token keyword">var</span> a<span class="token punctuation">;</span>               <span class="token comment">// 证明词法分析第二步。</span>
<span class="token number">4.</span>    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//100</span>
<span class="token number">5.</span>    a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token number">6.</span>    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//20</span>
<span class="token number">7.</span><span class="token punctuation">&#125;</span>
<span class="token number">7.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ps:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//100</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//20</span>
    <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 是赋值，只有在执行时才有效</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//function()&#123;&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ps:(执行结果同上)</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//100</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//20</span>
    <span class="token keyword">var</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 是赋值，只有在执行时才有效</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//function()&#123;&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>补充说明：函数声明与函数表达式</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 函数声明</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 函数表达式</span>
<span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>a 和 b 在词法分析时，区别：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">a 在词法分析时，就发挥作用；
b 只有在执行阶段，才发挥作用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="词法作用域">词法作用域 </span></h2><p> 词法作用域的意思是，作用域为在定义时 (词法分析时) 就确定下来的，而并非在执行时确定。即在函数未执行前，函数执行的顺序已经被确定，而不是类似 JAVA 一样，是在执行前根本不知道执行顺序。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 async</title>
    <url>/2017/07/17/javascript/Javascript%E4%B8%AD%E7%9A%84async/</url>
    <content><![CDATA[<p>异步编程一直是 JavaScript 中的麻烦事，但在浏览器环境中，对异步的支持是必须的。JavaScript 一直都有异步的解决方案。最早是回调函数，但由于连环回调会带来严重的嵌套问题，所以后来换做扁平化的 Promise 解决方案。</p>
<a id="more"></a>
<h2><span id="回调函数">回调函数 </span></h2><h3><span id="过程"> 过程 </span></h3><p> 调用一个函数 f -&gt; 函数 f 执行完毕 -&gt; f 调用回调函数 c </p>
<h3><span id="使用场合">使用场合</span></h3><ul>
<li>资源加载：动态加载 js 文件后执行回调，加载 iframe 后执行回调，ajax 操作回调，图片加载完成执行回调，AJAX 等等。</li>
<li>DOM 事件及 Node.js 事件基于回调机制(Node.js 回调可能会出现多层回调嵌套的问题)。<br>setTimeout 的延迟时间为 0，这个 hack 经常被用到，settimeout 调用的函数其实就是一个 callback 的体现</li>
<li>链式调用：链式调用的时候，在赋值器 (setter) 方法中 (或者本身没有返回值的方法中) 很容易实现链式调用，而取值器 (getter) 相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是 this 指针，如果要实现链式方法，可以用回调函数来实现</li>
<li>setTimeout、setInterval 的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了 setTimeout 及 setInterval 的意义了，所以用 return 已经没有意义，只能使用 callback。callback 的意义在于将 timer 执行的结果通知给代理函数进行及时处理。</li>
</ul>
<h3><span id="作用">作用 </span></h3><p> 传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个 return 返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。</p>
<p>　　但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX 请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在 javascript 中使用异步调用。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> httpRequest<span class="token punctuation">;</span>　　　　<span class="token comment">// 创建 XHR</span>
    httpRequest <span class="token operator">=</span> window<span class="token punctuation">.</span>XMLHttpRequest <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>　　　
　　　　    window<span class="token punctuation">.</span>ActiveXObject <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Microsoft.XMLHTTP"</span>             <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token comment">// 针对 IE 进行功能性检测</span>
    
    httpRequest<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 把回调函数注册到某个事件上</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>httpRequest<span class="token punctuation">.</span>readystate <span class="token operator">===</span> <span class="token number">4</span> 
                <span class="token operator">&amp;&amp;</span> httpRequest<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　<span class="token comment">// 状态判断</span>
          <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>httpRequest<span class="token punctuation">.</span>responseXML<span class="token punctuation">)</span><span class="token punctuation">;</span>  
       <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    httpRequest<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    httpRequest<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"text.xml"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　　　<span class="token comment">// 调用函数</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　<span class="token comment">// 此语句后输出</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"this will run before the above callback."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">// 此语句先输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 call、apply 和 bind</title>
    <url>/2016/10/17/javascript/Javascript%E4%B8%AD%E7%9A%84call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h2><span id="apply-amp-call">apply &amp; call</span></h2><blockquote>
<p>在 JavaScript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的 </p>
</blockquote>
<p><strong>在 JavaScript 中，一切都是对象</strong>，包括函数。函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<a id="more"></a>
<p>例：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function people() &#123;&#125;
 
people.prototype &#x3D; &#123;
    name: &quot;ming&quot;,
    say: function() &#123;
        console.log(&quot;My name is &quot; + this.name);
    &#125;
&#125;
 
var a &#x3D; new people;
a.say();    &#x2F;&#x2F;My name is ming<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时我们有一个对象 <code>b=&#123;name:&quot;su&quot;&#125;</code>，不想重新定义<code>say</code> 方法， 那么可以通过 <code>call</code> 或者 <code>apply</code> 方法。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">b&#x3D;&#123;
	name:&quot;su&quot;
&#125;
a.say.call(b); &#x2F;&#x2F;My name is su
a.say.apply(b); &#x2F;&#x2F;My name is su<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 <code>call</code> 和<code>apply</code>都是为了动态改变 <code>this</code> 而出现的。当一个 <code>object</code> 没有某个方法，可以借助 call 或 apply 用其他对象的方法来操作。</p>
<h3><span id="apply-和-call-的区别">apply 和 call 的区别 </span></h3><p> 对于 <code>apply</code>、<code>call</code> 二者而言，作用完全一样，只是接受参数的方式不太一样。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var func &#x3D; function(arg1, arg2) &#123;
     
&#125;;
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>call</code> 需要把参数按顺序传递进去，而 <code>apply</code> 则是把参数放在数组里。　</p>
<p>明确知道参数数量时用 <code>call</code> 。而不确定的时候用 <code>apply</code>，然后把参数 <code>push</code> 进数组传递进去。当参数数量不确定时，函数内部也可以通过 <code>arguments</code> 这个伪数组来遍历所有的参数。</p>
<ul>
<li><p><strong>数组追加</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var array1 &#x3D; [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458]; 
var array2 &#x3D; [&quot;Doe&quot; , 555 , 100]; 
Array.prototype.push.apply(array1, array2); 
&#x2F;* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>获取数组最大最小值</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var  numbers &#x3D; [5, 458 , 120 , -215]; 
var maxInNumbers &#x3D; Math.max.apply(Math, numbers),   &#x2F;&#x2F;458
    maxInNumbers &#x3D; Math.max.call(Math,5, 458 , 120 , -215); &#x2F;&#x2F;458<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>number</code> 本身没有 <code>max</code> 方法，但是 <code>Math</code> 有，我们就可以借助 <code>call</code> 或者 <code>apply</code> 使用其方法。</p>
</li>
<li><p><strong>验证是否是数组</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">functionisArray(obj)&#123; 
    return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39; ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>类（伪）数组使用数组方法</strong></p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>JavaScript 中存在一种名为伪数组的对象结构。比较特别的是 <code>arguments</code> 对象，还有像调用 <code>getElementsByTagName</code> , <code>document.childNodes</code> 之类的，它们返回 NodeList 对象都属于伪数组。不能应用 <code>Array</code>下的 <code>push</code> , <code>pop</code> 等方法。</p>
<p>但是我们能通过 <code>Array.prototype.slice.call</code>转换为真正的数组的带有 <code>length</code> 属性的对象，这样 domNodes 就可以应用 <code>Array</code> 下的所有方法了。</p>
</li>
</ul>
<h3><span id="实例">实例</span></h3><ul>
<li><p>用 <code>log</code> 来代理<code>console.log</code></p>
<p>由于传入参数不确定，所以普通的方法对于多个参数是失效的。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function log(msg)　&#123;
  console.log(msg);
&#125;
log(1);    &#x2F;&#x2F;1
log(1,2);    &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时 <code>arguments</code> 就派上用场了，可以把 <code>arguments</code> 传入 <code>apply</code> 方法中。</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function log()&#123;
  console.log.apply(console, arguments);
&#125;;
log(1);    &#x2F;&#x2F;1
log(1,2);    &#x2F;&#x2F;1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2><span id="bind">bind</span></h2><p>与 <code>call</code>、<code>apply</code> 一样，<code>bind</code> 也可以改变函数体内 <code>this</code> 的指向。</p>
<blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; &#123;
    bar : 1,
    eventBind: function()&#123;
        var _this &#x3D; this;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            &#x2F;* Act on the event *&#x2F;
            console.log(_this.bar);     &#x2F;&#x2F;1
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 JavaScript 特有的机制，上下文环境在 <code>eventBind:function()&#123; &#125;</code> 过渡到 <code>$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123; &#125;)</code> 发生了改变，上述使用变量保存 <code>this</code> 这些方式都是有用的，也没有什么问题。当然使用 <code>bind()</code> 可以更加优雅的解决这个问题：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var foo &#x3D; &#123;
    bar : 1,
    eventBind: function()&#123;
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;
            &#x2F;* Act on the event *&#x2F;
            console.log(this.bar);      &#x2F;&#x2F;1
        &#125;.bind(this));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述代码里，<code>bind()</code> 创建了一个函数，当这个 <code>click</code> 事件绑定在被调用的时候，它的 <code>this</code> 关键词会被设置成被传入的值（这里指调用 <code>bind()</code> 时传入的参数）。因此，这里我们传入想要的上下文 <code>this</code>(其实就是 foo)，到 <code>bind()</code> 函数中。然后，当回调函数被执行的时候， <code>this</code> 便指向 <code>foo</code> 对象。再来一个简单的栗子：</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var bar &#x3D; function()&#123;
	console.log(this.x);
&#125;
var foo &#x3D; &#123;
	x:3
&#125;
bar(); &#x2F;&#x2F; undefined
var func &#x3D; bar.bind(foo);
func(); &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们创建了一个新的函数 <code>func</code>，当使用 <code>bind()</code> 创建一个绑定函数之后，它被执行的时候，它的 <code>this</code> 会被设置成 <code>foo</code> ， 而不是像我们调用 <code>bar()</code> 时的全局作用域。</p>
<p>如果 <code>bind</code> 多次会如何？</p>
<pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var bar &#x3D; function()&#123;
    console.log(this.x);
&#125;
var foo &#x3D; &#123;
    x:3
&#125;
var sed &#x3D; &#123;
    x:4
&#125;
var func &#x3D; bar.bind(foo).bind(sed);
func(); &#x2F;&#x2F;3
 
var fiv &#x3D; &#123;
    x:5
&#125;
var func &#x3D; bar.bind(foo).bind(sed).bind(fiv);
func(); &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>仍旧输出 3。原因在于 bind()相当使用函数在内部包了一个<code>call/apply</code>，往后 <code>bind()</code> 相当于再包住第一次 <code>bind()</code> , 故第二次以后的 <code>bind</code> 是无法生效的。</p>
<h2><span id="apply-call-bind-比较">apply、call、bind 比较</span></h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var obj &#x3D; &#123;
    x: 81,
&#125;;
 
var foo &#x3D; &#123;
    getX: function() &#123;
        return this.x;
    &#125;
&#125;
 
console.log(foo.getX.bind(obj)());  &#x2F;&#x2F;81
console.log(foo.getX.call(obj));    &#x2F;&#x2F;81
console.log(foo.getX.apply(obj));   &#x2F;&#x2F;81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>三个都可以改变上下文环境，但 <code>bind</code> 并非立刻执行 (需要调用)，而<code>call</code> 和<code>apply</code>都是立即执行。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈 Javascript 模块化</title>
    <url>/2017/01/27/javascript/Javascript%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<p>js 代码 2009 年 HTML5 兴起后，前端代码的行数已经呈现井喷式发展，随着代码量的增加，模块的缺失的缺点日益凸显，Javascript 社区做了很多探索。如今 JavaScript 模块化编程的概念已经普及开来，一提起模块化，大家想到的可能是 AMD，CMD，requirejs 或 seajs。其实还有很多其他的概念。本文将会陈述下 JavaScript 模块的前世今生。</p>
<a id="more"></a>
<h2><span id="模块">模块</span></h2><blockquote>
<p>模块, 又称构件, 是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）</p>
</blockquote>
<p>一个独立的模块需要能够独立完成一个功能，可以引用依赖和被依赖。例如 C 语言中的库和头文件，Java 中的包，等等。</p>
<h2><span id="原始写法">原始写法 </span></h2><p> 一个函数实际上就是一个模块</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 最简单的函数，可以称作一个模块</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个更合理的模拟模块方式</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mod<span class="token punctuation">,</span> $<span class="token punctuation">,</span> _</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	mod<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token operator">**</span><span class="token operator">*</span><span class="token punctuation">;</span>
	mod<span class="token punctuation">.</span>sub <span class="token operator">=</span> <span class="token operator">**</span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>mod <span class="token operator">=</span> window<span class="token punctuation">.</span>mod <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jQuery<span class="token punctuation">,</span> Underscore<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这依旧不完美，因为这个模块必须要先依赖 jQuery 库。理想的情况是，模块的依赖顺序是随意的，我们可以随机顺序指定依赖而不用担心定义先后的问题。</p>
<h2><span id="cmdcommon-module-definition">CMD(Common Module Definition)</span></h2><p>说道 <a href="https://github.com/cmdjs/specification">CMD</a> 就不能不提<a href="http://wiki.commonjs.org/wiki/CommonJS">commonjs</a>，提到 commonjs 就不能不提<a href="http://nodejs.org/">node</a>。</p>
<p>CMD 规范参照 commonjs 中的方式，定义模块的方式如下:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// The module code goes here</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>一个文件就是一个模块，文件名就是模块的名字，使用模块的方法也和 commonjs 中一致，只需 require 就好了，模块名字可省略后缀。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 使用 event.js 模块</span>
<span class="token keyword">var</span> ec <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>CMD 的典型实现就是<a href="http://seajs.org/">seajs</a>，应用的很广泛。</p>
<h2><span id="amdasynchronous-module-definition">AMD(Asynchronous Module Definition)</span></h2><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88">AMD</a>)是异步模块定义，特别适合在浏览器端使用，其规范和 CMD 是很像的，AMD 规范中定义模块的方式如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span>id<span class="token operator">?</span><span class="token punctuation">,</span> dependencies<span class="token operator">?</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同 CMD 一样，一个文件即一个模块，模块的使用方法如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"beta"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">beta</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	bata<span class="token punctuation">.</span><span class="token operator">**</span><span class="token operator">*</span><span class="token comment">// 调用模块</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>AMD 主张依赖注入，这点和 CMD 不同（以来查找）。</p>
<p>AMD 也支持已 CMD 的方式来使用依赖。</p>
<p>AMD 的典型实现有 <a href="http://requirejs.org/">requireJS</a>，<a href="https://github.com/fex-team/mod">modJS</a> 和<a href="https://github.com/yanhaijing/lodjs">lodJS</a>。</p>
<h2><span id="es6">ES6</span></h2><p><a href="http://yanhaijing.com/es5/">ES6</a>带来了语言层面的模块化支持，规范方面见 <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-module-namespace-exotic-objects"> 这里 </a>，文档方面见<a href="http://es6.ruanyifeng.com/#docs/class"> 这里</a>。=</p>
<h2><span id="umd">UMD</span></h2><p><a href="https://github.com/umdjs/umd">UMD</a>的全称是 Universal Module Definition。和它名字的意思一样，这种规范基本上可以在任何一个模块环境中工作。</p>
<p>一段典型的 UMD 代码如下所示：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> Data <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// AMD</span>
        <span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> Data<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Node.js</span>
        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Data<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Browser globals</span>
        <span class="token keyword">var</span> _Data <span class="token operator">=</span> root<span class="token punctuation">.</span>Data<span class="token punctuation">;</span>
        
        Data<span class="token punctuation">.</span><span class="token function-variable function">noConflict</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>Data <span class="token operator">===</span> Data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                root<span class="token punctuation">.</span>Data <span class="token operator">=</span> _Data<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            
            <span class="token keyword">return</span> Data<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>Data <span class="token operator">=</span> Data<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> Data <span class="token operator">=</span> <span class="token operator">...</span>
	<span class="token comment">// 自己的代码</span>
	<span class="token keyword">return</span> Data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是出自 <a href="https://github.com/yanhaijing/data.js">data.js</a> 中的一部分代码，其原理就是做个判断，不同的环境进行不同的处理。</p>
<h2><span id="总结">总结 </span></h2><p> 模块化的探索，使前端工程化成为了可能，可以说没有模块，工程化更无从弹起，</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式协议之 Raft 算法</title>
    <url>/2017/09/28/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8BRaft%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Raft 是一种分布式共识算法。相对于之前的 Paxos 协议，它的设计易于理解。它解决了即使面对故障也使多个服务器在共享状态上达成一致的问题。共享状态通常是复制日志支持的数据结构。只要大多数服务器都处于运行状态，我们就需要系统能够完全运行。</p>
<p>Raft 通过选举集群中的一位 leader 来工作。leader 负责接受 client 请求并管理将日志复制到其他服务器。数据仅在一个方向上流动：从 leader 流向其他服务器。</p>
<a id="more"></a>
<p>Raft 将共识分解为三个子问题：</p>
<ul>
<li>leader 选举：如果现有 leader 失败，则需要选举一名新 leader。</li>
<li>日志复制：leader 需要通过复制使所有服务器的日志与其自己的服务器保持同步。</li>
<li>安全性：如果其中一台服务器已在特定索引上提交了日志条目，则其他任何服务器都无法对该索引应用其他日志条目。</li>
</ul>
<h2><span id="基础">基础 </span></h2><p> 每个服务器都处于以下三种状态之一：leader，follower 或 candidate。</p>
<p><img src="https://i.loli.net/2020/09/09/xoBVRrGPyQzFDAY.png" alt="oN6xZLkKQrVnaWWlp7I8w9aep2NNgMz5fR9D"></p>
<blockquote>
<p>在正常操作中，只有一个 leader，其他所有服务器都是 follower。follower 是被动的：他们自己不发出请求，而只是响应 leader 和 candidate 的请求。leader 处理所有客户请求（如果客户联系 follower，则 follower 将其重定向到 leader）。第三种状态，candidate，用于选举新 leader。</p>
</blockquote>
<p>Raft 将时间分为任意长度，每个长度以选举开始。如果 candidate 赢得选举，则在剩余任期中仍将是 leader。如果表决分裂，则该任期在没有 leader 的情况下结束。</p>
<p><strong>term 号 </strong> 单调增加。每个服务器存储当前的 term 编号，该编号也在每次通信中交换。</p>
<blockquote>
<p>.. 如果一台服务器的当前期限小于另一台服务器，则它将其当前期限更新为较大的值。如果 candidate 或 leader 发现其任期已过时，它将立即恢复为 follower 状态。如果服务器收到带有过期条款编号的请求，则该服务器将拒绝该请求。</p>
</blockquote>
<p>Raft 利用两个远程过程调用（RPC）来执行其基本操作。</p>
<p>candidate 在选举期间使用 RequestVotes<br>leader 将 AppendEntries 用于复制日志条目，并用作检测信号（检查服务器是否已启动的信号 - 它不包含任何日志条目）</p>
<h2><span id="leader-选举">leader 选举</span></h2><p>leader 定期向其 follower 发送心跳，以保持权威。当 follower 在等待 leader 的心跳后超时时，将触发 leader 选举。该 follower 转换为 candidate 状态并增加其任期编号。在为自己投票之后，它与集群中的其他进程并行地发出 RequestVotes RPC。可能有以下三种结果：</p>
<ol>
<li>candidate 从大多数服务器中获得选票并成为 leader。然后，它将心跳消息发送给集群中的其他人以建立权限。</li>
<li>如果其他 candidate 收到 AppendEntries RPC，他们将检查 term 号。如果 term 号大于自己的 term 号，则他们接受服务器作为 leader 并返回到 follower 状态。如果 term 号数量较小，则他们拒绝 RPC，并且仍然是 candidate。</li>
<li>candidate 既不输也不赢。如果同时有多个服务器成为 candidate 服务器，则可以在没有明显多数的情况下进行表决。在这种情况下，其中一名 candidate 超时后便会开始新的选举。</li>
</ol>
<blockquote>
<p>Raft 使用随机的选举超时来确保分割票很少发生，并且可以快速解决。为了避免一票分裂，首先从固定间隔（例如 150-300 毫秒）中随机选择选举超时。这样会分散服务器，因此在大多数情况下，只有一台服务器会超时；它会赢得选举并在其他任何服务器超时之前发送心跳信号。使用相同的机制来处理拆分投票。每位 candidate 在选举开始时都会重新启动其随机选举超时时间，并等待该超时时间过去后才开始下一次选举；这减少了在新选举中再次进行分裂表决的可能性。</p>
</blockquote>
<h2><span id="日志复制">日志复制</span></h2><p>client 请求现在假定为仅写。每个请求都包含一个命令，该命令理想地由所有服务器的复制状态机执行。leader 收到客户请求后，会将其作为新条目添加到自己的日志中。日志中的每个条目：</p>
<ul>
<li>包含 client 指定的命令</li>
<li>有一个索引来标识日志中条目的位置（索引从 1 开始）</li>
<li>有一个 term 号可以从逻辑上识别条目的写入时</li>
</ul>
<p>它需要将条目复制到所有 follower 节点，以保持日志一致。leader 将 AppendEntries RPC 并行发布到所有其他服务器。leader 将重试此操作，直到所有 follower 安全地复制新条目为止。</p>
<p>当条目由创建它的 leader 复制到大多数服务器时，就被视为已提交。所有以前的条目，包括由早期 leader 创建的条目，也都视为已提交。负责人一旦提交就执行该条目，并将结果返回给 client。</p>
<p>leader 在其日志中维护它知道要提交的最高索引，并将其与 AppendEntries RPC 一起发送给其 follower。一旦 follower 发现条目已提交，它将按顺序将条目应用于其状态机。</p>
<p>Raft 维护以下属性，它们共同构成了日志匹配属性。</p>
<ul>
<li>如果不同日志中的两个条目具有相同的索引和 term，那么它们存储的是同一个命令。</li>
<li>如果不同日志中的两个条目具有相同的索引和 term，那么在前面的所有条目中，日志是相同的。</li>
</ul>
<p>当发送 AppendEntries RPC 时，leader 包括紧接在新条目之前的条目的 term 号和索引。如果 follower 在自己的日志中找不到与该条目匹配的条目，它就会拒绝附加新条目的请求。</p>
<p>这种一致性检查可以让 leader 得出这样的结论：每当 AppendEntries 从 follower 成功返回时，它们的日志都是相同的，直到 RPC 中包含的索引。</p>
<p>但是在面对 leader 崩溃的情况下，leader 和 follower 的日志可能会变得不一致。</p>
<blockquote>
<p> 在 Raft 中，leader 通过强制 follower 的日志复制自己的日志来处理不一致的情况。这意味着，follower 日志中的冲突条目将被 leader 日志中的条目覆盖。</p>
</blockquote>
<p>leader 试图找到其日志与 follower 日志相匹配的最后一个索引，删除多余的条目（如果有），并添加新的条目。</p>
<blockquote>
<p>leader 为每个 follower 维护一个 nextIndex，它是 leader 将发送给该 follower 的下一个日志条目的索引。当 leader 第一次上电时，它将所有的 nextIndex 值初始化为其日志中最后一条后的索引。</p>
</blockquote>
<p>每当 AppendRPC 返回一个 follower 失败时，leader 就会递减 nextIndex，并发出另一个 AppendEntries RPC。最终，nextIndex 会达到一个值，在这个值上，日志会趋于一致。当这种情况发生时，AppendEntries 将会成功，它可以从 leader 的日志中删除无关的条目（如果有的话），并添加新的条目（如果有的话）。因此，从一个 follower 成功的 AppendEntries 可以保证 leader 的日志与它一致。</p>
<blockquote>
<p>通过这种机制，leader 在上电时不需要采取任何特殊的操作来恢复日志一致性。它只需开始正常的操作，日志就会自动收敛，以应对 Append-Entries 一致性检查的失败。leader 从不覆盖或删除自己日志中的条目。</p>
</blockquote>
<h2><span id="安全性">安全性</span></h2><p>Raft 确保一个 term 的 leader 在其日志中承诺了以前所有 term 的条目。<br>Raft 确保一个 term 的 leader 在其日志中已经提交了以前所有 term 的条目。这是为了确保所有的日志是一致的，并且状态机执行相同的命令集。</p>
<p>在 leader 选举期间，RequestVote RPC 包含了 candidate 的日志信息。如果投票者发现它的日志比 candidate 的更新，它就不会投给它。</p>
<p>Raft 通过比较两个日志中最后条目的索引和 term 来确定哪个日志更及时。如果日志的最后条目有不同的 term，那么 term 较晚的日志更及时。如果两个日志的最后条目有相同的 term，那么哪个日志更长，哪个日志就更最新。</p>
<h2><span id="集群成员">集群成员 </span></h2><p> 为了使配置变更机制安全，在过渡期间必须没有任何一点可以让两个 leader 在同一 term 内当选。不幸的是，任何服务器直接从旧配置切换到新配置的方法都是不安全的。<br>Raft 使用了一个两阶段的方法来改变集群成员。首先，它切换到一个称为联合共识的中间配置。然后，一旦这一点被满足，它就会切换到新的配置。</p>
<p>联合共识允许各个服务器在不同的时间在配置之间转换，而不影响安全。此外，联合共识还允许集群在整个配置变化过程中继续服务于 client 请求。<br>联合共识将新旧配置结合起来，具体如下。</p>
<ul>
<li>日志条目被复制到两个配置中的所有服务器上。</li>
<li>任何新旧服务器都可以成为 leader。</li>
<li>协议要求新老组合分别获得多数票。</li>
</ul>
<p>当 leader 收到配置变更消息时，它会存储并复制加入共识 <code>C&lt;old，new&gt;</code> 的条目。服务器总是使用其日志中的最新配置来做决策，即使它没有被提交。当联合共识被提交时，只有日志中含有 <code>C&lt;old，new&gt;</code> 的服务器才能成为 leader。</p>
<p>现在，leader 可以安全地创建一个描述 <code>C&lt;new&gt;</code> 的日志条目，并将其复制到集群中。同样，这个配置一旦被看到，就会在每个服务器上生效。当新配置在 <code>C&lt;new&gt;</code> 的规则下提交后，旧配置就无关紧要了，不在新配置中的服务器可以被关闭。</p>
<h2><span id="图解">图解 </span></h2><p> 见<a href="http://thesecretlivesofdata.com/raft/">Raft 协议图解</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统理论之 CAP 定理</title>
    <url>/2017/09/20/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8BCAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2><span id="什么是-cap-定理">什么是 CAP 定理</span></h2><blockquote>
<p>CAP 由 <a href="https://en.wikipedia.org/wiki/Eric_Brewer_(scientist">Eric Brewer</a>) 在 2000 年 PODC 会议上提出，是 Eric Brewer 在 Inktomi 期间研发搜索引擎、分布式 web 缓存时得出的关于数据一致性 (consistency)、服务可用性(availability)、分区容错性(partition-tolerance) 的猜想：</p>
<p>It is impossible for a web service to provide the three following guarantees : Consistency, Availability and Partition-tolerance.</p>
</blockquote>
<p>C 代表 Consistency 一致性， A 代表 Availability 可用性， P 代表 partition-tolerance 分区容错性。<br><a id="more"></a></p>
<ul>
<li><strong>数据一致性</strong>(consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性(strong consistency) (又叫原子性 atomic、线性一致性 linearizable consistency)</li>
<li><strong>服务可用性</strong>(availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待</li>
<li><strong>分区容错性</strong>(partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务</li>
</ul>
<p>在某时刻如果满足 AP，分隔的节点同时对外服务但不能相互通信，将导致状态不一致，即不能满足 C；如果满足 CP，网络分区的情况下为达成 C，请求只能一直等待，即不满足 A；如果要满足 CA，在一定时间内要达到节点状态一致，要求不能出现网络分区，则不能满足 P。即 C、A、P 三者最多只能满足其中两个。</p>
<h2><span id="论证">论证 </span></h2><p> 如图所示，是我们证明 CAP 的基本场景，网络中有两个节点 N1 和 N2，可以简单的理解 N1 和 N2 分别是两台计算机，他们之间网络可以连通，N1 中有一个应用程序 A，和一个数据库 V，N2 也有一个应用程序 B 和一个数据库 V。现在，A 和 B 是分布式系统的两个部分，V 是分布式系统的数据存储的两个子数据库。</p>
<p><img src="https://i.loli.net/2020/08/22/aOhnCg5yRKJikSm.jpg" alt="fb6d8e8e-1cc2-4ab2-8691-6010d8a4c0cd"></p>
<p>在满足一致性的时候，N1 和 N2 中的数据是一样的，V0=V0。<br>在满足可用性的时候，用户不管是请求 N1 或者 N2，都会得到立即响应。<br>在满足分区容错性的情况下，N1 和 N2 有任何一方宕机，或者网络不通的时候，都不会影响 N1 和 N2 彼此之间的正常运作。</p>
<p>如图所示，这是分布式系统正常运转的流程，用户向 N1 机器请求数据更新，程序 A 更新数据库 V0 为 V1。分布式系统将数据进行同步操作 M，将 V1 同步的 N2 中 V0，使得 N2 中的数据 V0 也更新为 V1，N2 中的数据再响应 N2 的请求。</p>
<p><img src="https://i.loli.net/2020/08/22/Vul7CZY5i4AxeH8.jpg" alt="04910e6c-a768-4b8c-b9a0-0149006803d4"></p>
<p>根据 CAP 原则定义，系统的一致性、可用性和分区容错性细分如下：</p>
<p>一致性：N1 和 N2 的数据库 V 之间的数据是否完全一样。<br>可用性：N1 和 N2 的对外部的请求能否做出正常的响应。<br>分区容错性：N1 和 N2 之间的网络是否互通。</p>
<p>这是正常运作的场景，也是理想的场景。作为一个分布式系统，它和单机系统的最大区别，就在于网络。现在假设一种极端情况，N1 和 N2 之间的网络断开了，我们要支持这种网络异常。相当于要满足分区容错性，能不能同时满足一致性和可用性呢？还是说要对他们进行取舍？</p>
<p><img src="https://i.loli.net/2020/08/22/oBEMSxLCYl98QfU.jpg" alt="bcf62eb4-d42e-4380-95de-dd4bdad228d8"></p>
<p>假设在 N1 和 N2 之间网络断开的时候，有用户向 N1 发送数据更新请求，那 N1 中的数据 V0 将被更新为 V1。由于网络是断开的，所以分布式系统同步操作 M，所以 N2 中的数据依旧是 V0。这个时候，有用户向 N2 发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据 V1，怎么办呢？<br>这里有两种选择：</p>
<p>第一：牺牲数据一致性，保证可用性。响应旧的数据 V0 给用户。<br>第二：牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作 M 完成之后，再给用户响应最新的数据 V1。</p>
<p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p>
<h2><span id="权衡-trade-off">权衡 Trade-off</span></h2><p>通过 CAP 理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p>
<h3><span id="ca-without-p">CA without P</span></h3><p>如果不要求 P（不允许分区），则 C（强一致性）和 A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此 CA 的系统更多的是允许分区后各子系统依然保持 CA。</p>
<h3><span id="cp-without-a">CP without A</span></h3><p>如果不要求 A（可用），相当于每个请求都需要在 Server 之间强一致，而 P（分区）会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p>
<h3><span id="ap-wihtout-c">AP wihtout C</span></h3><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的 NoSQL 都属于此类。</p>
<h3><span id="最终一致性">最终一致性 </span></h3><p> 根据 CAP 定理，我们要不是选择 C（一致性）而放弃 A（可用性），就是反过来。但现实世界的情况，往往不是这么地非黑即白。依照不同的商业逻辑与使用情境，在两者间取得平衡的设计是非常普遍的。<br>举例来说，对于 C（一致性）而言，我们把 CAP 定理所定义的一致性称为 <strong> 强一致性（strong consistency）</strong>。适合处理像是金钱、付款这种对资料同步高度要求的任务。但相对的，扩展性、可用性就会比较局限（想像一下，若数据库的数量持续地增加，同步所有数据的成本也会不断上升）。<br>与强一致性相对的是所谓的最终一致性（eventually consistency）。当使用者更新某笔资料时，也许因为网路暂时中断或延迟，没有即时同步到另一个资料库。我们还是让其他使用者可以继续存取资料（不是最新的也没关系），但最终，我们保证这笔资料一定会同步（最后的结果还是对的）。</p>
<h2><span id="总结">总结 </span></h2><p> 我们从但一系统开始，随着流量增长，演变为分布式系统架构。在分布式系统架构下，会遇到网络问题导致的数据分区。CAP 定理就是用来探讨在这种情况下，系统在设计上必须做出的取舍。其中 CA 的系统对于 CAP 定理意义不大，于是我们分别探讨 CP 和 AP 的情况。</p>
<p>对于某些特殊情况，例如对于涉及到钱财这样不能有一丝让步的场景，C 必须保证。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A，例如网络故障时只读不写。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>简析一致性哈希算法及其实现</title>
    <url>/2017/04/04/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2><span id="场景">场景 </span></h2><p> 业务中有 N 台 redis 缓存服务器 [0, N-1]，那么对于任意一个关键字 key 的请求，我们都是做一个对 key 哈希值取模的请求分发。前台请求被分发到编号 (hash(key)%N) 这台服务器上。理想状态下，这样的缓存命中率是很高的。但当因为业务需求而增删服务节点数，例如添加一台服务器。那么原来被分配到 k 号服务器的现在会被分到 (k-1) 号服务器。这个时候几乎所有的缓存全部会被 miss 掉，造成极大的业务压力。</p>
<p><strong>一致性哈希算法的目的就是，当后台增删节点时，旧的数据能够依旧计算到原来的服务器，而新数据能够按新的哈希算法分配到新服务器。</strong></p>
<a id="more"></a>
<h2><span id="原理">原理 </span></h2><p> 一致性哈希算法把 N 个服务节点映射到一个环上。对每个服务节点的 key 值进行 hash 计算，获得一个长度为 N 的数组，再把数组首尾相连，获得一个环。我们对所有的请求节点 key 作 hash 计算，会落入该环的某一个弧段，我们可以设定每个弧段上的请求节点都以顺时针最近的 Node 作为服务节点。这样增加或减少服务节点，那影响的也只是一个弧段上的请求节点，而其他弧段上的请求节点则不受影响。</p>
<p>这实际上就是把映射环增大了。减少了数据映射关系的变动，不会像 hash(i)%N 那样带来全局的变动。</p>
<p>如果某一个弧段上的节点密度很大，导致单个服务节点过载，即热点数据问题，那我们可以在这个弧段上增加一个服务节点就可以分担压力。</p>
<h2><span id="改进">改进 </span></h2><h3><span id="雪崩效应"> 雪崩效应 </span></h3><p> 上述的算法有一个弊端，就是如果某个服务节点因为过载而 down 掉，那么原本分配在它上面的负载都会被分配到顺时针下一台服务器上去，那么下一台服务器也会 down 掉，依次类推，所有的服务器最终都会挂掉。这就是雪崩效应。</p>
<p>为了解决雪崩效应，最好的办法就是，当一个服务节点挂掉的时候，分配在上面的流量被其他的服务节点共同分担。这样才能保证整个集群的可用性。因此，可以采用 <strong> 虚拟节点 </strong> 的方式来改进算法。</p>
<h3><span id="虚拟节点">虚拟节点 </span></h3><p> 这里把每个服务器分为两个副本节点，每个副本节点负责一个更精细的环，如图可以得知，如果 A 挂掉了，那么原本分配给 A 的两个小环的流量会被 D 和 C 来分摊。实际上我们可以通过增加副本节点的数量来提高算法的均衡性。</p>
<h2><span id="实现代码">实现代码</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#! /usr/bin/env python</span>
<span class="token comment"># -*- coding:utf8 -*-</span>

<span class="token keyword">import</span> md5

<span class="token keyword">class</span> <span class="token class-name">HashRing</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> replicas<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        创建一个 hash 环
        :nodes 
            节点 
        :replicas
            每个服务节点的副本数
        """</span>

        self<span class="token punctuation">.</span>replicas <span class="token operator">=</span> replicas
        self<span class="token punctuation">.</span>ring <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
        self<span class="token punctuation">.</span>_sorted_keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> nodes<span class="token punctuation">:</span>
            <span class="token keyword">for</span> node <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>add_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">add_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""把一个服务节点加入 hash 环"""</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>replicas<span class="token punctuation">)</span><span class="token punctuation">:</span>
            key <span class="token operator">=</span> self<span class="token punctuation">.</span>gen_key<span class="token punctuation">(</span><span class="token string">"%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>ring<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node
            self<span class="token punctuation">.</span>_sorted_keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>_sorted_keys<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">remove_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""从 hash 环删除一个服务节点"""</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>replicas<span class="token punctuation">)</span><span class="token punctuation">:</span>
            key <span class="token operator">=</span> self<span class="token punctuation">.</span>gen_key<span class="token punctuation">(</span><span class="token string">"%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">del</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>_sorted_keys<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_node_keys</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""获取一个服务节点的所有副本的虚拟 key"""</span>
        keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>replicas<span class="token punctuation">)</span><span class="token punctuation">:</span>
            key <span class="token operator">=</span> self<span class="token punctuation">.</span>gen_key<span class="token punctuation">(</span><span class="token string">"%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>
            keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> key

    <span class="token keyword">def</span> <span class="token function">get_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> string_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""对于给定的 key 获取对应的服务节点，返回节点"""</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>get_node_pos<span class="token punctuation">(</span>string_key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">get_node_pos</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> string_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""对于给定的 key 获取对应的服务节点，返回节点和位置"""</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>

        key <span class="token operator">=</span> self<span class="token punctuation">.</span>gen_key<span class="token punctuation">(</span>string_key<span class="token punctuation">)</span>
        nodes <span class="token operator">=</span> self<span class="token punctuation">.</span>_sorted_keys
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            node <span class="token operator">=</span> nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span> key <span class="token operator">&lt;=</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">,</span> i

        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">[</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>

    <span class="token keyword">def</span> <span class="token function">get_nodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> string_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        对于一个给定的 key ，返回一个
        Given a string key it returns the nodes as a generator that can hold the key.
        The generator is never ending and iterates through the ring starting at the correct position.
        """</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">:</span>
            <span class="token keyword">yield</span> <span class="token boolean">None</span>

        node<span class="token punctuation">,</span> pos <span class="token operator">=</span> self<span class="token punctuation">.</span>get_node_pos<span class="token punctuation">(</span>string_key<span class="token punctuation">)</span>
        <span class="token keyword">for</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>_sorted_keys<span class="token punctuation">:</span>
            <span class="token keyword">yield</span> self<span class="token punctuation">.</span>ring<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">gen_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""以 md5 算法来进行 hash(key)运算"""</span>
        m <span class="token operator">=</span> md5<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token punctuation">)</span>
        m<span class="token punctuation">.</span>update<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token builtin">long</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode1115. 交替打印 FooBar</title>
    <url>/2018/01/02/%E5%88%B7%E9%A2%98/Leetcode1115.%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>借助这题复习一下 Java 并发类和工具。</p>
<h2><span id="题目描述">题目描述 </span></h2><p> 两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p>
<p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<a id="more"></a>
<p>我们提供一个类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            
        	<span class="token comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span>
        	printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            
            <span class="token comment">// printBar.run() outputs "bar". Do not change or remove this line.</span>
        	printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>示例 1:</p>
<p>输入: n = 1<br>输出: “foobar”<br>解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，”foobar” 将被输出一次。</p>
</li>
<li><p>示例 2:</p>
<p>输入: n = 2<br>输出: “foobarfoobar”<br>解释: “foobar” 将被输出两次。</p>
</li>
</ul>
<h2><span id="思路">思路 </span></h2><p> 这题考的是线程同步，那么显而易见，信号量、互斥锁、共享内存这些方案都是可行的。</p>
<h2><span id="题解">题解 </span></h2><h3><span id="信号量-semaphore"> 信号量 Semaphore</span></h3><p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p>Semaphore 类位于 java.util.concurrent 包下，它提供了 2 个构造器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 参数 permits 表示许可数目，即同时可以允许多少线程进行访问</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这个多了一个参数 fair 表示是否是公平的，即等待时间越久的越先获取许可</span>
    sync <span class="token operator">=</span> <span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面说一下 Semaphore 类中比较重要的几个方法，首先是 acquire()、release()方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>     <span class="token comment">// 获取一个许可</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取 permits 个许可</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>          <span class="token comment">// 释放一个许可</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放 permits 个许可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p>
<p>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</p>
<p>这 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    
<span class="token comment">// 尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  
<span class="token comment">// 尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
<span class="token comment">// 尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外还可以通过 availablePermits()方法得到可用的许可数目。</p>
<p>此题可设置两个信号量分别标示 FooBar 的可用状态。</p>
<h4><span id="代码">代码</span></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token class-name">Semaphore</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Semaphore</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            foo<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            bar<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            bar<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            foo<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="公平锁">公平锁 </span></h3><p> 锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如 ReadWriteLock 的读写锁。在 Lock 接口出现之前，Java 程序是靠 synchronized 关键字实现锁功能的。JDK1.5 之后并发包中新增了 Lock 接口以及相关实现类来实现锁功能。</p>
<p><strong>Lock 接口的实现类：</strong> <code>ReentrantLock</code> ， <code>ReentrantReadWriteLock.ReadLock</code> ， <code>ReentrantReadWriteLock.WriteLock</code></p>
<p><strong>Lock 接口提供的 synchronized 关键字不具备的主要特性：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>尝试非阻塞地获取锁</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Lock 接口基本的方法：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。</td>
</tr>
<tr>
<td>void lockInterruptibly()</td>
<td>获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和 lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为 true；如果锁不可用，则此方法将立即返回值为 false 。</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUnit unit)</td>
<td>超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2. 当前线程在超时时间内被中断；3. 超时时间结束，返回 false.</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            	<span class="token keyword">if</span><span class="token punctuation">(</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            	    printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>
                    permitFoo <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            	<span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
            	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            	    printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            	    i<span class="token operator">++</span><span class="token punctuation">;</span>
            	    permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            	<span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
            	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="无锁">无锁 </span></h3><p> 以上的公平锁方案完全可以改造成无锁方案：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>     
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            	i<span class="token operator">++</span><span class="token punctuation">;</span>
            	permitFoo <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>       
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	i<span class="token operator">++</span><span class="token punctuation">;</span>
        	permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="cyclicbarrier-类">CyclicBarrier 类 </span></h3><p> 循环场景中常用 CyclicBarrier</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token class-name">CyclicBarrier</span> cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>
            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	    <span class="token punctuation">&#125;</span>
            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode300. 最长上升子序列</title>
    <url>/2018/01/08/%E5%88%B7%E9%A2%98/Leetcode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>经典 DP 问题之一——LIS。</p>
<a id="more"></a>
<h2><span id="描述">描述</span></h2><h3><span id="300-最长上升子序列"></span></h3><p>Difficulty: 中等</p>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<pre class="line-numbers language-none"><code class="language-none">输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 $O(n^2)$ 。</li>
</ul>
<p>进阶: 你能将算法的时间复杂度降低到 $O(nlogn)$ 吗?</p>
<h2><span id="思路-amp-题解">思路 &amp; 题解 </span></h2><h3><span id="经典-lis"> 经典 LIS</span></h3><h4><span id="思路">思路 </span></h4><p> 对于所有的 DP 问题，经典四步走：</p>
<ol>
<li><p>定义状态</p>
<p>由于一个子序列一定会以一个数结尾，于是将状态定义成：<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的「上升子序列」的长度。注意：这个定义中 <code>`nums[i]</code> 必须被选取，且必须是这个子序列的最后一个元素。</p>
</li>
<li><p>考虑状态转移方程</p>
<p>遍历到 <code>nums[i]</code> 时，需要把下标 <code>i</code> 之前的所有的数都看一遍；<br>只要 <code>nums[i]</code> 严格大于在它位置之前的某个数，那么 <code>nums[i]</code> 就可以接在这个数后面形成一个更长的上升子序列；<br>因此，<code>dp[i]</code> 就等于下标 i 之前严格小于 <code>nums[i]</code> 的状态值的最大者 +1。<br> 因此我们可以写出下面的状态转移方程：</p>
<script type="math/tex; mode=display">dp[i]=\max \limits_{0\leq j<i, nums[j]<nums[i]}dp[j]+1</script></li>
<li><p>考虑初始化</p>
<p>dp[i] = 1，每个字符都至少构成长度为 1 的子序列</p>
</li>
<li><p>输出</p>
<p>状态数组 dp 的最大值才是最后要输出的值。</p>
</li>
<li><p>状态压缩</p>
<p>遍历到一个新数的时候，之前所有的状态值都得保留，因此无法压缩。</p>
</li>
</ol>
<h4><span id="代码">代码</span></h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token function">Max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> x <span class="token operator">></span> y <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> x
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> y
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">&#125;</span>
    ans <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token comment">// 要注意考虑特殊情况 例如长度为 0 或 1</span>
    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> j<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                ans <span class="token operator">=</span> <span class="token function">Max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ans
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="二分查找-贪心">二分查找 + 贪心 </span></h3><h4><span id="思路"> 思路 </span></h4><p> 题目中要找 $O(nlogn)$ 的做法，考虑到二分查找的复杂度为 $O(logn)$，所以可以考虑在第二层循环做文章，改成二分查找。</p>
<p>在这里，我们的出发点基于一个贪心的做法：结尾的数尽量小，遍历后接的数就有更大的可能性构成更长的序列。</p>
<p>我们可以记录长度固定的状况下，结尾最小的元素数值。</p>
<ol>
<li><p>定义状态</p>
<p><code>tail[i]</code>表示长度为 <code>i+1</code> 的所有上升子序列的结尾最小值。</p>
<p><code>tail[0]</code> 表示长度为 1 的所有上升子序列中，结尾最小的那个元素的数值，以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3<br>下标和长度有一个 1 的偏差；</p>
</li>
<li><p>状态转移方程</p>
<p>这里可以证明 <code>tail</code> 严格上升。</p>
<p>证明：对于任意下表 $0 \leq i &lt; j &lt; len$，都有 $tail[i]&lt;tail[j]$</p>
<p>假设对于任意 $i<j$，存在 `tail[i]>=tail[j]`</j$，存在></p>
<p>对于<code>tail[i]</code>，对应一个上升子序列 $[a_0,a_1,…,a_i]$，$tail[i]=a_i$</p>
<p>对于<code>tail[j]</code>，对应一个上升子序列 $[b_0,b_1,…,b_j]$，$tail[j]=b_j$</p>
<p>由于 <code>tail[i]&gt;=tail[j]</code>，$a_i&gt;b_j$。而在 $[b_0,b_1,…,b_j]$ 中，$b_i<b_j$ ，则 $a_i\geq b_j>b_i$，则上升子序列 $[b_0,b_1,…,b_j]$ 是一个长度为<code>i+1</code> 但结尾更小的数组，与假设矛盾，命题得证。</b_j$></p>
<p>根据命题，我们维护 <code>tail</code> 即可直接取得最长上升子序列的长度。</p>
</li>
</ol>
<h4><span id="算法">算法</span></h4><p>1、设置一个数组 tail，初始时为空；</p>
<p>注意：数组 <code>tail</code> 虽然是有序数组，但它不是问题中的「最长上升子序列」（下文还会强调），不能命名为 LIS。有序数组 tail 只是用于求解 LIS 问题的辅助数组。</p>
<p>2、在遍历数组 <code>nums</code> 的过程中，每来一个新数 num，如果这个数严格大于有序数组 <code>tail</code> 的最后一个元素，就把 num 放在有序数组 <code>tail</code> 的后面，否则进入第 3 点；</p>
<p>注意：这里的大于是「严格大于」，不包括等于的情况。</p>
<p>3、在有序数组 <code>tail</code> 中查找第 1 个等于大于 num 的那个数，试图让它变小；</p>
<p>如果有序数组 <code>tail</code> 中存在等于 num 的元素，什么都不做，因为以 num 结尾的最短的「上升子序列」已经存在；<br>如果有序数组 <code>tail</code> 中存在大于 num 的元素，找到第 1 个，让它变小，这样我们就找到了一个结尾更小的相同长度的上升子序列。<br>说明：我们再看一下数组 <code>tail[i]</code> 的定义：长度为 i + 1 的所有最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们试图让一个大的值变小是合理的。</p>
<p>这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 <code>nums[i]</code> 的数变小，变成 <code>nums[i]</code>，这一步操作是“无后效性”的。</p>
<p>由于是在有序数组中的操作，因此可以使用「二分查找算法」。</p>
<p>4、遍历新的数 num ，先尝试上述第 2 点，第 2 点行不通则执行第 3 点，直到遍历完整个数组 nums，最终有序数组 tail 的长度，就是所求的“最长上升子序列”的长度。</p>
<p>第 3 步：思考初始化<br><code>dp[0] = nums[0]</code>，在只有 1 个元素的情况下，它当然是长度为 1 并且结尾最小的元素。</p>
<p>第 4 步：思考输出 <br> 数组 <code>tail</code> 的长度，上文其实也已经说了，还是依据定义，<code>tail[i]</code> 表示长度固定为 i + 1 的所有「上升子序列」的结尾元素中最小的那个，长度最多就是数组 <code>tail</code> 的长度。</p>
<p>第 5 步：思考状态压缩 <br> 无法压缩。</p>
<p>下面看一下这个算法在示例上的的执行流程，以加深体会，我在示例的数组后面加上了 4、8、6、12，依然是先让幻灯片动起来，看思想就好了。</p>
<h4><span id="代码">代码</span></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> len<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 遍历第 1 个数，直接放在有序数组 tail 的开头</span>
        tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// end 表示有序数组 tail 的最后一个已经赋值元素的索引</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 直接添加在那个元素的后面，所以 end 先加 1</span>
                end<span class="token operator">++</span><span class="token punctuation">;</span>
                tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 使用二分查找法，在有序数组 tail 中</span>
                <span class="token comment">// 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小</span>
                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">// 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解</span>
                    <span class="token comment">// int mid = left + (right - left) / 2;</span>
                    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 中位数肯定不是要找的数，把它写在分支的前面</span>
                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token comment">// 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素</span>
                <span class="token comment">// 因此，无需再单独判断</span>
                tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 调试方法</span>
            <span class="token comment">// printArray(nums[i], tail);</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 此时 end 是有序数组 tail 最后一个元素的索引</span>
        <span class="token comment">// 题目要求返回的是长度，因此 +1 后返回</span>
        end<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 调试方法，以观察是否运行正确</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"当前数字："</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\t 当前 tail 数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> tail<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tail<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token class-name">Solution</span> solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> lengthOfLIS <span class="token operator">=</span> solution8<span class="token punctuation">.</span><span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最长上升子序列的长度："</span> <span class="token operator">+</span> lengthOfLIS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode347. 前 K 个高频元素</title>
    <url>/2018/01/08/%E5%88%B7%E9%A2%98/Leetcode347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<a id="more"></a>
<h2><span id="描述">描述 </span></h2><h3><span id="347-前-k-个高频元素"></span></h3><p>Difficulty: <strong> 中等</strong></p>
<p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2
输出: [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [1], k &#x3D; 1
输出: [1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 $1\leq k\leq m$, m 为数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度 <strong> 必须 </strong> 优于 $O(nlogn)$ , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<h2><span id="题解">题解 </span></h2><h3><span id="思路"> 思路 </span></h3><p> 遍历数组，记录每个数字出现的次数，保存在哈希表中，这样的时间复杂度为 $O(n)$。</p>
<p>我们只需要找出这个哈希表中值最大的 k 个。</p>
<p>在这里我们可以用堆来排序。建立一个小顶堆，遍历出现次数数组。</p>
<ul>
<li>堆元素个数小于 k，入堆</li>
<li>堆元素等于 k，检查堆顶与当前出现次数的大小，堆顶更大，则至少有 k 个数字出现次数比当前值大，舍弃当前值，否则弹出堆顶，插入当前值到堆。</li>
</ul>
<p>遍历完成后，堆中元素纪委出现次数数组前 k 大的值。</p>
<p>遍历数组，用哈希表的记录时间为 $O(n)$，遍历出现次数数组，建立大小为 k 的堆，每次堆操作为时间复杂度为 $O(logk)$，n 次操作为 $O(nlogk)$，总时间复杂度为 $O(n)+O(nlogk)=O(n)$</p>
<h3><span id="代码">代码</span></h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    occurrences <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">&#123;</span>
        occurrences<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    h <span class="token operator">:=</span> <span class="token operator">&amp;</span>IHeap<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    heap<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> occurrences <span class="token punctuation">&#123;</span>
        heap<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span>key<span class="token punctuation">,</span> value<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k <span class="token punctuation">&#123;</span>
            heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    ret <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        ret<span class="token punctuation">[</span>k <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> IHeap <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h IHeap<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>h IHeap<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>h IHeap<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>IHeap<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>h <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 分类刷题指南</title>
    <url>/2017/09/04/%E5%88%B7%E9%A2%98/Leetcode%E5%88%86%E7%B1%BB%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>一些常见的题型，刷题事半功倍。</p>
<a id="more"></a>
<h2><span id="1-pattern-sliding-window滑动窗口类型">1. Pattern: Sliding window，滑动窗口类型 </span></h2><p> 经典题目：</p>
<p>Maximum Sum Subarray of Size K (easy)</p>
<p>Smallest Subarray with a given sum (easy)</p>
<p>Longest Substring with K Distinct Characters (medium)</p>
<p>Fruits into Baskets (medium)</p>
<p>No-repeat Substring (hard)</p>
<p>Longest Substring with Same Letters after Replacement (hard)</p>
<p>Longest Subarray with Ones after Replacement (hard)</p>
<h2><span id="2-pattern-two-points-双指针类型">2. Pattern: two points, 双指针类型 </span></h2><p> 经典题目：</p>
<p>Pair with Target Sum (easy)</p>
<p>Remove Duplicates (easy)</p>
<p>Squaring a Sorted Array (easy)</p>
<p>Triplet Sum to Zero (medium)</p>
<p>Triplet Sum Close to Target (medium)</p>
<p>Triplets with Smaller Sum (medium)</p>
<p>Subarrays with Product Less than a Target (medium)</p>
<p>Dutch National Flag Problem (medium)</p>
<h2><span id="3-pattern-fast-amp-slow-pointers-快慢指针类型">3. Pattern: Fast &amp; Slow pointers, 快慢指针类型 </span></h2><p> 经典题目：</p>
<p>LinkedList Cycle (easy)</p>
<p>Start of LinkedList Cycle (medium)</p>
<p>Happy Number (medium)</p>
<p>Middle of the LinkedList (easy)</p>
<h2><span id="4-pattern-merge-intervals区间合并类型">4. Pattern: Merge Intervals，区间合并类型 </span></h2><p> 经典题目：</p>
<p>Merge Intervals (medium)</p>
<p>Insert Interval (medium)</p>
<p>Intervals Intersection (medium)</p>
<p>Conflicting Appointments (medium)</p>
<h2><span id="5-pattern-cyclic-sort循环排序">5. Pattern: Cyclic Sort，循环排序 </span></h2><p> 经典题目：</p>
<p>Cyclic Sort (easy)</p>
<p>Find the Missing Number (easy)</p>
<p>Find all Missing Numbers (easy)</p>
<p>Find the Duplicate Number (easy)</p>
<p>Find all Duplicate Numbers (easy)</p>
<h2><span id="6-pattern-in-place-reversal-of-a-linkedlist链表翻转">6. Pattern: In-place Reversal of a LinkedList，链表翻转 </span></h2><p> 经典题目：</p>
<p>Reverse a LinkedList (easy)</p>
<p>Reverse a Sub-list (medium)</p>
<p>Reverse every K-element Sub-list (medium)</p>
<h2><span id="7-pattern-tree-breadth-first-search树上的-bfs">7. Pattern: Tree Breadth First Search，树上的 BFS**</span></h2><p>经典题目：</p>
<p>Binary Tree Level Order Traversal (easy)</p>
<p>Reverse Level Order Traversal (easy)</p>
<p>Zigzag Traversal (medium)</p>
<p>Level Averages in a Binary Tree (easy)</p>
<p>Minimum Depth of a Binary Tree (easy)</p>
<p>Level Order Successor (easy)</p>
<p>Connect Level Order Siblings (medium)</p>
<h2><span id="8-pattern-tree-depth-first-search树上的-dfs">8. Pattern: Tree Depth First Search，树上的 DFS**</span></h2><p>经典题目：</p>
<p>Binary Tree Path Sum (easy)</p>
<p>All Paths for a Sum (medium)</p>
<p>Sum of Path Numbers (medium)</p>
<p>Path With Given Sequence (medium)</p>
<p>Count Paths for a Sum (medium)</p>
<h2><span id="9-pattern-two-heaps双堆类型">9. Pattern: Two Heaps，双堆类型 </span></h2><p> 经典题目：</p>
<p>Find the Median of a Number Stream (medium)</p>
<p>Sliding Window Median (hard)</p>
<p>Maximize Capital (hard)</p>
<h2><span id="10-pattern-subsets子集类型一般都是使用多重-dfs">10. Pattern: Subsets，子集类型，一般都是使用多重 DFS**</span></h2><p>经典题目：</p>
<p>Subsets (easy)</p>
<p>Subsets With Duplicates (easy)</p>
<p>Permutations (medium)</p>
<p>String Permutations by changing case (medium)</p>
<p>Balanced Parentheses (hard)</p>
<p>Unique Generalized Abbreviations (hard)</p>
<h2><span id="11-pattern-modified-binary-search改造过的二分">11. Pattern: Modified Binary Search，改造过的二分 </span></h2><p> 经典题目：</p>
<p>Order-agnostic Binary Search (easy)</p>
<p>Ceiling of a Number (medium)</p>
<p>Next Letter (medium)</p>
<p>Number Range (medium)</p>
<p>Search in a Sorted Infinite Array (medium)</p>
<p>Minimum Difference Element (medium)</p>
<p>Bitonic Array Maximum (easy)</p>
<h2><span id="12-pattern-top-k-elements前-k-个系列">12. Pattern: Top ‘K’ Elements，前 K 个系列 </span></h2><p> 经典题目：</p>
<p>Top ‘K’ Numbers (easy)</p>
<p>Kth Smallest Number (easy)</p>
<p>‘K’ Closest Points to the Origin (easy)</p>
<p>Connect Ropes (easy)</p>
<p>Top ‘K’ Frequent Numbers (medium)</p>
<p>Frequency Sort (medium)</p>
<p>Kth Largest Number in a Stream (medium)</p>
<p>‘K’ Closest Numbers (medium)</p>
<p>Maximum Distinct Elements (medium)</p>
<p>Sum of Elements (medium)</p>
<p>Rearrange String (hard)</p>
<h2><span id="13-pattern-k-way-merge多路归并">13. Pattern: K-way merge，多路归并 </span></h2><p> 经典题目：</p>
<p>Merge K Sorted Lists (medium)</p>
<p>Kth Smallest Number in M Sorted Lists (Medium)</p>
<p>Kth Smallest Number in a Sorted Matrix (Hard)</p>
<p>Smallest Number Range (Hard)</p>
<h2><span id="14-pattern-01-knapsack-dynamic-programming01-背包类型">14. Pattern: 0/1 Knapsack (Dynamic Programming)，0/1 背包类型 </span></h2><p> 经典题目：</p>
<p>0/1 Knapsack (medium)</p>
<p>Equal Subset Sum Partition (medium)</p>
<p>Subset Sum (medium)</p>
<p>Minimum Subset Sum Difference (hard)</p>
<h2><span id="15-pattern-topological-sort-graph拓扑排序类型">15. Pattern: Topological Sort (Graph)，拓扑排序类型 </span></h2><p> 经典题目：</p>
<p>Topological Sort (medium)</p>
<p>Tasks Scheduling (medium)</p>
<p>Tasks Scheduling Order (medium)</p>
<p>All Tasks Scheduling Orders (hard)</p>
<p>Alien Dictionary (hard)</p>
<p>大家好好练练这些题目，面试中遇到的题目，应该就能回答得不错了。</p>
<p>祝面试好运！</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer20. 表示数值的字符串</title>
    <url>/2018/01/05/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>一道经典的自动状态机题。</p>
<a id="more"></a>
<h2><span id="题目描述">题目描述 </span></h2><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/"> 剑指 Offer20. 表示数值的字符串</a></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<h2><span id="思路">思路 </span></h2><p> 这题是典型的自动状态机，定义当前状态，以当前字符作为状态转移动作。</p>
<p><strong>字符类型</strong>：</p>
<p>空格 「 」、数字「 0—9 」 、正负号 「 +- 」 、小数点 「 . 」 、幂符号 「 eEeE 」 。</p>
<p><strong>状态定义</strong>：</p>
<p>按照字符串从左到右的顺序，定义以下 9 种状态。</p>
<ol>
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
<li>结束状态</li>
</ol>
<p>合法的结束状态有 2, 3, 7, 8 。</p>
<p><img src="https://i.loli.net/2020/09/02/2JV9ULagksCuj4P.png" alt="6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1"></p>
<h2><span id="题解">题解</span></h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> State <span class="token builtin">int</span>
<span class="token keyword">type</span> CharType <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    STATE_INITIAL State <span class="token operator">=</span> <span class="token boolean">iota</span>
    STATE_INT_SIGN
    STATE_INTEGER
    STATE_POINT
    STATE_POINT_WITHOUT_INT
    STATE_FRACTION
    STATE_EXP
    STATE_EXP_SIGN
    STATE_EXP_NUMBER
    STATE_END
<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    CHAR_NUMBER CharType <span class="token operator">=</span> <span class="token boolean">iota</span>
    CHAR_EXP
    CHAR_POINT
    CHAR_SIGN
    CHAR_SPACE
    CHAR_ILLEGAL
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">toCharType</span><span class="token punctuation">(</span>ch <span class="token builtin">byte</span><span class="token punctuation">)</span> CharType <span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> ch <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_NUMBER
    <span class="token keyword">case</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_EXP
    <span class="token keyword">case</span> <span class="token string">'.'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_POINT
    <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_SIGN
    <span class="token keyword">case</span> <span class="token string">''</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_SPACE
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> CHAR_ILLEGAL
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    transfer <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span>State<span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
        STATE_INITIAL<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_SPACE<span class="token punctuation">:</span>  STATE_INITIAL<span class="token punctuation">,</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_INTEGER<span class="token punctuation">,</span>
            CHAR_POINT<span class="token punctuation">:</span>  STATE_POINT_WITHOUT_INT<span class="token punctuation">,</span>
            CHAR_SIGN<span class="token punctuation">:</span>   STATE_INT_SIGN<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_INT_SIGN<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_INTEGER<span class="token punctuation">,</span>
            CHAR_POINT<span class="token punctuation">:</span>  STATE_POINT_WITHOUT_INT<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_INTEGER<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_INTEGER<span class="token punctuation">,</span>
            CHAR_EXP<span class="token punctuation">:</span>    STATE_EXP<span class="token punctuation">,</span>
            CHAR_POINT<span class="token punctuation">:</span>  STATE_POINT<span class="token punctuation">,</span>
            CHAR_SPACE<span class="token punctuation">:</span>  STATE_END<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_POINT<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_FRACTION<span class="token punctuation">,</span>
            CHAR_EXP<span class="token punctuation">:</span>    STATE_EXP<span class="token punctuation">,</span>
            CHAR_SPACE<span class="token punctuation">:</span>  STATE_END<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_POINT_WITHOUT_INT<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_FRACTION<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_FRACTION<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_FRACTION<span class="token punctuation">,</span>
            CHAR_EXP<span class="token punctuation">:</span>    STATE_EXP<span class="token punctuation">,</span>
            CHAR_SPACE<span class="token punctuation">:</span>  STATE_END<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_EXP<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_EXP_NUMBER<span class="token punctuation">,</span>
            CHAR_SIGN<span class="token punctuation">:</span>   STATE_EXP_SIGN<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_EXP_SIGN<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_EXP_NUMBER<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_EXP_NUMBER<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_NUMBER<span class="token punctuation">:</span> STATE_EXP_NUMBER<span class="token punctuation">,</span>
            CHAR_SPACE<span class="token punctuation">:</span>  STATE_END<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        STATE_END<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span>CharType<span class="token punctuation">]</span>State<span class="token punctuation">&#123;</span>
            CHAR_SPACE<span class="token punctuation">:</span> STATE_END<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
    state <span class="token operator">:=</span> STATE_INITIAL
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        typ <span class="token operator">:=</span> <span class="token function">toCharType</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> transfer<span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">[</span>typ<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            state <span class="token operator">=</span> transfer<span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">[</span>typ<span class="token punctuation">]</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> state <span class="token operator">==</span> STATE_INTEGER <span class="token operator">||</span> state <span class="token operator">==</span> STATE_POINT <span class="token operator">||</span> state <span class="token operator">==</span> STATE_FRACTION <span class="token operator">||</span> state <span class="token operator">==</span> STATE_EXP_NUMBER <span class="token operator">||</span> state <span class="token operator">==</span> STATE_END
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>自动状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客中几种语言的输入输出姿势</title>
    <url>/2020/04/06/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2%E4%B8%AD%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A7%BF%E5%8A%BFmd/</url>
    <content><![CDATA[<p>有些坑爹公司考试居然要自己处理输入输出 ，哎。。。。</p>
<p>总结一波自己常用的 Python、Java、Golang 的输入输出技巧。</p>
<a id="more"></a>
<h2><span id="输入">输入 </span></h2><h3><span id="70-common-输入输出">70% Common 输入输出</span></h3><p> 输入两个整数，输入一个矩阵类型</p>
<h4><span id="go">Go</span></h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> m<span class="token punctuation">,</span> n <span class="token builtin">int</span>
	fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span>
	<span class="token keyword">var</span> hash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
		<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="java">Java</span></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IODemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m1 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n1 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
      	<span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fmap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
      	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                fmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="python">Python</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">m<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
dray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token operator">*</span>n
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>看看人家 Python 处理的多舒服，除了要暴力计算的时候，一般首选 Python。😁</p>
<h3><span id="90-common-字符串转整数">90% Common 字符串转整数 </span></h3><p> 输入的数据以某个字符分割, 并转化为整数 or 小数</p>
<h4><span id="go">Go</span></h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
 
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"bufio"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
    <span class="token string">"strconv"</span>
    <span class="token string">"strings"</span>
<span class="token punctuation">)</span>
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
    <span class="token keyword">for</span> input<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        a <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span>
        a0<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        a1<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a0 <span class="token operator">+</span> a1<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="java">Java</span></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> IO2 <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ss <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ss<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> thenum <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>ss<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thenum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">+=</span> thenum<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="python">Python</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">st <span class="token operator">=</span> intput<span class="token punctuation">(</span><span class="token punctuation">)</span>
ist <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="输出">输出</span></h2><h3><span id="go">Go</span></h3><pre class="line-numbers language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText">%v     值的默认格式。
%+v   类似 %v，但输出结构体时会添加字段名
%#v　 相应值的 Go 语法表示 
%T    相应值的类型的 Go 语法表示 
%%    百分号, 字面上的 %, 非占位符含义
%b     二进制表示 
%c     相应 Unicode 码点所表示的字符 
%d     十进制表示 
%o     八进制表示 
%q     单引号围绕的字符字面值，由 Go 语法安全地转义 
%x     十六进制表示，字母形式为小写 a-f 
%X     十六进制表示，字母形式为大写 A-F 
%U     Unicode 格式：123，等同于 &quot;U+007B&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 旗标、宽度、精度、索引</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%0+- #[1]*.[2]*[3]d|%0+- #[1]*.[2]*[4]d|\n"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>

	<span class="token comment">// 浮点型精度</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%f|%8.4f|%8.f|%.4f|%.f|\n"</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%.3f|%.3g|\n"</span><span class="token punctuation">,</span> <span class="token number">12.345678</span><span class="token punctuation">,</span> <span class="token number">12.345678</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%.2f|\n"</span><span class="token punctuation">,</span> <span class="token number">12.345678</span><span class="token operator">+</span><span class="token number">12.345678i</span><span class="token punctuation">)</span>

	<span class="token comment">// 字符串精度</span>
	s <span class="token operator">:=</span> <span class="token string">"你好世界！"</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%s|%8.2s|%8.s|%.2s|%.s|\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"|%x|%8.2x|%8.x|%.2x|%.x|\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span>

	<span class="token comment">// 带引号字符串</span>
	s1 <span class="token operator">:=</span> <span class="token string">"Hello 世界!"</span>       <span class="token comment">// CanBackquote</span>
	s2 <span class="token operator">:=</span> <span class="token string">"Hello\n 世界!"</span>      <span class="token comment">// !CanBackquote</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span>  <span class="token comment">// 双引号</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#q\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span> <span class="token comment">// 反引号成功</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#q\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token comment">// 反引号失败</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+q\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token comment">// 仅包含 ASCII 字符</span>

	<span class="token comment">// Unicode 码点</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%U, %#U\n"</span><span class="token punctuation">,</span> <span class="token string">'好'</span><span class="token punctuation">,</span> <span class="token string">'好'</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%U, %#U\n"</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>

	<span class="token comment">// 接口类型将输出其内部包含的值</span>
	<span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
		name <span class="token builtin">string</span>
		age  <span class="token builtin">int</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">"AAA"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>  <span class="token comment">// 只输出字段值</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">// 同时输出字段名</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">// Go 语法格式</span>

	<span class="token comment">// 输出类型</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText">|+0032   |+0064   |
|3.200000|  3.2000|       3|3.2000|3|
|12.346|12.3|
|(12.35+12.35i)|
| 你好世界！|      你好 |        | 你好 ||
|e4bda0e5a5bde4b896e7958cefbc81|    e4bd|        |e4bd||
&quot;Hello 世界!&quot;
&#96;Hello 世界!&#96;
&quot;Hello\n 世界!&quot;
&quot;Hello\n\u4e16\u754c!&quot;
U+597D, U+597D &#39; 好 &#39;
U+000A, U+000A
&#123;AAA 20&#125;
&#123;name:AAA age:20&#125;
struct &#123; name string; age int &#125;&#123;name:&quot;AAA&quot;, age:20&#125;
struct &#123; name string; age int &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="java">Java</span></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> IO3 <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">/*** 输出字符串 ***/</span>
        <span class="token comment">// %s 表示输出字符串，也就是将后面的字符串替换模式中的 %s</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token number">1212</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %n 表示换行</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> <span class="token string">"end line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 还可以支持多个参数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s = %s%n"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"Zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %S 将字符串以大写形式输出</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%S = %s%n"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"Zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 支持多个参数时，可以在 %s 之间插入变量编号，1$ 表示第一个字符串，3$ 表示第 3 个字符串</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$s = %3$s %2$s%n"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"Zhang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出 boolean 类型 ***/</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"true = %b; false ="</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%b%n"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出整数类型 ***/</span>
        <span class="token class-name">Integer</span> iObj <span class="token operator">=</span> <span class="token number">342</span><span class="token punctuation">;</span>
        <span class="token comment">// %d 表示将整数格式化为 10 进制整数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d; %d; %d%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">2343L</span><span class="token punctuation">,</span> iObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %o 表示将整数格式化为 8 进制整数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%o; %o; %o%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">2343L</span><span class="token punctuation">,</span> iObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %x 表示将整数格式化为 16 进制整数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x; %x; %x%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">2343L</span><span class="token punctuation">,</span> iObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %X 表示将整数格式化为 16 进制整数，并且字母变成大写形式</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%X; %X; %X%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">2343L</span><span class="token punctuation">,</span> iObj<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出浮点类型 ***/</span>
        <span class="token class-name">Double</span> dObj <span class="token operator">=</span> <span class="token number">45.6d</span><span class="token punctuation">;</span>
        <span class="token comment">// %e 表示以科学技术法输出浮点数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%e; %e; %e%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">756.403f</span><span class="token punctuation">,</span> <span class="token number">7464.232641d</span><span class="token punctuation">,</span> dObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %E 表示以科学技术法输出浮点数，并且为大写形式</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%E; %E; %E%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">756.403f</span><span class="token punctuation">,</span> <span class="token number">7464.232641d</span><span class="token punctuation">,</span> dObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %f 表示以十进制格式化输出浮点数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f; %f; %f%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">756.403f</span><span class="token punctuation">,</span> <span class="token number">7464.232641d</span><span class="token punctuation">,</span> dObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 还可以限制小数点后的位数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1f; %.3f; %f%n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">756.403f</span><span class="token punctuation">,</span> <span class="token number">7464.232641d</span><span class="token punctuation">,</span> dObj<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出日期类型 ***/</span>
        <span class="token comment">// %t 表示格式化日期时间类型，%T 是时间日期的大写形式，在 %t 之后用特定的字母表示不同的输出格式</span>
        <span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> dataL <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 格式化年月日</span>
        <span class="token comment">// %t 之后用 y 表示输出日期的年份（2 位数的年，如 99）</span>
        <span class="token comment">// %t 之后用 m 表示输出日期的月份，%t 之后用 d 表示输出日期的日号</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">,</span> dataL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 Y 表示输出日期的年份（4 位数的年），</span>
        <span class="token comment">// %t 之后用 B 表示输出日期的月份的完整名， %t 之后用 b 表示输出日期的月份的简称</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">,</span> dataL<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 以下是常见的日期组合</span>
        <span class="token comment">// %t 之后用 D 表示以 "%tm/%td/%ty" 格式化日期</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tD%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 F 表示以 "%tY-%tm-%td" 格式化日期</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tF%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出时间类型 ***/</span>
        <span class="token comment">// 输出时分秒</span>
        <span class="token comment">// %t 之后用 H 表示输出时间的时（24 进制），%t 之后用 I 表示输出时间的时（12 进制），</span>
        <span class="token comment">// %t 之后用 M 表示输出时间的分，%t 之后用 S 表示输出时间的秒</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">,</span> dataL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 L 表示输出时间的秒中的毫秒</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tH:%1$tM:%1$tS %1$tL%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后 p 表示输出时间的上午或下午信息</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tH:%1$tM:%1$tS %1$tL %1$tp%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 以下是常见的时间组合</span>
        <span class="token comment">// %t 之后用 R 表示以 "%tH:%tM" 格式化时间</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tR%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 T 表示以 "%tH:%tM:%tS" 格式化时间</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tT%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 r 表示以 "%tI:%tM:%tS %Tp" 格式化时间</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tr%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*** 输出星期 ***/</span>
        <span class="token comment">// %t 之后用 A 表示得到星期几的全称</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tF %1$tA%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// %t 之后用 a 表示得到星期几的简称</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tF %1$ta%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出时间日期的完整信息</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1$tc%n"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText">1212end line
Name &#x3D; Zhangsan
NAME &#x3D; Zhangsan
Name &#x3D; Zhang san
true &#x3D; true; false &#x3D; false
-500; 2343; 342
37777777014; 4447; 526
fffffe0c; 927; 156
FFFFFE0C; 927; 156
-7.564030e+02; 7.464233e+03; 4.560000e+01
-7.564030E+02; 7.464233E+03; 4.560000E+01
-756.403015; 7464.232641; 45.600000
-756.4; 7464.233; 45.600000
20-09-06; 20-09-06
2020-September-06; 2020-Sep-06
09&#x2F;06&#x2F;20
2020-09-06
18:03:51; 06:03:51
18:03:51 273
18:03:51 273 pm
18:03
18:03:51
06:03:51 PM
2020-09-06 Sunday
2020-09-06 Sun
Sun Sep 06 18:03:51 CST 2020<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="python">Python</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th>转换说明符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d、%i</td>
<td>转换为带符号的十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>转换为带符号的八进制整数</td>
</tr>
<tr>
<td>%x、%X</td>
<td>转换为带符号的十六进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>转化为科学计数法表示的浮点数（e 小写）</td>
</tr>
<tr>
<td>%E</td>
<td>转化为科学计数法表示的浮点数（E 大写）</td>
</tr>
<tr>
<td>%f、%F</td>
<td>转化为十进制浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>智能选择使用 %f 或 %e 格式</td>
</tr>
<tr>
<td>%G</td>
<td>智能选择使用 %F 或 %E 格式</td>
</tr>
<tr>
<td>%c</td>
<td>格式化字符及其 ASCII 码</td>
</tr>
<tr>
<td>%r</td>
<td>使用 repr() 函数将表达式转换为字符串</td>
</tr>
<tr>
<td>%s</td>
<td>使用 str() 函数将表达式转换为字符串</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText"># 占位符
name &#x3D; &quot;maywzh 的网站 &quot;
age &#x3D; 8
url &#x3D; &quot;https:&#x2F;&#x2F;maywzh.com&quot;
print(&quot;%s 已经 %d 岁了，它的网址是 %s。&quot; % (name, age, url))

# 指定宽度
n &#x3D; 1234567
print(&quot;n(10):%10d.&quot; % n)
print(&quot;n(5):%5d.&quot; % n)
url &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;
print(&quot;url(35):%35s.&quot; % url)
print(&quot;url(20):%20s.&quot; % url)

#对齐方式
n &#x3D; 123456
# %09d 表示最小宽度为 9，左边补 0
print(&quot;n(09):%09d&quot; % n)
# %+9d 表示最小宽度为 9，带上符号
print(&quot;n(+9):%+9d&quot; % n)
f &#x3D; 140.5
# %-+010f 表示最小宽度为 10，左对齐，带上符号
print(&quot;f(-+0):%-+010f&quot; % f)
s &#x3D; &quot;Hello&quot;
# %-10s 表示最小宽度为 10，左对齐
print(&quot;s(-10):%-10s.&quot; % s)

# 指定小数精度
f &#x3D; 3.141592653
# 最小宽度为 8，小数点后保留 3 位
print(&quot;%8.3f&quot; % f)
# 最小宽度为 8，小数点后保留 3 位，左边补 0
print(&quot;%08.3f&quot; % f)
# 最小宽度为 8，小数点后保留 3 位，左边补 0，带符号
print(&quot;%+08.3f&quot; % f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Go</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从 JWT 聊聊认证</title>
    <url>/2017/02/10/%E5%AF%86%E7%A0%81%E5%AD%A6/%E4%BB%8EJWT%E8%81%8A%E8%81%8A%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p><strong>跨域认证 </strong> 意指把 A 服务的认证状态可分享给 B 服务，这样单服务的 Session+cookie 的解决方案就不合适了。我们可以通过服务端搭建 session 持久化层来解决这个问题，该层由多个服务共享，这种方式对持久化层的稳定性要求较高。另一种方式是把认证数据保存在客户端。其中一种方式就是<strong>Json Web Tokens</strong>(JWT)。</p>
<a id="more"></a>
<h2><span id="原理">原理</span></h2><p>JWT 是初次认证时，服务器把认证信息生成一个 Json 文本，回送给用户。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"andy"</span><span class="token punctuation">,</span>
  <span class="token property">"authority"</span><span class="token operator">:</span> <span class="token string">"admin"</span><span class="token punctuation">,</span>
  <span class="token property">"expire"</span><span class="token operator">:</span> <span class="token string">"201807010000000"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>往后用户与服务端通信的时候，都要发回这个 JSON 对象。服务器根据该对象来进行用户身份确认。服务器会在生成该对象时加上签名。</p>
<h2><span id="结构">结构</span></h2><p>JWT 由三个部分组成。</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">Header.Payload.Signature
头部. 负载. 签名
例：eyJhbGciOijIfdkKjf3mJKL.ejkajEgjkdesdIlk8HJKH9jKyh9jkh9hgty8k.4342kldffjklauyx9jh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。JWT 内部无换行。</p>
<h3><span id="header">Header</span></h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  <span class="token string">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>
  <span class="token string">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h3><span id="payload">Payload</span></h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>也可以自定义字段</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>
  <span class="token property">"admin"</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3><span id="signature">Signature</span></h3><p>为了防止用户篡改 token，需要签名字段 Signature。</p>
<p>把服务器的密钥 secret 作为参数传递到签名算法里面，按照如下公式进行加密。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">HMACSHA256</span><span class="token punctuation">(</span>
  <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span>
  <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>
  secret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h2><span id="使用方式">使用方式 </span></h2><p> 客户端收到服务器返回的 JWT，可以存放在 Cookie 中，也可以存放在 http 请求的 Authorization 头部字段中，这样可以跨域认证。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http">GET / HTTP/1.2
...
<span class="token header-name keyword">Authorization:</span> Bearer &lt;token>
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以放在 POST 请求的数据体里面。</p>
<h2><span id> </span></h2><h2><span id="特点">特点</span></h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>身份认证</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学之 Diffie-Hellman 密钥交换</title>
    <url>/2019/10/10/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8BDiffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange">Deffie-Hellman</a>(简称 DH) 密钥交换是最早的密钥交换算法之一，它使得通信的双方能在非安全的信道中安全的交换密钥，用于加密后续的通信消息。 Whitfield Diffie 和 Martin Hellman 于 1976 提出该算法，之后被应用于安全领域，比如 Https 协议的 TSL(<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>) 和 IPsec 协议的 IKE(<a href="https://en.wikipedia.org/wiki/Internet_Key_Exchange">Internet Key Exchange</a>) 均以 DH 算法作为密钥交换算法。</p>
<a id="more"></a>
<h2><span id="数论基础">数论基础 </span></h2><p> 理解 DH 算法前，先介绍一些必要的数论领域知识，分别是离散对数问题和一个求模公式。</p>
<h3><span id="离散对数问题">离散对数问题 </span></h3><p> 假定 a, p 均是素数，下面两个集合相等，证明过程请参考 <a href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 第八章：</p>
<script type="math/tex; mode=display">{a^1 (mod\ p), a^2 (mod\ p), ... a^{p-1}(mod\ p)} = {1,2,...,p-1}</script><p>上述式子可概括成以下三点，对于 1 &lt;= x,y &lt;= p - 1，有：</p>
<ul>
<li>$a^x (mod\ p)$ 一定属于 {1, 2, …, p -1}</li>
<li>$\forall x != y, a^x (mod\ p) \neq a^y (mod\ p)$</li>
<li>$1 \leq b \leq p - 1$，一定存在唯一的 $1 \leq x \leq p-1$，使得 $b = a^x (mod\ p)$</li>
</ul>
<blockquote>
<p>✨ 出于方便，我们在下面的推导中 $=$ 两边默认省略 $(mod\ p)$</p>
</blockquote>
<p>第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，那么这便是一个困难问题，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题 (<a href="https://en.wikipedia.org/wiki/Discrete_logarithm">Discrete logarithm</a>)，它是 DH 算法能够安全交换密钥的基础</p>
<h3><span id="求模公式">求模公式 </span></h3><p> 假设 q 为素数，对于正整数 a,x,y，有：</p>
<script type="math/tex; mode=display">(a^x)^y = a^{xy}</script><p>证明如下：</p>
<blockquote>
<p>令 $ a^x = mp + n$， 其中 m, n 为自然数，$ 0 \leq n &lt; p$，则有</p>
</blockquote>
<script type="math/tex; mode=display">\begin{equation} \begin{split} C &= (a^x)^y \\
  &= (mp + n)^y \\
  &= n^y \\
  &= (mp +n)^y \\
  &= a^{xy} \end{split} \end{equation}</script><h2><span id="deffie-hellman-算法原理">Deffie-Hellman 算法原理 </span></h2><p> 本文参考 <a href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 一书，介绍 DH 算法原理，在掌握上节数论知识的基础上，理解 DH 算法原理非常容易。</p>
<p>假设 A, B 两方进行通信前需要交换密钥，首先 A, B 共同选取 p 和 a 两个素数，其中 p 和 a 均公开。之后 A 选择一个自然数 Xa，计算出 Ya，Xa 保密，Ya 公开；同理，B 选择 Xb 并计算出 Yb，其中 Xb 保密，Yb 公开。之后 A 用 Yb 和 Xa 计算出密钥 K，而 B 用 Ya 和 Xb 计算密钥 K，流程如下：</p>
<pre class="line-numbers language-none"><code class="language-none">+-------------------------------------------------------------------+
|                    Global Pulic Elements                          |
|                                                                   |
|       p                               prime number                |
|       a                               prime number, a &lt; p         |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User A Key Generation                          |
|                                                                   |
|       Select private Xa               Xa &lt; p                      |
|       Calculate public Ya             Ya &#x3D; a^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User B Key Generation                          |
|                                                                   |
|       Select private Xb               Xb &lt; p                      |
|       Calculate public Yb             Yb &#x3D; a^Xb mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User A                 |
|                                                                   |
|       Secret Key K                    K &#x3D; Yb^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User B                 |
|                                                                   |
|       Secret Key K                    K &#x3D; Ya^Xb mod p             |
+-------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面证明，A 和 B 计算出来的密钥 K 相同。</p>
<blockquote>
<script type="math/tex; mode=display">\begin{equation}\begin{split} K = Yb^{Xa}
  = (a^{Xb})^{Xa}
  = a^{Xa \cdot Xb}          
  = (a^{Xa} )^{Xb} 
  = Ya^{Xb}\end{split} \end{equation}</script></blockquote>
<p>上面一共出现了 $a, p, Xa, Ya, Xb, Yb, K$ 共 7 个数，其中：</p>
<ul>
<li>公开的数：$a, p, Ya, Yb$</li>
<li>非公开数：$Xa, Xb, K$</li>
</ul>
<p>通常情况下，a 一般为 2 或 5，而 $p$ 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 <a href="https://en.wikipedia.org/wiki/Pollard&#39;s_rho_algorithm_for_logarithms">$O(p^{0.5})$</a>。对于攻击者来说，已知 $Ya，Xa$ 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在透明的信道中安全的交换密钥。<a href="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange#/media/File:Diffie-Hellman_Key_Exchange.svg">下图 </a> 非常形象的描述密钥交换流程：</p>
<p>​                        <img src="https://i.loli.net/2020/09/11/j7te34ZRPH59fYz.png" alt="DH key exchange"></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密和非对称加密</title>
    <url>/2017/01/27/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>对称加密和非对称加密，是加密通信中常见的两个概念。wiki 的定义是：</p>
<blockquote>
<p><strong>对称密钥加密 </strong> 是<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学 </a> 中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。</p>
<p><strong>非对称加密 </strong> 也称 <strong> 非对称加密 </strong>，是<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8"> 密码学 </a> 的一种 <a href="https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95"> 算法 </a>，它需要两个<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5"> 密钥 </a>，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87"> 明文 </a> 加密后所得的 <a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87"> 密文</a>，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。</p>
</blockquote>
<p>为了便于理解。我们来举例说明。</p>
<a id="more"></a>
<h2><span id="对称加密">对称加密 </span></h2><p> 回想起初中时代的小纸条了没，假设同学 A 想给同学 B 传一个小纸条，但是 A 离 B 隔着几个座位，需要由中间的 C 来帮忙传纸条，因为 C 是个爱打小报告的家伙，所以 A 和 B 都不想让 C 知道纸条中的具体内容是什么。于是 A 和 B 私下约定，纸条中的内容以摩尔斯编码来代替，例如要发送“hello”，那么纸条中就写“hello”的摩尔斯编码“…. . .-.. .-.. —- ”，由于 C 不知道 A 与 B 的约定转换规则，所以他即使看到了纸条的内容，也不知道 A 与 B 的交谈内容。但 B 得到了这个密文，通过对照摩尔斯编码转换表，就可以得到原始信息“hello”。</p>
<p>此时，A 与 B 就是通信的双方，摩尔斯编码就是密钥，也就是明文“hello”——&gt; 密文”…. . .-.. .-.. —“的映射关系。</p>
<p>A 与 B 用的是同一个密钥来加密解密信息，也就是摩尔斯编码。所以称为对称加密。</p>
<p>抽象一点来说，实际上密钥就是一种函数 / 映射关系，我们以 encry()来表示。整个传递过程如下：</p>
<pre class="line-numbers language-none"><code class="language-none">A 明文 ----&gt;encry----&gt;A 密文 ----&gt;C 信道 ----&gt;B 密文 ----encry----&gt;B 明文<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一句话总结就是，对称加密就是通信双方用的是相同密钥来进行加密和解密。</p>
<p>常见的对称加密算法有</p>
<blockquote>
<p>DES、3DES、AES、Blowfish、IDEA、RC5、RC6。</p>
</blockquote>
<h3><span id="缺陷">缺陷 </span></h3><p> 对称加密相当简单，但有一个致命的缺陷就是，一旦密钥被第三方获取，那么加密的信息就全部泄漏了。依旧以上面的例子为例，C 知道了 A 与 B 是用摩尔斯编码来通信，那么他获取了摩尔斯编码表，就相当于完全掌握了 A 与 B 的通信内容。为了解决这个问题，人们又引入了非对称加密算法。</p>
<h2><span id="非对称加密">非对称加密 </span></h2><p> 对称加密算法在于共同的密钥，非对称加密算法的做法是，每个人生成一个私钥 - 公钥对，私钥由个人保护不公开，而公钥可以随便分享，最关键的是，<strong>使用公钥加密的信息，只有对应的私钥才能解密，使用私钥加密的信息，只有对应的公钥能解密</strong>。</p>
<p>假设，A 生成了自己的一个私钥 - 公钥对“A 私钥 -A 公钥”，B 也生成了自己的私钥 - 公钥对“B 私钥 -B 公钥”，依照非对称加密的原则，A 的私钥由 A 保存只有 A 知道，B 同理。</p>
<p>此刻，A 想给 B 发送密文。</p>
<p>通信过程如下：</p>
<pre class="line-numbers language-none"><code class="language-none">A: “hi，老哥，我想给你发个密文，把你的公钥发给我一下”
B: “好啊好啊，这是我的公钥‘HE8eU#hb*!’，请查收”
A: ”这是密文 &#39;jk2$$#4dfjkl&#96;&#96;$@#cds&#39;“<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这时 C 听到了 A 和 B 的通话，而且知道了 B 的公钥‘HE8eU#hb<em>!’和密文’jk2$$#4dfjkl``$@#cds’。他兴奋地回去，想要解密密文，听听 A 和 B 到底在说什么。但是他发现没有办法解密这个密文。为什么？因为 <strong> 密文是用 B 的公钥来加密的</strong>，<em>* 只有 B 的私钥才能解密</em></em>！所以 C 除了 B 的公钥和密文之外什么也得不到。这就是非对称加密的强大之处。 </p>
<p>总结一下通信过程，假设某人发送信息，那么他先要获取对方的公钥，再用这个公钥来加密明文为密文发送给对方，对方再用自己私钥来解密信息。而第三方没有私钥，所以没法解密。</p>
<p>一句话总结，非对称加密的非对称表现在，<strong>加密的密钥公开，而解密的密钥不公开</strong>。</p>
<h3><span id="实例">实例 </span></h3><p> 我们常用的密钥方式 ssh 登陆服务器的流程就是以非对称加密方式实现的：</p>
<ol>
<li>远程服务器持有用户公钥，当有用户进行登录，服务器就会随机生成一串字符串，然后发送给正在进行登录的用户。</li>
<li>用户收到远程服务器发来的字符串，使用与 <strong> 远程服务器公钥配对的私钥 </strong> 对字符串进行加密，再发送给远程服务器。</li>
<li>服务器使用公钥对用户发来的加密字符串进行解密，得到的解密字符串如果与第一步中发送给客户端的随机字符串一样，那么判断为登录成功。</li>
</ol>
<h3><span id="缺陷">缺陷 </span></h3><p> 非对称加密可以确保，发送方知道接收方的公钥的前提下，该密文在有效时间内无法被破解。但请注意这个前提，发送方知道接收方公钥，也就是说，第三方可以伪造自己的公钥为接收方公钥，在第一次通信建立的时候，发送方无法分辨他得到的公钥是不是接收方公钥。如何解决这个问题呢？答案就是数字签名和数字证书。详情请见</p>
<hr>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学之椭圆曲线</title>
    <url>/2019/11/05/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>我们在《几何》课本里学过二元一次方程表示直线，二元二次方程表示圆锥曲线(圆，椭圆，双曲线和抛物线)，那么二元三次方程表示什么曲线呢？答案自然就是椭圆曲线。为了方便研究，大部分的二元三次方程可以简化成魏尔斯特拉斯方程的形式。其中，系数 a 和 b 需要满足条件 $4a^3 + 27b^2 \neq 0$，该条件保证方程中不会出现非奇异点以获得平滑的椭圆曲线。</p>
<p>椭圆曲线的形状跟椭圆毫无关系。当初数学家们在研究如何计算椭圆弧长的时候发现需要求解如下类型的积分, 由于和椭圆相关，积分中的分母项 $y =\sqrt{(x^3+ax+b)}$ 便被称作椭圆曲线。</p>
<script type="math/tex; mode=display">
\int_{\alpha}^{\beta}{\frac{dx}{\sqrt{x^3+ax+b}}}</script><p>下图展示了一些合法的椭圆曲线，</p>
<p><img src="https://i.loli.net/2020/09/11/HVAGpxoOJeICg4L.png" alt="img"></p>
<p>下图展示了两种非法的椭圆曲线，分别存在一个尖点和叉点使曲线不平滑。</p>
<p><img src="https://i.loli.net/2020/09/11/PBChKjWvuZrtcwx.png" alt="6663612-59e2ae0394772adb"></p>
<a id="more"></a>
<h2><span id="密码学与有限循环群">密码学与有限循环群 </span></h2><p> 现代密码学算法和协议中，消息是作为有限空间中的数字或元素来处理的。加密和解密的各种操作必须在消息之间进行变换，以使变换服从有限消息空间内部的封闭性。然而，数的一般运算诸如加减乘除并不满足有限空间内部的封闭性。所以密码算法通常运行于具有某些保持封闭性的代数结构的空间中，这种代数结构就是 <strong> 有限循环群</strong>。在数学中，群是一种代数结构，由一个集合以及一个二元运算组成。群必须满足以下四个条件：封闭性，结合律，存在单位元和存在逆元。</p>
<h2><span id="椭圆曲线群定义">椭圆曲线群定义</span></h2><p>1985 年，Neal Koblitz 和 Victor S.Miller 分别独立提出利用椭圆曲线产生椭圆曲线循环群用于密码学。在数学上，椭圆曲线群的元素为椭圆曲线上的点，群操作为”+”,”+”的定义为，给定曲线两点 $P，Q，P+Q$ 等于 $P$ 和 $Q$ 两点的连线与曲线交点沿 X 轴的对称点，如果 $P=Q$，则 $P+P$ 等于 P 在曲线上的切线与曲线交点沿 X 轴的对称点。该群的单位元为无穷远零点记作 $O=(0,0)$，有 $P+O=P$，点 P 的逆元为其沿 X 轴的对称点，记作 $-P$。</p>
<p>下图演示了如何计算 $P+Q=R(P\neq Q)$</p>
<p><img src="https://i.loli.net/2020/09/11/42pa379WjufgEOs.png" alt="6663612-092e13fc0b2a01eb"></p>
<p>下图演示了如何计算 $P+Q=2P=R(P=Q)$。</p>
<p><img src="https://i.loli.net/2020/09/11/aOgDzy4JedX1RnS.png" alt="6663612-6f8e91a21db4b3e3"></p>
<p>下图演示了如何计算 $P$ 的逆元 $-P$。</p>
<p><img src="https://i.loli.net/2020/09/11/iuAdvgZBc54NKwn.png" alt="6663612-ef00d3b116ffb790"></p>
<h2><span id="椭圆曲线有限循环群">椭圆曲线有限循环群 </span></h2><p> 前面介绍的椭圆曲线都是基于有理数的，但是计算机运算浮点数 (小数) 的速度较慢，更重要的是四舍五入浮点数会产生误差，导致多次加密解密操作后原始消息不能被还原。故考虑到加密算法的可实现性，密码学上使用基于整数的模加运算产生椭圆曲线有限循环群。</p>
<p>本文不涉及具体的数学计算，将用具体的例子展示如何产生 ECC 有限循环群。例如考虑 $y^2=x^3-7x+10\ (mod\  19)$ 的集合，该集合中所有的元素如下图所示。模运算把发散的椭圆曲线映射到 $19\times 19$ 的正方形空间中，并且保持了原有曲线的上下对称特性。</p>
<p><img src="https://i.loli.net/2020/09/11/wA3g81lh6yupBQO.png" alt="6663612-95901135c214ebea"></p>
<p>下图展示了 $y^2=x^3-7x+10\ (mod\ 19)$ 集合中的元素和椭圆曲线的关系。</p>
<p>点 $Q’$ 映射到点 $Q$，点 P 的对称点也由点 $-P’$ 映射到点 $-P$。</p>
<p><img src="https://i.loli.net/2020/09/11/OlF2SeAchVWC486.png" alt="6663612-f99ccd0e5533dc70"></p>
<p>如果取一个更大的质数 $p$ 进行模运算，集合中的元素点也会相应地增多。下图展示了利用同一个曲线方程进行不同模运算的结果。在实际的椭圆曲线加密算法中，使用长度为 192-256 位的质数 $p$ 进行模运算。</p>
<p><img src="https://i.loli.net/2020/09/11/IB4EoegpHlNiT71.png" alt="6663612-6aa923268fa3e091"></p>
<p>现在我们基于 $y^2=x^3-7x+10\ (mod\ 19)$，利用产生元 $P=(2,2)$ 来生成 ECC 有限循环群。如下图所示。具体的计算使用 <a href="http://www.christelbach.com/ECCalculator.aspx"> 在线 ECC 计算器</a>。</p>
<p>得到如下结果:</p>
<script type="math/tex; mode=display">
1P=(2,2)\\
2P=(13,8)\\
3P=(1,2)\\
4P=(16,17)\\
5P=(10,3)\\
...\\
22P=(13,11)\\
23P=(2,17)\\
24P=(0,0)</script><p>$G={nP|P=(2,2)}$ 完整的集合为</p>
<p>${p=(2,2),2P=(13,8),3P=(1,2), … 23P=(2,17),24P=O=(0,0)}$</p>
<h2><span id="椭圆曲线离散对数问题-ecdlp">椭圆曲线离散对数问题 ECDLP</span></h2><p>请问上图中与点 $Q$ 相对应的 $n$ 值为多少？</p>
<p>查找集合 $G={nP|P=(2,2)}$ 中的元素可知答案是 $Q=(5,10)=10P$，但是实际应用中没有现成的集合可供查表。若已知某个点 Q，只能用比较原始的方法演算可能的 $n$ 值，目前可实现的效率最高的算法为 Baby-step giant-step 算法，计算复杂度为 $O(\sqrt{n})$。反过来，如果已知 n 计算 $n*P$ 则简单的多，因为有限循环群满足结合律，可以使用 square and multiply 算法，计算复杂度为 $O(2log2n)$。例如，比特币使用名为 secp256k1 的标准 ECC 曲线，$n$ 的长度为 256 位. Baby-step giant-step 算法的计算复杂度为 $O(2^{128})$，而 square and multiply 算法的计算复杂度仅为 O(512)。</p>
<p>用密码学术语描述为：ECC 有限循环群构成了一个单向函数 $Q=nP$，已知 $n,P$ 可以很容易计算 $Q$；反过来已知 $P,Q$ 则难以计算 $n$. 于是 $(n,Q=n\cdot P)$ 构成了一对私钥和公钥。</p>
<p>举个具体的例子，利用 square and multiply 算法计算 Q=137P，仅需 9 步便得到计算结果。</p>
<h2><span id="ecdh-基于椭圆曲线的-diffie-hellman-密钥交换">ECDH 基于椭圆曲线的 Diffie-Hellman 密钥交换</span></h2><p>ECC 可以用于加密解密，但是由于其算法复杂计算速度慢，故莱迪思 iCE40 UltraPlus 系列芯片综合使用 ECDH 算法进行密钥交换，再通过 AES 进行消息的快速加密 / 解密助力于 IoT 通信。故本文以 iCE40 UltraPlus 芯片的 Security IP 为例介绍 ECDH 密钥交换。下图为 ECDH 密钥交换算法的示意图，iCE40Plus 和 Host 分别产生自己的私钥和公钥，然后通过公共网络把公钥分享给对方，再各自使用私钥在本地计算出相同的密钥进行 AES 加密通信。</p>
<p><img src="https://i.loli.net/2020/09/11/IHxbt7OJ8SgXFka.png" alt="6663612-b52df96317d4d4bf"></p>
<p>由于有限循环群满足交换律，我们可以验证</p>
<script type="math/tex; mode=display">
{KEY}_{Host}=m\cdot n\cdot P=n\cdot m\cdot P={KEY}_{FPGA}</script>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名和数字证书</title>
    <url>/2017/06/03/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>我们已经知道，非对称加密可以保证通信安全，但无法确认通信对象的身份。为了解决这个问题，就需要数字签名和数字证书技术了。</p>
<a id="more"></a>
<h2><span id="身份认证问题">身份认证问题 </span></h2><p> 非对称加密中，双方需要交换密钥，然后各自用对方的密钥加密发送的信息，对方则用自己的私钥去解密信息，这样保证了通信过程的安全，但没法确保通信对象的身份问题，第三方可以伪造身份，把自己的密钥给监听对象。</p>
<p>所以问题的核心在于身份认证。现实生活中我们是用身份证等证件进行身份认证，它的有效性由权威性国家机构担保。类似的，在互联网中，也有权威性机构作为担保，它就是 CA，又称为证书授权（Certificate Authority）中心。它通过数字证书来认证互联网用户身份。假如把公钥比作互联网用户的电话号码的话，那么 CA 就是电话局，通过证书来确认电话号码对应互联网用户。</p>
<h2><span id="数字证书是什么">数字证书是什么 </span></h2><p> 一句话概括，数字签名就是用户信息 / 公钥的密文，数字证书就是数字签名文件。</p>
<p>举个例子，A 想要认证 A 的公钥，那么 A 需要去 CA（Certificate Authority）申请证书，CA 就会用 CA 的思钥来加密 A 的个人信息和 A 的公钥信息为密文，这个密文被称为数字签名，数字签名被签在一个文件中，这个文件就是数字证书。</p>
<p>B 想要与 A 通信，要先认证 A 的身份，那么 A 需要把该证书给 B，B 会去 CA 申请 CA 的公钥去解密该证书上的签名（密文），因为只有 CA 的公钥才能解密 CA 的私钥加密的签名，所以这个签名可以确保来自于 CA，确保安全。B 解密签名后获得了 A 的公钥和 A 的信息，就可以与 A 建立通信了。</p>
<p>这里 CA 的公钥是关键，所有人都需要 CA 的公钥才能去验证证书，CA 的公钥也被称为根证书。一般根证书都是预先安装在电脑或浏览器上的。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>身份认证</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>WakaTime - 时间记录工具</title>
    <url>/2017/09/28/%E5%B7%A5%E5%85%B7/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E4%B9%8BWakaTime/</url>
    <content><![CDATA[<p>提高自制力的一个有效的方式就是自我量化，其中一个重要的维度即是时间记录，通过对我们的工作、生活各个方面进行数据记录和分析，可以帮助我们优化自己的时间管理策略，提高生产力。<br>对程序员而言，我们迫切需求有一个工具能够记录我们在工作中的时间分配和利用率。对于项目管理而言，也有了解开发人员开发效率的需求。<br><a href="WakaTime.com">WakaTime</a>正是这样一个工具。它专为程序员和开发者而设计，通过简单配置，它就可以记录我们花在各个项目、各种工具 (IDE、浏览器、编辑器等) 以及具体工作内容的时间。<br>对比 Rescuetime 的大而全，Wakatime 专精于记录编程和编辑的方面。推荐开发者都去试试，至少可以帮助提升自制力… :)</p>
<a id="more"></a>
<p>。</p>
<center>△ WakaTime 仪表盘</center>

<h3><span id="开始使用">开始使用 </span></h3><p> 首先去 <a href="WakaTime.com">WakaTime</a> 注册一个账户。我们也可以用自己的 Github 账户来授权登陆 WakaTime。然后我们需要给我们的 IDE 或者编辑器安装 WakaTime 时间记录插件，目前 WakaTime 已经基本支持主流的 IDE。</p>
<h3><span id="安装-ide-插件">安装 IDE 插件 </span></h3><p> 我们以 VS Code 和 Chrome 为例，分别给 IDE 和浏览器安装插件。</p>
<p>点击左边栏 Supported IDES 这个选项，然后点击 VS Code 选项。</p>
<p>按照官网的提示，我们在 VS Code 中下载好插件，重启 VS Code</p>
<p>按<code>F1</code>，出现选项框</p>
<p>选择 WakaTime API Key， 此时我们需要去 <a href="https://WakaTime.com/settings/account">WakaTime Account</a> 页面获取我们的 API Key，来关联我们的账户。</p>
<p>把 API Key 复制下来粘贴到 VS Code 的 WakaTime API Key 框，然后<code>Enter</code>。</p>
<p>此时 VS Code 的 WakaTime 就配置完成了。</p>
<h3><span id="数据可视化">数据可视化 </span></h3><p> 到<a href="https://WakaTime.com/dashboard">WakaTime Dashboard</a>页面查看，我们的 VS Code 已经开始记录了。</p>
<p>(我这里是已经安装了多个 IDE 插件的结果)</p>
<p>如果 VS Code 打开了一个项目，例如我们打开一个 tcpudp 的 demo。</p>
<p>在 <a href="https://WakaTime.com/dashboard">WakaTime Dashboard</a> 的下面的 Projects 栏就会多出一个</p>
<p>里面也有项目所用语言、编辑器的细节。</p>
<p><a href="https://WakaTime.com/dashboard">WakaTime Dashboard</a>也有各个项目的时间轴，可以查看我们在每个项目上花的时间。</p>
<h3><span id="设置目标">设置目标 </span></h3><p> 我们可以为每个项目设置每日要完成的目标，例如每工作日花三小时。</p>
<p>可以订阅这个目标，然后系统会发送邮件给我们提醒。</p>
<h3><span id="集成到其他网站">集成到其他网站</span></h3><p>WakaTime 提供了统计结果的 HTML 代码，我们可以把它分享到 Facebook 等社交网站上，也可以直接挂在我们的博客上。</p>
<h3><span id="积分榜">积分榜 </span></h3><p> 我们可以把自己的数据放在 Leaderboards 上去排位。</p>
<h3><span id="api-文档">API 文档 </span></h3><p> 可以在 <a href="https://WakaTime.com/developers">WakaTime API</a> 里面查询 WakaTime 提供的 API，来进行丰富的功能定制。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 生产力之——Terminal 命令</title>
    <url>/2016/01/05/%E5%B7%A5%E5%85%B7/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E4%B9%8BmacOS%E7%9A%84%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>记录下常用的 macOS 命令。<br><a id="more"></a></p>
<p>&nbsp;</p>
<h2><span id="open-打开文件-目录或执行程序">open - 打开文件、目录或执行程序 </span></h2><p><code>open</code> 其实等同于我们在 GUI 下面执行双击命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">open</span> /Applications/Dictionary.app <span class="token comment">#Dictionary 应用 </span>
<span class="token function">open</span> ~/Movies <span class="token comment"># 开当前用户 Movies 目录</span>

<span class="token function">touch</span> ~/1.txt <span class="token comment"># 创建 1.txt</span>
<span class="token function">open</span> -e ~/1.txt <span class="token comment"># 打开 1.txt 并用 TextEdit 编辑</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们也可以直接把文件夹拖入 Terminal 就会在命令行直接出现该文件夹路径。</p>
<p>&nbsp;</p>
<h2><span id="say-文字转语音">say - 文字转语音 </span></h2><p><code>say</code> 是命令行上的 VoiceOver：</p>
<pre class="line-numbers language-none"><code class="language-none">$ say &quot;Never trust a computer you can&#39;t lift.&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用 <code>-f</code> 选项朗读特定文本文件，<code>-o</code>选项将朗读结果存为音频文件而不是播放：</p>
<pre class="line-numbers language-none"><code class="language-none">$ say -f mynovel.txt -o myaudiobook.aiff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>say</code>命令也可以用于在脚本中播放警告或提示可以在系统设置（System Preferences）的字典和语音（Dictation &amp; Speech）选项中调整系统的语音选项甚至是语音的语言。</p>
<p>&nbsp;</p>
<h2><span id="screencapture-截图">screencapture - 截图 </span></h2><p><code>screencapture</code> 实际上就是命令行上的 Grab.app。</p>
<p>全屏幕截图，并保存为 image.png，作为新邮件的附件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ screencapture -C -M image.png <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>鼠标选择抓取范围并复制到剪贴板：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ screencapture -c -W<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>延迟 10 秒截屏，用 preview.app 打开</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ screencapture -T <span class="token number">10</span> -P image.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>鼠标选择抓取范围保存到 image.pdf 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ screencapture -s -t pdf image.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更多用法可以参阅<code>screencapture --help</code>。</p>
<p>&nbsp;</p>
<h2><span id="pbcopypbpaste-直接与系统剪贴板交互">pbcopy/pbpaste - 直接与系统剪贴板交互 </span></h2><p> 在命令行拷贝到系统剪贴板一般是用鼠标选中需要的部分然后 <kbd>⌘</kbd>+<kbd>c</kbd>，反之从系统剪贴板粘贴到命令行则是<kbd>⌘</kbd>+<kbd>v</kbd>。但这样效率并不高，macOS 提供了<code>pbcopy</code> 和<code>pbpaste</code>工具来进行命令行和系统剪贴板的交互。</p>
<p>利用管道符来传递待拷贝内容到 pbcopy 命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> ~ <span class="token operator">|</span> pbcopy <span class="token comment"># 把 ls ~ 的结果拷贝到系统剪贴板 </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以利用重定向符号来传递内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pbcopy <span class="token operator">&lt;</span> blogpost.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们也可以多个命令组合起来实现一个复杂的操作，如访问 Google 拷贝其徽标</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://www.google.com/doodles<span class="token punctuation">\</span>#oodles/archive <span class="token operator">|</span> <span class="token function">grep</span> -A5 <span class="token string">'latest-doodle on'</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'img src'</span> <span class="token operator">|</span> <span class="token function">sed</span> s/.*<span class="token string">'&lt;img src="\/\/'</span>/<span class="token string">''</span>/ <span class="token operator">|</span> <span class="token function">sed</span> s/<span class="token string">'"alt=".*'</span>/<span class="token string">''</span>/ <span class="token operator">|</span> pbcopy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>利用管道语法可以选取要拷贝的内容，我们也可以利用 pbcopy 和 pbpaste 来实现自动化工作流，例如抓取 <a href="api.github.com">Github 的 api</a> 到本地的文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> https://api.github.com <span class="token operator">|</span> pbcopy <span class="token operator">&amp;&amp;</span> pbpaste <span class="token operator">>></span> ~/api.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>&nbsp;</p>
<h2><span id="mdfind-命令行上的-spotlight">mdfind - 命令行上的 Spotlight</span></h2><p>类似于 Spotlight，<code>mdfind</code>可以实现自定义查找，例如文件内容匹配和元数据查找。</p>
<p><code>mdfind</code>还提供更多的搜索选项。例如 <code>-onlyin</code> 选项可以约束搜索范围为一个目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mdfind -onlyin ~/Documents essay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>mdfind</code>的索引数据库在后台自动更新。</p>
<p>&nbsp;</p>
<h2><span id="launchctl-macos-启动脚本">launchctl - macOS 启动脚本 </span></h2><p><code>launchctl</code> 管理 OS X 的启动脚本和定时服务。类似于 linux 的 cron。</p>
<p>显示当前的启动脚本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ launchctl list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>开机自启动 apache 服务器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>停止正在运行的 apache 服务</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> launchctl unload /System/Library/LaunchDaemons/org.apache.httpd.plist <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>停止并取消开机启动的 apache 服务</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Launchd 脚本存储位置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~/Library/LaunchAgents    
/Library/LaunchAgents          
/Library/LaunchDaemons
/System/Library/LaunchAgents
/System/Library/LaunchDaemons<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动脚本的格式可以参考 <a href="http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/"> 这篇 blog</a>，或苹果开发者中心的 <a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html"> 文章 </a>。也可以使用<a href="http://www.peterborgapps.com/lingon/">Lingon</a> 应用来完全取代命令行。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>K 均值聚类与 python 实现</title>
    <url>/2017/09/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>K-means 算法采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大，是很典型的基于距离的聚类算法。该算法认为簇是由距离靠近的对象组成的，因此把得到紧凑且独立的簇作为最终目标。</p>
<a id="more"></a>
<h2><span id="步骤">步骤 </span></h2><p> 算法步骤：</p>
<ul>
<li>创建 k 个点作为起始支点(随机选择)</li>
<li>当任意一个簇的分配结果发生改变的时候</li>
<li>对数据集的每个数据点<ul>
<li>对每个质心<ul>
<li>计算质心与数据点之间的距离</li>
</ul>
</li>
<li>将数据分配到距离其最近的簇</li>
</ul>
</li>
<li>对每一簇，计算簇中所有点的均值并将其均值作为质心</li>
</ul>
<p>k 个初始类聚类中心点的选取对聚类结果具有较大的影响，因为在该算法第一步中是随机的选取任意 k 个对象作为初始聚类的中心，初始地代表一个簇。该算法在每次迭代中对数据集中剩余的每个对象，根据其与各个簇中心的距离将每个对象重新赋给最近的簇。当考察完所有数据对象后，一次迭代运算完成，新的聚类中心被计算出来。如果在一次迭代前后，J 的值没有发生变化，说明算法已经收敛。</p>
<h2><span id="测试数据集">测试数据集 </span></h2><p> 首先从 <code>sklearn</code> 导入数据集。我们用非常著名的 <code>iris</code> 数据集。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt

iris <span class="token operator">=</span> datasets<span class="token punctuation">.</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target

data <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment"># 为了便于可视化，只取两个维度</span>
plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="欧式距离">欧式距离 </span></h2><p> 计算欧式距离，我们需要为每个点找到离其最近的质心，需要用这个辅助函数。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""
  Return Eclud distance between two points.
  p1 = np.array([0,0]), p2 = np.array([1,1]) => 1.414
  """</span>
  tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token operator">-</span>p2<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>

distance<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">1.4142135623730951<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="随机质心">随机质心 </span></h2><p> 在给定数据范围内随机产生 k 个簇心，作为初始的簇。随机数都在给定数据的范围之内 <code>dmin + (dmax - dmin) * np.random.rand(k)</code> 实现。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rand_center</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""Generate k center within the range of data set."""</span>
  n <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># features</span>
  centroids <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># init with (0,0)....</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dmin<span class="token punctuation">,</span> dmax <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    centroids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dmin <span class="token operator">+</span> <span class="token punctuation">(</span>dmax <span class="token operator">-</span> dmin<span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
  <span class="token keyword">return</span> centroids

centroids <span class="token operator">=</span> rand_center<span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
centroids<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">array([[4.18354619, 2.3433686],[3.22403937, 0.17507507]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="k-均值聚类">k 均值聚类 </span></h2><p> 这个基本的算法只需要明白两点。</p>
<ul>
<li>给定一组质心，则簇更新，所有的点被分配到离其最近的质心中。</li>
<li>给定 k 簇，则质心更新，所有的质心用其簇的均值替换</li>
</ul>
<p>当簇不在有更新的时候，迭代停止。当然 kmeans 有个缺点，就是可能陷入局部最小值，有改进的方法，比如二分 k 均值，当然也可以多计算几次，去效果好的结果。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">kmeans</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">_distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    Return Eclud distance between two points.
    p1 = np.array([0,0]), p2 = np.array([1,1]) => 1.414
    """</span>
    tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token operator">-</span>p2<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">_rand_center</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Generate k center within the range of data set."""</span>
    n <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># features</span>
    centroids <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># init with (0,0)....</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        dmin<span class="token punctuation">,</span> dmax <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        centroids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dmin <span class="token operator">+</span> <span class="token punctuation">(</span>dmax <span class="token operator">-</span> dmin<span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    <span class="token keyword">return</span> centroids

  <span class="token keyword">def</span> <span class="token function">_converged</span><span class="token punctuation">(</span>centroids1<span class="token punctuation">,</span> centroids2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># if centroids not changed, we say 'converged'</span>
      set1 <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> centroids1<span class="token punctuation">]</span><span class="token punctuation">)</span>
      set2 <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> centroids2<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>set1 <span class="token operator">==</span> set2<span class="token punctuation">)</span>


  n <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># number of entries</span>
  centroids <span class="token operator">=</span> _rand_center<span class="token punctuation">(</span>data<span class="token punctuation">,</span>k<span class="token punctuation">)</span>
  label <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">,</span>dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment"># track the nearest centroid</span>
  assement <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token comment"># for the assement of our model</span>
  converged <span class="token operator">=</span> <span class="token boolean">False</span>

  <span class="token keyword">while</span> <span class="token keyword">not</span> converged<span class="token punctuation">:</span>
    old_centroids <span class="token operator">=</span> np<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>centroids<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token comment"># determine the nearest centroid and track it with label</span>
      min_dist<span class="token punctuation">,</span> min_index <span class="token operator">=</span> np<span class="token punctuation">.</span>inf<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>
      <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        dist <span class="token operator">=</span> _distance<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>centroids<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> dist <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>
          min_dist<span class="token punctuation">,</span> min_index <span class="token operator">=</span> dist<span class="token punctuation">,</span> j
          label<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j
      assement<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> _distance<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>centroids<span class="token punctuation">[</span>label<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span>

    <span class="token comment"># update centroid</span>
    <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
      centroids<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">[</span>label<span class="token operator">==</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
    converged <span class="token operator">=</span> _converged<span class="token punctuation">(</span>old_centroids<span class="token punctuation">,</span>centroids<span class="token punctuation">)</span>
  <span class="token keyword">return</span> centroids<span class="token punctuation">,</span> label<span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>assement<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于算法可能局部收敛的问题，随机多运行几次，取最优值</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">best_assement <span class="token operator">=</span> np<span class="token punctuation">.</span>inf
best_centroids <span class="token operator">=</span> <span class="token boolean">None</span>
best_label <span class="token operator">=</span> <span class="token boolean">None</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  centroids<span class="token punctuation">,</span> label<span class="token punctuation">,</span> assement <span class="token operator">=</span> kmeans<span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> assement <span class="token operator">&lt;</span> best_assement<span class="token punctuation">:</span>
    best_assement <span class="token operator">=</span> assement
    best_centroids <span class="token operator">=</span> centroids
    best_label <span class="token operator">=</span> label

data0 <span class="token operator">=</span> data<span class="token punctuation">[</span>best_label<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span>
data1 <span class="token operator">=</span> data<span class="token punctuation">[</span>best_label<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如下图，我们把数据分为两簇，绿色的点是每个簇的质心。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fig<span class="token punctuation">,</span> <span class="token punctuation">(</span>ax1<span class="token punctuation">,</span>ax2<span class="token punctuation">)</span> <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax1<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'c'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span>
ax2<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data0<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data0<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>
ax2<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'c'</span><span class="token punctuation">)</span>
ax2<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>centroids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>centroids<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="http://mitscherlich.me/assets/k-means/output.png"><img src="http://mitscherlich.me/assets/k-means/output.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何分辨 CLI、Terminal、Console 和 Shell</title>
    <url>/2015/09/25/%E7%A7%91%E6%99%AE/%E7%A7%91%E6%99%AE%E4%B9%8B%E5%88%86%E8%BE%A8CLI%E3%80%81Terminal%E3%80%81Console%E5%92%8CShell/</url>
    <content><![CDATA[<p>CLI 命令行界面、Terminal 终端 、Console 控制台和 Shell，是几个比较容易混淆的概念。</p>
<p>虽然经常在工作中遇到这些概念，但常常处于半知半解的状态，下文通过聊聊计算机发展史的方式初步探讨一下这些术语。</p>
<hr>
<h2><span id="一句话概括">一句话概括</span></h2><ul>
<li><strong>命令行界面</strong> (CLI) = 使用文本命令进行交互的用户界面</li>
<li><strong>终端</strong> (Terminal) = <strong>TTY</strong> = 文本输入 / 输出环境</li>
<li><strong>控制台</strong> (Console) = 一种特殊的终端</li>
<li><p><strong>Shell</strong> = 命令行解释器，执行用户输入的命令并返回结果</p>
<a id="more"></a>
</li>
</ul>
<h2><span id="命令行界面cli"> 命令行界面(CLI)</span></h2><blockquote>
<p>命令行界面（英语：Command-line Interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。</p>
</blockquote>
<p>命令行界面相对于我们日常使用的图形用户界面 (GUI) 而言，是一种操作效率极高的操作系统管理和控制方式。</p>
<p>▲ <em>命令行界面</em></p>
<p>▲<em>图形界面</em></p>
<p>尽管图形界面人机交互更加友好和现代化，但相对于直观的命令行界面来说，其操作效率远远不如，所以现代所有的操作系统都提供了命令行的操作方式。例如 macOS 的 Terminal，Windows 的 Powershell。</p>
<h2><span id="终端-terminal"> 终端 (Terminal)</span></h2><p> 终端是一种用于与计算机进行交互的输入输出设备，其特征就是，我们在上面输入命令，命令传递给计算机，计算机把处理结果反馈到终端的显示界面上。终端本身不参与计算和处理任务。</p>
<h3><span id="起源">起源 </span></h3><p> 在大型机和小型机时代，计算机体型相当巨大，往往是安放在单独的计算机室，操作用户则利用另外的终端设备与之交互。而现在常见的键盘和显示器在当时相当昂贵。</p>
<p>Unix 的创始人 Ken Thompson 和 Dennis Ritchie 想让 Unix 成为一个多用户系统。多用户系统就意味着要给每个用户配置一个终端，每个用户都要有一个显示器、一个键盘。但当时所有的计算机设备都非常昂贵（包括显示器），而且键盘和主机是集成在一起的，根本没有独立的键盘。</p>
<p>当时有一种电传打字机，其原本用途是在电报线路上首发电报，它有可以作为输入设备的键盘，也有作为输出设备的纸袋打印机，价格也比较低廉。于是完美满足了这一需求。</p>
<p>▲<em>电传打字机</em></p>
<p>于是他们机智地把电传打字机连接到计算机上，每个用户都可以在终端登录并操作主机。看起来是不是十分 geek？</p>
<h3><span id="控制台">控制台 </span></h3><p> 控制台是一种特殊的终端，普通的终端都是以外设的形式连接到计算机，而控制台是计算机自带的的控制面板。</p>
<p>▲<em>左边是控制台 右边是终端</em></p>
<p>控制台一般是系统管理员操作，有更高的控制权限。</p>
<p>但随着个人计算机的普及，控制台和终端的概念已经逐渐模糊，我们往往具有对计算机的全部控制权限。目前的输入（键盘等）输出设备（显示器等）既可以充当控制台可以作为终端使用。因此，现在 Console 与 Terminal 基本被看作是同义词。</p>
<h3><span id="终端模拟器">终端模拟器 </span></h3><p> 如今，图形操作界面已经成为了主流。有许多优秀的命令行程序不兼容如今的图形化操作界面，为了在图形界面下与之交互，人们发明了终端模拟器来模拟终端。</p>
<p>对于命令行程序，终端模拟器与传统的终端实体机无异，而对于我们的图形操作界面，它又相当于一个 GUI 程序。</p>
<p>其工作流如下</p>
<p>实际上起到一个命令行程序和 GUI 的中介作用。</p>
<p>终端模拟器有很多</p>
<ul>
<li>GNU/Linux：gnome-terminal、Konsole；</li>
<li>macOS：Terminal、iTerm2；</li>
<li>Windows：cmd.exe、ConEmu 等。</li>
</ul>
<p><img src="/Users/maywzh/Desktop/Screen Shot 2018-09-25 at 7.16.13 PM.png" alt="Screen Shot 2018-09-25 at 7.16.13 PM"></p>
<p>▲<em>macOS 下的 Terminal 就是一种终端模拟器</em></p>
<h3><span id="tty-是啥">tty 是啥 </span></h3><p> 有的时候我们会发现系统进程中有一些名字叫 tty* 的进程，对应于我们的终端程序。</p>
<p>这些 tty 是什么呢，实际上，tty 就是电传打字机 (Teletype / Teletypewriter) 的英文缩写，它表示终端的统称。</p>
<p>在类 UNIX 系统中，硬件设备都被抽象为文件，而当时的作为终端机的电传打字机就对应于操作系统的 /dev/tty* 的设备文件。随着计算机的发展，终端设备已经有很多种，但是 tty 这个名字还是保留了下来。</p>
<blockquote>
<p>实际上 UNIX 系统有许多我们当今看起来十分奇怪的设计，都是早期计算机发展相对不完善的历史遗留问题。例如 /bin 和 /usr/bin 这两个目录。有兴趣的同学可以去查一查。</p>
</blockquote>
<h2><span id="shell">Shell</span></h2><p>处于稳定性和安全方面的考虑，我们往往不建议用户直接对操作系统进行操作，而是通过应用程序调用操作系统的 API 进行操作。但生产生活中还是需要直接操作操作系统的，这个时候就需要一个专门的程序，接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。它就是 Shell。它与操作系统的构架如下图。</p>
<p>Shell 分为命令行 Shell 和图形 Shell，前者提供一个命令行界面(CLI)，后者则提供一个图形界面(GUI)。</p>
<p>像 macOS 的 Finder 实际上就可以理解为一个图形 Shell。而 Terminal 就是一个命令行 Shell。</p>
<p>常见或历史上知名的命令行 Shell 有：</p>
<ul>
<li>适用于 Unix 及类 Unix 系统：<ul>
<li><strong>sh</strong> (Bourne shell)，最经典的 Unix shell；</li>
<li><strong>bash</strong> (Bourne-Again shell)，目前绝大多数 Linux 发行版的默认 shell；</li>
<li><strong>zsh</strong> (Z shell)，我个人最喜欢的 shell；</li>
<li><strong>fish</strong> (Friendly interactive shell)，专注于易用性与友好用户体验的 shell；</li>
</ul>
</li>
<li>Windows 下的 <strong>cmd.exe</strong> (命令提示符) 与 <strong>PowerShell</strong>。</li>
</ul>
<h3><span id="shell-与终端">Shell 与终端 </span></h3><p> 从前文我们得知，终端的作用在于接受用户输入指令并显示输出结果。而 Shell 提供了与操作系统内核的交互接口。可以把终端理解为 Shell 的前端，</p>
<ul>
<li><p>终端把用户输入传递给 Shell，把 Shell 返回的结果显示给用户。</p>
</li>
<li><p>Shell 从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学中最重要的 32 个算法</title>
    <url>/2015/09/16/%E7%A7%91%E6%99%AE/%E7%A7%91%E6%99%AE%E4%B9%8B%E5%B8%B8%E8%A7%8132%E4%B8%AA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>奥地利符号计算研究所（Research Institute for Symbolic Computation，简称 RISC）的 Christoph Koutschan 博士在自己的页面上发布了 <a href="http://www.risc.jku.at/people/ckoutsch/stuff/e_algorithms.html"> 一篇文章</a>，提到他做了一个调查，参与者大多数是计算机科学家，他请这些科学家投票选出最重要的算法，以下是这次调查的结果，按照英文名称字母顺序排序。</p>
<a id="more"></a>
<ol>
<li><p>A<em> 搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A</em>搜索算法是最佳优先搜索的范例。</p>
</li>
<li><p>集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的 m 个最符合条件的节点，m 是固定数字——集束的宽度。</p>
</li>
<li><p>二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。</p>
</li>
<li><p>分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。</p>
</li>
<li><p>Buchberger 算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。</p>
</li>
<li><p>数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。</p>
</li>
<li><p>Diffie-Hellman 密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。</p>
</li>
<li><p>Dijkstra 算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。</p>
</li>
<li><p>离散微分算法（Discrete differentiation）</p>
</li>
<li><p>动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法</p>
</li>
<li><p>欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前 300 前欧几里得的《几何原本》。</p>
</li>
<li><p>期望 - 最大算法（Expectation-maximization algorithm，又名 EM-Training）——在统计计算中，期望 - 最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM 在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。</p>
</li>
<li><p>快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。</p>
</li>
<li><p><a href="http://www.infoq.com/32-most-important-algorithms/zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">梯度下降</a>（Gradient descent）——一种数学上的最优化算法。</p>
</li>
<li><p>哈希算法（Hashing）</p>
</li>
<li><p>堆排序（Heaps）</p>
</li>
<li><p>Karatsuba 乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于 1962 年。</p>
</li>
<li><p>LLL 算法（Lenstra-Lenstra-Lovasz  lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL 算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的 RSA 加密等等。</p>
</li>
<li><p>最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流 - 最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。</p>
</li>
<li><p>合并排序（Merge Sort）</p>
</li>
<li><p>牛顿法（Newton’s method）——求非线性方程（组）零点的一种重要的迭代法。</p>
</li>
<li><p>Q-learning 学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring 的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。</p>
</li>
<li><p>两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法 Number Field Sieve）。对于 110 位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。</p>
</li>
<li><p>RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。</p>
</li>
<li><p>RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA 在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。</p>
</li>
<li><p>Schönhage-Strassen 算法——在数学中，Schönhage-Strassen 算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。</p>
</li>
<li><p>单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。</p>
</li>
<li><p>奇异值分解（Singular value decomposition，简称 SVD）——在线性代数中，SVD 是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。</p>
</li>
<li><p>求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</p>
</li>
<li><p>Strukturtensor 算法——应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。</p>
</li>
<li><p>合并查找算法（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：</p>
<ul>
<li><ul>
<li>查找：判断某特定元素属于哪个组。</li>
<li>合并：联合或合并两个组为一个组。</li>
</ul>
</li>
</ul>
</li>
<li><p>维特比算法（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的 Markov 模型中。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>主定理计算时间复杂度</title>
    <url>/2017/08/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%BB%E5%AE%9A%E7%90%86%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>在算法导论中，主定理可以用来计算递归调用的时间复杂度，在这里给出主定理的证明和几个实例。</p>
<a id="more"></a>
<h2><span id="主定理">主定理 </span></h2><h3><span id="描述"> 描述 </span></h3><p> 一个规模为 $n$ 的问题通过分治，得到 $a$ 个规模为 $n/b$ 的问题，每次递归带来的额外计算为 $c(n^d)$，则 $T(n)\leq aT(n/b)+c(n^d)$</p>
<p>问题的复杂度为</p>
<script type="math/tex; mode=display">
T(n)=\begin{equation}
\left\{\begin{array}{lr}
              O(n^d log(n)) & a = b^d  \\
             O(n^d) & a < b^d\\
             O(n^{log_b^a})) &  a > b^d
             \end{array}
\right.
\end{equation}</script><h3><span id="证明">证明</span></h3><p><img src="https://i.loli.net/2020/08/31/ezxRJpByd1ZPHGC.png" alt="20140429185231062"></p>
<p>可见，每次递归把问题分为 a 个规模为 $n/b$ 的子问题。从根节点开始，共有 $log_b^n+1$ 层，叶子节点数为 $a^{log_b^n}$。那么，第 j 层共有 $a^j$ 个子问题，每个问题规模为 $n/b^j$，每个子问题运算量为 $c\cdot(n/b^j)^d$ 需要完成的计算量不超过：</p>
<script type="math/tex; mode=display">
a^j\cdot c\cdot (\frac{n}{b^j})^d = cn^d\cdot  (\frac{a}{b^d})^j</script><p>整个问题的运算量</p>
<script type="math/tex; mode=display">
Tot \leq cn^d\cdot \sum_{j=0}^{log_b^n}(\frac{a}{b^d})^j</script><h3><span id="应用实例">应用实例 </span></h3><h3><span id="二分搜索"> 二分搜索 </span></h3><p> 每次规模减半，并只选择一个分支，带来的额外计算为常数级, 则 $a=1,b=2,d=0$</p>
<p>复杂度为 $O(n^0\cdot log(n))=O(log(n))$</p>
<h3><span id="快排">快排 </span></h3><p> 随机选择一个锚点，划分是否平均影响复杂度</p>
<p>每次问题规模减半，带来额外计算次数正比于 $n$，$a=2,b=2,d=0$</p>
<p>复杂度为 $O(n^1\cdot log(n))=O(nlog(n))$</p>
<h3><span id="归并排序">归并排序 </span></h3><p> 数据均分为两部分，分别排序，然后以 $O(n)$ 的复杂度归并，空间复杂度为 $O(n)$</p>
<p>每次问题规模减半，带来额外计算次数正比于 $n$，$a=2,b=2,d=0$</p>
<p>复杂度为 $O(n^1\cdot log(n))=O(nlog(n))$</p>
<h3><span id="基数排序">基数排序 </span></h3><p> 最低位到最高位按位排序</p>
<p>每次递归问题规模变为原来的 1/10，需要求解 10 个子问题，额外运算为 $O(n)$，$a=10,b=10,d=1$</p>
<p>复杂度 $O(n^1\cdot log(n))=O(nlog(n))$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是微服务</title>
    <url>/2017/01/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2><span id="微服务-microservice">微服务 - microservice</span></h2><p>　　<strong>微服务是指提供单个业务功能的服务</strong>。无独立进程，采用轻量级的通信协议，独立部署且无集中式管理。</p>
<p>​    技术角度上看，就是把一个传统的复杂软件架构拆分为若干小而独立运行（有自己的端口）微服务组成，这些独立处理组件之间通讯是通过与语言无关的 API 进行。这种做法可以将具体业务拆分为多个模块，提供充分的灵活性，大大提高了项目生命周期和开发效率。<br><a id="more"></a></p>
<h2><span id="特性">特性</span></h2><p>　　每个微服务组件都有自己分配的存储 内存和 CPU 资源，这就使得硬件利用更加易于优化和跟踪开，只要遵循微服务之间的 API 规范，微服务组件就可以组成一个完整的服务。这个服务的复杂性和扩展性是良好的，更新其中一个微服务组件不会引起连锁反应，因为微服务之间是松耦合的。 </p>
<p>　　</p>
<h2><span id="容器技术与微服务">容器技术与微服务</span></h2><p>​    因为有很多应用和服务部署在基于云主机的环境中，微服务架构将会严重依赖容器技术，容器隔离了微服务处理过程，将一个应用切分为一个个小的实例，这些容器中的小实例有自己的端口和虚拟化环境。广泛使用的容器技术是 Docker。</p>
<p>　　微服务架构不只是传统服务变微变小。微服务两个显著特点是：微服务本身是无状态的；微服务之间很少可变共享。可以设想一下，如果微服务之间可以共享，那么带来两个问题：微服务团队之间需要合作，因为共享的是一个统一数据库，如果这种共享没有带来沟通成本，没有破坏一个团队就能搞定的宗旨，那么这种共享数据库也是可以考虑，但是这种情况很少，大部分团队因为共享问题破坏了独立性；再者，微服务如果使用 Docker 分别打包在一个容器中，这些容器可能是跨不同基础设施部署，部署方式很灵活，是一种 cloud native 应用，而共享数据库属于底层基础设施，显然提高了部署难点。</p>
<p>　　另外，传统服务之间通讯无论是 RPC/RMI 或是 Http/RESTful 都是同步的，而微服务之间通信最好是异步的或 reactive 的，也就是非同步的。根据 <a href="http://www.jdon.com/47927">FLP 不可能原理</a> 网络默认是不可靠的，RPC 在一旦发生网络堵塞会连环爆炸，事后监控并不能根本解决这个问题，需要参考 <a href="http://www.jdon.com/37625">CAP 定理</a> 进行平衡设计，引入事件驱动或 Pub/Sub 消息方式能在提高网络容错性的同时，保证数据最终一致性，柔性事务是微服务环境的主要选择。</p>
<p>　　传统服务变成铁板一块经常是因为事务处理要求，某个服务方法的代码很多，需要塞在同一个事务边界内，虽然这带来了高一致性的，但是扩展性比较差，因为同一个事务边界内的动作无法分离到几个微服务中，因此，使用微服务必须积极拥抱最终一致性，对分布式系统以及 CAP 定理有一定理解。当然，这些都是必须有多个微服务调用的情况下才需要考虑，由于微服务粒度小且专一，可以通过组合替代共享继承的思路，容忍代码有一定的重复性。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU 的工作原理</title>
    <url>/2017/10/10/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8BCPU/</url>
    <content><![CDATA[<p>CPU 的全称是 <code>Central Processing Unit</code>，即中央处理单元，是计算机的核心部件 - 计算部件。CPU 的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段：<strong>提取，解码和执行</strong>。CPU 从系统的主存中提取指令，然后解码该指令的实际内容，然后再由 CPU 的相关部分执行该指令。</p>
<a id="more"></a>
<h3><span id="计算机内部处理过程">计算机内部处理过程 </span></h3><p> 以 C 语言为例来说明程序运行流程：</p>
<p><img src="https://i.loli.net/2020/08/22/NHXAQos2fRl53ZL.jpg" alt="运行流程"></p>
<p>在这个流程中，CPU 负责的就是解释和运行最终转换成机器语言的内容。<br>CPU 主要由两部分构成：控制单元 和 算术逻辑单元（ALU）</p>
<p>控制单元：从内存中提取指令并解码执行 <br> 算数逻辑单元（ALU）：处理算数和逻辑运算</p>
<p>CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。它与输入 / 输出（I / O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。<br>从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。</p>
<p><img src="https://i.loli.net/2020/08/22/hHwJPmTrgZDXafE.jpg" alt="cpu 部件"></p>
<p><strong>寄存器 </strong> 是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20 - 100 个寄存器。</p>
<p><strong>控制器 </strong> 负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</p>
<p><strong>运算器 </strong> 负责运算从内存中读入寄存器的数据</p>
<p><strong>时钟 </strong> 负责发出 CPU 开始计时的时钟信号</p>
<h3><span id="cpu-是一系列寄存器的集合体">CPU 是一系列寄存器的集合体 </span></h3><p> 控制器、运算器、时钟都是基于数字电路原理，在计算机科学中主要关注寄存器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>累加寄存器</td>
<td>存储运行的数据和运算后的数据。</td>
</tr>
<tr>
<td>标志寄存器</td>
<td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。</td>
</tr>
<tr>
<td>程序计数器</td>
<td>程序计数器是用于存放下一条指令所在单元的地址的地方。</td>
</tr>
<tr>
<td>基址寄存器</td>
<td>存储数据内存的起始位置</td>
</tr>
<tr>
<td>变址寄存器</td>
<td>存储基址寄存器的相对地址</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>存储任意数据</td>
</tr>
<tr>
<td>指令寄存器</td>
<td>储存正在被运行的指令，CPU 内部使用，程序员无法对该寄存器进行读写</td>
</tr>
<tr>
<td>栈寄存器</td>
<td>存储栈区域的起始位置</td>
</tr>
</tbody>
</table>
</div>
<p>其中 <strong> 程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器 </strong> 都只有一个，其他寄存器一般有多个。</p>
<p><img src="https://i.loli.net/2020/08/22/6TfRVKgohB1EdUI.jpg" alt="CPU 寄存器"></p>
<h4><span id="程序计数器">程序计数器 </span></h4><p><code> 程序计数器 (Program Counter)</code> 是用来存储下一条指令所在单元的地址。</p>
<p>程序执行时，PC 的初值为程序第一条指令的地址，在顺序执行程序时，<code>控制器 </code> 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 指向下一条要执行的指令。</p>
<p>我们还是以一个事例为准来详细的看一下程序计数器的执行过程</p>
<p><img src="https://i.loli.net/2020/08/22/b9s4MyeLopKfaJE.jpg" alt="程序计数器"></p>
<p>这是一段进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。</p>
<p>地址 <code>0100</code> 是程序运行的起始位置。Windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器作为设定为起始位置 0100，然后执行程序，每执行一条指令后，程序计数器的数值会增加 1（或者直接指向下一条指令的地址），然后，CPU 就会根据程序计数器的数值，从内存中读取命令并执行，也就是说，<strong>程序计数器控制着程序的流程</strong>。</p>
<h4><span id="条件分支和循环机制">条件分支和循环机制 </span></h4><p> 高级语言中的条件控制流程主要分为三种：<code>顺序执行、条件分支、循环判断 </code> 三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。</p>
<ul>
<li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li>
<li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li>
</ul>
<p>下面以条件分支为例来说明程序的执行过程（循环也很相似）</p>
<p><img src="https://i.loli.net/2020/08/22/muNPLRZGkgwisQ8.jpg" alt="条件分支和循环机制"></p>
<p>程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序 +1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 <code>if()</code> 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接 +1，而是下一条指令的地址。</p>
<h4><span id="标志寄存器">标志寄存器 </span></h4><p> 条件和循环分支会使用到 <code>jump（跳转指令）</code>，会根据当前的指令来判断是否跳转，上面我们提到了 <code> 标志寄存器</code>，无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存</p>
<p>CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定，运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为 1 时，分别代表着正数、零和负数。</p>
<p>CPU 的执行机制比较有意思，假设累加寄存器中存储的 XXX 和通用寄存器中存储的 YYY 做比较，执行比较的背后，CPU 的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示 XXX 比 YYY 大，结果为零表示 XXX 和 YYY 相等，结果为负表示 XXX 比 YYY 小。<strong>程序比较的指令，实际上是在 CPU 内部做减法运算。</strong></p>
<p><img src="https://i.loli.net/2020/08/22/6B2wr1Zh3okmODN.jpg" alt="标志寄存器"></p>
<h4><span id="函数调用机制">函数调用机制 </span></h4><p> 接下来，我们继续介绍函数调用机制，哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后，必须进行返回处理，单纯的指令跳转没有意义，下面是一个实现函数跳转的例子</p>
<p><img src="https://i.loli.net/2020/08/22/8cruihwQzUC1HAM.jpg" alt="程序调用"></p>
<p>图中将变量 a 和 b 分别赋值为 123 和 456 ，调用 MyFun(a,b) 方法，进行指令跳转。图中的地址是将 C 语言编译成机器语言后运行时的地址，由于 1 行 C 程序在编译后通常会变为多行机器语言，所以图中的地址是分散的。在执行完 MyFun(a,b)指令后，程序会返回到 MyFun(a,b) 的下一条指令，CPU 继续执行下面的指令。</p>
<p>函数的调用和返回很重要的两个指令是 <code>call</code> 和 <code>return</code> 指令，再将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 指令。return 指令的功能是把保存在栈中的地址设定到程序计数器。MyFun 函数在被调用之前，0154 地址保存在栈中，MyFun 函数处理完成后，会把 0154 的地址保存在程序计数器中。这个调用过程如下</p>
<p><img src="https://i.loli.net/2020/08/22/vnrEX81DhKyRsjM.jpg" alt="call 与 return"></p>
<p>在一些高级语言的条件或者循环语句中，函数调用的处理会转换成 call 指令，函数结束后的处理则会转换成 return 指令。</p>
<h4><span id="通过地址和索引实现数组">通过地址和索引实现数组 </span></h4><p> 接下来我们看一下基址寄存器和变址寄存器，通过这两个寄存器，我们可以对主存上的特定区域进行划分，来实现类似数组的操作，首先，我们用十六进制数将计算机内存上的 00000000 - FFFFFFFF 的地址划分出来。那么，凡是该范围的内存地址，只要有一个 32 位的寄存器，便可查看全部地址。但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话，使用两个寄存器会更加方便。</p>
<p>例如，我们用两个寄存器（基址寄存器和变址寄存器）来表示内存的值</p>
<p><img src="https://i.loli.net/2020/08/22/8mMGZuRozht7e5p.jpg" alt="数组"></p>
<p>这种表示方式很类似数组的构造，<code>数组 </code> 是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值，通过索引来区分数组的各个数据元素，例如: a[0] - a[4]，<code>[]</code>内的 0 - 4 就是数组的下标。</p>
<h3><span id="cpu-指令执行过程">CPU 指令执行过程 </span></h3><p> 几乎所有的冯·诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：<strong>取指令、指令译码、执行指令、访存取数、结果写回</strong>。</p>
<ul>
<li><code>取指令 </code> 阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址</li>
<li><code>指令译码 </code> 阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</li>
<li><code>执行指令 </code> 阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。</li>
<li><code>访问取数 </code> 阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li>
<li><code>结果写回 </code> 阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到 CPU 的内部寄存器中，以便被后续的指令快速地存取；</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存的工作原理</title>
    <url>/2017/10/11/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>把 CPU 作为大脑的话，CPU 缓存是人的瞬时记忆，内存是人的短时记忆，磁盘是人的长时记忆。那么 CPU 如何与内存交互?</p>
<a id="more"></a>
<h3><span id="什么是内存">什么是内存 </span></h3><p> 内存（Memory）是计算机中最重要的部件之一，它是程序与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为 <code> 主存</code>，其作用是存放 CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到主存中进行运算，当运算完成后 CPU 再将结果传送出来，主存的运行也决定了计算机的稳定运行。</p>
<p>内存是易失性存储，与磁盘不同，掉电则失去所有数据。</p>
<h3><span id="内存的物理结构">内存的物理结构 </span></h3><p> 内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器</p>
<ul>
<li>随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 <code>丢失</code>。</li>
<li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。</li>
<li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存 <code> 更快 </code> 的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在 Cache 中没有，CPU 会再去读取内存中的数据。</li>
</ul>
<p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图</p>
<p><img src="https://i.loli.net/2020/08/22/Lch5xOsutFeQYB9.jpg" alt="物理模型"></p>
<p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，<strong>+5V 表示 1，0V 表示 0</strong>。</p>
<p>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10 次方 = <code>1024 个地址</code>。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p>
<h3><span id="内存的读写过程">内存的读写过程 </span></h3><p> 让我们把关注点放在内存 IC 对数据的读写过程上来吧！我们来看一个对内存 IC 进行数据写入和读取的模型</p>
<p><img src="https://i.loli.net/2020/08/22/u1vzTSMIFcqfehA.jpg" alt="读写过程"></p>
<p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p>
<ul>
<li>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 <code>A0 - A9</code> 来指定数据的存储场所，然后再把数据的值输入给 <code>D0 - D7</code> 的数据信号，并把 <code>WR（write）</code>的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据</li>
<li>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。</li>
<li>图中的 RD 和 WR 又被称为控制信号。其中当 WR 和 RD 都为 0 时，无法进行写入和读取操作。</li>
</ul>
<h3><span id="内存的现实模型">内存的现实模型 </span></h3><p> 为了便于记忆，我们把内存模型映射成为我们现实世界的模型，在现实世界中，内存的模型很想我们生活的楼房。在这个楼房中，1 层可以存储一个字节的数据，楼层号就是 <code> 地址</code>，下面是内存和楼层整合的模型图</p>
<p><img src="https://i.loli.net/2020/08/22/wy5ebZ4inc3QAHh.jpg" alt="内存模型"></p>
<p>我们知道，程序中的数据不仅只有数值，还有 <code> 数据类型 </code> 的概念，从内存上来看，就是占用内存大小（占用楼层数）的意思。即使物理上强制以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其数据类型，也能实现以特定字节数为单位来进行读写。、</p>
<h3><span id="内存与磁盘的关系">内存与磁盘的关系 </span></h3><p> 计算机最主要的存储部件是内存和磁盘。<strong>磁盘中存储的程序必须加载到内存中才能运行</strong>，在磁盘中保存的程序是无法直接运行的，这是因为负责解析和运行程序内容的 CPU 是需要通过程序计数器来指定内存地址从而读出程序指令的。</p>
<p><img src="https://i.loli.net/2020/08/22/lPBhsc7DZFxkMzC.jpg" alt="1ae073cb-2a7f-4404-8f8a-681fed48f2c3"></p>
<h3><span id="磁盘缓存">磁盘缓存 </span></h3><p> 我们上面提到，磁盘往往和内存是互利共生的关系，相互协作，彼此持有良好的合作关系。每次内存都需要从磁盘中读取数据，必然会读到相同的内容，所以一定会有一个角色负责存储我们经常需要读到的内容。 我们大家做软件的时候经常会用到 <code> 缓存技术 </code>，那么硬件层面也不例外，磁盘也有缓存，磁盘的缓存叫做<code> 磁盘缓存</code>。</p>
<p>磁盘缓存指的是把从磁盘中读出的数据存储到内存的方式，这样一来，当接下来需要读取相同的内容时，就不会再通过实际的磁盘，而是通过磁盘缓存来读取。某一种技术或者框架的出现势必要解决某种问题的，那么磁盘缓存就大大 <strong> 改善了磁盘访问的速度</strong>。</p>
<p><img src="https://i.loli.net/2020/08/22/nv6VdCAOwjXh3W1.jpg" alt="3cfa9bac-5a56-44ed-b3f9-49db0d00b005"></p>
<h3><span id="虚拟内存">虚拟内存 </span></h3><p> 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。它是内存和磁盘交互的第二个媒介。虚拟内存是指把磁盘的一部分作为 <code> 假想内存 </code> 来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p><img src="https://i.loli.net/2020/08/22/c3j2rNJyp5xvaq1.png" alt="虚拟地址映射"></p>
<h4><span id="虚拟内存与内存的交换方式">虚拟内存与内存的交换方式 </span></h4><p> 虚拟内存的方法有 <code> 分页式 </code> 和 <code> 分段式 </code> 两种。Windows 采用的是分页式。该方式是指在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以<code> 页</code>为单位进行置换。在分页式中，我们把磁盘的内容读到内存中称为 <code>Page In</code>，把内存的内容写入磁盘称为 <code>Page Out</code>。Windows 计算机的页大小为 4KB ，也就是说，需要把应用程序按照 4KB 的页来进行切分，以页（page）为单位放到磁盘中，然后进行置换。</p>
<p><img src="https://i.loli.net/2020/08/22/tJE5glHcFyeYjUO.jpg" alt="60a51c98-4dbd-4813-a3a3-172c159f2174"> </p>
<p>为了实现内存功能，Windows 在磁盘上提供了虚拟内存使用的文件（page file，页文件）。该文件由 Windows 生成和管理，文件的大小和虚拟内存大小相同，通常大小是内存的 1 - 2 倍。</p>
<h4><span id="地址映射">地址映射 </span></h4><p> 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<p><img src="http://www.c-jump.com/CIS77/asm_images/memory_paging.png" alt="memory_paging"></p>
<p><img src="http://www.c-jump.com/CIS77/asm_images/virtual_2_physical.png" alt="virtual_2_physical"></p>
<h3><span id="参考文献">参考文献</span></h3><p><a href="https://www.cnblogs.com/felixfang/p/3420462.html">https://www.cnblogs.com/felixfang/p/3420462.html</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IP 地址分类</title>
    <url>/2015/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>在计算机网络中有著名的 OSI 七层协议体系结构，概念清楚，理论完整，但是它既复杂又不实用。TCP/IP 体系结构则不同，得到的广泛的应用。最终结合 OSI 和 TCP/IP 的优点，采用了一种只有五层协议的体系结构，本文的讲述的 IP 都是基于五层协议模型中的 <strong><em> 网络层 \</em></strong>。</p>
<a id="more"></a>
<h2><span id="网络模型介绍">网络模型介绍</span></h2><div class="table-container">
<table>
<thead>
<tr>
<th>OSI 体系结构</th>
<th>TCP/IP 体系结构</th>
<th>五层体系结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7 应用层</td>
<td>应用层</td>
<td>5 应用层</td>
</tr>
<tr>
<td>6 表示层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5 会话层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4 传输层</td>
<td>传输层</td>
<td>4 传输层</td>
</tr>
<tr>
<td>3 网络层</td>
<td>网络层</td>
<td>3 网络层</td>
</tr>
<tr>
<td>2 数据链路层</td>
<td>网络接口层</td>
<td>2 数据链路层</td>
</tr>
<tr>
<td>1 物理层</td>
<td>1 物理层</td>
</tr>
</tbody>
</table>
</div>
<h2><span id="分类的-ip-地址">分类的 IP 地址</span></h2><h3><span id="ip-地址的表示方法">IP 地址的表示方法</span></h3><p>IP 地址就是给英特网上的每个主机（路由器）的每个接口分配一个在全世界范围内是唯一的 32 位的标识符。其组成第一个字段是网络号，第二个字段是主机号。一个主机号在前面的网络号所指明的网络范围内必须是唯一的，所以一个 IP 地址在整个网络中都是唯一的。目前分为 A、B、C、D、E 五类 IP 地址。<br><img src="https://img-blog.csdn.net/20170604163951489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="IP"></p>
<ul>
<li>在 A、B、C 三类地址中灰色的部分即为网络号，网络号的前三位是类别位，分别是 0,10，110。也就是说我们可以凭借这个类别位置来判断网络类别。</li>
<li>32 位的总长度，由于 A、B、C 三类网络号的长度的不同，导致 A、B、C 类地址的主机号字段的字节数分别为 3、2、1（一个字节 8 位）。</li>
<li>D 类地址的网络号为 1110，用于多播（一对多通讯）。E 类地址的网络号为 1111，保留以后使用。</li>
</ul>
<p>因此我们一般使用的就是 ABC 三类网络地址，IP 地址是 32 位的二进制代码，为了提高可读性，把 32 位的 IP 地址中的每 8 位用等效的十进制表示出来（点分十进制），于是我们日常生活中常见的 IP 地址就出现了。</p>
<p>例如：IP 地址，128.11.3.31，转化为二进制为 100000000 00001011 00000011 00011111 ，可以看出类别位为 10，可以判断为一个 B 类地址。</p>
<h3><span id="常用-ip-地址的指派范围">常用 IP 地址的指派范围 </span></h3><h4><span id="网络号指派范围"> 网络号指派范围</span></h4><ul>
<li>A 类地址网络号占用一个字节，但是由于有一位是类别位，只有 7 位可供使用，但是由于规定，网络字段全 0 是个保留字段表示本网络，而 127（01111111）是另外一个保留字段，作为本地软件的环回测试。<strong>我们常见的 127.0.0.1 表示本机，原因也是出自这里。</strong>所以 A 类地址可以指派的网络号个数为（27-2）.</li>
<li>B 类网络地址网络号有两个字节，前两位为 10 已经固定，只剩下 14 位可用，由于这 14 位无论怎么取值都不会使得网络号为全 0 或者全 1，单实际上规定，规定 B 类最小网络地址为 128.1.0.0。因此 B 类地址可指派的网络号个数为（214-1）.</li>
<li>C 类地址有 3 个字节的网络字段号，前三位固定 110，只有剩下 21 位可用，同样 C 类地址可指派的最小网络地址也是 192.0.1.0。因此 C 类地址可指派的网络号个数为（221-1）.</li>
</ul>
<h4><span id="主机号指派范围">主机号指派范围</span></h4><ul>
<li>由于主机号有规定，全 0 的主机号代表 IP 地址是“本主机”所连接到的单个网络地址（例，一主机地址为 5.6.7.8，则该主机所在的网络地址为 5.0.0.0），而全 1 则表示“所有的”，即表示该网络上的所有主机。</li>
<li>A 类地址的主机号是由三个字节，24 位组成，所以每一个 A 类网络中可分配的主机个数为（224-2）.</li>
<li>B 类地址的主机号是由两个字节，16 位组成，所以每一个 B 类网络中可分配的主机个数为（216-2）.</li>
<li>C 类地址的主机号是由一个字节，8 位组成，所以每一个 C 类网络中可分配的主机个数为（28-2）.</li>
</ul>
<h4><span id="总结-ip-指派范围">总结 IP 指派范围 </span></h4><p> 综上网络号和主机号的指派描述可知，IP 地址空间共有 232 个地址。<br>所有 A 类地址共有（27-2）∗∗（224-2）个，大约 231，占 50%；<br>所有 B 类地址共有（214-1）∗∗（216-2）个，大约 230, 占 25%；<br>所有 C 类地址共有（221-1）∗∗（28-2）个，大约 229, 占 12.5%；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大可分配网络数</th>
<th>首个可分配网络号</th>
<th>最后一个可分配网络号</th>
<th>每个网络中最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>126（27-2）</td>
<td>1</td>
<td>126</td>
<td>16777214</td>
</tr>
<tr>
<td>B</td>
<td>16383（214-1）</td>
<td>128.1</td>
<td>191.255</td>
<td>65534</td>
</tr>
<tr>
<td>C</td>
<td>2097151（221-1）</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>所以可以这样来表示一个 A 类 IP 地址 n.x.y.zn.x.y.z，若 1≤n≤1261≤n≤126，0≤x,y,z≤2550≤x,y,z≤255，其中 x,y,zx,y,z 不同时为 0 也不能同时为 255.</li>
<li>所以可以这样来表示一个 B 类 IP 地址 n.m.x.yn.m.x.y，若 128≤n≤191128≤n≤191，0≤m≤2550≤m≤255，0≤x,y≤2550≤x,y≤255，其中 I. 当 n=128n=128 时，m≠0m≠0; II. x,yx,y 不同时为 0 也不能同时为 255;</li>
<li>所以可以这样来表示一个 C 类 IP 地址 n.m.k.xn.m.k.x，若 192≤n≤223192≤n≤223，0≤m,k≤2550≤m,k≤255，1≤x≤2541≤x≤254，其中 当 n=192n=192 时，k≠0k≠0.</li>
</ul>
<h2><span id="ip-地址和硬件地址">IP 地址和硬件地址 </span></h2><p> 从层次角度来看，硬件地址是数据链路层和物理层使用的地址（常称作 MAC 地址），而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。在网络层我们进行数据报文从 IP1 传输到 IP2，无论我们中间经过多少次转发，从网络层来看，源地址始终是 IP1，目的地址始终是 IP2。但是从数据链路层来看，显然就不是这样了，这些是物理地址，很有可能从源节点经过多次中间节点的物理地址的转变才能到达目的节点。</p>
<blockquote>
<p>而 IP 地址和物理地址的之间的转化则需要依靠两个重要的协议 ARP（地址解析协议），RARP（逆地址解析协议）。IP 地址通过 ARP 转化成物理地址，物理地址可以通过 RARP 转化成相应的 IP 地址。</p>
</blockquote>
<h2><span id="子网和超网">子网和超网 </span></h2><p> 简单的来说就是如何来管理一个 IP 地址下的多台主机</p>
<h3><span id="子网">子网 </span></h3><p> 现在假设这样一个场景，一个数据报起目的地址是 145.13.3.10（在子网 145.13.3.0 中），已经到达路由器 R1（145.13.0.0），那么这个路由器怎么将它转发到 145.13.3.0 呢？<br>我们并不知道目的地址是否进行了子网的划分。<br>这就引出了子网掩码的概念了，子网掩码也是 32 位，由一串 1 和 0 组成，子网掩码中的 1 对应于 IP 地址中的网络号位置 + 子网网络号位置，子网掩码中的 0 对应与 IP 地址中现在的主机号位置。<br>我们只要将 IP 地址和子网掩码进行“与”运算，如果进行子网的划分，就立刻得出要找的子网的网络地址，如果没有进行子网划分（有默认的子网掩码），则直接能够得出该 IP 地址的网络地址出来。</p>
<ul>
<li>A 类地址的默认子网掩码是 255.0.0.0</li>
<li>B 类地址的默认子网掩码是 255.255.0.0</li>
<li>C 类地址的默认子网掩码是 255.255.255.0</li>
</ul>
<h3><span id="超网">超网 </span></h3><p> 无分类编址 CIDR，使用变长的子网掩码，可以进一步提高 IP 地址的资源利用率。有两个特点 <br> 第一，消除了传统的 ABC 类地址及划分子网的概念，CIRD 把 32 位的 IP 地址划分成为两个部分，网络前缀和剩下的部分，表示方法为，在 IP 地址后面加上“/”，然后写上网络前缀所占位数。<br>第二，把网络前缀相同的 IP 地址组成一个 CIDR 地址块，例如，IP 地址 128.14.35.7/20 用二进制表示 100000000 00001110 00100011 00000111，所以我们很容易可以得出这块地址中最小地址为 128.14.32.0, 即 100000000 00001110 00100000 00000000，最大地址为 128.14.47.255，即 100000000 00001110 00101111 11111111.</p>
<p>为了更加方便进行路由选择，CIDR 使用 32 位的地址掩码，1 的个数就是网络前缀的长度，如上面所举例中的 /20 的地址块的地址掩码是 11111111 11111111 11110000 00000000</p>
<p>因此可以看出，网络前缀越短，其地址块所包含的地址就越多，这样可以根据实际情况更加有效的分配 IPv4 的地址空间。而由很多个 CIDR 地址快构成的庞大的网络就就被称为“超网”。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 三次握手与四次挥手详解</title>
    <url>/2017/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。IP 协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。</p>
<p>UDP，在传送数据前不需要先建立连接，远地的主机在收到 UDP 报文后也不需要给出任何确认。虽然 UDP 不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是 UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此 TCP 是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<a id="more"></a>
<h2><span id="常用的熟知端口号">常用的熟知端口号</span></h2><div class="table-container">
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
</tr>
</tbody>
</table>
</div>
<h2><span id="tcp-的概述">TCP 的概述</span></h2><blockquote>
<p>TCP 把连接作为最基本的对象，每一条 TCP 连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到 IP 地址即构成了套接字，例如，若 IP 地址为 192.3.4.16 而端口号为 80，那么得到的套接字为 192.3.4.16:80。</p>
</blockquote>
<h3><span id="tcp-报文首部">TCP 报文首部</span></h3><ol>
<li>源端口和目的端口，各占 2 个字节，分别写入源端口和目的端口；</li>
<li>序号，占 4 个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有 100 字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始；</li>
<li>确认号，占 4 个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B 收到了 A 发送过来的报文，其序列号字段是 501，而数据长度是 200 字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701；</li>
<li>数据偏移，占 4 位，它指出 TCP 报文的数据距离 TCP 报文段的起始处有多远；</li>
<li>保留，占 6 位，保留今后使用，但目前应都位 0；</li>
<li>紧急 URG，当 URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>
<li>确认 ACK，仅当 ACK=1 时，确认号字段才有效。TCP 规定，在连接建立后所有报文的传输都必须把 ACK 置 1；</li>
<li>推送 PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 PSH=1；</li>
<li>复位 RST，当 RST=1，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>
<li>同步 SYN，在连接建立时用来同步序号。当 SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使 SYN=1，ACK=1；</li>
<li>终止 FIN，用来释放连接。当 FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>
<li>窗口，占 2 字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>
<li>检验和，占 2 字节，校验首部和数据这两部分；</li>
<li>紧急指针，占 2 字节，指出本报文段中的紧急数据的字节数；</li>
<li>选项，长度可变，定义一些其他的可选的参数。</li>
</ol>
<h3><span id="tcp-连接的建立三次握手">TCP 连接的建立（三次握手）</span></h3><p><img src="https://i.loli.net/2020/09/04/CxKqBnRU8VfjmLv.gif" alt="这里写图片描述"></p>
<p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p>
<ol>
<li>TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；</li>
<li>TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。<br><img src="https://i.loli.net/2020/09/04/B9WVqO3DULcpQxJ.png" alt="三次握手"></li>
</ol>
<h3><span id="tcp-连接的释放四次挥手">TCP 连接的释放（四次挥手）</span></h3><p><img src="https://i.loli.net/2020/09/04/MRzkwCVnKaGd94t.gif" alt="这里写图片描述"></p>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/04/4jckDEF81C59HaX.png" alt="四次挥手"></p>
<h2><span id="一些其他问题">一些其他问题 </span></h2><h3><span id="为什么-tcp-客户端最后还要发送一次确认呢"> 为什么 TCP 客户端最后还要发送一次确认呢？</span></h3><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h3><span id="为什么客户端最后还要等待-2msl">为什么客户端最后还要等待 2MSL？</span></h3><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。</p>
<p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3><span id="为什么建立连接是三次握手关闭连接确是四次挥手呢">为什么建立连接是三次握手，关闭连接确是四次挥手呢？</span></h3><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p>
<h3><span id="如果已经建立了连接但是客户端突然出现故障了怎么办">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></h3><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘 socket</title>
    <url>/2015/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BSocket/</url>
    <content><![CDATA[<p>我们经常在网络编程接触 socket 这个概念，简而言之，socket 就是网络套接字，提供一个网络通信的接口给通信的进程，但这样讲了等于没讲，今天就来好好研究研究。</p>
<h2><span id="啥是-socket">啥是 socket</span></h2><p>虽然 socket 平时还是相当常用的，每当需要做网络编程的时候都会用到它，但深究起来，似乎还真的没办法说的很清楚。计算机里边有许多概念就是这样，比较抽象，解释了跟没解释一样。在此我们用大白话描述一下，争取让”街上卖煎饼果子的大叔“都能听懂。</p>
<p>简单来说，<strong>socket 是对底层网络通信的一层抽象，让程序员可以像文件那样操作网络上发送和接收的数据。</strong></p>
<a id="more"></a>
<blockquote>
<p>veryone knows what a files is… It’s that “photo”, “document”, or “music” that you use. Programs are made of files, in fact, the whole Linux operating system is just a collection of files… But, now for the weird part. Not only is that digital photo that you uploaded to your computer a file, but your monitor is a file too! You see, in Linux, everything is a file! WOW!!! How can that be? Let’s try to explain it.</p>
<p>在 linux 和 Unix 系统中，一起都是文件。</p>
</blockquote>
<p>这么说更加一脸懵逼了。我们举个例子。</p>
<p>A 与 B 打电话，A、B 正对应于需要通信的两个进程。A 想要和 B 通信，那么 A 就需要调用通信接口发信息（拨打电话），B 也调用通信接口接受信息（接电话）。电话在这里就相当于 socket，是 A、B 语音通信的接口，而电话的原理，A、B 并不关心（进程不关心网络通信实现的细节）。</p>
<p>假设现在你要编程网络程序，进行服务器端和客户端的通信（数据交换）。对于服务端的通信进程 SPrs 和客户端的通信进程 CPrs 来说，他们的核心功能其实就是发送、接受数据。而中间的数据缓冲、监听端口、控制 IO、封装解析 TCP/IP 协议等工作是非常标准化而繁琐的。那么按照模块分层设计原则，这些底层的功能就应该用接口来实现。socket 正是这样一个接口，它将网络连接封装为一个 socket 模块，对于想要通信的双方而言，只要调用 socket，就好像他们在直接通话一样。</p>
<p>socket，它现在已经是操作系统的一部分，在 linux 中是标准的系统调用，只要调用它提供的一组接口（下面会详解常用函数的使用），就能轻松地建立连接，读写数据，关闭连接，让网络操作就像文件操作一样简单。</p>
<h2><span id="通信地址">通信地址 </span></h2><p> 正如想要打电话需要知道电话号码和分机号一样，在网络编程中，想要通信的双方也需要知道对方的通信地址。</p>
<p>在网络编程中，一个进程的地址是一个三元组（ip, port 端口, protocol 协议）。</p>
<p>ip 地址是网络层用来路由和通信的标识符，端口（port） 是传输层管理的。而 socket 是在这两层之上，所以需要这两个地址来标识。这里的协议指的是 ipv4，ipv6 或者其他协议。</p>
<h2><span id="socket-类型">socket 类型</span></h2><p>socket 类型在创建时指定，常用的有三种</p>
<ul>
<li><p><code>SOCK_STREAM</code>：面向连接的稳定通信，底层是 TCP 协议。</p>
</li>
<li><p><code>SOCK_DGRAM</code>：无连接的通信，底层是 UDP 协议，需要上层的协议来保证可靠性。</p>
</li>
<li><p><code>SOCK_RAW</code>：更加灵活的数据控制，可指定 IP 头部。</p>
</li>
</ul>
<h2><span id="实战">实战 </span></h2><p> 一个典型的 tcp socket 连接如下图</p>
<h3><span id="创建-socket">创建 socket</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> socketid <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//socketid: socket 描述符，可以看做是一个文件描述符，通过它来读 / 写数据</span>

<span class="token comment">//family：整数，通信域。 </span>
<span class="token comment">//   - AF_INET：因特网协议协议，网络地址，最常用。</span>
<span class="token comment">//   - AF_UNIX，本地通信，文件地址</span>

<span class="token comment">//type：通信类型</span>
<span class="token comment">//   - SOCK_STREAM：可靠的，面向连接的服务，TCP 协议</span>
<span class="token comment">//   - SOCK_DGRAM：不可靠，无连接的服务，UDP 协议</span>
<span class="token comment">//   - SOCK_RAW：需要自己管理 IP 头部的数据</span>

<span class="token comment">//protocol：协议, 一般设为 0， 表示使用默认协议</span>
<span class="token comment">//   - IPPROTO_TCP，IPPROTO_UDP</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="关闭-socket">关闭 socket</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token function">close</span><span class="token punctuation">(</span>socketid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回值 0 正确</span>
<span class="token comment">// 返回值 -1 出错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关闭连接和释放端口。</p>
<h3><span id="服务端-客户端绑定bind地址三元组到-socket">服务端 / 客户端绑定（bind）地址三元组到 socket</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">,</span> socklen_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 还记得那句话吗，在 Unix 系统里，一切都是文件，socket 也对应一个文件描述符 fd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>把 socket 绑定到某个地址三元组，用于 server 端监听端口。第一个参数是 socket 的描述符，第二个参数 <code>struct sockaddr</code> 是地址结构体，第三个参数是地址结构体的长度。绑定失败的话返回值为负数，否则为 -1，并且设置 <code>errno</code>。</p>
<p>其中最重要的就是地址结构体，它在 <code>netinet/in.h</code> 中被定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">short</span>   sin_family<span class="token punctuation">;</span> <span class="token comment">/* must be AF_INET */</span>
  u_short sin_port<span class="token punctuation">;</span>   <span class="token comment">/* 端口号，必须要通过 htons 转换为网络格式 */</span>
  <span class="token keyword">struct</span>  <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>  <span class="token comment">/* ip 地址 */</span>
  <span class="token keyword">char</span>    sin_zero<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Not used, must be zero */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中， <code>in_addr</code> 也是在同一个文件夹被定义，格式为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">in_addr</span>
<span class="token punctuation">&#123;</span>
    uint32_t s_addr<span class="token punctuation">;</span> <span class="token comment">//32 位整数 本机地址</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 可以用 INADDR_ANY 变量表示接受来自任何地址的连接，使用之前需要把地址变量初始化为全 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器端的 <code>s_addr</code> 是本机地址，<code>sockaddr</code> 是通用的 socket 地址结构，<code>sockaddr_in</code> 是网络 socket 的结构，参数有一个类型转换的过程。</p>
<h3><span id="服务端监听listensocket">服务端监听（listen）socket</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">listen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 参数 1 socket 描述符</span>
<span class="token comment">// 参数 2 最大连接数，表示发来请求但是没有被 accept 的连接数量。</span>
<span class="token comment">// listen 函数在成功时返回 0，失败时返回 -1，并且设置错误代码。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>listen</code> 系统调用让服务端进程监听在指定的 socket 上面，函数在成功时返回 0，失败时返回 -1，并且设置错误代码。</p>
<h3><span id="客户端请求连接connect">客户端请求连接（connect）</span></h3><p>客户端要连接自己的 socket 和服务器的监听 socket：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> address<span class="token punctuation">,</span> size_t address_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// socket 是客户端本地创建的套接字</span>
<span class="token comment">// address 是服务器的三元组地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>成功调用时，服务器端将收到请求，<code>accept</code> 连接之后，就在两者之间建立了 socket 通信的管道，之后的读写就是直接对 socket 进行操作。</p>
<h3><span id="服务端接受accept连接">服务端接受（accept）连接</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">new_socket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>socket_desc<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token punctuation">(</span>socklen_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>每当接收到客户端的连接请求时，服务端调用<code>accept</code> 函数接受该连接，把客户端的 socket 地址信息保存到 <code>client</code> 变量里，新建一个 socket，返回其描述符，然后数据的读写就能通过新 socket 进行。 新 socket 的地址和服务器监听 socket 是一样的，如果不关心客户端地址信息的话，可以把第二个和第三个参数都设置为空指针 <code>NULL</code>。</p>
<p>有了 <code>client</code> 变量，就能得到客户端的 <code>ip</code> 和 <code>port</code> ：</p>
<pre class="line-numbers language-none"><code class="language-none">char *client_ip &#x3D; inet_ntoa(client.sin_addr);
int client_port &#x3D; ntohs(client.sin_port);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>如果没有客户端连接，<code>accept</code> 函数将会阻塞，直到有连接过来</strong>。</p>
<h3><span id="读-写write数据">读 / 写（Write）数据 </span></h3><p> 上面那么多的函数调用，只是建立了服务器端和客户端的连接，算是通信前的准备工作，两者都有了自己的 socket 描述符。 有了 socket 描述符，就可以像文件那样进行读写数据：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">write</span><span class="token punctuation">(</span>socket_des<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">read</span><span class="token punctuation">(</span>socket_des<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要注意的是，<code>read</code> 函数调用是阻塞的，也就是说如果没有数据发送过来的话，该函数会一直等待，直到可以读到数据。</p>
<p><code>read</code>和 <code>write</code> 返回的是实际读写的数据，这个数据最大是 buffer 的大小。如果传输的数据大于 buffer 的话，需要在程序里显式地去读取，否则会出错。</p>
<p>你可能会想，我一直读到返回的数据小于 <code>sizeof(buff)</code> 不就行了。嗯，这是一个解决方案，不过要判断返回值不是 0，因为返回值是 0 表示连接已经中断（需要调用 <code>close</code> 来关闭 socket），而不是没有数据发送过来。</p>
<h3><span id="其他常用函数">其他常用函数</span></h3><ol>
<li><p>获取 ip 地址</p>
<p>很多时候，我们只知道服务器的域名，并不知道 ip 地址。<code>gethostbyname</code> 函数就能完成这个功能，<code>netdb.h</code> 文件里有它的定义，它的原型是：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;netdb.h&gt; struct hostent * gethostbyname(const char *name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数 <code>name</code> 是诸如 <code>www.google.com</code> 的字符串，返回值是 <code>struct hostent</code> 结构体，用来存储得到的地址信息。</p>
<pre class="line-numbers language-none"><code class="language-none">struct hostent &#123; char *h_name; &#x2F;* Official name of host. *&#x2F; char **h_aliases; &#x2F;* Alias list. *&#x2F; int h_addrtype; &#x2F;* Host address type. *&#x2F; int h_length; &#x2F;* Length of address. *&#x2F; char **h_addr_list; &#x2F;* List of addresses from name server. *&#x2F; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果函数调用失败，返回空指针 <code>NULL</code>。</p>
</li>
<li><p>把 long 类型的 ip 转换为字符串类型</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;arpa&#x2F;inet.h&gt; char *inet_ntoa(struct in_addr); int inet_aton(const char *cp, struct in_addr *inp);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面的函数返回可用的 in_addr 结构体，需要你手动赋值。下面的函数把转换后的结构拷贝到 inp 指向的结构体里面，然后 inp 就可以直接使用了。</p>
</li>
<li><p>把字符串类型的 ip 转换为 long 类型</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;arpa&#x2F;inet.h&gt; in_addr_t inet_addr(const char *ip);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>把字符串转换成整数</p>
<pre class="line-numbers language-none"><code class="language-none">int atoi(const char *nptr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个可以把从键盘输入的端口号转换成可用的整数。</p>
</li>
<li><p><code>getpeername</code>：获取连在某个 socket 另一端的客户地址(ip 和 port)</p>
<pre class="line-numbers language-none"><code class="language-none">int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回的信息保存在 addr 结构体里。</p>
</li>
</ol>
<h2><span id="demo-演示">Demo 演示 </span></h2><p> 本 demo 实现一个 EchoServer，监听 54321 端口，接受客户端的信息并加上时间戳发送回去。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">BUFFER_SIZE <span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PORT <span class="token number">54321</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">BACKLOG <span class="token number">5</span></span></span>

<span class="token keyword">int</span> <span class="token function">setup_sock</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/*
        * This function sets up a socket listening on local port.
        *
        * port: port number to listen on.
        * :return: socket file descriptor.
        */</span>
    <span class="token keyword">int</span> listen_fd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>
    
    listen_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">bind</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">listen</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> BACKLOG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> listen_fd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">void</span> <span class="token function">echo_request</span><span class="token punctuation">(</span><span class="token keyword">int</span> conn_fd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    time_t ticks<span class="token punctuation">;</span>
    <span class="token keyword">char</span> sendBuff<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> recvBuff<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token function">memset</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>recvBuff<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>recvBuff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">,</span> recvBuff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>recvBuff<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ticks <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">snprintf</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%.24s:"</span><span class="token punctuation">,</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ticks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
        recvBuff<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received:  %s"</span><span class="token punctuation">,</span> recvBuff<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcat</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">,</span> recvBuff<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">,</span> sendBuff<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sendBuff<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received 0 bytes, close.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> listen_fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> conn_fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    socklen_t cli_len<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> cli_addr<span class="token punctuation">;</span>
    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"start server...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cli_addr<span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    listen_fd <span class="token operator">=</span> <span class="token function">setup_sock</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"listening on 0.0.0.0 %d...\n"</span><span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cli_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>cli_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cli_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client ip: %s, port: %d\n"</span><span class="token punctuation">,</span>
                <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">ntohs</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
        <span class="token function">echo_request</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 telnet 测试的结果如下：</p>
<h2><span id="参考资料">参考资料</span></h2><ul>
<li><a href="http://www.csd.uoc.gr/~hy556/material/tutorials/cs556-3rd-tutorial.pdf">Introduction to Sockets Programming in C using TCP/IP</a></li>
<li><a href="http://beej.us/guide/bgnet/">Beej’s Guide to Network Programming Using Internet Sockets</a></li>
<li><a href="http://www.binarytides.com/socket-programming-c-linux-tutorial/">socket programming in C on Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 原理解析</title>
    <url>/2016/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTPS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HTTP 协议是明文传输，它简单易于理解，但同时也带来了安全性问题，在复杂的网络环境中，HTTP 流量几乎是在裸奔，可以轻易被监听，为了解决这个问题，人们提出了 HTTP over SSL 即 HTTPS，即通过 ssl 隧道来传输 HTTP 流量，这样加密了 HTTP 数据包，实现了传输链路上的安全性。相比于 HTTP，HTTPS 在 TCP 层上多了一个 SSL/TLS 层。</p>
<p><img src="http://blog.upyun.com/wp-content/uploads/2017/03/httpvshttps.png" alt="img"></p>
<h2><span id="https-的通信过程">HTTPS 的通信过程</span></h2><h3><span id="ssltls">SSL/TLS</span></h3><blockquote>
<p>SSL（Secure Socket Layer，安全套接字层）：1994 年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999 年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0 和 TLS1.0 由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是 TLS 1.1、TLS 1.2。</p>
</blockquote>
<p>可以简单认为 SSL 与 TLS 是描述的同一种协议，本文中不做区分，SSL/TLS 是为了在 TCP 连接上添加一个加密隧道来加密通信流量，可以确保通信流量安全无法解密。</p>
<h3><span id="图解">图解 </span></h3><p> 由于 HTTPS 的 TLS 层是在 TCP 上的，所以与 HTTP 一样，在建立 TLS 连接之前必须先 TCP 三次握手</p>
<p>HTTPS 的通信过程可以由下图简单表示。</p>
<h3><span id="步骤详解">步骤详解</span></h3><h4><span id="0x01-clienthello">0x01 ClientHello</span></h4><ol>
<li>ClientHello。 首先 https 请求是基于 http 的，也就是基于 tcp 的，所以先得建立 tcp 三次握手，这个就不说了，然后 tcp 握手后是 SSL 层的握手，也就是图中的 ClientHello 消息，client 发送本地最新的 TLS 版本、算法组合的一个集合和其他很多辅助的信息，并且生成一个随机数 A。</li>
</ol>
<p>   <img src="https:////upload-images.jianshu.io/upload_images/2000804-900ab967d4c437d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>   ClientHello.png</p>
<p>   可以看到随机数（</p>
   <pre class="line-numbers language-none"><code class="language-none">Random<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   ）是一个 GMT UNIX 时间加上一串随机字节，算法组合（</p>
   <pre class="line-numbers language-none"><code class="language-none">Cipher Suite<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   ）有 26 种。还有 ClientHello 并不是我随便叫叫的，真的叫 ClientHello😢……</p>
<ol>
<li>ServerHello。Server 收到这些信息后比对自己的 TLS 版本，选择其中低的一个作为返回，并且从算法组合的集合中选出一种合适的组合，然后同样也生成一个随机数 B，一起打包到 ServerHello 中传回给 Client。内容如图（<code>ServerHello.png</code>）：</li>
</ol>
<p>   <img src="https:////upload-images.jianshu.io/upload_images/2000804-84e576eff565ee07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>   ServerHello.png</p>
<p>   同样 ServerHello 也不是随便叫的，可以看到随机数格式和 ClientHello 一样，并且这里选出了一种 CipherSuite 算法组合。</p>
<ol>
<li>Certificatie,ServerHelloDone。服务端在选出沟通策略之后将自己的证书信息告诉 Client 端（<code>Certificate</code>），通知 Client 关于秘钥更新的信息（<code>ServerkeyExchange</code>），接下去就看你的了，并且表示该发的都发给你了，我的 Hello 结束了（<code>ServerHelloDone</code>）。</li>
</ol>
<p>   <img src="https:////upload-images.jianshu.io/upload_images/2000804-d472cf46f4216b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>   Certificate-ServerHelloDone.png</p>
<ol>
<li><p>Client 收到 2，3 步的信息后先验证证书是不是合法的，包括它的颁发机构，域名匹配，有限期限等，这个具体的过程就不探究了，只要知道这些步骤就行了。</p>
</li>
<li><p>证书验证通过之后，生成随机数 C1, 然后用证书内容中的公钥通过服务器选择的非对称加密算法加密，得出为 C2。</p>
</li>
<li><p>由之前的三个随机数 A、B、C1 通过一个伪随机函数再生成一个 D，<strong>注意！这个是最终 http 真正使用的加密秘钥！！！</strong>。</p>
</li>
<li><p>由 D 再次通过伪随机函数生成一个秘钥组，包含 6 个秘钥，假设为 P1,P2,P3,P4,P5,P6。</p>
</li>
<li><p>ClientKeyExchange。通知 Server 秘钥相关的信息，发送第 5 步中算出的 C2 给 Server 端。</p>
</li>
<li><p>Client 端发送 ClientKeyExchange 之后，计算之前所有与 Server 端交互消息的 hash 值，假设为 client_hash1，用步骤 7 中得到的其中一个 P1 进行加密，结果为 E。</p>
</li>
<li><p>Server 端收到 C2 后用私钥结合非对称算法解密 C2，得到 C1。</p>
</li>
<li><p>同样的 Server 端也根据 A、B、C1 由伪随机函数生成 D(<strong>最终的加密秘钥！！！</strong>), 再由 D 得出秘组钥（P1-P6），因为这里涉及到的算法都是一样的，所以得出的秘钥也是一样的。</p>
</li>
<li><p>Server 端计算之前所有和 Client 端交互消息的 hash 值，假设为 server_hash2，大家可能发现了，11、12 跟 Client 端的 6、7、9 过程一致，只是少了 9 中的 P1 加密过程。</p>
</li>
<li><p>这个时候 Client 端会发送 ChangeCipherSpec 消息和 EncryptedHandshakeMessage 消息，通知 Server 端接下去使用选定的加密策略来通信了，并且将第 9 步中的 E 传给了 Server。（这里几个步骤的顺序只是为了好理解一点而这样排列，实际两条线是独立在处理信息的，所以先后顺序不能保证）</p>
</li>
<li><p>这个时候 Client 会再次计算之前握手消息的 hash 值，得出结果 client_hash2。</p>
</li>
<li><p>Server 在收到 EncryptedHandshakeMessage 消息带过来的 E 之后，利用步骤 11 中的 P1 解密 E，由于加密算法和 P1 都是相同的，所以这里还原出了 client_hash1，然后与步骤 12 中的 server_hash2 比对，如果一样说明之前的几条协商秘钥的消息都被对方正确无误的理解了。</p>
</li>
<li><p>Server 端再次对之前的消息做 hash 值，得出 server_hash2，用 P2 进行加密结果为 F，然后通过 ChangeCipherSpec-EncryptedHandshakeMessage 消息传给 Client 端。</p>
</li>
<li><p>Client 收到 Server 的消息后根据 P2 解密 F 还原得出 server_hash2，与 client_hash2 比对如果一致，则认为之前的交互过程都是正确无误且被对方理解的。至此，整个握手过程就结束了，之后的 http 数据报就会被之前确定的加密策略和加密秘钥 D 进行加密传输了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP/HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 三次握手的底层逻辑</title>
    <url>/2018/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>TCP 三次握手是基础中的基础，所有工程师都对此熟悉不过。但这里的三次往往被忽视，究竟为何 TCP 需要三次握手？本文中，我们探讨 TCP 三次握手的底层逻辑。</p>
<p>这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li>通过三次握手才能阻止重复历史连接的初始化；</li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；</li>
</ul>
<p>这几个论点中的第一个是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因，我们在这里对它们的讨论只是为了让整个视角更加丰富，通过多方面理解这一有趣的设计决策。</p>
<a id="more"></a>
<p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。</p>
<p><img src="https://i.loli.net/2020/09/02/dfQg4A3Y1JqeyTu.png" alt="what-is-tcp-connection"></p>
<p>所以，建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。</p>
<p>到这里，我们将原有的问题转换成了『为什么需要通过三次握手才可以初始化 Sockets、窗口大小和初始序列号？』，那么接下来我们就开始对这个细化的问题进行分析并寻找解释。</p>
<h2><span id="设计">设计 </span></h2><p> 这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li>通过三次握手才能阻止重复历史连接的初始化；</li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；</li>
</ul>
<p>这几个论点中的第一个是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因，我们在这里对它们的讨论只是为了让整个视角更加丰富，通过多方面理解这一有趣的设计决策。</p>
<h3><span id="历史连接">历史连接</span></h3><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 其实就指出了 TCP 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<p><img src="https://i.loli.net/2020/09/03/YEVnqM4zvKRmDhG.png" alt="tcp-recovery-from-old-duplicate-syn"></p>
<p>想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p>
<p>所以，TCP 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>
<ul>
<li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li>
</ul>
<p>使用三次握手和 <code>RST</code> 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</p>
<h3><span id="初始序列号">初始序列号 </span></h3><p> 另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p>
<p><img src="https://i.loli.net/2020/09/03/aEen7ulNP21jfTC.png" alt="basic-4-way-handshake"></p>
<p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 TCP 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h3><span id="通信次数">通信次数 </span></h3><p> 当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以 <strong> 使用更多的通信次数交换相同的信息</strong>，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。</p>
<p><img src="https://i.loli.net/2020/09/03/LcoAQhJECWtXBil.png" alt="basic-3-way-handshake"></p>
<p>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。</p>
<h2><span id="总结">总结 </span></h2><p> 我们在这篇文章中讨论了为什么 TCP 建立连接需要经过三次握手，在具体分析这个问题之前，我们首先重新思考了 TCP 连接究竟是什么，<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a> 对 TCP 连接有着非常清楚的定义 —— 用于保证可靠性和流控制机制的数据，包括 Socket、序列号以及窗口大小。</p>
<p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 <code>ACK</code> 和 <code>SYN</code> 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<p>我们重新回到在文章开头提的问题，为什么使用类比解释 TCP 使用三次握手是错误的？这主要还是因为，这个类比没有解释清楚核心问题 —— 避免历史上的重复连接。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细想一下下面的问题：</p>
<ul>
<li>除了使用序列号是否还有其他方式保证消息的不重不丢？</li>
<li>UDP 协议有连接的概念么，它能保证数据传输的可靠么？</li>
</ul>
<h2><span id="reference">Reference</span></h2><ul>
<li><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a></li>
<li><a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way">Why do we need a 3-way handshake? Why not just 2-way?</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>了解 tcp 拥塞控制</title>
    <url>/2017/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2><span id="什么是拥塞">什么是拥塞 </span></h2><p> 我们都知道计算机网络中的资源是有限的。某段时间内网络中对资源的需求超过了网络中的可用部分，而导致网络性能下降的情况就是 <strong> 拥塞</strong>。</p>
<p>通俗点说就是发送的数据包太多网络中的设备处理不过来，而导致网络性能下降的情况。</p>
<h2><span id="tcp-为什么要进行拥塞控制">TCP 为什么要进行拥塞控制 </span></h2><p> 网络中的路由器会有一个数据包处理队列，当路由器接收到的数据包太多而一下子处理不过来时，就会导致数据包处理队列过长。此时，路由器就会无条件的丢弃新接收到的数据封包。</p>
<p>这就会导致上层的 TCP 协议以为数据包在网络中丢失，进而重传这些数据包，而路由器又会丢弃这些重传的数据包，如此以往，就会导致网络性能急剧下降，引起网络瘫痪。</p>
<p>因此，TCP 需要控制数据包发送的数量来避免网络性能的下降。</p>
<h2><span id="拥塞控制与流量控制的区别">拥塞控制与流量控制的区别 </span></h2><p> 引用书上的答案：</p>
<blockquote>
<ul>
<li><strong>拥塞控制 </strong> 就是防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li><strong>流量控制 </strong> 往往指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
</blockquote>
<h1><span id="拥塞控制的方法">拥塞控制的方法 </span></h1><h2><span id="慢开始"> 慢开始 </span></h2><h3><span id="拥塞窗口"> 拥塞窗口 </span></h3><p> 拥塞窗口（cwnd）是指发送方维护的一个根据网络状况动态变化的窗口。一般来说，发送方会让自己的发送窗口等于拥塞窗口的大小。</p>
<blockquote>
<p>如果考虑到流量控制的话，发送窗口也有可能小于拥塞窗口的大小。</p>
</blockquote>
<h3><span id="传输轮次">传输轮次 </span></h3><p> 一个传输轮次是指发送方把自己的发送窗口内的数据全部发送出去并收到对最后一个字节的确认。</p>
<p>例如，A 将自己的发送窗口内的数据全部连续发送给了 B，而 B 收到这些数据后向 A 发送了对这些数据的确认，A 收到这个确认后，一个传输轮次就算是完成了。</p>
<h3><span id="慢开始算法">慢开始算法 </span></h3><p> 慢开始算法中的主要方法就是有小到大逐渐增大发送窗口。</p>
<p>那么，具体是怎么增大的呢？</p>
<p>简单来说就是每个传输轮次后将 cwnd 大小加倍。</p>
<p>举个例子：</p>
<p>首先，发送方设置 cwnd=1（为方便理解，这里用报文段的个数作为窗口大小的单位），在收到接收方发来的确认后（也就是下个传输轮次），设置 cwnd=2，然后将发送窗口的数据发送出去。在一次收到接收方发来的确认后，发送方设置 cwnd=4，再讲发送窗口中的数据发送出去。然后再重复上面的过程。</p>
<p>这里就应该清楚，<strong>慢开始 </strong> 算法中的 <strong> 慢</strong>不是说 cwnd 增长的 <strong> 慢</strong>，而是相对一下子发送大量数据而言，这种一次先发送少量的数据包的方式要 <strong> 慢</strong>许多。</p>
<p>当然，cwnd 的大小肯定不可能一直以这种指数的方式增长下去，要不然很快就会增长到引起网络瘫痪的程度了。</p>
<p>所以，经过一定时间或条件，我们就要换成 <strong> 拥塞避免 </strong> 算法来发送数据。</p>
<h2><span id="拥塞避免">拥塞避免 </span></h2><h3><span id="慢开始门限-ssthresh"> 慢开始门限 ssthresh</span></h3><p>像上面所说，不能任由慢开始算法中的 cwnd 任意增长，所以我们引入一个 <strong> 慢开始门限（ssthresh）</strong>的阈值来控制 cwnd 的增长。</p>
<p>具体作用如下：</p>
<ul>
<li>cwnd &lt; ssthresh ，使用慢开始算法</li>
<li>cwnd = ssthresh , 使用慢开始算法或拥塞避免算法都可以</li>
<li>cwnd &gt; ssthresh , 使用拥塞避免算法呢</li>
</ul>
<p>还有一个问题就是这个 ssthresh 是怎么设置的呢？</p>
<p>TCP/IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把 ssthresh 设置为此时发送窗口的一半大小（不能小于 2）。</p>
<h3><span id="拥塞避免过程">拥塞避免过程 </span></h3><p><strong> 拥塞避免 </strong> 算法也是逐渐的增大 cwnd 的大小，只是采用的是线性增长而不是像 <strong> 慢开始 </strong> 算法那样的指数增长。</p>
<p>具体来说就是每个传输轮次后将 cwnd 的大小加一（加法增大），如果发现出现网络拥塞的话就按照上面的方法重新设置 <strong>ssthresh</strong> 的大小（乘法减小）并从 cwnd=1 开始重新执行 <strong> 慢开始 </strong> 算法。</p>
<p>如下面的图片所示：</p>
<p><img src="http://static.zybuluo.com/lxyzk/zxxuqcjbsq9gzyotfbfjwjrn/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3" alt="拥塞避免算法图解"></p>
<p>（图片来源于网络）</p>
<h2><span id="快重传">快重传 </span></h2><p> 前面复习到过，TCP 的可靠传输的原理就是 <strong> 超时重传 </strong> 机制。配合上面的 <strong> 慢开始 </strong> 和<strong>拥塞避免 </strong> 使用就是发送发发送完数据后设置一个定时器，如果在定时器时间内没有收到对接收方发来的确认的话就去执行上述的 <strong> 乘法减小 </strong> 过程并重新开始 <strong> 慢开始 </strong> 算法。</p>
<p>而 <strong> 快重传 </strong> 则是允许发送方再连续收到 3 个重复的确认后就可以开始执行 <strong> 乘法减小 </strong> 过程而不必再等待所设置的重传计时器到时。</p>
<p>这就需要接收方没收到一个 <strong> 失序的报文段 </strong> 就立即发出重复确认以让发送发及早知道有报文段丢失，而不是等待自己发送数据的时候进行捎带确认。</p>
<h2><span id="快恢复">快恢复 </span></h2><p><strong> 快恢复算法 </strong> 是与 <strong> 快重传算法 </strong> 配合使用的一个算法。</p>
<p>使用了 <strong> 快恢复算法 </strong> 后与原来不同的一点是当发现网络出现拥塞并执行了 <strong> 乘法减小 </strong> 过程后，并不是设置 cwnd=1 并重新开始执行 <strong> 慢开始 </strong> 算法，而是让 cwnd=<strong>乘法减小 </strong> 后的 <strong>ssthresh</strong> 并开始执行 <strong> 拥塞避免 </strong> 算法。</p>
<p>因为此时发送发能连续接收到三个重复的确认就可以认为此时网络很可能没有发生拥塞。</p>
<p>使用了 <strong> 快重传 </strong> 和<strong>快恢复 </strong> 的拥塞避免过程如下：</p>
<p><img src="http://static.zybuluo.com/lxyzk/i6zrad1hw97f0a4okjxke7c4/%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%BF%AB%E6%81%A2%E5%A4%8D" alt="快重传快恢复"></p>
<p>（图片来源于网络）</p>
<h2><span id="tcp-的发送窗口到底是多大">TCP 的发送窗口到底是多大 </span></h2><p> 发送窗口的上限值 = Min{rwnd, cwnd}</p>
<p>rwnd：接收方接收窗口<br>cwnd：发送方拥塞窗口</p>
<a id="more"></a>
<h1><span id="todo">TODO</span></h1>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Web - 从 url 到页面发生了什么</title>
    <url>/2016/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BB%8Eurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2><span id="访问过程">访问过程 </span></h2><p> 我们在浏览器地址栏中输入 google.com 这个地址，然后浏览器经过短暂加载后给我们呈现了 Google 的搜索页面。</p>
<p>这中间的步骤有哪些呢？</p>
<a id="more"></a>
<ol>
<li><p>首先是域名解析 google.com 转换为这个网站服务器的 IP，这其中或许还包含有 CDN 加速、负载均衡，分布式服务等技术。</p>
</li>
<li><p>获取到服务器 IP 之后，我们的浏览器会通过 TCP 三次握手与服务器建立 TCP 连接。</p>
<ul>
<li>如果网站是 HTTPS，还会经过 TLS/SSL 的握手步骤与服务器建立 TLS/SSL 连接。</li>
</ul>
</li>
<li><p>建立 TCP 连接之后，浏览器作为客户端发送 HTTP 请求 (request) 报文到目的 IP 地址即 Web 服务器 IP。</p>
</li>
<li><p>有的时候获取的 IP 是反向代理的服务器 IP，这些服务器接受客户端请求，并把请求转发给真实服务器 IP。</p>
</li>
<li><p>接下来是服务器的工作过程：</p>
<ul>
<li>服务器上 Google.com 服务进程监听服务端口，收到客户端的 HTTP 请求报文，这个报文被服务器上安装的 Web 服务器 (Web Server) 如 apache、nginx、LigHTTPd、IIS 所监听到。</li>
<li>Web Server 解析 HTTP 请求报文，根据路由配置去访问特定位置的资源或委托给服务器上的处理请求的程序进行处理，如 CGI 脚本、JSP、ASP、servlets、node.js 等。</li>
<li>Web App 把响应数据交给 Web Server，Web Server 按照 HTTP 响应报文格式封装数据为 HTTP 响应 (response) 报文，并把报文通过 TCP 连接链路回送给客户端。</li>
</ul>
</li>
<li><p>客户端浏览器接受到 HTTP 响应报文，从数据部分提取出 html 代码，通过加载、解析、渲染的过程，来在屏幕上绘制出页面。</p>
</li>
</ol>
<h2><span id="url-格式探秘">URL 格式探秘</span></h2><p>URL(Uniform Resource Locator, 统一资源定位符)，互联网设计为一个大的文件系统，就像是我们电脑中每个文件都有对应的文件地址，互联网上的资源地址就是 URL。其格式为</p>
<blockquote>
<p>protocol://<hostname>:<port>/<route>/<filename></filename></route></port></hostname></p>
</blockquote>
<ul>
<li><p>协议 (protocol) 常见的有 HTTP，HTTPS，ftp，telnet，file 等几种。这些协议都属于应用协议，位于协议层的应用层，它们基于传输层的协议而工作，例如 HTTP 基于 TCP，HTTPS 基于 TLS/SSL，TLS/SSL 也是基于 TCP 传输协议。</p>
</li>
<li><p>主机名 (hostname) 代表一个提供服务的服务器 IP，它可以是 IP 或者可以解析为 IP 的网址。</p>
</li>
<li><p>端口号 (port) 代表服务器的一个服务进程，这个进程监听这个端口上的 TCP 或 UDP 数据报。一台主机往往提供多个服务，例如既提供 Web 服务也提供 FTP 服务，那么端口就可以告诉 web 服务器所在主机把请求交给哪一个服务。各个协议都有默认（缺省）的端口。</p>
</li>
<li><p>路径 (route) 代表一个服务下的资源的路径，例如 <code>https://myblog.com/blog/2017/index.html</code> 中的 /<code>blog/2017</code>代表 2017 年的所有博客，返回的资源取决于后端服务器的实现。</p>
</li>
<li><p>文件名 (filename) 代表某个特定的资源，例如 <code>https://myblog.com/blog/2017/index.html</code> 的<code>index.html</code>代表这个特定的页面。</p>
</li>
</ul>
<h2><span id="ip-地址">IP 地址 </span></h2><p> 就像每栋房子都有地址，IP 代表一个计算机或者局域网在互联网上的地址。IP 协议如今已有 IPv4 和 IPv6，目前依旧是 IPv4 占据主流，但 IPv6 是未来的趋势。IPv4 协议中，存在公网地址不足的问题，所以人们发明了 NAT 技术把一个局域网地址映射为一个公网地址(局域网网关地址)。局域网内的主机要提供互联网服务必须利用端口映射把该主机上的服务端口映射到局域网网关的端口。</p>
<p>但 IP 地址不易辨识，所以人们用网站域名来作为 IP 地址的别名，从 IP 地址到域名或从域名到 IP 地址的映射过程称为 DNS 解析。</p>
<h2><span id="dns-解析">DNS 解析 </span></h2><h3><span id="dns-解析过程">DNS 解析过程</span></h3><p> 在浏览器地址栏输入 url 之后，电脑会发出一个 DNS 解析请求到本地 DNS 服务器。然后按照以下步骤依次查找：</p>
<ol>
<li><p>查找浏览器缓存</p>
<p>浏览器检查缓存是否有未过期的该域名解析过的 IP 地址，如果有，那么解析过程成功结束。</p>
</li>
</ol>
<center>▲ chrome 的浏览器缓存示例</center>

<ol>
<li><p>查找操作系统缓存</p>
<p>如果浏览器 dns 缓存不存在或已过期，那么浏览器会从 hosts 文件中查找，查找是否有对应的域名 dns 配置项。</p>
</li>
<li><p>查找路由器缓存</p>
<p>如果系统缓存也没有，那么去路由器的 dns 缓存中查找。</p>
</li>
<li><p>网络接入服务商(ISP)DNS 缓存</p>
<p>ISP 都会提供 DNS 缓存服务器。我们也可以在网络配置中配置特定的 DNS 服务器。</p>
</li>
</ol>
<p>   如果是局域网内的主机，这个本地 DNS 服务器一般是局域网的网关。网关会把 DNS 解析请求转发给 ISP DNS 服务器。</p>
<ol>
<li><p>递归查询</p>
<p>经历了如上步骤都找不到 DNS 服务器的话，那么就会直接访问互联网的 DNS 服务器进行递归查询。</p>
</li>
</ol>
<p>   假设解析 <code>www.google.com</code> 这个域名，本地 dns 服务器把 dns 解析请求转发给互联网的根域名服务器，如果根域名服务器不存在该域名记录，则根据顶级域 com 向 com 顶级域 dns 服务器发送 dns 请求，如果还没有则根据二级域 google.com 服务器查询，知道最终得到该域名的 IP 地址，并把它缓存到本地。</p>
<p>   所以网址的 dns 解析过程是一个由右向左的解析过程：</p>
<p>   <code>. --&gt; .com --&gt; google.com --&gt; www.google.com</code></p>
<h3><span id="dns-负载均衡">DNS 负载均衡 </span></h3><p> 我们也可以在命令行通过 nslookup 命令来对某个域名进行 dns 解析获得它的 IP 地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">nslookup</span> google.com

Non-authoritative answer:
Name:	baidu.com
Address: <span class="token number">220.181</span>.57.216
Name:	baidu.com
Address: <span class="token number">123.125</span>.115.110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现 baidu.com 这个域名有两个 IP 地址。这是采用了 DNS 负载均衡技术。</p>
<p>由于单台服务器的性能有限，现代的大型网络服务往往都是集群服务器提供服务，而这些服务器集群往往有多个 IP 地址，而 DNS 可以根据根据每台服务器的负载量，该机器离用户地理位置的距离等来返回一个合适的服务器的 IP 给用户，这就是 DNS 的负载均衡也称为 DNS 重定向。CDN 正是采用了这种技术。</p>
<h2><span id="tcp-连接">TCP 连接</span></h2><p>Web 服务都是基于 HTTP/HTTPS 协议提供的，而 HTTP/HTTPS 协议又是基于传输层的 TCP 协议的。所以进行 HTTP 通信前，必须先建立 TCP 连接，TCP 连接是通过三次握手来建立的，通过四次挥手来断开。这里不详细赘述。</p>
<h3><span id="http-协议">HTTP 协议 </span></h3><h4><span id="http-的无连接">HTTP 的无连接</span></h4><p><strong>HTTP 协议是无连接的协议</strong>，无连接的意思就是指每次连接只处理一个请求。服务器处理完客户请求，收到应答之后，即断开 TCP 连接。这种设计是因为客户端与服务端的交换数据时间间隔较大，而且两次传送的数据关联性较低，为了节省 TCP 连接信道所占据的资源，HTTP 协议被设计为<strong> 请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端</strong>。但是对于某些情景，例如网页中含有大量引用资源，每次访问引用资源都需要建立一次 TCP 连接就显得十分低效（TCP 的三次握手和四次挥手性能消耗十分严重）。</p>
<p>为了实现持续 TCP 连接，HTTP 协议引入了 Keep-Alive 字段。<strong>Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 可以保持客户端与服务端的持续 TCP 连接</strong>。对于静态网站，这个功能十分有用，但对于动态网站来说，过多的连接会耗尽服务器的连接池，持续占用资源影响性能。所以要谨慎使用 Keep-Alive 功能。</p>
<h4><span id="http-的无状态">HTTP 的无状态</span></h4><p><strong>HTTP 协议是无状态的协议</strong>，这是指协议对于事务处理没有记忆能力，服务器不知道客户端中的状态，即我们与服务器的每一次请求响应过程，服务器都不会记录任何信息。每个请求都是独立的。</p>
<p>例如：电商网站中，我们向购物车放一个商品。如果我们没有登陆，那么服务器无法记录购物车里的商品清单，因为它无法分辨究竟是哪个用户的购物车。</p>
<p>为了解决这个问题，HTTP 使用了 Cookie 和 Session 两种保持 HTTP 连接状态的技术，我们常见的登陆操作常见的做法就是在本地生成一个状态 cookie，然后 cookie 中保存 sessionid，我们每次发送 http 请求时，服务器读取 cookie 中的 sessionid，在服务端查找持久化的 session 信息，判断用户的登陆状态，并读取对应的业务信息。</p>
<h3><span id="https-协议">HTTPS 协议</span></h3><p>HTTP 协议完全是明文传输，直接把明文的 HTTP 报文通过 TCP 连接传送到对方，这其中有相当的信息泄漏的风险。为了解决这个问题，网景公司提出了一种新协议 HTTPS，即基于 SSL 协议的 HTTP，这是把 HTTP 报文放在加密的 SSL 信道中进行通信。SSL 后来被标准化为 TLS 协议，一般称之为 TLS/SSL。</p>
<p>HTTPS 与 HTTP 协议不同之处在于，建立 TCP 连接之后，HTTPS 协议还需要再经过<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">TLS/SSL 握手过程</a>，来建立 TLS/SSL 通道，然后才进行 HTTP 通信。这也带来了一定的性能损耗。</p>
<h2><span id="客户端构造-http-请求报文">客户端构造 HTTP 请求报文 </span></h2><p> 获取了目的 IP，建立了 TCP 连接之后，客户端构建 HTTP 请求报文，通过 TCP 协议发送到服务器指定端口(HTTP 协议默认端口 80/8080, HTTPS 协议默认端口 443)。</p>
<h2><span id="服务端接受-http-请求">服务端接受 HTTP 请求 </span></h2><p> 从这里开始就是服务端的工作了。Web Server 监听 TCP 端口，当端口接收到 <code>HTTPRequest</code> 报文，就对报文进行解析，并封装称为 <code>HTTPRequest</code> 对象，供上层使用。</p>
<p>根据访问的资源，大致可分为静态资源和动态资源，静态资源就是指目录中某个位置中预先生成好的文件，例如 myblog/index.html，动态资源则是指会根据请求数据动态生成的页面，例如根据用户权限不同展示的数据统计表。</p>
<p>Web Server 从 HTTP 请求中获取参数后，如果是静态资源，则读取该资源文件，根据 HTTP 响应报文格式产生 HTTP 响应，回送给客户端。如果是动态资源，则进行一系列的处理，产生 HTTP 响应报文。</p>
<p>例如目前主流的后端 Web 框架是 MVC 模式。</p>
<p>MVC 框架首先根据 <code>HTTPRequest</code> 对象的参数、内容，先根据路由配置去选择对应的 Controller，Controller 根据参数进行业务处理，中间可能会进行读写数据库等操作，然后渲染一个数据模型 Model，数据模型用来渲染模版页，这里的工作由模版引擎来完成，最终生成 HTTP 响应。</p>
<p>假设 <code>myblog.com/blogs/1/edit</code> 是修改 <code>myblog.com</code> 的第一篇博客的接口，那么 Router 首先对 <code>blogs/1/edit</code> 进行路由匹配，匹配到的 <code>controller</code> 是<code>edit</code>，那么调用 <code>edit</code> 这个方法，该方法从 <code>HTTP Request</code> 对象的正文获得了修改后的博文，于是调用数据库引擎，对数据库内的对应博文进行修改。然后返回一个新的博文的 json 数据，该数据即是数据模型 <code>Model</code>，然后调用模版引擎，把<code>Model</code> 渲染到模版页，生成 html 页面，然后根据 html 页面产生 <code>HTTPResponse</code> 对象。</p>
<h2><span id="服务端发出-http-响应">服务端发出 HTTP 响应 </span></h2><p>Web 服务器根据<code>HTTPResponse</code> 对象来产生 HTTP 响应报文，通过 TCP 连接回送该报文。然后根据 HTTP 中的 Keep-Alive 字段的值确定是否要在响应发送完成后关闭 TCP 连接。</p>
<h2><span id="客户端接受-http-响应报文">客户端接受 HTTP 响应报文 </span></h2><p> 浏览器从 HTTP 响应报文中的数据段提取出 html、css、js 文件，然后浏览器对这些资源进行渲染，把渲染出来的网页绘制在屏幕上。</p>
<p>浏览器从上而下解析 HTML 文件，如果解析过程中遇到外部资源，如图像、JS、CSS 文件等，则会重复以上 HTTP 通信过程。这个对外部资源的请求是异步的，所以不会影响资源解析。当解析到 JS 文件时，HTML 文档则会挂起渲染过程，等待 JS 文件加载完毕和执行完毕。因此 JS 会阻塞后续资源的下载。JS 代码执行前必须保证所有的 CSS 文件加载完毕。</p>
<p>浏览器解析 HTML 文件构造 DOM 树，解析 CSS 文件构造渲染树，渲染树构建完成后，则开始根据渲染树绘制页面到屏幕上。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘 http 响应报文结构</title>
    <url>/2015/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%8E%A2%E7%A7%98http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>HTTP 响应报文通过通信双方建立的 TCP 连接传送，传送完成后根据 HTTP 协议中的 Connection 字段确定是否要继续保持 TCP 连接。HTTP 响应报文由状态行、响应头部 和 响应包体 3 个部分组成，如下图所示：</p>
<a id="more"></a>
<h3><span id="实例">实例 </span></h3><p> 以访问 www.baidu.com 为例，我们可以 <kbd>⌥</kbd> +<kbd>⌘</kbd> +<kbd>j</kbd> 打开 Chrome Dev Tools 来看一个实例。</p>
<p>、</p>
<p>展开 Response Headers 选项，我们得到了响应报文。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Bdpagetype:</span> 2
<span class="token header-name keyword">Bdqid:</span> 0xb8a2e3a70000a2ab
<span class="token header-name keyword">Cache-Control:</span> private
<span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Type:</span> text/html;charset=utf-8
<span class="token header-name keyword">Date:</span> Mon, 01 Oct 2018 08:11:18 GMT
<span class="token header-name keyword">Expires:</span> Mon, 01 Oct 2018 08:11:17 GMT
<span class="token header-name keyword">Server:</span> BWS/1.1
<span class="token header-name keyword">Set-Cookie:</span> BDSVRTM=171; path=/
<span class="token header-name keyword">Set-Cookie:</span> BD_HOME=1; path=/
<span class="token header-name keyword">Set-Cookie:</span> H_PS_PSSID=xxxxxxxx; path=/; domain=.baidu.com
<span class="token header-name keyword">Strict-Transport-Security:</span> max-age=172800
<span class="token header-name keyword">X-Ua-Compatible:</span> IE=Edge,chrome=1
<span class="token header-name keyword">Transfer-Encoding:</span> chunked<span class="token text-html">

<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上而下分别是有三个部分：状态行，响应头部和响应包体。</p>
<h3><span id="http-响应状态行">HTTP 响应状态行 </span></h3><p> 状态行由协议版本 响应码 和响应描述组成</p>
<h4><span id="响应码">响应码 </span></h4><p> 根据客户端的 HTTP 请求，会产生不同的 HTTP 响应状态，这些状态用状态码来表示。</p>
<p>按照分类，响应大概分为以下几大类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态码</th>
<th>响应类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>信息性状态码（Informational）</td>
<td>服务器正在处理请求</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码（Success）</td>
<td>请求已正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码（Redirection）</td>
<td>需要进行额外操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码（Client Error）</td>
<td>客户端原因导致服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码（Server Error）</td>
<td>服务器原因导致处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<p>常用的状态码有 200，204，207，301，302，303，304，307，400，401，403，404，500，503 这些</p>
<ul>
<li>200 OK 表示请求被服务器正常处理</li>
<li>204 No Content 表示请求已成功处理，但是没有内容返回</li>
<li>206 Partial Content 表示服务器已经完成了部分 GET 请求</li>
<li>301 Moved Permanently 永久重定向，表示请求的资源已经永久的搬到了其他位置</li>
<li>302 Found 临时重定向，表示请求的资源临时搬到了其他位置</li>
<li>303 See Other 表示请求资源存在另一个 URI，应使用 GET 定向获取请求资源</li>
<li>304 Not Modified 表示客户端发送附带条件的请求（GET 方法请求报文中的 IF…）时，条件不满足</li>
<li>307 Temporary Redirect 临时重定向，和 302 有着相同含义</li>
<li>400 Bad Request 表示请求报文存在语法错误或参数错误，服务器不理解</li>
<li>401 Unauthorized 表示发送的请求需要有 HTTP 认证信息或者是认证失败了</li>
<li>403 Forbidden 表示对请求资源的访问被服务器拒绝了</li>
<li>404 Not Found 表示服务器找不到请求的资源</li>
<li>500 Internal Server Error 表示服务器执行请求的时候出错了</li>
<li>503 Service Unavailable 表示服务器超负载或正停机维护，无法处理请求</li>
</ul>
<h3><span id="http-响应头部">HTTP 响应头部 </span></h3><p> 响应头部由若干响应头部字段组成，这些字段类似于键值对形式，每个字段占据一行。</p>
<h4><span id="常用标准响应头字段">常用标准响应头字段</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Access-Control-Allow-Origin</strong></td>
<td>指定哪些站点可以参与跨站资源共享</td>
<td>Access-Control-Allow-Origin: *</td>
</tr>
<tr>
<td><strong>Accept-Patch</strong></td>
<td>指定服务器支持的补丁文档格式，适用于 http 的 patch 方法</td>
<td>Accept-Patch: text/example;charset=utf-8</td>
</tr>
<tr>
<td><strong>Accept-Ranges</strong></td>
<td>服务器通过 byte serving 支持的部分内容范围类型</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td><strong>Age</strong></td>
<td>对象在代理缓存中暂存的秒数</td>
<td>Age: 1200</td>
</tr>
<tr>
<td><strong>Allow</strong></td>
<td>设置特定资源的有效行为，适用方法不被允许的 http 405 错误</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td><strong>Alt-Svc</strong></td>
<td>服务器使用”Alt-Svc”（Alternative Servicesde 的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取</td>
<td>Alt-Svc: h2=”http2.example.com:443”; ma=7200</td>
</tr>
<tr>
<td><strong>Cache-Control</strong></td>
<td>告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒</td>
<td>Cache-Control: max-age=3600</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>设置当前连接和 hop-by-hop 协议请求字段列表的控制选项</td>
<td>Connection: close</td>
</tr>
<tr>
<td><strong>Content-Disposition</strong></td>
<td>告诉客户端弹出一个文件下载框，并且可以指定下载文件名</td>
<td>Content-Disposition: attachment; filename=”fname.ext”</td>
</tr>
<tr>
<td><strong>Content-Encoding</strong></td>
<td>设置数据使用的编码类型</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td><strong>Content-Language</strong></td>
<td>为封闭内容设置自然语言或者目标用户语言</td>
<td>Content-Language: en</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td>响应体的字节长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td><strong>Content-Location</strong></td>
<td>设置返回数据的另一个位置</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td><strong>Content-MD5</strong></td>
<td>设置基于 MD5 算法对响应体内容进行 Base64 二进制编码</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td><strong>Content-Range</strong></td>
<td>标识响应体内容属于完整消息体中的那一部分</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>设置响应体的 MIME 类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td><strong>Date</strong></td>
<td>设置消息发送的日期和时间</td>
<td>Date: Tue, 15 Nov 1996 08:12:31 GMT</td>
</tr>
<tr>
<td><strong>ETag</strong></td>
<td>特定版本资源的标识符，通常是消息摘要</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td><strong>Expires</strong></td>
<td>设置响应体的过期时间</td>
<td>Expires: Thu, 01 Dec 1996 16:00:00 GMT</td>
</tr>
<tr>
<td><strong>Last-Modified</strong></td>
<td>设置请求对象最后一次的修改日期</td>
<td>Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</td>
</tr>
<tr>
<td><strong>Link</strong></td>
<td>设置与其他资源的类型关系</td>
<td>Link: &lt;/feed&gt;; rel=”alternate”</td>
</tr>
<tr>
<td><strong>Location</strong></td>
<td>在重定向中或者创建新资源时使用</td>
<td>Location: <code>http://www.w3.org/pub/WWW/People.html</code></td>
</tr>
<tr>
<td><strong>P3P</strong></td>
<td>以 P3P:CP=”your_compact_policy”的格式设置支持 P3P(Platform for Privacy Preferences Project)策略，<br>大部分浏览器没有完全支持 P3P 策略，许多站点设置假的策略内容欺骗支持 P3P 策略的浏览器以获取第三方 cookie 的授权</td>
<td>P3P: CP=”This is not a P3P policy! See <code>http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657</code> for more info.”</td>
</tr>
<tr>
<td><strong>Pragma</strong></td>
<td>设置特殊实现字段，可能会对请求响应链有多种影响</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td><strong>Proxy-Authenticate</strong></td>
<td>设置访问代理的请求权限</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td><strong>Public-Key-Pins</strong></td>
<td>设置站点的授权 TLS 证书</td>
<td>Public-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”;</td>
</tr>
<tr>
<td><strong>Refresh</strong></td>
<td>重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持<br><meta http-equiv="refresh" content="5; url=http://example.com/"></td>
<td>Refresh: 5; url=<code>http://www.w3.org/pub/WWW/People.html</code></td>
</tr>
<tr>
<td><strong>Retry-After</strong></td>
<td>如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者 HTTP 时间</td>
<td>Retry-After: 120<br> Retry-After: Fri, 07 Nov 2014 23:59:59 GMT</td>
</tr>
<tr>
<td><strong>Server</strong></td>
<td>服务器名称</td>
<td>Server: nginx/1.14.0 (Ubuntu)</td>
</tr>
<tr>
<td><strong>Set-Cookie</strong></td>
<td>设置 HTTP Cookie</td>
<td>Set-Cookie: UserID=Andy; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>设置 HTTP 响应状态</td>
<td>Status: 200 OK</td>
</tr>
<tr>
<td><strong>Strict-Transport-Security</strong></td>
<td>一种 HSTS 策略通知 HTTP 客户端缓存 HTTPS 策略多长时间以及是否应用到子域</td>
<td>Strict-Transport-Security: max-age=16070400; includeSubDomains</td>
</tr>
<tr>
<td><strong>Trailer</strong></td>
<td>标识给定的 header 字段将展示在后续的 chunked 编码的消息中</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td><strong>TSV</strong></td>
<td>在响应中设置给 DNT(do-not-track), 可能的取值</td>
<td>TSV: N</td>
</tr>
<tr>
<td><strong>Upgrade</strong></td>
<td>请求客户端升级协议</td>
<td>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</td>
</tr>
<tr>
<td><strong>Vary</strong></td>
<td>通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的</td>
<td>Vary: Accept-Language</td>
</tr>
<tr>
<td><strong>Warning</strong></td>
<td>实体可能会发生的问题的通用警告</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td><strong>WWW-Authenticate</strong></td>
<td>标识访问请求实体的身份验证方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
<tr>
<td><strong>X-Frame-Options</strong></td>
<td>点击劫持保护：<br>deny 不渲染 <br>sameorigin <strong> 如果源不匹配不渲染</strong><br>allow-from 允许指定位置访问<br>allowall 不标准，允许任意位置访问</td>
<td>X-Frame-Options: deny</td>
</tr>
</tbody>
</table>
</div>
<h4><span id="常用非标准响应头字段">常用非标准响应头字段</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>X-XSS-Protection</strong></td>
<td>过滤跨站脚本</td>
<td>X-XSS-Protection: 1; mode=block</td>
</tr>
<tr>
<td><strong>Content-Security-Policy</strong></td>
<td>定义内容安全策略</td>
<td></td>
</tr>
<tr>
<td><strong>X-Content-Security-Policy</strong></td>
<td>定义内容安全策略</td>
<td></td>
</tr>
<tr>
<td><strong>X-WebKit-CSP</strong></td>
<td>定义内容安全策略</td>
<td>X-WebKit-CSP: default-src ‘self’</td>
</tr>
<tr>
<td><strong>X-Content-Type-Options</strong></td>
<td>唯一的取值是””, 阻止 IE 在响应中嗅探定义的内容格式以外的其他 MIME 格式</td>
<td>X-Content-Type-Options: nosniff</td>
</tr>
<tr>
<td><strong>X-Powered-By</strong></td>
<td>指定支持 web 应用的技术</td>
<td>X-Powered-By: PHP/5.4.0</td>
</tr>
<tr>
<td><strong>X-UA-Compatible</strong></td>
<td>推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活 IE 中内嵌 chrome 框架插件<br><meta http-equiv="X-UA-Compatible" content="chrome=1"></td>
<td>X-UA-Compatible: IE=EmulateIE7<br> X-UA-Compatible: IE=edge</td>
</tr>
</tbody>
</table>
</div>
<p> X-UA-Compatible: Chrome=1 |<br>| <strong>X-Content-Duration</strong>            | 提供音视频的持续时间，单位是秒，只有 Gecko 内核浏览器支持      | X-Content-Duration: 42.666                                   |<br>| <strong>Upgrade-Insecure-Requests</strong>     | 标识服务器是否可以处理 HTTPS 协议                              | Upgrade-Insecure-Requests: 1                                 |<br>| <strong>X-Request-ID,X-Correlation-ID</strong> | 标识一个客户端和服务端的请求                                 | X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5           |</p>
<h3><span id="http-响应包体">HTTP 响应包体 </span></h3><p> 响应包体包含 HTTP 响应所返回的数据，其数据类型由响应头部中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type">Content-Type 字段</a> 指定。</p>
<p>例如响应一个 js 资源</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span class="token header-name keyword">cache-control:</span> no-cache
<span class="token header-name keyword">Content-Security-Policy:</span> script-src 'self' blob: filesystem: chrome-extension-resource:; object-src 'self' blob: filesystem:;
<span class="token header-name keyword">Content-Type:</span> text/javascript
<span class="token header-name keyword">ETag:</span> "xx+STUs6bw="

define(["core/Logger"],function(t)&#123;var i,n=&#123;settings:[300,60,10],NOTIFICATION_TTL:5e3,initAPI:function(t)&#123;i=t,i.mixin("Notification",&#123;get:this.get.bind(this),saveSettings:this.saveSettings.bind(this)&#125;)&#125;,init:function(t)&#123;this.loadSettings(),"function"==typeof t&amp;&amp;t()&#125;,get:function()&#123;return this.settings&#125;,show:function(t)&#123;var n="",e="",o=0,s=this;"nuclear"===t?(o=i.NuclearOption.getSecondsUntilActive(),n="common/img/eye_48x48_nuclear.png",e=i.Chrome.Translation.get("nuclearNotification")||"The Nuclear Option will start blocking sites in"):"block"===t&amp;&amp;(o=i.StayFocusd.getTotalSecondsRemaining(),n="common/img/eye_48x48_red.png",e=i.Chrome.Translation.get("blockNotification")||"StayFocusd will start blocking your Blocked Sites in"),e+=o>60?""+i.Date.secondsToMinsAndSecs(o):" "+o+" seconds";var c=&#123;type:"basic",title:"StayFocusd",iconUrl:n,message:e&#125;;i.Chrome.Notification.create("",c,function(t)&#123;setTimeout(function()&#123;i.Chrome.Notification.clear(t,function()&#123;&#125;)&#125;,s.NOTIFICATION_TTL)&#125;)&#125;,isset:function(t)&#123;return this.settings.inArray(t)&#125;,saveSettings:function(t)&#123;this.settings=t,i.Settings.set(&#123;notificationSettings:t&#125;)&#125;,loadSettings:function()&#123;var t=i.Settings.get("notificationSettings");t&amp;&amp;(this.settings=t)&#125;&#125;;return n&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="总结">总结</span></h3><p>HTTP 响应报文的控制信息保存在 HTTP 响应状态行和响应头部，数据则被保存在包体中。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>HTTP/HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘 http 请求报文结构</title>
    <url>/2015/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%8E%A2%E7%A7%98http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>HTTP 请求报文由客户端发出，在发送报文之前要先与服务器建立 TCP 连接，如果使用 HTTPS 协议还需要建立 TLS/SSL 加密隧道连接，HTTP 请求报文是由三部分组成: <strong>请求行 </strong>, <strong> 请求报头 </strong> 和<strong>请求正文</strong>。</p>
<a id="more"></a>
<h3><span id="实例">实例 </span></h3><p> 举个例子，下面是对 www.google.com 发出的请求报文。我们可以在 Google Dev Tools 中查看。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http">GET / HTTP/1.2
<span class="token header-name keyword">accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
<span class="token header-name keyword">accept-encoding:</span> gzip, deflate, br
<span class="token header-name keyword">accept-language:</span> zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
<span class="token header-name keyword">cache-control:</span> no-cache
<span class="token header-name keyword">cookie:</span> OTZ=4569705_24_24__24_; _ga=GA1.1.1839148291.1537105919; HSID=AOuQZEx7qIgKNr4Gg; SSID=sdsdfgGFWWA...
<span class="token header-name keyword">dnt:</span> 1
<span class="token header-name keyword">pragma:</span> no-cache
<span class="token header-name keyword">upgrade-insecure-requests:</span> 1
<span class="token header-name keyword">user-agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="http-请求行">HTTP 请求行 </span></h3><p> 请求行标示请求方法、请求资源相对地址和 HTTP 协议版本</p>
<h4><span id="常用的请求方法">常用的请求方法</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>请求方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>GET 方法请求一个指定资源的表示形式. 使用 GET 的请求应该只被用于获取数据.</td>
</tr>
<tr>
<td>POST</td>
<td>POST 方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT 方法用请求有效载荷替换目标资源的所有当前表示。</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE 方法删除指定的资源。</td>
</tr>
<tr>
<td>HEAD</td>
<td>HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体.</td>
</tr>
<tr>
<td>CONNECT</td>
<td>CONNECT 方法建立一个到由目标资源标识的服务器的隧道。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>OPTIONS 方法用于描述目标资源的通信选项。</td>
</tr>
<tr>
<td>TRACE</td>
<td>TRACE 方法沿着到目标资源的路径执行一个消息环回测试。</td>
</tr>
<tr>
<td>PATCH</td>
<td>PATCH 方法用于对资源应用部分修改。</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="http-请求报头">HTTP 请求报头 </span></h3><p> 包含请求的附加信息和客户端的标识信息。</p>
<h4><span id="常用标准请求头字段">常用标准请求头字段：</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Accept</strong></td>
<td>设置接受的内容类型</td>
<td>Accept: text/plain</td>
</tr>
<tr>
<td><strong>Accept-Charset</strong></td>
<td>设置接受的字符编码</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td><strong>Accept-Encoding</strong></td>
<td>设置接受的编码格式</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td><strong>Accept-Datetime</strong></td>
<td>设置接受的版本时间</td>
<td>Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td>
</tr>
<tr>
<td><strong>Accept-Language</strong></td>
<td>设置接受的语言</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td><strong>Authorization</strong></td>
<td>设置 HTTP 身份验证的凭证</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td><strong>Cache-Control</strong></td>
<td>设置请求响应链上所有的缓存机制必须遵守的指令</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td><strong>Connection</strong></td>
<td>设置当前连接和 hop-by-hop 协议请求字段列表的控制选项</td>
<td>Connection: keep-alive<br>Connection: Upgrade</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td>设置请求体的字节长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td><strong>Content-MD5</strong></td>
<td>设置基于 MD5 算法对请求体内容进行 Base64 二进制编码</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>设置请求体的 MIME 类型（适用 POST 和 PUT 请求）</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td><strong>Cookie</strong></td>
<td>设置服务器使用 Set-Cookie 发送的 http cookie</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td><strong>Date</strong></td>
<td>设置消息发送的日期和时间</td>
<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td><strong>Expect</strong></td>
<td>标识客户端需要的特殊浏览器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td><strong>Forwarded</strong></td>
<td>披露客户端通过 http 代理连接 web 服务的源信息</td>
<td>Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43 <br>Forwarded: for=192.0.2.43, for=198.51.100.17</td>
</tr>
<tr>
<td><strong>From</strong></td>
<td>设置发送请求的用户的 email 地址</td>
<td>From: <a href="https://link.jianshu.com/?t=mailto:user@example.com">user@example.com</a></td>
</tr>
<tr>
<td><strong>Host</strong></td>
<td>设置服务器域名和 TCP 端口号，如果使用的是服务请求标准端口号，端口号可以省略</td>
<td>Host: en.wikipedia.org:8080<br>Host: en.wikipedia.org</td>
</tr>
<tr>
<td><strong>If-Match</strong></td>
<td>设置客户端的 ETag, 当时客户端 ETag 和服务器生成的 ETag 一致才执行，适用于更新自从上次更新之后没有改变的资源</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d</td>
</tr>
<tr>
<td><strong>If-Modified-Since</strong></td>
<td>设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回 304 Not Modified</td>
<td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td><strong>If-None-Match</strong></td>
<td>设置客户端 ETag，如果和服务端接受请求生成的 ETage 相同，允许服务端返回 304 Not Modified</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td><strong>If-Range</strong></td>
<td>设置客户端 ETag，如果和服务端接受请求生成的 ETage 相同，返回缺失的实体部分；否则返回整个新的实体</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td><strong>If-Unmodified-Since</strong></td>
<td>设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应</td>
<td>If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td><strong>Max-Forwards</strong></td>
<td>限制代理或网关转发消息的次数</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td><strong>Origin</strong></td>
<td>标识跨域资源请求（请求服务端设置 Access-Control-Allow-Origin 响应字段）</td>
<td>Origin: <code>http://www.example-social-network.com</code></td>
</tr>
<tr>
<td><strong>Pragma</strong></td>
<td>设置特殊实现字段，可能会对请求响应链有多种影响</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td><strong>Proxy-Authorization</strong></td>
<td>为连接代理授权认证信息</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td><strong>Range</strong></td>
<td>请求部分实体，设置请求实体的字节数范围，具体可以参见 HTTP/1.1 中的 Byte serving</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td><strong>Referer</strong></td>
<td>设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在 A 页面中发送的，那么 referer 就是 A 页面的 url 地址</td>
<td>Referer: <code>http://en.wikipedia.org/wiki/Main_Page</code></td>
</tr>
<tr>
<td><strong>TE</strong></td>
<td>设置用户代理期望接受的传输编码格式，和响应头中的 Transfer-Encoding 字段一样</td>
<td>TE: trailers, deflate</td>
</tr>
<tr>
<td><strong>Upgrade</strong></td>
<td>请求服务端升级协议</td>
<td>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</td>
</tr>
<tr>
<td><strong>User-Agent</strong></td>
<td>用户代理的字符串值</td>
<td>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36</td>
</tr>
<tr>
<td><strong>Via</strong></td>
<td>通知服务器代理请求</td>
<td>Via: 1.0 fred, 1.1 example.com (Apache/1.1)</td>
</tr>
<tr>
<td><strong>Warning</strong></td>
<td>实体可能会发生的问题的通用警告</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
</div>
<h4><span id="常用非标准请求头字段">常用非标准请求头字段</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>X-Requested-With</strong></td>
<td>标识 Ajax 请求，大部分 js 框架发送请求时都会设置它为 XMLHttpRequest</td>
<td style="text-align:left">X-Requested-With: XMLHttpRequest</td>
</tr>
<tr>
<td><strong>DNT</strong></td>
<td>请求 web 应用禁用用户追踪</td>
<td style="text-align:left">DNT: 1 (Do Not Track Enabled) <br>DNT: 0 (Do Not Track Disabled)</td>
</tr>
<tr>
<td><strong>X-Forwarded-For</strong></td>
<td>一个事实标准，用来标识客户端通过 HTTP 代理或者负载均衡器连接的 web 服务器的原始 IP 地址</td>
<td style="text-align:left">X-Forwarded-For: client1, proxy1, proxy2<br>X-Forwarded-For: 129.78.138.66, 129.78.64.103</td>
</tr>
<tr>
<td><strong>X-Forwarded-Host</strong></td>
<td>一个事实标准，用来标识客户端在 HTTP 请求头中请求的原始 host, 因为主机名或者反向代理的端口可能与处理请求的原始服务器不同</td>
<td style="text-align:left">X-Forwarded-Host: en.wikipedia.org:8080<br>X-Forwarded-Host: en.wikipedia.org</td>
</tr>
<tr>
<td><strong>X-Forwarded-Proto</strong></td>
<td>一个事实标准，用来标识 HTTP 原始协议，因为反向代理或者负载均衡器和 web 服务器可能使用 http, 但是请求到反向代理使用的是 https</td>
<td style="text-align:left">X-Forwarded-Proto: https</td>
</tr>
<tr>
<td><strong>Front-End-Https</strong></td>
<td>微软应用程序和负载均衡器使用的非标准 header 字段</td>
<td style="text-align:left">Front-End-Https: on</td>
</tr>
<tr>
<td><strong>X-Http-Method-Override</strong></td>
<td>请求 web 应用时，使用 header 字段中给定的方法（通常是 put 或者 delete）覆盖请求中指定的方法（通常是 post）,<br>如果用户代理或者防火墙不支持直接使用 put 或者 delete 方法发送请求时，可以使用这个字段</td>
<td style="text-align:left">X-HTTP-Method-Override: DELETE</td>
</tr>
<tr>
<td><strong>X-ATT-DeviceId</strong></td>
<td>允许更简单的解析用户代理在 AT&amp;T 设备上的 MakeModel/Firmware</td>
<td style="text-align:left">X-Att-Deviceid: GT-P7320/P7320XXLPG</td>
</tr>
<tr>
<td><strong>X-Wap-Profile</strong></td>
<td>设置描述当前连接设备的详细信息的 xml 文件在网络中的位置</td>
<td style="text-align:left">x-wap-profile: <code>http://wap.samsungmobile.com/uaprof/SGH-I777.xml</code></td>
</tr>
<tr>
<td><strong>Proxy-Connection</strong></td>
<td>早起 HTTP 版本中的一个误称，现在使用标准的 connection 字段</td>
<td style="text-align:left">Proxy-Connection: keep-alive</td>
</tr>
<tr>
<td><strong>X-UIDH</strong></td>
<td>服务端深度包检测插入的一个唯一 ID 标识 Verizon Wireless 的客户</td>
<td style="text-align:left">X-UIDH: …</td>
</tr>
<tr>
<td><strong>X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN</strong></td>
<td>防止跨站请求伪造</td>
<td style="text-align:left">X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</td>
</tr>
<tr>
<td><strong>X-Request-ID,X-Correlation-ID</strong></td>
<td>标识客户端和服务端的 HTTP 请求</td>
<td style="text-align:left">X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="http-请求正文">HTTP 请求正文 </span></h3><p> 当使用 POST, PUT 等方法时，需要客户端向服务器传递参数。这些数据就储存在请求正文中。在请求报头中有一些与请求正文相关的信息。</p>
<p>例如: 现在的 Web 应用通常采用 Restful 架构，请求的数据格式一般为 json。这时就需要设置 Content-Type: application/json。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>HTTP/HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>编程模型之事件循环</title>
    <url>/2017/04/19/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>UI 编程中，我们需要对鼠标点击，键盘按键等进行响应。这些用户操作在程序中被称为事件(消息)。我们如何获得事件呢？</p>
<h2><span id="用一个线程轮询检测">用一个线程轮询检测 </span></h2><p> 事件相对于整个运行阶段其实是非常时间稀疏的，但这样一个线程一直轮询相当于在整个运行期间大部分是做无用功，造成大量的 CPU 资源浪费。</p>
<p>理想状况时，每个事件都有一个回调函数，这个函数就是操作的响应。由事件去通知主线程调用回调函数。有点类似于协程的原理。我们通过事件驱动模型来实现。</p>
<a id="more"></a>
<h2><span id="事件驱动模型">事件驱动模型 </span></h2><p> 事件驱动模型有几大要素：</p>
<ul>
<li>一个事件 (消息) 队列</li>
<li>每当有一个事件发生，就往队列中增加一个事件(消息)</li>
<li>一个事件循环，它不断从队列中取出事件，根据事件来调用相应回调函数。例如鼠标点击对应的 <code>onclick()</code>，键盘敲击对应的<code>onKeyDown()</code> 等。</li>
<li>每个事件 (消息) 都保存自己的回调函数指针 ，这样每个消息都有独立的处理函数。</li>
</ul>
<h3><span id="单线程-多线程与事件循环">单线程、多线程与事件循环 </span></h3><p> 我们不难发现，不同于单线程的固定程序执行流和多线程的并行 / 并发执行流，<strong>事件驱动编程范式 </strong> 的程序执行流取决于外部事件。由事件循环来控制程序执行流。<strong>它是典型的异步编程</strong>。</p>
<p>单线程程序编写最简单，任务按照固定的顺序执行，当某个任务发生了阻塞，其他的任务也必须等待。直到它完成之后它们才能依次执行。即使各个任务并没有相互依赖的关系。可以理解为几个人在同一个银行窗口排队取款，每个人都必须等待前面的人取好款才能开始取款。</p>
<p>多线程程序编写比较复杂，任务在独立的线程上运行，这些线程是操作系统管理，如果 CPU 是单核，那么这些线程是并发执行，如果 CPU 是多核，那么这些线程可以并行执行。这种方法由于把各个线程的阻塞时间段重叠了，提升了程序执行效率。但多线程程序必须面临线程安全问题，多个线程需要处理好共享资源的问题。可以理解为几个人在不同的银行窗口取款，他们同步办理取款业务，但银行只有一台验钞机（共享资源），所以各个人的处理进度都与验钞机的分配有关。</p>
<p>事件驱动程序中，多个任务交错在一个线程执行，当等待 I/O 等阻塞操作时，它们注册一个回调到事件队列中，然后阻塞操作完成后，继续执行。回调描述了如何处理某个事件。事件循环轮询事件队列中的事件，并调用回调函数。它比多线程程序更直观，程序员无需关心线程安全问题。可以理解为可以理解为几个人在同一个银行窗口排队取款，前面有一个人需要去洗手间，那么窗口开始处理下一个人的业务，等钱一个人回来，再继续处理他的业务。</p>
<h3><span id="何时使用事件循环">何时使用事件循环</span></h3><ul>
<li>程序中的多个任务高度独立，不互相通信或依赖</li>
<li>等待事件到来之前，任务会阻塞。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>从同步编程到异步编程</title>
    <url>/2016/04/16/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%88%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>虽然我们生活在一个异步的世界里，但对于多数编程初学者来说，异步还是很陌生。学习一门编程语言，通常都是从同步流程开始的，即顺序、分支和循环。而异步流程是什么呢——开始一个异步调用，然后……就没有然后了。异步程序跑哪去了？</p>
<p>异步程序会以某种异步的形式在运行着，比如多线程、异步 IO 等，直到处理完成。那如果需要处理结果怎么办？给一个程序入口，让它处理完当前过程之后，把处理结果送到这个入口，然后执行另一段程序——俗称回调。回调一般使用 <code>callback</code> 这个名称，不过有时候我更喜欢使用 <code>next</code>，因为它代表着下一个处理步骤。</p>
<a id="more"></a>
<h2><span id="同步和异步的概念">同步和异步的概念 </span></h2><p> 现在我们接触到了一些概念，比如同步和异步，它们是什么？</p>
<p>这两个概念并不来源于编程语言，而是来源于低层指令，甚至更低层的——电路。它们是基于时序的两个概念，其中，“步”是指步调，所以同步表示相同的步调，而异步表示不同的步调。当然这两个概念提升到程序这个级别的时候，精确的意思与时钟无关，但所表示的意义仍然未变。</p>
<h3><span id="同步">同步 </span></h3><p> 举个生活中的例子来说明这个问题——排除买票。售票厅开了一个窗口，有一队人在排队依次买票。这个队伍中，前面一个人往前走了一步，后面的人才能往前走一步；前面的人在等待，后面的人就一定在等待。那么在理想的情况下，所有人可以同时向前迈步。OK，大家步伐一致，称为同步。</p>
<p>这里把售票窗口看作是处理器，每个人看作是等待执行的指令，买票这个动作就是在执行指令。它的特点是按步就班，如果一个人买票时间过长（指令执行时间过长），就会造成阻塞。</p>
<h3><span id="异步多线程">异步（多线程）</span></h3><p>现在买票的人渐渐多起来，所以售票厅多开了几个窗口同时售票。每个单独的队伍仍然保持着同步，但不同的队伍之间，步伐不再一致，称为异步。A 队列售票很顺利，队伍在有序快速的前进，但 B 队列的某个顾客似乎在付费时遇到点麻烦，花了很长的时候，造成阻塞，但这对 A 队列并不产生影响。</p>
<p>这时候的售票厅可以看作是在以多线程的方式运行着异步程序。从这个例子可以看到异步的两个特点：其一，两个异步流程之间相互独立，它们相互不会阻塞（有个前提，不需要等待共享资源的情况下）；其二，<strong>异步程序内部仍然是同步的</strong>。</p>
<h3><span id="异步io">异步（IO）</span></h3><p>上面的例子比较符合多线程异步的情况。那 IO 异步又是什么样呢？</p>
<p>年底了，M 在准备年终汇报的资料，这可是个紧张的工作（CPU），要收集不少数据来写好些文案。为了其中一份文案，M 需要车间的生产数据，但跑一趟车间（IO）可需要花不少时间，所以他让 N 去车间收集数据，自己则继续写其它方案，同时等 N 把数据收集回来（启动异步程序）。半天以后，N 带回了数据（插入事件消息），M 继续完成手上的文案（完成当前事件循环），之后使用 N 带回来的数据开始撰写关于车间的报告（新的事件循环）……</p>
<p>IO 的处理速度比 CPU 慢得多，所以 IO 异步让 CPU 不必闲置着等待 IO 操作完成。当 IO 操作完成之后，CPU 会适地使用 IO 操作结果继续工作。</p>
<h2><span id="同步逻辑和异步逻辑">同步逻辑和异步逻辑 </span></h2><p> 回到程序上来，我们以一个函数的处理过程来描述同步和异步的处理方式。</p>
<h3><span id="同步逻辑">同步逻辑 </span></h3><p> 那么，同步处理过程是：</p>
<pre class="line-numbers language-none"><code class="language-none">接受输入 ⇒ 处理 ⇒ 产生输出
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>用一段伪代码来描述就是</p>
<blockquote>
<p>注：本文中的伪代码比较接近 JavaScript 语法，而有时候为了说明类型，采用了 TypeScript 的类型申明语法。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">function func(input) &#123;
    do something with input
    return output
&#125;
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是标准的 IPO(Input-Process-Output) 处理。</p>
<h3><span id="异步逻辑">异步逻辑 </span></h3><p> 而异步呢，是：</p>
<pre class="line-numbers language-none"><code class="language-none">接受输入 ⇒ 处理 ⇒ 启动下一步（如果有）
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>用伪代码来描述就是：</p>
<pre class="line-numbers language-none"><code class="language-none">function asyncFunc(input, next) &#123;
    do something with input
    if (next is a entry) &#123;
        next(output)
    &#125;
&#125;
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个过程称为 IPN(Input-Process-Next)。</p>
<p>注意到这里的 Next，下一步，只有一步。这一步，囊括了后续的若干步骤。所以这一步，只能是后续若干步骤封装出来一个模块入口，或者说函数。</p>
<p>因此，<strong>模块化思想在异步思维中是一个非常关键的思想</strong>。很多初学者写代码喜欢像记流水账一样一句句往下写，动不动就是成百上千行的函数，这就是一种缺乏模块化思想的表现。模块化思想需要训练，分析代码的相关性，提炼函数，提取对象，在具有一定经验之后还需要掌握模块细化的粒度平衡。这不是一朝一夕之功，不过我推荐看看“设计模式”和“重构”相关的书籍。</p>
<h2><span id="异步开发工具sdk-和语法层面的">异步开发工具（SDK 和语法层面的）</span></h2><h3><span id="承诺promise">承诺（Promise）</span></h3><p>再想想上面关于年终汇报的例子，M 请 N 去车间收集数据的时候，N 会说：“好的，我很快就把数据带回来”，这是一种承诺。基于这个承诺，M 才能安排后面撰写关于车间的汇报材料。这个过程用伪代码来描述就是</p>
<pre class="line-numbers language-none"><code class="language-none">function collectData(): Promise &#123;
    &#x2F;&#x2F; N 去收集数据，产生了一个承诺
    return new Promise(resolve &#x3D;&gt; &#123;
        collect data from workshop
        &#x2F;&#x2F; 这个承诺最终会带来数据
        resolve(data)
    &#125;)
&#125;

function writeWorkshopReport(data) &#123;
    write report with data
&#125;

&#x2F;&#x2F; 收集数据的承诺兑现之后，可将这个数据用于写报告
collectData()
    .then(data &#x3D;&gt; writeWorkshopReport(data))
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以 JavaScript 为代表的一些语言 SDK 中使用了 <code>Promise</code>。不过 C# 中是采用的 <code>Task</code> 和 <code>Task&lt;T&gt;</code>，相应的，使用了 <code>Task.ContinueWith</code> 和 <code>Task&lt;T&gt;.ContinueWith</code> 来代替 <code>Promise.then</code>。</p>
<h3><span id="异步逻辑同步化">异步逻辑同步化 </span></h3><p> 上面提到了同步思维和异步思维在一个处理步骤中的区别。如果跳出一个处理步骤，从更大范围的处理流程来看，异步与同步其实也没多大区别，都是 <code>输入 --&gt; 处理 --&gt; 产生输出 --&gt; 将输出用于下一步骤 </code>，唯一要注意的是需要等待异步处理产生的输出，我们可以称之为<strong> 异步等待</strong>。由于我们可以一边进行异步等待（async wait，简写 await），一边做别的事情，所以这个等待并不产生阻塞。但是，由于声明了这个等待，编译器 / 解释器会将后面的代码自动放在等待完成之后调用，这让异步代码写起来就像写同步代码一样。</p>
<p>上面的例子使用异步等待的伪代码会像这样</p>
<pre class="line-numbers language-none"><code class="language-none">async function collectData(): Promise &#123;
    collect data from workshop
    &#x2F;&#x2F; 多数语言会把 async 函数的返回值封装成 Promise
    return data
&#125;

function writeWorkshopReport(data) &#123;
    write report with data
&#125;

&#x2F;&#x2F; await 只能用于声明为 async 的函数中
async function main() &#123;
    data &#x3D; await collectData()
    writeWorkshopReport(data)
&#125;

&#x2F;&#x2F; 定义了异步 main 函数，一定要记得调用，不然它是不会执行的
main()
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像 C# 和 JavaScript 等语言都从语法层面规定了 <code>await</code> 必须用在声明为 <code>async</code> 的函数中，这就从编译 / 解释的层面限定了 <code>await</code> 的用途，只要使用了 <code>await</code>，那它所处的就一定是一个异步上下文。而 <code>async</code> 也要求编译器 / 解释器对其返回值进行一些自动处理，比如在 JavaScript 中，其返回值如果不是 Promise 对象，它会自动封装成一个 Promise 对象；而在 C# 中，它会自动封装成 <code>Task</code> 或 <code>Task&lt;T&gt;</code>（所以 <code>async</code> 方法的类型需要声明为 <code>Task</code> 或 <code>Task&lt;T&gt;</code>）。</p>
<h3><span id="注意注意注意">注意，注意，注意 </span></h3><p> 尽管语言服务在异步程序同步化方面已经做了很多工作，但是仍然避免不了一些人为错误，比如忘记写 <code>await</code> 关键字。在强类型语言中编译器会检查得严格一些，但如果是在 JavaScript 中，忘记写 <code>await</code> 意味着原本应该取得一个值的语句，会取到一个 Promise。解释器不会对此质疑，但程序运行的结果会不正确。</p>
<h2><span id="小结">小结 </span></h2><p> 总的来说，异步编程并不是特别困难的事情。使用 async/await 语言特性甚至可以用类似编写同步代码的方法来编写异步代码。但语法糖终究是糖，要想把异步编程掌握得更好，还是需要去了解和熟悉异步、回调、Promise、模块化、设计模式、重构等概念。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解版本号</title>
    <url>/2016/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2><span id="一句话概括">一句话概括 </span></h2><p> 语义化版本号的格式为主版本号. 次版本号. 修订号(x.y.z)，递增规则如下</p>
<p>x: 主版本号，做了不兼容的 API 修改</p>
<p>y: 次版本号，做了向下兼容的功能性更新</p>
<p>z: 修订号，一般是向下兼容的 bugfix 和优化</p>
<p>（以下，皆以 x 代表主版本号，y 代表次版本号，z 代表修订号）<br><img src="https://raw.githubusercontent.com/maywzh/imagebed/master/img/1_7h56wnp4mqlOqRm4aF9cTQ.png" alt="img"></p>
<a id="more"></a>
<h2><span id="为什么要版本号">为什么要版本号 </span></h2><h3><span id="依赖地狱问题">“依赖地狱”问题</span></h3><p> 大型软件系统往往依赖于众多套件、库，这些依赖关系相当复杂，依赖关系过高会导致版本控制被锁死的问题。想象一下，某一个库依赖于其他库，这些库又依赖于另一些库，那么其中某个库的升级导致的不兼容问题，则会因影响整个系统。依赖关系太松散，则会导致版本的混乱。这就被称之为依赖地狱。</p>
<h3><span id="解决方案">解决方案 </span></h3><p> 一个合理的语义化的版本号约束规则，可以明确版本中的依赖问题。例如 x1.y1.z1 软件依赖于 x11.y11.z11 这个特定版本的库，在库的整个 x11 的主版本，x1 版本的软件可以确保使用正常。这套规则针对于定义的公共 API 而制定：</p>
<ul>
<li>重大版本更新： x 递增，大量新功能的更新，可能不向下兼容</li>
<li>版本功能更新：y 递增，API 保持向下兼容的新增及修改</li>
<li>版本修订，z 递增，修复问题但不影响 API ，向下兼容</li>
</ul>
<p>在这套规则约束下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p>
<h2><span id="规则">规则 </span></h2><h3><span id="重要程度"> 重要程度</span></h3><ul>
<li><strong>必要级: MUST, MUST NOT</strong><ul>
<li>使用语义化版本控制的软件必须定义公共 API</li>
<li>标准版本号必须采用 X.Y.Z 格式，数值递增<ul>
<li>1.8.1 -&gt; 1.9.0 -&gt; 1.10.0</li>
</ul>
</li>
<li>某版本发行后禁止修改，幂等性地，修改后必须按新版本发行</li>
<li>修订号 Z（x.y.Z | x &gt; 0）在 <strong> 只做了向下兼容的修正时 </strong> 才递增。这里的修正指的是针对不正确结果而进行的内部修改</li>
<li>次版本号 Y（x.Y.z | x &gt; 0）在 <strong> 有向下兼容的新功能出现时 </strong> 递增，任何公共 API 的功能被标记为弃用时也必须递增。每当次版本号递增时，修订号必须归零</li>
<li>主版本号 X（X.y.z | X &gt; 0）必须 <strong> 在有任何不兼容的修改被加入公共 API 时 </strong> 递增。每当主版本号递增时，次版本号和修订号必须归零。</li>
<li>判断版本优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级“必须 MUST ”透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。<ul>
<li>范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应该级：REQUIRED, SHALL, SHALL NOT</strong></p>
<ul>
<li>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版</li>
<li>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</li>
<li>当判断版本的优先层级时，版本编译信息应该被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。</li>
</ul>
</li>
<li><p><strong>选项级：MAY、OPTIONAL</strong></p>
<ul>
<li>次版本号 Y（x.Y.z | x &gt; 0）在内部程序有大量新功能或改进被加入时递增，也可以包括修订级别的改变</li>
<li>主版本号可以包括次版本号及修订级别的改变。</li>
<li>先行版本号被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号必须由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且禁止留白。数字型的标识符号禁止在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。<ul>
<li>范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</li>
</ul>
</li>
<li>版本编译信息可以被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号必须由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且禁止留白。<ul>
<li>范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="一些建议">一些建议</span></h2><ul>
<li>0.y.z 初始开发阶段，最好以 0.1.0 作为原始开发版本</li>
<li>快速开发和迭代时期，此时主版本号应该为 0</li>
<li>软件被用于正式环境即是 1.0.0 版本的最佳时机</li>
<li>不要为了语义化版本号而语义化，它是为了开发迭代服务的</li>
<li>谨慎对待不兼容的大版本（即主版本号级别）升级</li>
<li>处理启用的更新之前，保留一个次版本，该版本应具有弃用信息</li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>用 jsDelivr 来改善网站响应速度</title>
    <url>/2016/01/13/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E4%B9%8BjsDelivr%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>今天树莓派上的服务检测脚本忽然告警了，博客出现了大量资源 down 掉的情况，赶紧上线查看，页面都刷不出来，原来是 <code>cdn.bootcss.com</code> 这个 CDN down 掉了，我的 <code>jquery</code>,<code>fontawesome</code> 等 JS 库还有一些 CSS 库都引用这个 CDN 导致页面崩坏。坑爹呢  (；￣Д￣）</p>
<p>我心中顿时出现了一个解决方案，维护一个 CDN 列表，然后服务器上跑一个性能监测脚本，对这些 CDN 进行可达性和性能测试，然后在网站里去根据这个脚本动态修改依赖的 CDN。</p>
<p>等等好像有什么问题，服务器上进行性能监测好像没啥卵用啊，我们要保证客户端可达，这个好像是 CDN 要做的工作啊。</p>
<p>难道要在客户端去跑这个脚本？ =͟͟͞͞(꒪⌓꒪*) 算了算了还是搜一个靠谱的 CDN 吧。</p>
<p>在 StackOverflow 搜索了一下发现有人推荐 <a href="https://www.jsdelivr.com/">jsDelivr</a> 作为 CDN。</p>
<p>试验了一下，发现效果相当给力。推荐一下～</p>
<a id="more"></a>
<h2><span id="what-is-jsdelivr">What is jsDelivr</span></h2><blockquote>
<p>jsDelivr - Open Source CDN free fast and reliable</p>
</blockquote>
<p>它是一个高性能的 CDN，通过</p>
<h2><span id="how-it-work">How it work</span></h2><p>官网上有一张原理的简要介绍</p>
<p><img src="https://www.jsdelivr.com/img/network/infographics.png?v=d4a4024db2475bb20dc7a8166d98130a51606502" alt="img"></p>
<p>jsDelivr 通过多个 CDN 服务商对全球用户提供高性能的内容分发服务，其中对中国线路做了特别优化。整个大陆地区有超过 600 个边缘节点。默认使用 <a href="https://www.cedexis.com/">cedexis</a> 提供的智能负载均衡服务来进行 CDN 选择，如果 cedexis 挂掉，则默认选择 StackPath CDN 或 CloudFlare CDN。如果请求内容未命中 jsDelivr 的缓存，则去上游的 Amazon S3 对象存储服务查找资源，Amazon S3 服务也会同步最终来自于 npm 和 Github 的源文件。如果 Amazon S3 服务 down 掉，jsDelivr 则把请求直接转发给存储源文件的 npm 和 github。</p>
<p>总之，jsDelivr 有众多的边缘服务节点，对中国大陆服务友好，并有宕机备份解决方案，保证了 CDN 的可达性和性能。</p>
<h2><span id="performance-test">Performance test</span></h2><p>我们利用 <a href="http://www.17ce.com/site">17ce</a> 这个测速工具来测量 jsDelivr 的性能。</p>
<p>速度还是相当给力的。</p>
<h2><span id="how-to-use">How to use</span></h2><p>jsDelivr 提供了三种 CDN 服务方式：npm，github 和 wordpress。我们着重讲讲 github 的方式。</p>
<p>github 方式</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">// load any GitHub release or commit
// note: we recommend using npm for projects that support it
https://cdn.jsdelivr.net/gh/user/repo@version/file

// load jQuery v3.2.1
https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js

// use a version range instead of a specific version
https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js
https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js

// omit the version completely to get the latest one
// you should NOT use this in production
https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js

// add ".min" to any JS/CSS file to get a minified version
// if one doesn't exist, we'll generate it for you
https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js

// add / at the end to get a directory listing
https://cdn.jsdelivr.net/gh/jquery/jquery/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如我们想要 <code>pangu</code> 的版本号为 3.3.0 的 <code>pangu.min.js</code> 插件的 CDN 地址，那么我们去<a href="https://github.com/vinta/pangu.js">pangu 的 github 页面</a>，</p>
<p>从 commits 历史或 releases 中查找 3.3.0 版本，查看文件并搜索 <code>pangu.min.js</code> 的相对路径</p>
<p>其路径是<code>dist/browser/pangu.min.js</code>，根据作者名称和 repo 名分别是<code>vinta/pangu.js</code>。所以引用路径是</p>
<p><code>https://cdn.jsdelivr.net/gh/vinta/pangu.js@3.3.0/dist/browser/pangu.min.js</code>，我们也可以对这个地址测速。</p>
<p>awesome！把它放在我们项目的配置文件中即可。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>申请 Let&#39;s Encrypt 证书来实现网站 HTTPS 化</title>
    <url>/2017/11/02/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E4%B9%8B%E7%94%B3%E8%AF%B7Let&#39;s%20Encrypt%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<a id="more"></a>
<h3><span id="什么是-lets-encrypt">什么是 Let’s Encrypt</span></h3><p>Let’s Encrypt 是国外一个公共的免费 SSL 项目，由 Linux 基金会托管。它的来头不小，由 Mozilla、思科、Akamai、IdenTrust 和 EFF 等组织发起，目的就是向网站自动签发和管理免费证书。以便加速互联网由 HTTP 过渡到 HTTPS，目前 Facebook 等大公司开始加入赞助行列。</p>
<p>Let’s Encrypt 已经得了 IdenTrust 的交叉签名，这意味着其证书现在已经可以被 Mozilla、Google、Microsoft 和 Apple 等主流的浏览器所信任。用户只需要在 Web 服务器证书链中配置交叉签名，浏览器客户端会自动处理好其它的一切，Let’s Encrypt 安装简单，使用非常方便。</p>
<p>本文将会详细介绍如何免费申请 Let’s Encrypt 通配符证书。</p>
<h3><span id="什么是通配符证书">什么是通配符证书 </span></h3><p> 域名通配符证书类似 DNS 解析的泛域名概念，通配符证书就是证书中可以包含一个通配符。主域名签发的通配符证书可以在所有子域名中使用，比如 <code>.example.com</code>、<code>bbs.example.com</code>。</p>
<h3><span id="申请通配符证书">申请通配符证书</span></h3><p>Let’s Encrypt 上的证书申请是通过 ACME 协议来完成的。ACME 协议规范化了证书申请、更新、撤销等流程，实现了 Let’s Encrypt CA 自动化操作。解决了传统的 CA 机构是人工手动处理证书申请、证书更新、证书撤销的效率和成本问题。</p>
<p>ACME v2 是 ACME 协议的更新版本，通配符证书只能通过 ACME v2 获得。要使用 ACME v2 协议申请通配符证书，只需一个支持该协议的客户端就可以了，官方推荐的客户端是 Certbot。</p>
<h4><span id="获取-certbot-客户端">获取 Certbot 客户端</span></h4><pre class="line-numbers language-none"><code class="language-none"># 下载 Certbot 客户端
$ wget https:&#x2F;&#x2F;dl.eff.org&#x2F;certbot-auto

# 设为可执行权限
$ chmod a+x certbot-auto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：Certbot 从 0.22.0 版本开始支持 ACME v2，如果你之前已安装旧版本客户端程序需更新到新版本。</p>
</blockquote>
<p>更详细的安装可参考官方文档：<a href="https://certbot.eff.org/">https://certbot.eff.org/</a></p>
<h4><span id="申请通配符证书">申请通配符证书 </span></h4><p> 客户在申请 Let’s Encrypt 证书的时候，需要校验域名的所有权，证明操作者有权利为该域名申请证书，目前支持三种验证方式：</p>
<ul>
<li>dns-01：给域名添加一个 DNS TXT 记录。</li>
<li>http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。</li>
<li>tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件。</li>
</ul>
<p>使用 Certbot 客户端申请证书方法非常的简单，只需如下一行命令就搞定了。</p>
<pre class="line-numbers language-none"><code class="language-none">$ .&#x2F;certbot-auto certonly  -d &quot;*.xxx.com&quot; --manual --preferred-challenges dns-01  --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>1. 申请通配符证书，只能使用 dns-01 的方式。<br>2.<code>xxx.com</code> 请根据自己的域名自行更改。</p>
</blockquote>
<p>相关参数说明：</p>
<pre class="line-numbers language-none"><code class="language-none">certonly 表示插件，Certbot 有很多插件。不同的插件都可以申请证书，用户可以根据需要自行选择。
-d 为哪些主机申请证书。如果是通配符，输入 *.xxx.com (根据实际情况替换为你自己的域名)。
--preferred-challenges dns-01，使用 DNS 方式校验域名所有权。
--server，Let&#39;s Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行完这一步之后，就是命令行的输出，请根据提示输入相应内容：</p>
<p><img src="https://www.hi-linux.com/img/linux/le_ssl_01.png" alt="img"></p>
<p>执行到上图最后一步时，先暂时不要回车。申请通配符证书是要经过 DNS 认证的，接下来需要按照提示在域名后台添加对应的 DNS TXT 记录。添加完成后，先输入以下命令确认 TXT 记录是否生效：</p>
<pre class="line-numbers language-none"><code class="language-none">$ dig  -t txt _acme-challenge.xxx.com @8.8.8.8    
...
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;_acme-challenge.xxx.com.        IN      TXT

;; ANSWER SECTION:
_acme-challenge.xxx.com. 599 IN  TXT     &quot;xxUHdwoZ6IaU_ab87h67rvbU2yJgdRyRe9zEA3jw&quot;
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>确认生效后，回车继续执行，最后会输出如下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xxx.com&#x2F;fullchain.pem
   Your key file has been saved at:
   &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xxx.com&#x2F;privkey.pem
   Your cert will expire on 2018-06-12. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot-auto
   again. To non-interactively renew *all* of your certificates, run
   &quot;certbot-auto renew&quot;
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG &#x2F; Let&#39;s Encrypt:   https:&#x2F;&#x2F;letsencrypt.org&#x2F;donate
   Donating to EFF:                    https:&#x2F;&#x2F;eff.org&#x2F;donate-le<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到了这一步后，恭喜您，证书申请成功。 证书和密钥保存在下列目录：</p>
<pre class="line-numbers language-none"><code class="language-none">$ tree &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xxx.com&#x2F;
.
├── cert.pem
├── chain.pem
├── fullchain.pem
└── privkey.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>校验证书信息，输入如下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">$ openssl x509 -in  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xxx.com&#x2F;cert.pem -noout -text 

# 可以看到证书包含了 SAN 扩展，该扩展的值就是 *.xxx.com
...
Authority Information Access: 
        OCSP - URI:http:&#x2F;&#x2F;ocsp.int-x3.letsencrypt.org
        CA Issuers - URI:http:&#x2F;&#x2F;cert.int-x3.letsencrypt.org&#x2F;

X509v3 Subject Alternative Name: 
    DNS:*.xxx.com
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，我们就演示了如何在 Let’s Encrypt 申请免费的通配符证书。</p>
<h3><span id="其它相关">其它相关</span></h3><ul>
<li>证书续期</li>
</ul>
<p>Let’s encrypt 的免费证书默认有效期为 90 天，到期后如果要续期可以执行：</p>
<pre class="line-numbers language-none"><code class="language-none">$ certbot-auto renew<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>在 Nginx 中 配置 Let’s Encrypt 证书</li>
</ul>
<p>Nginx 配置文件片断：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    server_name xxx.com;
    listen 443 http2 ssl;
    ssl on;
    ssl_certificate &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;fullchain.pem;
    ssl_certificate_key &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;privkey.pem;
    ssl_trusted_certificate  &#x2F;etc&#x2F;cert&#x2F;xxx.com&#x2F;chain.pem;

    location &#x2F; &#123;
      proxy_pass http:&#x2F;&#x2F;127.0.0.1:6666;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="参考文档">参考文档</span></h3><p><a href="https://www.google.com/">https://www.google.com</a><br><a href="https://www.jianshu.com/p/c5c9d071e395">https://www.jianshu.com/p/c5c9d071e395</a><br><a href="https://my.oschina.net/kimver/blog/1634575">https://my.oschina.net/kimver/blog/1634575</a></p>
<h1><span id="免费-https-证书lets-encrypt申请与配置">免费 https 证书（Let’s Encrypt）申请与配置</span></h1><p>2016-6-12 18:04 PM</p>
<p>之前要申请免费的 https 证书操作步骤相当麻烦，今天看到有人在讨论，就搜索了一下。发现现在申请步骤简单多了。</p>
<h2><span id="1-下载-certbot">1. 下载 certbot</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/certbot/certbot
<span class="token builtin class-name">cd</span> certbot
./certbot-auto --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>解压打开执行就会有相关提示</p>
<h2><span id="2-生成免费证书">2. 生成免费证书</span></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./certbot-auto certonly --webroot --agree-tos -v -t --email 邮箱地址 -w 网站根目录 -d 网站域名
./certbot-auto certonly --webroot --agree-tos -v -t --email keeliizhou@gmail.com -w /path/to/your/web/root -d note.crazy4code.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>注意 </strong> 这里 默认会自动生成到 /<strong> 网站根目录 </strong>/.well-known/acme-challenge 文件夹，然后 shell 脚本会对应的访问 <strong> 网站域名</strong>/.well-known/acme-challenge 是否存在来确定你对网站的所属权</p>
<p>比如：我的域名是 <strong>note.crazy4code.com</strong> 那我就得保证域名下面的 <strong>.well-known/acme-challenge/</strong> 目录是可访问的</p>
<p>如果返回正常就确认了你对这个网站的所有权，就能顺利生成，完成后这个目录会被清空</p>
<h2><span id="3-获取证书">3. 获取证书 </span></h2><p> 如果上面的步骤正常 shell 脚本会展示如下信息：</p>
<pre class="line-numbers language-none"><code class="language-none">- Congratulations! Your certificate and chain have been saved at
&#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F; 网站域名 &#x2F;fullchain.pem
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="4-生成-dhparams">4. 生成 dhparams</span></h2><p>使用 openssl 工具生成 dhparams</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl dhparam -out /etc/ssl/certs/dhparams.pem <span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="5-配置-nginx">5. 配置 Nginx</span></h2><p>打开 nginx server 配置文件加入如下设置：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">listen</span> <span class="token number">443</span>

<span class="token keyword">ssl</span> on<span class="token punctuation">;</span>
<span class="token keyword">ssl_certificate</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>网站域名<span class="token operator">/</span>fullchain<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
<span class="token keyword">ssl_certificate_key</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>网站域名<span class="token operator">/</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
<span class="token keyword">ssl_dhparam</span> <span class="token operator">/</span>etc<span class="token operator">/</span><span class="token keyword">ssl</span><span class="token operator">/</span>certs<span class="token operator">/</span>dhparams<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
<span class="token keyword">ssl_protocols</span> SSLv3 TLSv1 TLSv1<span class="token punctuation">.</span><span class="token number">1</span> TLSv1<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">ssl_ciphers</span> HIGH<span class="token punctuation">:</span><span class="token operator">!</span>aNULL<span class="token punctuation">:</span><span class="token operator">!</span>MD5<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后重启 nginx 服务就可以了</p>
<h2><span id="6-强制跳转-https">6. 强制跳转 https</span></h2><p>https 默认是监听 443 端口的，没开启 https 访问的话一般默认是 80 端口。如果你确定网站 80 端口上的站点都支持 https 的话加入下面的配件可以自动重定向到 https</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">server_name</span> your<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">301</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$server_name</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="7-证书更新">7. 证书更新 </span></h2><p> 免费证书只有 90 天的有效期，到时需要手动更新 renew。刚好 Let’s encrypt 旗下还有一个 <a href="https://letsmonitor.org/">Let’s monitor</a> 免费服务，注册账号添加需要监控的域名，系统会在证书马上到期时发出提醒邮件，非常方便。收到邮件后去后台执行 renew 即可，如果提示成功就表示 renew 成功</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./certbot-auto renew<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>HTTP/HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 五种 IO 模型详解</title>
    <url>/2018/02/28/Linux/Linux%E4%B9%8B%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>I/O 与计算是计算机系统的最核心的两个功能，而 I/O 往往占据了相当多的资源和时间，所以如何提高 I/O 性能，成为了性能优化的极其重要的点。这里我们结合一些其他的 Linux 系统核心概念来比较基本的五种 I/O 模型。</p>
<a id="more"></a>
<h2><span id="概念引入">概念引入 </span></h2><h3><span id="用户空间和内核空间"> 用户空间和内核空间 </span></h3><p> 现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h3><span id="进程切换">进程切换 </span></h3><p> 为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<p>详见 <a href="https://link.jianshu.com/?t=http://guojing.me/linux-kernel-architecture/posts/process-switch/"> 进程切换</a>。</p>
<h3><span id="进程阻塞">进程阻塞 </span></h3><p> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用 CPU 资源的。</p>
<h3><span id="文件描述符-fd">文件描述符 FD</span></h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<h3><span id="缓存-io">缓存 IO</span></h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p><strong>缓存 IO 的缺点：</strong></p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h2><span id="五种-io-模型">五种 I/O 模型 </span></h2><h3><span id="同步阻塞-blocking-io"> 同步阻塞 Blocking I/O</span></h3><blockquote>
<p>我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。<code>这就是典型的阻塞</code>。</p>
</blockquote>
<p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在 linux 中，默认情况下所有的 socket 都是 blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息, CPU 处理其它进程去了。</p>
<p>在这个 IO 模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。<strong>不能处理别的网络 IO</strong>。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。在调用 recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：</p>
<p><img src="https://i.loli.net/2020/08/28/V7co6PrnFAxOWei.png" alt="java10-1557020023"></p>
<p>当用户进程调用了 <code>recv()/recvfrom()</code> 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据（对于网络 IO 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 UDP 包。这个时候 kernel 就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。</p>
<p>所以，blocking IO 的特点就是在 IO 执行的两个阶段都被 block 了。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>能够及时返回数据，无延迟；</p>
</li>
<li><p>模型简单易于开发；</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>等待时间长，性能较差；</li>
</ul>
<h3><span id="同步非阻塞-nonblocking-io">同步非阻塞 Nonblocking I/O</span></h3><blockquote>
<p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。<code>这就是非阻塞</code>。需要不断的询问，是否准备好了。</p>
</blockquote>
<p>同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，<code>read</code> 操作可能会返回一个错误代码，说明这个命令不能立即满足（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>）。</p>
<p>在网络 IO 时候，非阻塞 IO 也会进行 recvform 系统调用，检查数据是否准备好，与阻塞 IO 不一样，”非阻塞将大的整片时间的阻塞分成 N 多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU 光顾”。</p>
<p>也就是说非阻塞的 <code>recvform</code> 系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个 <code>error</code>。进程在返回之后，可以干点别的事情，然后再发起 recvform 系统调用。重复上面的过程，循环往复的进行<code>recvform</code> 系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p>
<p>在 linux 下，可以通过设置 socket 使其变为 non-blocking。当对一个 non-blocking socket 执行读操作时，流程如图所示：</p>
<p><img src="https://i.loli.net/2020/08/28/RbsD6CcZVMBvFaq.png" alt="20152818_DXcj"></p>
<p>当用户进程发出 <code>read</code> 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking IO 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p>
<p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p>
<p><strong>优点</strong>：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>
<p><strong>缺点</strong>：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次 read 操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
<h3><span id="多路复用-multiplexing-io">多路复用 Multiplexing I/O</span></h3><blockquote>
<p>餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的 IO 多路复用。</p>
</blockquote>
<p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的 CPU 时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。<strong>如果轮询不是进程的用户态，而是有人帮忙就好了。</strong>那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 <code>select</code>、<code>poll</code>、<code>epoll</code> 就是干这个的（<code>epoll</code> 比 <code>poll</code>、<code>select</code> 效率高，做的事情是一样的）。</p>
<p>I/O 多路复用有两个特别的系统调用 <code>select</code>、<code>poll</code>、<code>epoll</code> 函数。<code>select</code>调用是内核级别的，<code>select</code>轮询相对非阻塞的轮询的区别在于——前者可以等待多个 socket，能实现同时对多个 IO 端口进行监听，当其中任何一个 socket 的数据准好了，就能返回进行可读，然后进程再进行 <code>recvform</code> 系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。<code>select</code>或 <code>poll</code> 调用之后，会阻塞进程，与 blocking IO 阻塞不同在于，此时的 <code>select</code> 不是等到 socket 数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧。</p>
<p>I/O 复用模型会用到 <code>select</code>、<code>poll</code>、<code>epoll</code> 函数，这几个函数也会使进程阻塞，但是和阻塞 I/O 所不同的的，这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作、多个写操作的 I/O 函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用 I/O 操作函数。</p>
<p>对于多路复用，也就是轮询多个 socket。多路复用既然可以处理多个 IO，也就带来了新的问题，多个 IO 之间的顺序变得不确定了，当然也可以针对不同的编号。具体流程，如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/28/T1hwz5douryFOXb.png" alt="20164149_LD8E"></p>
<p>IO multiplexing 就是我们说的 <code>select</code>，<code>poll</code>，<code>epoll</code>，有些地方也称这种 IO 方式为 event driven IO。<code>select/epoll</code> 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。它的基本原理就是 <code>select</code>，<code>poll</code>，<code>epoll</code> 这个 function 会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。</p>
<blockquote>
<p>多路复用的特点是通过一种机制一个进程能同时等待 IO 文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll 函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll 三种方式。</p>
</blockquote>
<p>上面的图和 blocking IO 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 system call (<code>select</code> 和 <code>recvfrom</code>)，而 blocking IO 只调用了一个 system call (<code>recvfrom</code>)。但是，用 <code>select</code> 的优势在于它可以同时处理多个 connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用 <code>select/epoll</code> 的 web server 不一定比使用 multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。（<code>select/epoll</code>的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在 IO multiplexing Model 中，实际中，对于每一个 socket，一般都设置成为 non-blocking，但是，如上图所示，整个用户的 process 其实是一直被 block 的。只不过 process 是被 <code>select</code> 这个函数 block，而不是被 socket IO 给 block。所以 <strong>IO 多路复用是阻塞在<code>select，epoll</code> 这样的系统调用之上，而没有阻塞在真正的 I/O 系统调用如 recvfrom 之上。</strong></p>
<p>在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 I/O 多路复用技术进行处理。I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程 / 多进程模型比<strong>，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程</strong>，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O 多路复用的主要应用场景如下：</p>
<ul>
<li><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>
</li>
<li><p>服务器需要同时处理多种网络协议的套接字。</p>
</li>
</ul>
<p>了解了前面三种 IO 模式，在用户进程进行系统调用的时候，<strong>他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，<code>select</code>或 <code>poll</code> 轮询</strong>，两个阶段过程：</p>
<ol>
<li><p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p>
</li>
<li><p>第二个阶段都是阻塞的。</p>
</li>
</ol>
<p><strong><u>从整个 IO 过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。</u></strong></p>
<p>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求，而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</p>
<h4><span id="到底是同步阻塞还是异步阻塞">到底是同步阻塞还是异步阻塞 </span></h4><p> 同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO 多路复用在阻塞到 select 阶段时，用户进程是主动等待并调用 select 函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把 IO 多路复用归为同步阻塞模式。</p>
<h3><span id="信号驱动-io-signal-driven-io">信号驱动 IO Signal-driven I/O</span></h3><p>允许 Socket 进行信号驱动 IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/28/tI3sfV4oyaSiNwE.png" alt="21091434_DsZb"></p>
<h3><span id="异步非阻塞-asynchronous-io">异步非阻塞 asynchronous I/O</span></h3><blockquote>
<p>女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。</p>
</blockquote>
<p>相对于同步 IO，异步 IO 不是顺序执行。用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到 socket 数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO 两个阶段，进程都是非阻塞的。</p>
<p>Linux 提供了 AIO 库函数实现异步，但是用的很少。目前有很多开源的异步 IO 库，例如 libevent、libev、libuv。异步过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/28/rsQRKLS6MxgYA2q.png" alt="20175459_gtgw"></p>
<p>用户进程发起 aio_read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存。当这一切都完成之后，kernel 会给用户进程发送一个 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它 read 操作完成了。</p>
<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<blockquote>
<p>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。</p>
<p>如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。</p>
<p>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
</blockquote>
<p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p>
<p><strong>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p>
<p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机：</p>
<blockquote>
<p>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</p>
<p>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</p>
<p>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。</p>
</blockquote>
<p>IO 多路复用除了需要阻塞之外，<code>select</code>函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。</p>
<h3><span id="关于异步阻塞">关于异步阻塞 </span></h3><p> 有时我们的 API 只提供异步通知方式，例如在 node.js 里，但业务逻辑需要的是做完一件事后做另一件事，例如数据库连接初始化后才能开始接受用户的 HTTP 请求，这样的业务逻辑就需要调用者是以阻塞方式来工作。</p>
<p>为了在异步环境里模拟 “顺序执行” 的效果，就需要把同步代码转换成异步形式，这称为 CPS（Continuation Passing Style）变换。BYVoid 大神的 <a href="https://link.jianshu.com?t=https://github.com/BYVoid/continuation">continuation.js</a> 库就是一个 CPS 变换的工具。用户只需用比较符合人类常理的同步方式书写代码，CPS 变换器会把它转换成层层嵌套的异步回调形式。</p>
<p><img src="https://i.loli.net/2020/08/28/Dxzcvh826j9Osfe.png" alt="20183314_5rY1"></p>
<p><img src="https://i.loli.net/2020/08/28/sGLikDutaBUR4TQ.png" alt="20183327_wIGf"></p>
<p>另外一种使用阻塞方式的理由是降低响应延迟。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好。</p>
<h2><span id="总结">总结 </span></h2><h3><span id="阻塞-vs-非阻塞"> 阻塞 vs 非阻塞 </span></h3><p> 调用 blocking IO 会一直 block 住对应的进程直到操作完成，而 non-blocking IO 在 kernel 还准备数据的情况下会立刻返回。</p>
<h3><span id="同步-vs-异步">同步 vs 异步 </span></h3><p> 关于 synchronous 和 asynchronous，POSIX 给出了如下的定义：</p>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p>两者的区别就在于 synchronous IO 做”IO operation”的时候会将 process 阻塞。按照这个定义，之前所述的 blocking IO，non-blocking IO，IO multiplexing 都属于 synchronous IO。</p>
<p>有人会说，non-blocking IO 并没有被 block 啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的 IO 操作，就是例子中的 <code>recvfrom</code> 这个 system call。non-blocking IO 在执行 <code>recvfrom</code> 这个 system call 的时候，如果 kernel 的数据没有准备好，这时候不会 block 进程。但是，当 kernel 中数据准备好的时候，recvfrom 会将数据从 kernel 拷贝到用户内存中，这个时候进程是被 block 了，在这段时间内，进程是被 block 的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I/O</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>实践 Linux 编程之贰 - 调试</title>
    <url>/2015/07/20/Linux/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B4%B0%20-%20%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>现代的 IDE 已经提供了相当丰富的调试功能，但有的时候在服务器环境中，我们还是要利用 Linux 的工具来对运行的进程来进行调试和分析。</p>
<a id="more"></a>
<h3><span id="进程调试">进程调试</span></h3><h4><span id="gdb-程序交互调试">gdb 程序交互调试</span></h4><p>GDB 是一个由 GNU 开源组织发布的、UNIX/LINUX 操作系统下的、基于命令行的、功能强大的程序调试工具。</p>
<p>对于一名 Linux 下工作的 c++ 程序员，gdb 是必不可少的工具；</p>
<p>GDB 中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。</p>
<p>以下从一个完整的调试过程简单说明最基本的几个命令;</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gdb programmer     <span class="token comment"># 启动 gdb</span>
<span class="token operator">></span>break main         <span class="token comment"># 设置断点</span>
<span class="token operator">></span>run                <span class="token comment"># 运行调试程序</span>
<span class="token operator">></span>next               <span class="token comment"># 单步调试</span>
<span class="token operator">></span>print var1         <span class="token comment"># 在调试过程中，我们需要查看当前某个变量值的时候，使用 print 命令打印该值</span>
<span class="token operator">></span>list               <span class="token comment"># 显示当前调试处的源代码</span>
<span class="token operator">></span>info b             <span class="token comment"># 显示当前断点设置情况</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当你完成了第一个程序调试之后，你当然会需要更多的命令：关于 gdb 常用命令及各种调试方法详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html#gdb">gdb 调试利器</a> ;</p>
<p>同时，你需要更高效的调试：常用的调试命令都会有单字符的缩写，使用缩写更方便；同时，直接敲回车表示重复执行上一步命令；这在单步调试时非常有用；</p>
<h4><span id="pstack-跟踪栈空间">pstack 跟踪栈空间</span></h4><p>pstack 是一个脚本工具，可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。其核心实现就是使用了 gdb 以及 thread apply all bt 命令;</p>
<p>语法:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pstrack <span class="token operator">&lt;</span>program-pid<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pstack <span class="token number">4551</span>
Thread <span class="token number">7</span> <span class="token punctuation">(</span>Thread <span class="token number">1084229984</span> <span class="token punctuation">(</span>LWP <span class="token number">4552</span><span class="token punctuation">))</span>:
<span class="token comment">#0  0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6</span>
<span class="token comment">#1  0x00000000006f0730 in ub::EPollEx::poll ()</span>
<span class="token comment">#2  0x00000000006f172a in ub::NetReactor::callback ()</span>
<span class="token comment">#3  0x00000000006fbbbb in ub::UBTask::CALLBACK ()</span>
<span class="token comment">#4  0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0</span>
<span class="token comment">#5  0x000000302afc6003 in clone () from /lib64/tls/libc.so.6</span>
<span class="token comment">#6  0x0000000000000000 in ?? ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="strace-分析系统调用">strace 分析系统调用 </span></h4><p>strace 常用来跟踪进程执行时的系统调用和所接收的信号。在 Linux 世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等) 时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace 可以跟踪到一个进程产生的系统调用, 包括参数，返回值，执行消耗的时间。</p>
<p>完整程序:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -o output.txt -T -tt -e <span class="token assign-left variable">trace</span><span class="token operator">=</span>all -p <span class="token number">28979</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>跟踪 28979 进程的所有系统调用（<code>-e trace=all</code>），并统计系统调用的花费时间，以及开始时间（以可视化的时分秒格式显示），最后将记录结果存在 <code>output.txt</code> 文件里面。</p>
<p>查看进程正在做什么(实时输出进程执行系统调用的情况):</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token operator">&lt;</span>process-pid<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>关于 strace 的详细介绍，详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html#strace">strace 跟踪进程中的系统调用</a> ;</p>
<h3><span id="目标文件分析">目标文件分析</span></h3><h4><span id="nm-符号清单">nm 符号清单</span></h4><p>nm 用来列出目标文件的符号清单。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ nm myProgrammer
08049f28 d _DYNAMIC
08049ff4 d _GLOBAL_OFFSET_TABLE_
080484dc R _IO_stdin_used
         w _Jv_RegisterClasses
08049f18 d __CTOR_END__
08049f14 d __CTOR_LIST__
08049f20 D __DTOR_END__
08049f1c d __DTOR_LIST__
080485e0 r __FRAME_END__
08049f24 d __JCR_END__
08049f24 d __JCR_LIST__
0804a014 A __bss_start
0804a00c D __data_start
08048490 t __do_global_ctors_aux
08048360 t __do_global_dtors_aux
0804a010 D __dso_handle
         w __gmon_start__
08048482 T __i686.get_pc_thunk.bx
08049f14 d __init_array_end
08049f14 d __init_array_start
08048480 T __libc_csu_fini
08048410 T __libc_csu_init
         U __libc_start_main@@GLIBC_2.0
0804a014 A _edata
0804a01c A _end
080484bc T _fini
080484d8 R _fp_hw
080482b4 T _init
08048330 T _start
0804a014 b completed.6086
0804a00c W data_start
0804a018 b dtor_idx.6088
080483c0 t frame_dummy
080483e4 T main
         U printf@@GLIBC_2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些包含可执行代码的段称为正文段。同样地，数据段包含了不可执行的信息或数据。另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p>
<p>常见的各种编码包括：</p>
<ul>
<li>A 表示绝对 (absolute)，这意味着不能将该值更改为其他的连接；</li>
<li>B 表示 BSS 段中的符号；</li>
<li>C 表示引用未初始化的数据的一般符号。</li>
</ul>
<p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p>
<p>在目标文件阶段，即使是一个简单的 Hello World 程序，其中也包含了大量的细节信息。nm 程序可用于列举符号及其类型和值，但是，要更仔细地研究目标文件中这些命名段的内容，需要使用功能更强大的工具。</p>
<p>其中两种功能强大的工具是 objdump 和 readelf 程序。</p>
<p>注解</p>
<p>关于 nm 工具的参数说明及更多示例详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html#nm">nm 目标文件格式分析</a> ;</p>
<h4><span id="objdump-分析二进制文件">objdump 分析二进制文件</span></h4><p>ogjdump 工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ objdump -d myprogrammer
a.out:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386


Disassembly of section .init:

080482b4 <span class="token operator">&lt;</span>_init<span class="token operator">></span>:
 80482b4:   <span class="token number">53</span>                      push   %ebx
 80482b5:   <span class="token number">83</span> ec 08                sub    <span class="token variable">$0x8</span>,%esp
 80482b8:   e8 00 00 00 00          call   80482bd <span class="token operator">&lt;</span>_init+0x<span class="token operator"><span class="token file-descriptor important">9</span>></span>
 80482bd:   5b                      pop    %ebx
 80482be:   <span class="token number">81</span> c3 <span class="token number">37</span> 1d 00 00       <span class="token function">add</span>    <span class="token variable">$0x1d37</span>,%ebx
 80482c4:   8b <span class="token number">83</span> fc ff ff ff       mov    -0x4<span class="token punctuation">(</span>%ebx<span class="token punctuation">)</span>,%eax
 80482ca:   <span class="token number">85</span> c0                   <span class="token builtin class-name">test</span>   %eax,%eax
 80482cc:   <span class="token number">74</span> 05                   je     80482d3 <span class="token operator">&lt;</span>_init+0x1f<span class="token operator">></span>
 80482ce:   e8 3d 00 00 00          call   <span class="token number">8048310</span> <span class="token operator">&lt;</span>__gmon_start__@plt<span class="token operator">></span>
 80482d3:   e8 e8 00 00 00          call   80483c0 <span class="token operator">&lt;</span>frame_dummy<span class="token operator">></span>
 80482d8:   e8 b3 01 00 00          call   <span class="token number">8048490</span> <span class="token operator">&lt;</span>__do_global_ctors_aux<span class="token operator">></span>
 80482dd:   <span class="token number">83</span> c4 08                <span class="token function">add</span>    <span class="token variable">$0x8</span>,%esp
 80482e0:   5b                      pop    %ebx
 80482e1:   c3                      ret

Disassembly of section .plt:
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个可执行代码段将在需要特定的事件时执行，这些事件包括库的初始化和该程序本身主入口点。</p>
<p>对于那些着迷于底层编程细节的程序员来说，这是一个功能非常强大的工具，可用于研究编译器和汇编器的输出。细节信息，比如这段代码中所显示的这些信息，可以揭示有关本地处理器本身运行方式的很多内容。对该处理器制造商提供的技术文档进行深入的研究，您可以收集关于一些有价值的信息，通过这些信息可以深入地了解内部的运行机制，因为功能程序提供了清晰的输出。</p>
<p>注解</p>
<p>关于 objdump 工具的参数说明及更多示例详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/objdump.html#objdump">objdump 二进制文件分析</a> ;</p>
<h4><span id="readelf-二进制文件分析">readelf 二进制文件分析 </span></h4><p> 这个工具和 objdump 命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖 BFD 库(BFD 库是一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）；</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ readelf -all a.out
ELF Header:
  Magic:   7f <span class="token number">45</span> 4c <span class="token number">46</span> 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              <span class="token number">2</span>'s complement, little endian
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - System V
  ABI Version:                       <span class="token number">0</span>
  Type:                              EXEC <span class="token punctuation">(</span>Executable <span class="token function">file</span><span class="token punctuation">)</span>
  Machine:                           Intel <span class="token number">80386</span>
  Version:                           0x1
  Entry point address:               0x8048330
  Start of program headers:          <span class="token number">52</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">4412</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Flags:                             0x0
  Size of this header:               <span class="token number">52</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">32</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">9</span>
  Size of section headers:           <span class="token number">40</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">30</span>
  Section header string table index: <span class="token number">27</span>

Section Headers:
  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">0</span>
  <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span> .interp           PROGBITS        08048154 000154 000013 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">1</span>
  <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">]</span> .note.ABI-tag     NOTE            08048168 000168 000020 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">]</span> .note.gnu.build-i NOTE            08048188 000188 000024 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">]</span> .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  <span class="token number">5</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">]</span> .dynsym           DYNSYM          080481cc 0001cc 000050 <span class="token number">10</span>   A  <span class="token number">6</span>   <span class="token number">1</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">6</span><span class="token punctuation">]</span> .dynstr           STRTAB          0804821c 00021c 00004c 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">1</span>
  <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">]</span> .gnu.version      VERSYM          08048268 000268 00000a 02   A  <span class="token number">5</span>   <span class="token number">0</span>  <span class="token number">2</span>
  <span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">]</span> .gnu.version_r    VERNEED         08048274 000274 000020 00   A  <span class="token number">6</span>   <span class="token number">1</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span> <span class="token number">9</span><span class="token punctuation">]</span> .rel.dyn          REL             08048294 000294 000008 08   A  <span class="token number">5</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> .rel.plt          REL             0804829c 00029c 000018 08   A  <span class="token number">5</span>  <span class="token number">12</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> .init             PROGBITS        080482b4 0002b4 00002e 00  AX  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> .plt              PROGBITS        080482f0 0002f0 000040 04  AX  <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">16</span>
  <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> .text             PROGBITS        08048330 000330 00018c 00  AX  <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">16</span>
  <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> .rodata           PROGBITS        080484d8 0004d8 000011 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> .ctors            PROGBITS        08049f14 000f14 000008 00  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> .jcr              PROGBITS        08049f24 000f24 000004 00  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  <span class="token number">6</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> .got              PROGBITS        08049ff0 000ff0 000004 04  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span> .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> .data             PROGBITS        0804a00c 00100c 000008 00  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> .bss              NOBITS          0804a014 001014 000008 00  WA  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> .comment          PROGBITS        00000000 001014 00002a 01  MS  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">1</span>
  <span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span> .shstrtab         STRTAB          00000000 00103e 0000fc 00      <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">1</span>
  <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span> .symtab           SYMTAB          00000000 0015ec 000410 <span class="token number">10</span>     <span class="token number">29</span>  <span class="token number">45</span>  <span class="token number">4</span>
  <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> .strtab           STRTAB          00000000 0019fc 0001f9 00      <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">1</span>
  <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ELF Header 为该文件中所有段入口显示了详细的摘要。在列举出这些 Header 中的内容之前，您可以看到 Header 的具体数目。在研究一个较大的目标文件时，该信息可能非常有用。</p>
<p>除了所有这些段之外，编译器可以将调试信息放入到目标文件中，并且还可以显示这些信息。输入下面的命令，仔细分析编译器的输出（假设您扮演了调试程序的角色）:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ readelf --debug-dump a.out <span class="token operator">|</span> <span class="token function">more</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调试工具，如 GDB，可以读取这些调试信息，并且当程序在调试器中运行的同时，您可以使用该工具显示更具描述性的标记，而不是对代码进行反汇编时的原始地址值。</p>
<p>注解</p>
<p>关于 readelf 工具的参数说明及更多示例详见 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html#readelf">readelf elf 文件格式分析</a> ;</p>
<h4><span id="size-查看程序内存占用">size 查看程序内存占用</span></h4><p>size 这个工具用来查看程序运行时各个段的实际内存占用:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ size a.out
text           data     bss     dec     hex filename
<span class="token number">1146</span>            <span class="token number">256</span>       <span class="token number">8</span>    <span class="token number">1410</span>     <span class="token number">582</span> a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4><span id="file-文件类型查询">file 文件类型查询 </span></h4><p> 这个工具用于查看文件的类型；</p>
<p>比如我们在 64 位机器上发现了一个 32 位的库，链接不上，这就有问题了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> a.out
a.out: ELF <span class="token number">64</span>-bit LSB executable, AMD x86-64, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, <span class="token keyword">for</span> GNU/Linux <span class="token number">2.6</span>.9, dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, <span class="token keyword">for</span> GNU/Linux <span class="token number">2.6</span>.9, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以查看 Core 文件是由哪个程序生成:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> core.22355<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="strings-查询数据中的文本信息">strings 查询数据中的文本信息 </span></h4><p> 一个文件中包含二进制数据和文本数据，如果只需要查看其文本信息，使用这个命令就很方便；过滤掉非字符数据，将文本信息输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ strings <span class="token operator">&lt;</span>objfile<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="fuser-显示文件使用者">fuser 显示文件使用者 </span></h4><p> 显示所有正在使用着指定的 file, file system 或者 sockets 的进程信息;</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">fuser</span> -m -u redis-server
redis-server: 11552rce<span class="token punctuation">(</span>weber<span class="token punctuation">)</span> 22912rce<span class="token punctuation">(</span>weber<span class="token punctuation">)</span> 25501rce<span class="token punctuation">(</span>weber<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用了 <code>-m</code> 和<code>-u</code>选项，用来查找所有正在使用 redis-server 的所有进程的 PID 以及该进程的 OWNER；</p>
<p>fuser 通常被用在诊断系统的”resource busy”问题。如果你希望 kill 所有正在使用某一指定的 file, file system or sockets 的进程的时候，你可以使用 -k 选项:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">fuser</span> –k /path/to/your/filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="xxd-十六进制显示数据">xxd 十六进制显示数据 </span></h4><p> 以十六进制方式显示文件，只显示文本信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$xxd</span> a.out
0000000: 7f45 4c46 0101 0100 0000 0000 0000 0000  .ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
0000010: 0200 0300 0100 0000 <span class="token number">3083</span> 0408 <span class="token number">3400</span> 0000  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token number">0</span><span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.
0000020: 3c11 0000 0000 0000 <span class="token number">3400</span> <span class="token number">2000</span> 0900 <span class="token number">2800</span>  <span class="token operator">&lt;</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.4. <span class="token punctuation">..</span>.<span class="token punctuation">(</span>.
0000030: 1e00 1b00 0600 0000 <span class="token number">3400</span> 0000 <span class="token number">3480</span> 0408  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.
0000040: <span class="token number">3480</span> 0408 <span class="token number">2001</span> 0000 <span class="token number">2001</span> 0000 0500 0000  <span class="token number">4</span><span class="token punctuation">..</span>. <span class="token punctuation">..</span>. <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.
0000050: 0400 0000 0300 0000 <span class="token number">5401</span> 0000 <span class="token number">5481</span> 0408  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.T<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="od-查看特殊格式文件内容">od 查看特殊格式文件内容 </span></h4><p> 通常使用 od 命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和 ASCII 码来显示文件。</p>
<p>参数说明：</p>
<p><code>-A</code> 指定地址基数，包括：</p>
<ul>
<li>d 十进制</li>
<li>o 八进制（系统默认值）</li>
<li>x 十六进制</li>
<li>n 不打印位移值</li>
</ul>
<p><code>-t</code> 指定数据的显示格式，主要的参数有：</p>
<ul>
<li>c ASCII 字符或反斜杠序列</li>
<li>d 有符号十进制数</li>
<li>f 浮点数</li>
<li>o 八进制（系统默认值为 02）</li>
<li>u 无符号十进制数</li>
<li>x 十六进制数</li>
</ul>
<p>除了选项 c 以外的其他选项后面都可以跟一个十进制数 n，指定每个显示值所包含的字节数。</p>
<p>说明：od 命令系统默认的显示方式是八进制，这也是该命令的名称由来（Octal Dump）。但这不是最有用的显示方式，用 ASCII 码和十六进制组合的方式能提供更有价值的信息输出。</p>
<p>以十六进制和字符同时显示:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ od -Ax -tcx4 a.c
000000   <span class="token comment">#   i   n   c   l   u   d   e       &lt;   s   t   d   i   o   .</span>
              636e6923        6564756c        74733c20        2e6f6964
000010   h   <span class="token operator">></span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>n   <span class="token function">v</span>   o   i   d       m   a   i   n   <span class="token punctuation">(</span>   <span class="token punctuation">)</span>  <span class="token punctuation">\</span>n
              0a0a3e68        64696f76        69616d20        0a29286e
000020   <span class="token punctuation">&#123;</span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>t   i   n   t       i       <span class="token operator">=</span>       <span class="token number">5</span>   <span class="token punctuation">;</span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>t   p
              69090a7b        6920746e        35203d20        70090a3b
000030   r   i   n   t   f   <span class="token punctuation">(</span>   <span class="token string">"h   e   l   l   o   ,   %   d"</span>
              746e6972        <span class="token number">68222866</span>        6f6c6c65        2264252c
000040   ,   i   <span class="token punctuation">)</span>   <span class="token punctuation">;</span>  <span class="token punctuation">\</span>n   <span class="token punctuation">&#125;</span>  <span class="token punctuation">\</span>n
              3b29692c        000a7d0a
000047<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以字符方式显示:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ od -c a.c
0000000   <span class="token comment">#   i   n   c   l   u   d   e       &lt;   s   t   d   i   o   .</span>
0000020   h   <span class="token operator">></span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>n   <span class="token function">v</span>   o   i   d       m   a   i   n   <span class="token punctuation">(</span>   <span class="token punctuation">)</span>  <span class="token punctuation">\</span>n
0000040   <span class="token punctuation">&#123;</span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>t   i   n   t       i       <span class="token operator">=</span>       <span class="token number">5</span>   <span class="token punctuation">;</span>  <span class="token punctuation">\</span>n  <span class="token punctuation">\</span>t   p
0000060   r   i   n   t   f   <span class="token punctuation">(</span>   <span class="token string">"h   e   l   l   o   ,   %   d"</span>
0000100   ,   i   <span class="token punctuation">)</span>   <span class="token punctuation">;</span>  <span class="token punctuation">\</span>n   <span class="token punctuation">&#125;</span>  <span class="token punctuation">\</span>n
0000107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 配置初步</title>
    <url>/2016/10/10/Nginx/Nginx%E9%85%8D%E7%BD%AE%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>Nginx 是一款轻量级的 Web 服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。这里实践一下 nginx 的配置</p>
<a id="more"></a>
<h2><span id="安装">安装 </span></h2><p> 下载必要组件</p>
<ul>
<li><p>nginx 下载地址</p>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>pcre 库下载地址，nginx 需要</p>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;pcre&#x2F;files&#x2F;pcre&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>zlib 下载地址，nginx 需要</p>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.zlib.net&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>openssl 下载地址，nginx 需要</p>
<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;openssl&#x2F;openssl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>在同级目录下, 解压安装 zlib、openssl、pcre</p>
<p>进入 nginx 目录，进行配置安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure <span class="token punctuation">\</span>
 --prefix<span class="token operator">=</span>/usr/local/nginx <span class="token punctuation">\</span>
 --with-http_ssl_module <span class="token punctuation">\</span>
 --with-http_flv_module <span class="token punctuation">\</span>
 --with-http_stub_status_module <span class="token punctuation">\</span>
 --with-http_gzip_static_module <span class="token punctuation">\</span>
 --with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.39 <span class="token punctuation">\</span>
 --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.8 <span class="token punctuation">\</span> 
 --with-openssl<span class="token operator">=</span><span class="token punctuation">..</span>/openssl-master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面可直接复制粘贴</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/usr/local/nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.39 --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.8 --with-openssl<span class="token operator">=</span><span class="token punctuation">..</span>/openssl-master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Nginx 会被安装在 /usr/local/nginx 目录下（也可以使用参数—prefix= 指定自己需要的位置）， 安装成功后 /usr/local/nginx 目录下有四个子目录分别是：conf、html、logs、sbin 。 其中 Nginx 的配置文件存放于 conf/nginx.conf， bin 文件是位于 sbin 目录下的 nginx 文件。 确保系统的 80 端口没被其他程序占用，运行 sbin/nginx 命令来启动 Nginx，</p>
<p>启动 nginx</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/nginx/sbin/nginx
    <span class="token comment">#netstat -ano|grep 80</span>
        tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:80              <span class="token number">0.0</span>.0.0:*               LISTEN      关闭 <span class="token punctuation">(</span><span class="token number">0.00</span>/0/0<span class="token punctuation">)</span>
        unix  <span class="token number">17</span>     <span class="token punctuation">[</span> <span class="token punctuation">]</span>         数据报                <span class="token number">10801</span>    /dev/log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 检查配置文件是否正确</span>
/usr/local/sbin/nginx -t 
<span class="token comment"># 可以看到编译选项</span>
/usr/local/sbin/nginx -V
<span class="token comment"># 重启 Nginx</span>
<span class="token function">sudo</span> /usr/local/sbin/nginx -s reload
<span class="token comment"># 关闭 Nginx</span>
<span class="token function">sudo</span> /usr/local/sbin/nginx -s stop
<span class="token comment"># 优雅停止服务</span>
<span class="token function">sudo</span> /usr/local/sbin/nginx -s quit
<span class="token function">kill</span> -s SIGQUIT pid_master
<span class="token function">kill</span> -s SIGWINCH pid_master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="配置">配置</span></h2><p>nginx.conf 配置文件, 基本就分为以下几块：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">main
<span class="token keyword">events</span>   <span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">http</span>        <span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">upstream</span> myproject <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">server</span>  <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">location</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">server</span>  <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">location</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>nginx 配置文件主要分为六个区域：</p>
<ul>
<li>main(全局设置)</li>
<li>events(nginx 工作模式)</li>
<li>http(http 设置)</li>
<li>sever(主机设置)</li>
<li>location(URL 匹配)</li>
<li>upstream(负载均衡服务器设置)</li>
</ul>
<p>下面依次来看下具体内容</p>
<ul>
<li>main 模块</li>
</ul>
<p>下面时一个 main 区域，他是一个全局的设置：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">user</span> nobody nobody<span class="token punctuation">;</span>
<span class="token keyword">worker_processes</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">error_log</span>  <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>error<span class="token punctuation">.</span>log  notice<span class="token punctuation">;</span>
<span class="token keyword">pid</span>        <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>var<span class="token operator">/</span>run<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span><span class="token keyword">pid</span><span class="token punctuation">;</span>
<span class="token keyword">worker_rlimit_nofile</span> <span class="token number">1024</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>user 来指定 Nginx Worker 进程运行用户以及用户组，默认由 nobody 账号运行。</p>
<p>worker_processes 来指定了 Nginx 要开启的子进程数。每个 Nginx 进程平均耗费 10M~12M 内存。根据经验，一般指定 1 个进程就足够了，如果是多核 CPU，建议指定和 CPU 的数量一样的进程数即可。我这里写 2，那么就会开启 2 个子进程，总共 3 个进程。</p>
<p>error_log 用来定义全局错误日志文件。日志输出级别有 debug、info、notice、warn、error、crit 可供选择，其中，debug 输出日志最为最详细，而 crit 输出日志最少。</p>
<p>pid 用来指定进程 id 的存储文件位置。</p>
<p>worker_rlimit_nofile 用于指定一个 nginx 进程可以打开的最多文件描述符数目，这里是 65535，需要使用命令“ulimit -n 65535”来设置。</p>
<ul>
<li>events 模块</li>
</ul>
<p>events 模块来用指定 nginx 的工作模式和工作模式及连接数上限，一般是这样：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">events</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">use</span> epoll<span class="token punctuation">;</span> <span class="token comment">#Linux 平台</span>
    <span class="token keyword">worker_connections</span>  <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>use 用来指定 Nginx 的工作模式。Nginx 支持的工作模式有 select、poll、kqueue、epoll、rtsig 和 /dev/poll。其中 select 和 poll 都是标准的工作模式，kqueue 和 epoll 是高效的工作模式，不同的是 epoll 用在 Linux 平台上，而 kqueue 用在 BSD 系统中, 对于 Linux 系统，epoll 工作模式是首选。</p>
<p>worker_connections 用于定义 Nginx 每个进程的最大连接数，即接收前端的最大请求数，默认是 1024。最大客户端连接数由 worker_processes 和 worker_connections 决定，即 Max_clients=worker_processes<em>worker_connections，在作为反向代理时，Max_clients 变为：Max_clients = worker_processes </em> worker_connections/4。 进程的最大连接数受 Linux 系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后 worker_connections 的设置才能生效。</p>
<ul>
<li>http 模块</li>
</ul>
<p>http 模块可以说是最核心的模块了，它负责 HTTP 服务器相关属性的配置，它里面的 server 和 upstream 子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">http</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">include</span>       mime<span class="token punctuation">.</span><span class="token keyword">types</span><span class="token punctuation">;</span>
    <span class="token keyword">default_type</span>  application<span class="token operator">/</span>octet<span class="token operator">-</span>stream<span class="token punctuation">;</span>
    <span class="token keyword">log_format</span>  main  <span class="token string">'$remote_addr - $remote_user [$time_local]"$request" '</span>
                      <span class="token string">'$status $body_bytes_sent"$http_referer" '</span>
                      <span class="token string">'"$http_user_agent" "$http_x_forwarded_for"'</span><span class="token punctuation">;</span>
    <span class="token keyword">access_log</span>  <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>
    <span class="token keyword">sendfile</span>        on<span class="token punctuation">;</span>
    <span class="token keyword">tcp_nopush</span>      on<span class="token punctuation">;</span>
    <span class="token keyword">tcp_nodelay</span>     on<span class="token punctuation">;</span>
    <span class="token keyword">keepalive_timeout</span>  <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token comment">#gzip  on;</span>
    <span class="token keyword">upstream</span> myproject <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面详细介绍下这段代码中每个配置选项的含义。</p>
<p>include 来用设定文件的 mime 类型, 类型在配置文件目录下的 mime.type 文件定义，来告诉 nginx 来识别文件类型。</p>
<p>default_type 设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置 asp 的 locate 环境时，Nginx 是不予解析的，此时，用浏览器访问 asp 文件就会出现下载了。</p>
<p>log_format 用于设置日志的格式，和记录哪些参数，这里设置为 main，刚好用于 access_log 来纪录这种类型。</p>
<p>main 的类型日志如下：也可以增删部分参数。</p>
<pre class="line-numbers language-none"><code class="language-none">127.0.0.1 - - [21&#x2F;Apr&#x2F;2015:18:09:54 +0800] &quot;GET &#x2F;index.php HTTP&#x2F;1.1&quot; 200 87151 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;41.0.2272.76 Safari&#x2F;537.36&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>access_log</p>
<p>用来纪录每次的访问日志的文件地址，后面的 main 是日志的格式样式，对应于 log_format 的 main。</p>
<p>sendfile 参数用于开启高效文件传输模式。将 tcp_nopush 和 tcp_nodelay 两个指令设置为 on 用于防止网络阻塞。</p>
<p>keepalive_timeout 设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p>
<ul>
<li>server 模块</li>
</ul>
<p>sever 模块是 http 的子模块，它用来定一个虚拟主机，我们先讲最基本的配置，这些在后面再讲。</p>
<p>我们看一下一个简单的 server 是如何做的？</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">listen</span>       <span class="token number">8080</span><span class="token punctuation">;</span>
        <span class="token keyword">server_name</span>  localhost <span class="token number">192.168</span><span class="token number">.12</span><span class="token number">.10</span> www<span class="token punctuation">.</span>yangyi<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
        <span class="token comment"># 全局定义，如果都是这一个目录，这样定义最简单。</span>
        <span class="token keyword">root</span>   <span class="token operator">/</span>Users<span class="token operator">/</span>yangyi<span class="token operator">/</span>www<span class="token punctuation">;</span>
        <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>php <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span> 
        <span class="token keyword">charset</span> utf<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span>
        <span class="token keyword">access_log</span>  usr<span class="token operator">/</span>local<span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>host<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>
        aerror_log  usr<span class="token operator">/</span>local<span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>host<span class="token punctuation">.</span>error<span class="token punctuation">.</span>log  error<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>server 标志定义虚拟主机开始。</p>
<p>listen 用于指定虚拟主机的服务端口。</p>
<p>server_name 用来指定 IP 地址或者域名，多个域名之间用空格分开。</p>
<p>root 表示在这整个 server 虚拟主机内，全部的 root web 根目录。注意要和 locate {}下面定义的区分开来。</p>
<p>index 全局定义访问的默认首页地址。注意要和 locate {}下面定义的区分开来。</p>
<p>charset 用于设置网页的默认编码格式。</p>
<p>access_log 用来指定此虚拟主机的访问日志存放路径，最后的 main 用于指定访问日志的输出格式。</p>
<ul>
<li>location 模块</li>
</ul>
<p>location 模块是 nginx 中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。慢慢来讲：</p>
<p>location 根据它字面意思就知道是来定位的，定位 URL，解析 URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过 location 指令实现 Nginx 对动、静态网页进行过滤处理。像我们的 php 环境搭建就是用到了它。</p>
<p>我们先来看这个，设定默认首页和虚拟机目录。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">root</span>   <span class="token operator">/</span>Users<span class="token operator">/</span>yangyi<span class="token operator">/</span>www<span class="token punctuation">;</span>
            <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>php <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>location / 表示匹配访问根目录。</p>
<p>root 指令用于指定访问根目录时，虚拟主机的 web 目录，这个目录可以是相对路径（相对路径是相对于 nginx 的安装目录）。也可以是绝对路径。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment"># 反向代理配置</span>
<span class="token keyword">location</span> <span class="token operator">/</span>itcast<span class="token operator">/</span> <span class="token punctuation">&#123;</span>
           <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">12345</span><span class="token punctuation">;</span>
           <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>real<span class="token operator">-</span>ip <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
           <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>


<span class="token comment"># 采用 uwsgi 方式</span>
<span class="token keyword">location</span> <span class="token operator">/</span>python<span class="token operator">/</span> <span class="token punctuation">&#123;</span>
           <span class="token keyword">include</span> uwsgi_params<span class="token punctuation">;</span>
           uwsgi_pass <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">33333</span><span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>



  <span class="token comment"># 访问 nginx 本机目录的文件</span>
  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">root</span>   <span class="token operator">/</span>home<span class="token operator">/</span>itcast<span class="token operator">/</span>xwp<span class="token operator">/</span>itcast<span class="token operator">/</span><span class="token punctuation">;</span>
          <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>

  <span class="token keyword">location</span>  <span class="token operator">/</span>static<span class="token operator">/</span> <span class="token punctuation">&#123;</span>
           <span class="token keyword">alias</span> <span class="token operator">/</span>var<span class="token operator">/</span>static<span class="token operator">/</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>upstram 模块</li>
</ul>
<p>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">upstream</span> test<span class="token punctuation">.</span>com<span class="token punctuation">&#123;</span>
    <span class="token keyword">ip_hash</span><span class="token punctuation">;</span>
    <span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.123</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.123</span><span class="token number">.2</span><span class="token punctuation">:</span><span class="token number">80</span> down<span class="token punctuation">;</span>
    <span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.123</span><span class="token number">.3</span><span class="token punctuation">:</span><span class="token number">8080</span>  max_fails<span class="token operator">=</span><span class="token number">3</span>  fail_timeout<span class="token operator">=</span><span class="token number">20</span>s<span class="token punctuation">;</span>
    <span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.123</span><span class="token number">.4</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，通过 upstream 指令指定了一个负载均衡器的名称 test.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</p>
<p>里面是 ip_hash 这是其中的一种负载均衡调度算法。</p>
<p>Nginx 的负载均衡模块目前支持 4 种调度算法:</p>
<ul>
<li>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight 值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问 IP 的 hash 结果分配，这样来自同一个 IP 的访客固定访问一个后端服务器，有效解决了动态网页存在的 session 共享问题。</li>
<li>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx 本身是不支持 fair 的，如果需要使用这种调度算法，必须下载 Nginx 的 upstream_fair 模块。</li>
<li>url_hash。按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx 本身是不支持 url_hash 的，如果需要使用这种调度算法，必须安装 Nginx 的 hash 软件包。</li>
</ul>
<p>在 HTTP Upstream 模块中，可以通过 server 指令指定后端服务器的 IP 地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p>
<p>down，表示当前的 server 暂时不参与负载均衡。</p>
<p>backup，预留的备份机器。当其他所有的非 backup 机器出现故障或者忙的时候，才会请求 backup 机器，因此这台机器的压力最轻。</p>
<p>max_fails，允许请求失败的次数，默认为 1。当超过最大次数时，返回 proxy_next_upstream 模块定义的错误。</p>
<p>fail_timeout，在经历了 max_fails 次失败后，暂停服务的时间。max_fails 可以和 fail_timeout 一起使用。</p>
<p>注意 当负载调度算法为 ip_hash 时，后端服务器在负载均衡调度中的状态不能是 weight 和 backup。</p>
<p>备注： nginx 的 worker_rlimit_nofile 达到上限时，再有客户端链接报 502 错误. 用了 log_format 指令设置了日志格式之后，需要用 access_log 指令指定日志文件的存放路径.</p>
<h2><span id="反向代理">反向代理 </span></h2><p> 正向代理，也就是传说中的代理, 他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。 从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。结论就是，正向代理 是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>从用途上来讲：</p>
<ul>
<li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问 Internet 的途径。</li>
<li>正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问。</li>
<li>反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li>
<li>反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。</li>
</ul>
<h3><span id="反向代理服务器的基本配置">反向代理服务器的基本配置</span></h3><ol>
<li><p>proxy_pass</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_pass</span> URL<span class="token punctuation">;</span>
配置块 <span class="token keyword">location</span> <span class="token keyword">if</span>
此配置将当前请求代理到 URL 参数指定的服务器上<span class="token punctuation">,</span>URL 可以是主机名或者 IP 地址加 PORT 的形式
<span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token punctuation">;</span>
也可以结合负载均衡实用 <span class="token operator">&lt;</span> 负载均衡会说明这种情况<span class="token operator">></span>
也可以吧 <span class="token keyword">HTTP</span> 转换成<span class="token keyword">HTTPS</span>
<span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">;</span>
默认情况反向代理不转发请求中的 Host 头部 <span class="token punctuation">,</span> 如果需呀设置抓发头部
    则 <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_method</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_method</span> method_name<span class="token punctuation">;</span>
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span>
此配置项表示转发时的协议方法名<span class="token punctuation">:</span>
    <span class="token keyword">proxy_method</span> POST<span class="token punctuation">;</span>
那么客户端发来的 GET 请求在转发时方法改为 POST<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_hide_header</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_hide_header</span> header1<span class="token punctuation">;</span>
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span><span class="token punctuation">;</span>
Nginx 会将上游服务器的响应转发给客户端 <span class="token punctuation">,</span> 但默认不转发 <span class="token keyword">HTTP</span> 头部字段<span class="token punctuation">(</span>Date <span class="token keyword">Server</span> X<span class="token operator">-</span>Pad X<span class="token operator">-</span>Accel<span class="token operator">-</span><span class="token operator">*</span> <span class="token punctuation">)</span>
使用 <span class="token keyword">proxy_hide_header</span> 可以指定任意头部不能被转发
<span class="token keyword">proxy_hide_header</span> Cache<span class="token operator">-</span>Control<span class="token punctuation">;</span>
<span class="token keyword">proxy_hide_header</span> MicrosoftOfficeWebServer<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_pass_header</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_pass_header</span> header1<span class="token punctuation">;</span>
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span>
功能与 <span class="token keyword">proxy_hide_header</span>相反 <span class="token punctuation">,</span> 是设置哪些头部允许转发<span class="token punctuation">.</span>
<span class="token keyword">proxy_pass_header</span> X<span class="token operator">-</span>Accel<span class="token operator">-</span>Redirect<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_pass_request_body</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_pass_request_body</span> off<span class="token operator">|</span>on<span class="token punctuation">;</span>
默认 on
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span><span class="token punctuation">;</span>
确定上游服务器是否向上游服务器转发 <span class="token keyword">HTTP</span> 包体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_pass_request_header</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">proxy_pass_request_header on <span class="token operator">|</span> off<span class="token punctuation">;</span>
默认 on
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span>
确定是否转发 <span class="token keyword">HTTP</span> 头部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_redirect</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">proxy_redirect</span> <span class="token punctuation">[</span>default <span class="token operator">|</span> off <span class="token operator">|</span>redirect <span class="token operator">|</span>replacement<span class="token punctuation">]</span>
默认 default
配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span>
当上游服务响应时重定向或刷新 <span class="token punctuation">(</span><span class="token keyword">HTTP</span> <span class="token number">301</span> <span class="token number">302</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">proxy_redirect</span> 可以重设 <span class="token keyword">HTTP</span> 头部的 <span class="token keyword">location</span> 或 refresh 字段
   
<span class="token keyword">proxy_redirect</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>locahost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token operator">/</span>two<span class="token operator">/</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>frontend<span class="token operator">/</span>one<span class="token operator">/</span><span class="token punctuation">;</span>
上游响应 <span class="token number">302</span><span class="token punctuation">,</span><span class="token keyword">location</span> 是 URI 是<span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>locahost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token operator">/</span>two<span class="token operator">/</span>some<span class="token operator">/</span>uri<span class="token operator">/</span>
那是实际转发给客户端的是 <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>frontend<span class="token operator">/</span>one<span class="token operator">/</span>some<span class="token operator">/</span>uri<span class="token operator">/</span><span class="token punctuation">;</span>
可以使用前面提到的 ngx_http_core_module 模块提供的变量 
<span class="token keyword">proxy_redirect</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>locahost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token operator">/</span>two<span class="token operator">/</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$host</span><span class="token punctuation">:</span>server_port<span class="token operator">/</span><span class="token punctuation">;</span>
可以省略 replacement 参数的主机名部分 <span class="token punctuation">,</span> 这时候用虚拟主机名填充
<span class="token keyword">proxy_redirect</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>locahost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token operator">/</span>two<span class="token operator">/</span> <span class="token operator">/</span>one<span class="token operator">/</span><span class="token punctuation">;</span>
   
使用 off 参数的时候 <span class="token punctuation">,</span> 将使 <span class="token keyword">location</span> 和 refresh 的字段维持不变
<span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>
   
如果使用的 <span class="token keyword">proxy_redirect</span> default<span class="token punctuation">;</span>
下面两种配置是等效的
    <span class="token keyword">location</span> <span class="token operator">/</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token keyword">upstream</span><span class="token punctuation">:</span>port<span class="token operator">/</span>two<span class="token operator">/</span><span class="token punctuation">;</span>
        <span class="token keyword">proxy_redirect</span> default<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">location</span> <span class="token operator">/</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token keyword">upstream</span><span class="token punctuation">:</span>port<span class="token operator">/</span>two<span class="token operator">/</span><span class="token punctuation">;</span>
        <span class="token keyword">proxy_redirect</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token keyword">upstream</span><span class="token punctuation">:</span>port<span class="token operator">/</span>two<span class="token operator">/</span> <span class="token operator">/</span>one<span class="token operator">/</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>proxy_next_upstream</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">    <span class="token keyword">proxy_next_upstream</span> <span class="token punctuation">[</span>error <span class="token operator">|</span><span class="token keyword">timeout</span> <span class="token operator">|</span>invalid_header <span class="token operator">|</span>http_500 <span class="token operator">|</span>http_502<span class="token operator">~</span><span class="token number">504</span> <span class="token operator">|</span>http_404 <span class="token operator">|</span> off<span class="token punctuation">]</span>
    默认 <span class="token keyword">proxy_next_upstream</span> error <span class="token keyword">timeout</span><span class="token punctuation">;</span>
    配置块 <span class="token keyword">http</span> <span class="token keyword">server</span> <span class="token keyword">location</span>

    此配置表示上游一台服务器转发请求出现错误时 <span class="token punctuation">,</span> 继续换一套服务器处理这个请求
    其参数用来说明在那些情况下继续选择下一台上游服务器转发请求<span class="token punctuation">.</span>
    error 向上游发起连接 发送请求 读取响应时出错
    <span class="token keyword">timeout</span> 发送请求或读取响应时出错
    invalid_header 上游服务器发送的响应时不合法
    http_500 上游响应<span class="token number">500</span>
    http_502 上游响应<span class="token number">502</span>
    http_503 上游响应<span class="token number">503</span>
    http_504 上游响应<span class="token number">504</span>
    http_404 上游响应<span class="token number">404</span>
    off      关闭 <span class="token keyword">proxy_next_upstream</span> 功能 只要一出错就选择另外一台上游再次出发
Nginx 反向代理模块中还提供很多配置 <span class="token punctuation">,</span> 如设置连接的超时时间 <span class="token punctuation">,</span> 临时文件如何存储 <span class="token punctuation">,</span> 如何缓存上游服务器响应等功能<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>可以通过阅读 ngx_http_proxy_module 了解更多详细情况</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment">#sudo vim /usr/local/nginx/conf/nginx.conf </span>

<span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">listen</span>       <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">server_name</span>  localhost<span class="token punctuation">;</span>
    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>
    <span class="token comment"># 保证代理机器能访问到 下面的机器并装有 nginx  在主机号为 100 的机器上有响应网页</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.100</span><span class="token punctuation">;</span>
    <span class="token keyword">root</span>   html<span class="token punctuation">;</span>
    <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
sudo <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>sbin<span class="token operator">/</span>nginx <span class="token operator">-</span>s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加一些判断条件 获取到 对方请求的主机 防止别人代理到自己的主机上</p>
<h2><span id="负载均衡">负载均衡 </span></h2><p> 负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求按照事先设定分配算法分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。</p>
<p>均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。</p>
<ol>
<li><p>upstream 块</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">upstream</span> name <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
配置块 <span class="token keyword">http</span>
<span class="token keyword">upstream</span>块定义一个上游服务器的集群 <span class="token punctuation">,</span> 便于反向代理中的 <span class="token keyword">proxy_pass</span> 使用

<span class="token keyword">upstream</span> mynet<span class="token punctuation">&#123;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai2<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai3<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">location</span> <span class="token operator">/</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mynet<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>server</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> name <span class="token punctuation">[</span>paramenters<span class="token punctuation">]</span>
配置块<span class="token keyword">upstream</span>
<span class="token keyword">server</span>配置项指定了一台上游服务器的名字 <span class="token punctuation">,</span> 可以是域名 IP 地址端口 UNIX 句柄
weight<span class="token operator">=</span> number<span class="token punctuation">;</span>设置向这台服务器转发的权重 <span class="token punctuation">,</span> 默认为<span class="token number">1</span>
max_fails<span class="token operator">=</span>number<span class="token punctuation">;</span>该选项域 fail_timeout 配合使用
        指在 fail_timeout 时间段内如果转发上游失败超过 number 次就认为当前的 fail_timeout 时间内
        这台服务器不可用<span class="token punctuation">,</span>max_fails 默认为<span class="token number">1</span> 如果设置为<span class="token number">0</span> 表示不检查失败次数
fail_timeout<span class="token operator">=</span>time<span class="token punctuation">;</span> fail_timeout 表示该时间内转发多少次失败后就认为上游不可用 <span class="token punctuation">.</span> 默认<span class="token number">10</span>s
down    表示上游服务器永久下线 <span class="token punctuation">,</span> 只能在 <span class="token keyword">ip_hash</span> 配置时才有效
backup  在 <span class="token keyword">ip_hash</span> 配置时无效 <span class="token punctuation">.</span> 只有所有非备份机都失败 <span class="token punctuation">,</span> 才向上游备份服务器转发请求<span class="token punctuation">.</span>
<span class="token keyword">upstream</span> mynet<span class="token punctuation">&#123;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai1<span class="token punctuation">.</span>com weight<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai2<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">8081</span> max_fails<span class="token operator">=</span><span class="token number">3</span> fail_timeout<span class="token operator">=</span><span class="token number">300</span>s<span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wopai2<span class="token punctuation">.</span>com down<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>ip_hash</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">配置块 <span class="token keyword">upstream</span>
希望来自某一个用户的请求始终落在固定的一台服务器上进行处理<span class="token punctuation">.</span>
根据客户端的 IP 散列计算出一个 key<span class="token punctuation">,</span>将 key 按照 <span class="token keyword">upstream</span> 集群中的上游服务器进行取模 <span class="token punctuation">,</span> 求得的值对应的主机接收转发请求<span class="token punctuation">.</span>
<span class="token keyword">ip_hash</span>不可以与 weight 同时使用
如果 <span class="token keyword">upstream</span> 配置中有一台服务器暂时不可用 <span class="token punctuation">,</span> 不能直接删除该配置 <span class="token punctuation">,</span> 而应该使用 down 标识<span class="token punctuation">.</span>
<span class="token keyword">upstream</span> mynet<span class="token punctuation">&#123;</span>
    <span class="token keyword">ip_hash</span><span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wowpai1<span class="token punctuation">.</span>top<span class="token punctuation">;</span>
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wowpai2<span class="token punctuation">.</span>top<span class="token punctuation">;</span>  
    <span class="token keyword">server</span> www<span class="token punctuation">.</span>wowpai3<span class="token punctuation">.</span>top down<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>例子, 服务器负载均衡基本配置,nginx 中可以进行负载均衡的相关设置:</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">upstream</span> my<span class="token punctuation">.</span>net<span class="token punctuation">&#123;</span>    <span class="token comment">#my.net 是自定义的命名 在 server 结构中引用即可</span>

<span class="token comment"># 代理服务器为 两台机器 192.168.22.136 192.168.22.147 做负载均衡操作 </span>
<span class="token comment"># 两台机器上 可以跑 apache 负载功能更为强大的网页相关任务</span>

<span class="token comment">#max_fails 表示尝试出错最大次数 即可认为该服务器 在 fail_timeout 时间内不可用</span>
<span class="token comment"># server servername:port   servername 可以写主机名 或者点分式 IP</span>
<span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.22</span><span class="token number">.136</span><span class="token punctuation">:</span><span class="token number">80</span> max_fails<span class="token operator">=</span><span class="token number">1</span> fail_timeout<span class="token operator">=</span><span class="token number">300</span>s<span class="token punctuation">;</span>
<span class="token keyword">server</span> <span class="token number">192.168</span><span class="token number">.22</span><span class="token number">.147</span><span class="token punctuation">:</span><span class="token number">80</span> max_fails<span class="token operator">=</span><span class="token number">1</span> fail_timeout<span class="token operator">=</span><span class="token number">300</span>s<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span>


<span class="token keyword">server</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">listen</span>       <span class="token number">80</span><span class="token punctuation">;</span>
<span class="token keyword">server_name</span>  localhost<span class="token punctuation">;</span> 
<span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">#upstream 块名</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>my<span class="token punctuation">.</span>net<span class="token punctuation">;</span>
    <span class="token keyword">root</span>   html<span class="token punctuation">;</span>
    <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>动手开始配置才能慢慢上手 nginx 配置和使用。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁:Redis vs. Zookeeper</title>
    <url>/2017/06/08/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis-vs-Zookeeper/</url>
    <content><![CDATA[<p>在 Java 中 synchronized 关键字和 ReentrantLock 可重入锁在我们的代码中是经常见的，一般我们用其在多线程环境中控制对资源的并发访问，但是随着分布式的快速发展，本地的加锁往往不能满足我们的需要，在我们的分布式环境中上面加锁的方法就会失去作用。基于此，业界提出了分布式锁的概念。</p>
<a id="more"></a>
<h2><span id="why-分布式锁">Why 分布式锁？</span></h2><p>在讨论这个问题之前，我们先来看一个业务场景：</p>
<p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p>
<p>由于系统有一定的并发，所以会预先将商品的库存保存在 redis 中，用户下单的时候会更新 redis 的库存。</p>
<p>此时系统架构如下：</p>
<p><img src="https://i.loli.net/2020/09/08/EPWQcd1ymU6eHAk.png" alt="img"></p>
<p>但是这样一来会 <strong> 产生一个问题</strong>：假如某个时刻，redis 里面的某个商品库存为 1，此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p>
<p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。</p>
<p>这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p>
<p>很明显不对啊！这就是典型的 <strong> 库存超卖问题</strong></p>
<p>此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p>
<p><img src="https://i.loli.net/2020/09/08/LIgj5Ols4R9xKcw.png" alt="img"></p>
<p>按照上面的图，在执行第 2 步时，使用 Java 提供的 synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。关注公众号互联网架构师，回复关键字 2T，获取最新架构视频</p>
<p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p>
<p><img src="https://i.loli.net/2020/09/08/8OICyhzeSFGkLBj.jpg" alt="img"></p>
<p>增加机器之后，系统变成上图所示。</p>
<p>假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现 <strong> 库存超卖 </strong> 的问题。</p>
<p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p>
<p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了</p>
<p>这是因为两台机器加的锁不是同一个锁(两个锁在不同的 JVM 里面)。</p>
<p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？</p>
<p>此时，就该 <strong> 分布式锁 </strong> 隆重登场了，分布式锁的思路是：</p>
<p>在整个系统提供一个 <strong> 全局、唯一 </strong> 的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p>
<p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。</p>
<p>文字描述不太直观，我们来看下图：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"><img src="https://i.loli.net/2020/09/08/lnpQLjsiq3GvxTJ.png" alt="640 (1)"></p>
<p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p>
<p>那么，如何实现分布式锁呢？接着往下看！</p>
<h2><span id="基于-redis-实现分布式锁">基于 Redis 实现分布式锁 </span></h2><p> 上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247493252&amp;idx=2&amp;sn=5530b330af0e0bcb56f9cc8bd7d0a25d&amp;chksm=ebd5d9a8dca250be07d54c37110fcc2549cb31968557910a77485747d9cb9ee842a2f05c25dc&amp;scene=21#wechat_redirect">Redisson 是如何实现分布式锁的？</a></p>
<p>最常见的一种方案就是使用 Redis 做分布式锁</p>
<p>使用 Redis 做分布式锁的思路大概是这样的：在 redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 key 删除。</p>
<p>具体代码是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取锁
&#x2F;&#x2F; NX 是指如果 key 不存在就成功，key 存在返回 false，PX 可以指定过期时间
SET anyLock unique_value NX PX 30000


&#x2F;&#x2F; 释放锁：通过执行一段 lua 脚本
&#x2F;&#x2F; 释放锁涉及到两条指令，这两条指令不是原子性的
&#x2F;&#x2F; 需要用到 redis 的 lua 脚本支持特性，redis 执行 lua 脚本是原子性的
if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then
return redis.call(&quot;del&quot;,KEYS[1])
else
return 0
end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种方式有几大要点：</p>
<ul>
<li><p><strong>一定要用 SET key value NX PX milliseconds 命令</strong></p>
<p>如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key 永久存在)</p>
</li>
<li><p><strong>value 要具有唯一性</strong></p>
<p>这个是为了在解锁的时候，需要验证 value 是和加锁的一致才删除 key。</p>
<p>这是避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/08/izNaYrJTKcltBVI.png" alt="img"></p>
<p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 redis 的部署问题。</p>
<p>redis 有 3 种部署方式：</p>
<ul>
<li>单机模式</li>
<li>master-slave + sentinel 选举模式</li>
<li>redis cluster 模式</li>
</ul>
<p>使用 redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 redis 故障了。加锁就不行了。</p>
<p>采用 master-slave 模式，加锁的时候只对一个节点加锁，即便通过 sentinel 做了高可用，但是如果 master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p>
<p>基于以上的考虑，其实 redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法，这个算法的意思大概是这样的：</p>
<p>假设 redis 的部署模式是 redis cluster，总共有 5 个 master 节点，通过以下步骤获取一把锁：</p>
<ul>
<li>获取当前时间戳，单位是毫秒</li>
<li>轮流尝试在每个 master 节点上创建锁，过期时间设置较短，一般就几十毫秒</li>
<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了</li>
<li>要是锁建立失败了，那么就依次删除这个锁</li>
<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁</li>
</ul>
<p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p>
<p><img src="https://i.loli.net/2020/09/08/ySZF51vKboscCnU.png" alt="img"></p>
<h3><span id="另一种方式redisson">另一种方式：Redisson</span></h3><p>此外，实现 Redis 的分布式锁，除了自己基于 redis client 原生 api 来实现之外，还可以使用开源框架：Redission</p>
<p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p>
<p>回想一下上面说的，如果自己写代码来通过 redis 设置一个值，是通过下面这个命令设置的。</p>
<ul>
<li>SET anyLock unique_value NX PX 30000</li>
</ul>
<p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，key 会过期，其他线程有可能会获取到锁。</p>
<p>这样一来的话，第一个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。所以我们还需要额外的去维护这个过期时间，太麻烦了~</p>
<p>我们来看看 redisson 是怎么实现的？先感受一下使用 redission 的爽：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Config config &#x3D; new Config();
config.useClusterServers()
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7001&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7002&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.101:7003&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7001&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7002&quot;)
.addNodeAddress(&quot;redis:&#x2F;&#x2F;192.168.31.102:7003&quot;);

RedissonClient redisson &#x3D; Redisson.create(config);


RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);
lock.lock();
lock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就是这么简单，我们只需要通过它的 api 中的 lock 和 unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p>
<ul>
<li><p>redisson 所有指令都通过 lua 脚本执行，redis 支持 lua 脚本原子性执行</p>
</li>
<li><p>redisson 设置一个 key 的默认过期时间为 30s, 如果某个客户端持有一个锁超过了 30s 怎么办？</p>
<p>redisson 中有一个 <code>watchdog</code> 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10 秒帮你把 key 的超时时间设为 30s</p>
<p>这样的话，就算一直持有锁也不会出现 key 过期了，其他线程获取到锁的问题了。</p>
</li>
<li><p>redisson 的“看门狗”逻辑保证了没有死锁发生。</p>
<p>(如果机器宕机了，看门狗也就没了。此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/08/VrfIShyRXCWTiEY.png" alt="img"></p>
<p>这里稍微贴出来其实现代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 加锁逻辑
private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) &#123;
    if (leaseTime !&#x3D; -1) &#123;
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    &#125;
    &#x2F;&#x2F; 调用一段 lua 脚本，设置一些 key、过期时间
    RFuture&lt;Long&gt; ttlRemainingFuture &#x3D; tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    ttlRemainingFuture.addListener(new FutureListener&lt;Long&gt;() &#123;
        @Override
        public void operationComplete(Future&lt;Long&gt; future) throws Exception &#123;
            if (!future.isSuccess()) &#123;
                return;
            &#125;

            Long ttlRemaining &#x3D; future.getNow();
            &#x2F;&#x2F; lock acquired
            if (ttlRemaining &#x3D;&#x3D; null) &#123;
                &#x2F;&#x2F; 看门狗逻辑
                scheduleExpirationRenewal(threadId);
            &#125;
        &#125;
    &#125;);
    return ttlRemainingFuture;
&#125;


&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;
    internalLockLeaseTime &#x3D; unit.toMillis(leaseTime);

    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
              &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +
                  &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +
                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +
                  &quot;return nil; &quot; +
              &quot;end; &quot; +
              &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1) then &quot; +
                  &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +
                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +
                  &quot;return nil; &quot; +
              &quot;end; &quot; +
              &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;,
                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
&#125;



&#x2F;&#x2F; 看门狗最终会调用了这里
private void scheduleExpirationRenewal(final long threadId) &#123;
    if (expirationRenewalMap.containsKey(getEntryName())) &#123;
        return;
    &#125;

    &#x2F;&#x2F; 这个任务会延迟 10s 执行
    Timeout task &#x3D; commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;
        @Override
        public void run(Timeout timeout) throws Exception &#123;

            &#x2F;&#x2F; 这个操作会将 key 的过期时间重新设置为 30s
            RFuture&lt;Boolean&gt; future &#x3D; renewExpirationAsync(threadId);

            future.addListener(new FutureListener&lt;Boolean&gt;() &#123;
                @Override
                public void operationComplete(Future&lt;Boolean&gt; future) throws Exception &#123;
                    expirationRenewalMap.remove(getEntryName());
                    if (!future.isSuccess()) &#123;
                        log.error(&quot;Can&#39;t update lock &quot; + getName() + &quot; expiration&quot;, future.cause());
                        return;
                    &#125;

                    if (future.getNow()) &#123;
                        &#x2F;&#x2F; reschedule itself
                        &#x2F;&#x2F; 通过递归调用本方法，无限循环延长过期时间
                        scheduleExpirationRenewal(threadId);
                    &#125;
                &#125;
            &#125;);
        &#125;

    &#125;, internalLockLeaseTime &#x2F; 3, TimeUnit.MILLISECONDS);

    if (expirationRenewalMap.putIfAbsent(getEntryName(), new ExpirationEntry(threadId, task)) !&#x3D; null) &#123;
        task.cancel();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，redisson 还提供了对 redlock 算法的支持,</p>
<p>它的用法也很简单：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RedissonClient redisson &#x3D; Redisson.create(config);
RLock lock1 &#x3D; redisson.getFairLock(&quot;lock1&quot;);
RLock lock2 &#x3D; redisson.getFairLock(&quot;lock2&quot;);
RLock lock3 &#x3D; redisson.getFairLock(&quot;lock3&quot;);
RedissonRedLock multiLock &#x3D; new RedissonRedLock(lock1, lock2, lock3);
multiLock.lock();
multiLock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>小结：</strong></p>
<p>本节分析了使用 redis 作为分布式锁的具体落地方案</p>
<p>以及其一些局限性</p>
<p>然后介绍了一个 redis 的客户端框架 redisson，</p>
<p>这也是我推荐大家使用的，</p>
<p>比自己写代码实现会少 care 很多细节。</p>
<h2><span id="基于-zookeeper-实现分布式锁">基于 zookeeper 实现分布式锁 </span></h2><p> 常见的分布式锁实现方案里面，除了使用 redis 来实现之外，使用 zookeeper 也可以实现分布式锁。</p>
<p>在介绍 zookeeper(下文用 zk 代替)实现分布式锁的机制之前，先粗略介绍一下 zk 是什么东西：</p>
<p>Zookeeper 是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>zk 的模型是这样的：zk 包含一系列的节点，叫做 znode，就好像文件系统一样每个 znode 表示一个目录，然后 znode 有一些特性：</p>
<ul>
<li><p><strong>有序节点</strong>：假如当前有一个父节点为<code>/lock</code>，我们可以在这个父节点下面创建子节点；</p>
<p>zookeeper 提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么 zookeeper 在生成子节点时会根据当前的子节点数量自动添加整数序号</p>
<p>也就是说，如果是第一个创建的子节点，那么生成的子节点为<code>/lock/node-0000000000</code>，下一个节点则为<code>/lock/node-0000000001</code>，依次类推。</p>
</li>
</ul>
<ul>
<li><p><strong>临时节点</strong>：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper 会自动删除该节点。</p>
</li>
<li><p><strong>事件监听</strong>：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper 会通知客户端。当前 zookeeper 有如下四种事件：</p>
</li>
<li><ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
</li>
</ul>
<p>基于以上的一些 zk 的特性，我们很容易得出使用 zk 实现分布式锁的落地方案：</p>
<ol>
<li><p>使用 zk 的临时节点和有序节点，每个线程获取锁就是在 zk 创建一个临时有序的节点，比如在 /lock/ 目录下。</p>
</li>
<li><p>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p>
</li>
<li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</p>
</li>
<li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p>
<p>比如当前线程获取到的节点序号为 <code>/lock/003</code>, 然后所有的节点列表为<code>[/lock/001,/lock/002,/lock/003]</code>, 则对<code>/lock/002</code> 这个节点添加一个事件监听器。</p>
</li>
</ol>
<p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。</p>
<p>比如 <code>/lock/001</code> 释放了，<code>/lock/002</code>监听到时间，此时节点集合为 <code>[/lock/002,/lock/003]</code>, 则<code>/lock/002</code> 为最小序号节点，获取到锁。</p>
<p>整个过程如下：</p>
<p><img src="https://i.loli.net/2020/09/08/prahvcI6zWuGoqN.png" alt="img"></p>
<p>具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。</p>
<h3><span id="curator-介绍">Curator 介绍</span></h3><p>Curator 是一个 zookeeper 的开源客户端，也提供了分布式锁的实现。</p>
<p>他的使用方式也比较简单：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">InterProcessMutex interProcessMutex &#x3D; new InterProcessMutex(client,&quot;&#x2F;anyLock&quot;);
interProcessMutex.acquire();
interProcessMutex.release();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其实现分布式锁的核心源码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception
&#123;
    boolean  haveTheLock &#x3D; false;
    boolean  doDelete &#x3D; false;
    try &#123;
        if (revocable.get() !&#x3D; null ) &#123;
            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);
        &#125;

        while ((client.getState() &#x3D;&#x3D; CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123;
            &#x2F;&#x2F; 获取当前所有节点排序后的集合
            List&lt;String&gt;        children &#x3D; getSortedChildren();
            &#x2F;&#x2F; 获取当前节点的名称
            String              sequenceNodeName &#x3D; ourPath.substring(basePath.length() + 1); &#x2F;&#x2F; +1 to include the slash
            &#x2F;&#x2F; 判断当前节点是否是最小的节点
            PredicateResults    predicateResults &#x3D; driver.getsTheLock(client, children, sequenceNodeName, maxLeases);
            if (predicateResults.getsTheLock() ) &#123;
                &#x2F;&#x2F; 获取到锁
                haveTheLock &#x3D; true;
            &#125; else &#123;
                &#x2F;&#x2F; 没获取到锁，对当前节点的上一个节点注册一个监听器
                String  previousSequencePath &#x3D; basePath + &quot;&#x2F;&quot; + predicateResults.getPathToWatch();
                synchronized(this)&#123;
                    Stat stat &#x3D; client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);
                    if (stat !&#x3D; null)&#123;
                        if (millisToWait !&#x3D; null)&#123;
                            millisToWait -&#x3D; (System.currentTimeMillis() - startMillis);
                            startMillis &#x3D; System.currentTimeMillis();
                            if (millisToWait &lt;&#x3D; 0)&#123;
                                doDelete &#x3D; true;    &#x2F;&#x2F; timed out - delete our node
                                break;
                            &#125;
                            wait(millisToWait);
                        &#125;else&#123;
                            wait();
                        &#125;
                    &#125;
                &#125;
                &#x2F;&#x2F; else it may have been deleted (i.e. lock released). Try to acquire again
            &#125;
        &#125;
    &#125;
    catch (Exception e) &#123;
        doDelete &#x3D; true;
        throw e;
    &#125; finally&#123;
        if (doDelete)&#123;
            deleteOurPath(ourPath);
        &#125;
    &#125;
    return haveTheLock;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实 curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p>
<p><img src="https://i.loli.net/2020/09/08/fyikAEdrKow7acD.png" alt="img"></p>
<p>小结：</p>
<p>本节介绍了 zookeeperr 实现分布式锁的方案以及 zk 的开源客户端的基本使用，简要的介绍了其实现原理。</p>
<h2><span id="两种方案的优缺点比较">两种方案的优缺点比较 </span></h2><p> 学完了两种分布式锁的实现方案之后，本节需要讨论的是 redis 和 zk 的实现方案中各自的优缺点。</p>
<p>对于 redis 的分布式锁而言，它有以下缺点：</p>
<ul>
<li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li>
<li>另外来说的话，redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮</li>
<li>即便使用 redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 redlock 的讨论可以看 How to do distributed locking</li>
<li>redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<p>但是另一方面使用 redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”</p>
<p>所以使用 redis 作为分布式锁也不失为一种好的方案，最重要的一点是 redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p>
<p>对于 zk 分布式锁而言:</p>
<ul>
<li>zookeeper 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 zk 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 zk 集群的压力会比较大。</p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线上 CPU、磁盘、内存、网络排障指南</title>
    <url>/2016/11/15/java/Java%E7%BA%BF%E4%B8%8ACPU%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%BD%91%E7%BB%9C%E6%8E%92%E9%9A%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>线上故障主要会包括 cpu、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。</p>
<a id="more"></a>
<h2><span id="cpu">CPU</span></h2><p>一般来讲我们首先会排查 cpu 方面的问题。cpu 异常往往还是比较好定位的。原因包括业务逻辑问题 (死循环)、频繁 gc 以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑) 导致的，可以使用 jstack 来分析对应的堆栈情况。</p>
<h3><span id="使用-jstack-分析-cpu-问题">使用 jstack 分析 cpu 问题 </span></h3><p> 我们先用 ps 命令找到对应进程的 pid(如果你有好几个目标进程，可以先用 top 看一下哪个占用比较高)。</p>
<p>接着用 <code>top -H -p pid</code> 来找到 cpu 使用率比较高的一些线程</p>
<p><img src="https://i.loli.net/2020/09/10/Psh2MYojnEFqHat.jpg" alt="img"></p>
<p>然后将占用最高的 pid 转换为 16 进制 <code>printf &#39;%x\n&#39; pid</code> 得到 nid</p>
<p><img src="https://i.loli.net/2020/09/10/vYIU4RZnSDibXTE.png" alt="img"></p>
<p>接着直接在 jstack 中找到相应的堆栈信息<code>jstack pid |grep &#39;nid&#39; -C5 –color</code></p>
<p><img src="https://i.loli.net/2020/09/10/TdrKy4JzmGS38vQ.jpg" alt="img"></p>
<p>可以看到我们已经找到了 nid 为 0x42 的堆栈信息，接着只要仔细分析一番即可。</p>
<p>当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令 <code>cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</code> 来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。</p>
<p><img src="https://i.loli.net/2020/09/10/qvukawlV4ASCLYr.jpg" alt="img"></p>
<h3><span id="频繁-gc">频繁 gc</span></h3><p>当然我们还是会使用 jstack 来分析问题，但有时候我们可以先确定下 gc 是不是太频繁，使用 jstat -gc pid 1000 命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。如果看到 gc 比较频繁，再针对 gc 方面做进一步分析。</p>
<p><img src="https://i.loli.net/2020/09/10/qvukawlV4ASCLYr.jpg" alt="img"></p>
<h3><span id="上下文切换">上下文切换 </span></h3><p> 针对频繁上下文问题，我们可以使用 <code>vmstat</code> 命令来进行查看</p>
<p><img src="https://i.loli.net/2020/09/10/21fEDaHF7IczjPT.jpg" alt="img"></p>
<p>cs(context switch)一列则代表了上下文切换的次数。</p>
<p>如果我们希望对特定的 pid 进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch 和 nvcswch 表示自愿及非自愿切换。</p>
<p><img src="https://i.loli.net/2020/09/10/wcovumKWTCUD6aB.jpg" alt="img"></p>
<h2><span id="磁盘">磁盘 </span></h2><p> 磁盘问题和 cpu 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用 df -hl 来查看文件系统状态</p>
<p><img src="https://i.loli.net/2020/09/10/uiHITf3o8ZXPsSV.jpg" alt="img"></p>
<p>更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x 来进行分析</p>
<p><img src="https://i.loli.net/2020/09/10/gnYA7u5U2QZlecH.png" alt="img"></p>
<p>最后一列 %util 可以看到每块磁盘写入的程度，而 <code>rrqpm/s</code> 以及 <code>wrqm/s</code> 分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>
<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。</p>
<p><img src="https://i.loli.net/2020/09/10/NniI3GxHWQht8lT.jpg" alt="img"></p>
<p>不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。</p>
<p><img src="https://i.loli.net/2020/09/10/glP9n6ZNzTwLbei.png" alt="img"></p>
<p>找到 pid 之后就可以看这个进程具体的读写情况 cat /proc/pid/io</p>
<p><img src="https://i.loli.net/2020/09/10/rl5kqySPGWUcQDZ.jpg" alt="img"></p>
<p>我们还可以通过 lsof 命令来确定具体的文件读写情况 lsof -p pid</p>
<p><img src="https://i.loli.net/2020/09/10/UWp75fjZdX8OiVo.jpg" alt="img"></p>
<h2><span id="内存">内存 </span></h2><p> 内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用 free 命令先来检查一发内存的各种情况。</p>
<p><img src="https://i.loli.net/2020/09/10/HntqNjKrP74eFaJ.png" alt="img"></p>
<h3><span id="堆内内存">堆内内存 </span></h3><p> 内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 StackOverflow。</p>
<h3><span id="oom">OOM</span></h3><p>JMV 中的内存不足，OOM 大致可以分为以下几种：</p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个意思是没有足够的内存空间给线程分配 java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定 Xss 来减少单个 thread stack 的大小。</p>
<p>另外也可以在系统层面，可以通过修改 /<code>etc/security/limits.confnofile</code>和 <code>nproc</code> 来增大 os 对线程的限制</p>
<p><img src="https://i.loli.net/2020/09/10/x8SMawkbylmL5pX.png" alt="img"></p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个意思是堆的内存占用已经达到 <code>-Xmx</code> 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整 Xmx 的值来扩大内存。</p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log">Caused by: java.lang.OutOfMemoryError: Meta space<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个意思是元数据区的内存占用已经达到 <code>XX:MaxMetaspaceSize</code> 设置的最大值，排查思路和上面的一致，参数方面可以通过 <code>XX:MaxPermSize</code> 来进行调整(这里就不说 1.8 以前的永久代了)。</p>
<h3><span id="stack-overflow">Stack Overflow</span></h3><p>栈内存溢出，这个大家见到也比较多。</p>
<pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.StackOverflowError<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过 Xss 来调整，但调整的太大可能又会引起 OOM。</p>
<h3><span id="使用-jmap-定位代码内存泄漏">使用 JMAP 定位代码内存泄漏 </span></h3><p> 上述关于 OOM 和 StackOverflow 的代码排查方面，我们一般使用 <code>jmap -dump:format=b,file=filename pid</code> 来导出 dump 文件</p>
<p><img src="https://i.loli.net/2020/09/10/kv2SEUOha1IzVdp.jpg" alt="img"></p>
<p>通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。</p>
<p><img src="https://i.loli.net/2020/09/10/rxLs2k8YTbnw3QW.jpg" alt="img"></p>
<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。</p>
<p>另一方面，我们可以在启动参数中指定 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 来保存 OOM 时的 dump 文件。</p>
<p>搜索 Java 知音，回复“后端面试”，送你一份面试宝典.pdf</p>
<h3><span id="gc-问题和线程">gc 问题和线程</span></h3><p>gc 问题除了影响 cpu 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。</p>
<p>线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的 unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code>。</p>
<p><img src="https://i.loli.net/2020/09/10/Ldomz6FipC3g9sx.jpg" alt="img"></p>
<p>或者直接通过查看 <code>/proc/pid/task</code> 的数量即为线程数量。</p>
<p><img src="https://i.loli.net/2020/09/10/KXl9q3PeC4uZhVW.png" alt="img"></p>
<h3><span id="堆外内存">堆外内存 </span></h3><p> 如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现 OutOfDirectMemoryError 错误，如果直接是 DirectByteBuffer，那会报<code>OutOfMemoryError: Direct buffer memory</code>。</p>
<p>堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况<code>pmap -x pid | sort -rn -k3 | head -30</code>，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>
<p><img src="https://i.loli.net/2020/09/10/yAe86jb9Th5RGFZ.jpg" alt="img"></p>
<p>我们如果确定有可疑的内存端，需要通过 gdb 来分析<code>gdb --batch --pid &#123;pid&#125; -ex &quot;dump memory filename.dump</code> {内存起始地址} {内存起始地址 + 内存块大小}”</p>
<p><img src="https://i.loli.net/2020/09/10/DOCuaFyY6IkJhG1.png" alt="img"></p>
<p>获取 dump 文件后可用 heaxdump 进行查看<code>hexdump -C filename | less</code>，不过大多数看到的都是二进制乱码。</p>
<p>NMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 <code>-XX:NativeMemoryTracking=summary</code> 或者 <code>-XX:NativeMemoryTracking=detail</code>，会有略微性能损耗。</p>
<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线 jcmd pid VM.native_memory baseline。</p>
<p><img src="https://i.loli.net/2020/09/10/sl7HWJdLcqpmi4E.png" alt="img"></p>
<p>然后等放一段时间后再去看看内存增长的情况，通过 jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。</p>
<p><img src="https://i.loli.net/2020/09/10/8wQJxAlatNRFTPi.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/09/10/7FLWf9OAj8d6sNK.jpg" alt="img"></p>
<p>可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。</p>
<p>detail 级别的话还会有具体内存段的增长情况，如下图。</p>
<p><img src="https://i.loli.net/2020/09/10/fkhKF9vrTgqaz3X.png" alt="img"></p>
<p>此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e “brk,mmap,munmap” -p pid</p>
<p>这边内存分配信息主要包括了 pid 和内存地址。</p>
<p><img src="https://i.loli.net/2020/09/10/3rHv69CoIy4MUn5.jpg" alt="img"></p>
<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用 -XX:+DisableExplicitGC)。</p>
<p>那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过 jmap -histo:live pid 手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过 -XX:MaxDirectMemorySize 进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。</p>
<p>搜索 Java 知音，回复“后端面试”，送你一份面试宝典.pdf</p>
<h3><span id="gc-问题">GC 问题 </span></h3><p> 堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。</p>
<p>我们在 cpu 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上 <code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code> 来开启 GC 日志。</p>
<p>常见的 Young GC、Full GC 日志含义在此就不做赘述了。</p>
<p>针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。</p>
<h4><span id="younggc-过频繁">youngGC 过频繁</span></h4><p>youngGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区 / 新生代设置的太小了，看能否通过调整 -Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。</p>
<h4><span id="younggc-耗时过长">youngGC 耗时过长 </span></h4><p> 耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。</p>
<p>Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。</p>
<p><img src="https://i.loli.net/2020/09/10/cvMh2IJLtuXUi6r.jpg" alt="img"></p>
<h4><span id="触发-fullgc">触发 fullGC</span></h4><p>G1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。</p>
<p>fullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：</p>
<ul>
<li>并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数 -XX:ConcGCThreads。</li>
<li>晋升失败：在 GC 的时候没有足够的内存供存活 / 晋升对象使用，所以触发了 Full GC。这时候可以通过 -XX:G1ReservePercent 来增加预留内存百分比，减少 -XX:InitiatingHeapOccupancyPercent 来提前启动标记，-XX:ConcGCThreads 来增加标记线程数也是可以的。</li>
<li>大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大 -XX:G1HeapRegionSize。</li>
<li>程序主动执行 System.gc()：不要随便写就对了。</li>
</ul>
<p>另外，我们可以在启动参数中配置 <code>-XX:HeapDumpPath=/xxx/dump.hprof</code> 来 dump fullGC 相关的文件，并通过 <code>jinfo</code> 来进行 gc 前后的 dump</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jinfo -flag +HeapDumpBeforeFullGC pid 
jinfo -flag +HeapDumpAfterFullGC pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。</p>
<p>搜索 Java 知音，回复“后端面试”，送你一份面试宝典.pdf</p>
<h2><span id="网络">网络 </span></h2><p> 涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。</p>
<h3><span id="超时">超时 </span></h3><p> 超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>
<ul>
<li>读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。</li>
<li>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，jetty 中表示空闲连接清理时间，tomcat 则表示连接维持的最大时间。</li>
<li>其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</li>
</ul>
<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>
<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>
<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>
<p>服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>
<h3><span id="tcp-队列溢出">TCP 队列溢出</span></h3><p>tcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p>
<p><img src="https://i.loli.net/2020/09/10/BIG7MdLE6zwhDF2.jpg" alt="img"></p>
<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。</p>
<p>tcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多 connection reset / connection reset by peer。</p>
<p>那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？</p>
<p>netstat 命令，执行<code>netstat -s | egrep &quot;listen|LISTEN&quot;</code></p>
<p><img src="https://i.loli.net/2020/09/10/MzG4jAKBJCl8PbT.jpg" alt="img"></p>
<p>如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。</p>
<h3><span id="ss-命令执行-ss-lnt">ss 命令，执行 ss -lnt</span></h3><p><img src="https://i.loli.net/2020/09/10/i4ITEDY6M9hZmtz.png" alt="img"></p>
<p>上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。</p>
<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>
<p>全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>
<p>在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 tomcat 中 backlog 叫做 acceptCount，在 jetty 里面则是 acceptQueueSize。</p>
<h3><span id="rst-异常">RST 异常</span></h3><p>RST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>
<p>在实际开发中，我们往往会看到 connection reset / connection reset by peer 错误，这种情况就是 RST 包导致的。</p>
<h3><span id="端口不存在">端口不存在 </span></h3><p> 如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。</p>
<h3><span id="主动代替-fin-终止连接">主动代替 FIN 终止连接 </span></h3><p> 一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。</p>
<p>客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接</p>
<p>我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>
<p>接收到的 TCP 报文不在已知的 TCP 连接内</p>
<p>比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。</p>
<p>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文</p>
<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。</p>
<p>之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报 connection reset，而在一个已关闭的连接上写操作则会报 connection reset by peer。通常我们可能还会看到 broken pipe 错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出 connection reset 错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。</p>
<p>我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。<code>tcpdump -i en0 tcp -w xxx.cap</code>，en0 表示监听的网卡。</p>
<p><img src="https://i.loli.net/2020/09/10/kNByEcrUovZAXDK.png" alt="img"></p>
<p>接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。</p>
<p><img src="https://i.loli.net/2020/09/10/J8tYfoUl9pSF4A6.jpg" alt="img"></p>
<h3><span id="time_wait-和-close_wait">TIME_WAIT 和 CLOSE_WAIT</span></h3><p>TIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。</p>
<p>在线上时，我们可以直接用命令 <code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code> 来查看 time-wait 和 close_wait 的数量</p>
<p>用 ss 命令会更快<code>ss -ant | awk &#39;&#123;++S[$1]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-7634ccbe9502c93040e7e00c75754aad_720w.jpg" alt="img"></p>
<h3><span id="time_wait">TIME_WAIT</span></h3><p>time_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。</p>
<p>过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭</span>
net.ipv4.tcp_tw_reuse <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment"># 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收，默认为 0，表示关闭</span>
net.ipv4.tcp_tw_recycle <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小 tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报 time wait bucket table overflow 的错。</p>
<h3><span id="close_wait">CLOSE_WAIT</span></h3><p>close_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>
<p>想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>
<p>开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了 countdownlatch.await 方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的 class not found。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的 select</title>
    <url>/2020/01/17/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84select/</url>
    <content><![CDATA[<p>很多 C 语言或者 Unix 开发者听到 <code>select</code> 想到的都是系统调用，而谈到 I/O 模型时最终大都会提到基于 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建的 IO 多路复用模型。Go 语言的 <code>select</code> 与 C 语言中的 <code>select</code> 有着比较相似的功能。本节会介绍 Go 语言 <code>select</code> 常见的现象、数据结构以及四种不同情况下的实现原理。</p>
<a id="more"></a>
<p>C 语言中的 <code>select</code> 关键字可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 关键字也能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</p>
<p><img src="https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png" alt="Golang-Select-Channels"></p>
<p><strong>图 5-5 Select 和 Channels</strong></p>
<p><code>select</code> 是一种与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a> 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> c <span class="token operator">&lt;-</span> x<span class="token punctuation">:</span>
			x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>quit<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"quit"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个的返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，就会随机选择一个 <code>case</code> 执行。</p>
<h2><span id="现象">现象 </span></h2><p> 当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p>
<ol>
<li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li>
<li><code>select</code> 在遇到多个 Channel 同时响应时会随机挑选 <code>case</code> 执行；</li>
</ol>
<p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体的场景并分析这两个现象背后的设计原理。</p>
<h3><span id="非阻塞的收发">非阻塞的收发 </span></h3><p> 在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 <code>default</code> 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p>
<ol>
<li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code>；</li>
<li>当不存在可以收发的 Channel 是，执行 <code>default</code> 中的语句；</li>
</ol>
<p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码并返回。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
		<span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token keyword">default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象就非常合理。<code>select</code> 的作用就是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 中的代码也是理所当然的。</p>
<p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望向 Channel 发送消息或者从 Channel 中接收消息会阻塞当前 Goroutine，我们只是想看看 Channel 的可读或者可写状态。下面就是一个常见的例子：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">errCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>
wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> tasks <span class="token punctuation">&#123;</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            errCh <span class="token operator">&lt;-</span> err
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> err <span class="token operator">:=</span> <span class="token operator">&lt;-</span>errCh<span class="token punctuation">:</span>
    <span class="token keyword">return</span> err
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句就能很好地完成这个任务。然而使用 <code>select</code> 的语法不是最原始的设计，它在最初版本使用 <code>x, ok := &lt;-c</code> 的语法实现非阻塞的收发，以下是与非阻塞收发的相关提交：</p>
<ol>
<li><a href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff">select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code> 情况；</li>
<li><a href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16">gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发的特性。</li>
<li><a href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059">gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除；</li>
<li><a href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c">gc, runtime: replace closed(c) with x, ok := &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态；</li>
</ol>
<p>我们可以从上面的几个提交中看到非阻塞收发从最初到现在的演变。</p>
<h3><span id="随机执行">随机执行 </span></h3><p> 另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择那个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token keyword">range</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			ch <span class="token operator">&lt;-</span> <span class="token number">0</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"case1"</span><span class="token punctuation">)</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"case2"</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
case1
case2
case1
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p>
<p>这个设计是在十多年前被 <a href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d">select</a> 提交引入并一直保留到现在的，虽然中间经历过一些修改<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:6">6</a>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p>
<h2><span id="数据结构">数据结构</span></h2><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是 <code>select</code> 控制结构中的 <code>case</code> 却使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体来表示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> scase <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	c           <span class="token operator">*</span>hchan
	elem        unsafe<span class="token punctuation">.</span>Pointer
	kind        <span class="token builtin">uint16</span>
	pc          <span class="token builtin">uintptr</span>
	releasetime <span class="token builtin">int64</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体中也包含一个 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51"><code>runtime.hchan</code></a> 类型的字段存储 <code>case</code> 中使用的 Channel；除此之外，<code>elem</code> 是接收或者发送数据的变量地址、<code>kind</code> 表示 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 的种类，总共包含以下四种：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
	caseNil <span class="token operator">=</span> <span class="token boolean">iota</span>
	caseRecv
	caseSend
	caseDefault
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这四种常量分别表示不同类型的 <code>case</code>，相信它们的命名已经能够充分帮助我们理解它们的作用了，所以这里也不一一介绍了。</p>
<h2><span id="实现原理">实现原理</span></h2><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每一个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点:</p>
<p><img src="https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png" alt="golang-oselect-and-ocases"></p>
<p><strong>图 5-7 OSELECT 和多个 OCASE</strong></p>
<p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 <code>OCASE</code> 既包含执行条件也包含满足条件后执行的代码。</p>
<p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p>
<ol>
<li><code>select</code> 不存在任何的 <code>case</code>；</li>
<li><code>select</code> 只存在一个 <code>case</code>；</li>
<li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li>
<li><code>select</code> 存在多个 <code>case</code>；</li>
</ol>
<p>上述的四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两方面分析上述情况。</p>
<h3><span id="直接阻塞">直接阻塞 </span></h3><p> 首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code> 时编译器是如何进行处理的，我们截取 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数的前几行代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">walkselectcases</span><span class="token punctuation">(</span>cases <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node <span class="token punctuation">&#123;</span>
	n <span class="token operator">:=</span> cases<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">&#123;</span><span class="token function">mkcall</span><span class="token punctuation">(</span><span class="token string">"block"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码非常简单并且容易理解，它直接将类似 <code>select &#123;&#125;</code> 的空语句转换成调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">gopark</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonSelectNoCases<span class="token punctuation">,</span> traceEvGoStop<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数的实现非常简单，它会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 让出当前 Goroutine 对处理器的使用权，传入的等待原因是 <code>waitReasonSelectNoCases</code>。</p>
<p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p>
<h3><span id="单一管道">单一管道 </span></h3><p> 如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么就会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面展示了原始的 <code>select</code> 语句和被改写、优化后的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 改写前</span>
<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> v<span class="token punctuation">,</span> ok <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span> <span class="token comment">// case ch &lt;- v</span>
    <span class="token operator">...</span>    
<span class="token punctuation">&#125;</span>

<span class="token comment">// 改写后</span>
<span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch <span class="token comment">// case ch &lt;- v</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p>
<h3><span id="非阻塞操作">非阻塞操作 </span></h3><p> 当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数会对这种情况单独处理，不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址。我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p>
<h4><span id="发送">发送 </span></h4><p> 首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用 <code>if/else</code> 语句和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 函数改写代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span>
    <span class="token operator">...</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">if</span> <span class="token function">selectnbsend</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码中最重要的就是 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 函数，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a> 一节介绍了向 Channel 发送数据的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectnbsend</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">chansend</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于我们向 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 函数传入了 <code>false</code>，所以哪怕是不存在接收方或者缓冲区空间不足都不会阻塞当前 Goroutine 而是会直接返回。</p>
<h4><span id="接收">接收 </span></h4><p> 由于从 Channel 中接收数据可能会返回一个或者两个值，所以接受数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 改写前</span>
<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> v <span class="token operator">&lt;-</span> ch<span class="token punctuation">:</span> <span class="token comment">// case v, ok &lt;- ch:</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 改写后</span>
<span class="token keyword">if</span> <span class="token function">selectnbrecv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">,</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// if selectnbrecv2(&amp;v, &amp;ok, ch) &#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709"><code>runtime.selectnbrecv2</code></a> 只是对 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 返回值的处理稍有不同：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectnbrecv</span><span class="token punctuation">(</span>elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	selected<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">selectnbrecv2</span><span class="token punctuation">(</span>elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> received <span class="token operator">*</span><span class="token builtin">bool</span><span class="token punctuation">,</span> c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">(</span>selected <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	selected<span class="token punctuation">,</span> <span class="token operator">*</span>received <span class="token operator">=</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为接收方不需要，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 会直接忽略返回的布尔值，而 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709"><code>runtime.selectnbrecv2</code></a> 会将布尔值回传给调用方。与 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 一样，<a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 也提供了一个 <code>block</code> 参数用于控制这一次接收是否阻塞。</p>
<h3><span id="常见流程">常见流程 </span></h3><p> 在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p>
<ol>
<li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体；</li>
<li>调用运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 从多个准备就绪的 Channel 中选择一个可执行的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34"><code>runtime.scase</code></a> 结构体；</li>
<li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code></li>
</ol>
<p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">selv <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>scase<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
order <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">uint16</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> cas <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">&#123;</span>
    c <span class="token operator">:=</span> scase<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    c<span class="token punctuation">.</span>kind <span class="token operator">=</span> <span class="token operator">...</span>
    c<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token operator">...</span>
    c<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>
chosen<span class="token punctuation">,</span> revcOK <span class="token operator">:=</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>selv<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> chosen <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>
    <span class="token keyword">break</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p>
<ol>
<li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li>
<li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li>
</ol>
<h4><span id="初始化">初始化</span></h4><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cas1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>scase<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>cas0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	order1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">17</span><span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>order0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	
	scases <span class="token operator">:=</span> cas1<span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	pollorder <span class="token operator">:=</span> order1<span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	lockorder <span class="token operator">:=</span> order1<span class="token punctuation">[</span>ncases<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>ncases<span class="token punctuation">:</span>ncases<span class="token punctuation">]</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> scases <span class="token punctuation">&#123;</span>
		cas <span class="token operator">:=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ncases<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		j <span class="token operator">:=</span> <span class="token function">fastrandn</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		pollorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pollorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
		pollorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 根据 Channel 的地址排序确定加锁顺序</span>
	<span class="token operator">...</span>
	<span class="token function">sellock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p>
<ul>
<li>轮询顺序：通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L114-L118"><code>runtime.fastrandn</code></a> 函数引入随机性；</li>
<li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li>
</ul>
<p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L45-L54"><code>runtime.sellock</code></a> 函数会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p>
<h4><span id="循环">循环 </span></h4><p> 当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p>
<ol>
<li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li>
<li>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；</li>
<li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数会根据不同情况通过 <code>goto</code> 跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p>
<ul>
<li><code>bufrecv</code>：可以从缓冲区读取数据；</li>
<li><code>bufsend</code>：可以向缓冲区写入数据；</li>
<li><code>recv</code>：可以从休眠的发送方获取数据；</li>
<li><code>send</code>：可以向休眠的接收方发送数据；</li>
<li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li>
<li><code>sclose</code>：向关闭的 Channel 发送数据；</li>
<li><code>retc</code>：结束调用并返回；</li>
</ul>
<p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p>
<ol>
<li><p>```<br>caseNil</p>
<pre class="line-numbers language-none"><code class="language-none">
：当前

 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>case</p>
<pre class="line-numbers language-none"><code class="language-none">
    

   不包含 Channel；

   - 这种 &#96;case&#96; 会被跳过；

2. &#96;&#96;&#96;
   caseRecv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>：当前</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   会从 Channel 中接收数据；</p>
<ul>
<li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine，就会跳到 <code>recv</code> 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</li>
<li>如果当前 Channel 的缓冲区不为空，就会跳到 <code>bufrecv</code> 标签处从缓冲区获取数据；</li>
<li>如果当前 Channel 已经被关闭，就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li>
</ul>
<ol>
<li><p>```<br>caseSend</p>
<pre class="line-numbers language-none"><code class="language-none">
：当前

 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>case</p>
<pre class="line-numbers language-none"><code class="language-none">
    

   会向 Channel 发送数据；

   - 如果当前 Channel 已经被关，闭就会直接跳到 &#96;sclose&#96; 标签，触发 &#96;panic&#96; 尝试中止程序；
   - 如果当前 Channel 的 &#96;recvq&#96; 上有等待的 Goroutine，就会跳到 &#96;send&#96; 标签向 Channel 发送数据；
   - 如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；

4. &#96;&#96;&#96;
   caseDefault<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>：当前</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   为</p>
   <pre class="line-numbers language-none"><code class="language-none">default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   语句；</p>
<ul>
<li>表示前面的所有 <code>case</code> 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 <code>select</code> 结构中的收发都是非阻塞的；</li>
</ul>
<p><img src="https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png" alt="golang-runtime-selectgo"></p>
<p><strong>图 5-8 运行时 selectgo 函数</strong></p>
<p>第一阶段的主要职责是查找所有 <code>case</code> 中 Channel 是否有可以立刻被处理的情况。无论是在包含等待的 Goroutine 还是缓冲区中存在数据，只要满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 <code>sendq</code> 或者 <code>recvq</code> 队列中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	nextp <span class="token operator">=</span> <span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>waiting
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> casei <span class="token operator">:=</span> <span class="token keyword">range</span> lockorder <span class="token punctuation">&#123;</span>
		casi <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>casei<span class="token punctuation">)</span>
		cas <span class="token operator">=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>casi<span class="token punctuation">]</span>
		c <span class="token operator">=</span> cas<span class="token punctuation">.</span>c
		sg <span class="token operator">:=</span> <span class="token function">acquireSudog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		sg<span class="token punctuation">.</span>g <span class="token operator">=</span> gp
		sg<span class="token punctuation">.</span>c <span class="token operator">=</span> c

		<span class="token keyword">switch</span> cas<span class="token punctuation">.</span>kind <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> caseRecv<span class="token punctuation">:</span>
			c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
		<span class="token keyword">case</span> caseSend<span class="token punctuation">:</span>
			c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">gopark</span><span class="token punctuation">(</span>selparkcommit<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonSelect<span class="token punctuation">,</span> traceEvGoBlockSelect<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了将当前 Goroutine 对应的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体加入队列之外，这些 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 函数挂起当前 Goroutine 等待调度器的唤醒。</p>
<p><img src="https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png" alt="Golang-Select-Waiting"></p>
<p><strong>图 5-9 Goroutine 上等待收发的 sudog 链表</strong></p>
<p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数的第三阶段，从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体中获取数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectgo</span><span class="token punctuation">(</span>cas0 <span class="token operator">*</span>scase<span class="token punctuation">,</span> order0 <span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> ncases <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	sg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>sudog<span class="token punctuation">)</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>param<span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>

	casi <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
	cas <span class="token operator">=</span> <span class="token boolean">nil</span>
	sglist <span class="token operator">=</span> gp<span class="token punctuation">.</span>waiting
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> casei <span class="token operator">:=</span> <span class="token keyword">range</span> lockorder <span class="token punctuation">&#123;</span>
		k <span class="token operator">=</span> <span class="token operator">&amp;</span>scases<span class="token punctuation">[</span>casei<span class="token punctuation">]</span>
		<span class="token keyword">if</span> sg <span class="token operator">==</span> sglist <span class="token punctuation">&#123;</span>
			casi <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>casei<span class="token punctuation">)</span>
			cas <span class="token operator">=</span> k
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> k<span class="token punctuation">.</span>kind <span class="token operator">==</span> caseSend <span class="token punctuation">&#123;</span>
				c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">dequeueSudoG</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">dequeueSudoG</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		sgnext <span class="token operator">=</span> sglist<span class="token punctuation">.</span>waitlink
		sglist<span class="token punctuation">.</span>waitlink <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token function">releaseSudog</span><span class="token punctuation">(</span>sglist<span class="token punctuation">)</span>
		sglist <span class="token operator">=</span> sgnext
	<span class="token punctuation">&#125;</span>

	c <span class="token operator">=</span> cas<span class="token punctuation">.</span>c
	<span class="token keyword">goto</span> retc
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p>
<p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p>
<p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">bufrecv<span class="token punctuation">:</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">true</span>
	qp <span class="token operator">=</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">)</span>
	<span class="token keyword">if</span> cas<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>recvx<span class="token operator">++</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>recvx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>recvx <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>qcount<span class="token operator">--</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc

bufsend<span class="token punctuation">:</span>
	<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sendx<span class="token punctuation">)</span><span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>sendx<span class="token operator">++</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>sendx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>sendx <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>qcount<span class="token operator">++</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里在缓冲区进行的操作和直接调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278"><code>runtime.chansend</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579"><code>runtime.chanrecv</code></a> 函数差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p>
<p>两个直接对 Channel 收发的情况会调用 Channel 运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L286-L317"><code>runtime.send</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L594-L635"><code>runtime.recv</code></a>，这两个函数会直接与处于休眠状态的 Goroutine 打交道：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">recv<span class="token punctuation">:</span>
	<span class="token function">recv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token keyword">goto</span> retc

send<span class="token punctuation">:</span>
	<span class="token function">send</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">goto</span> retc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p>
<ul>
<li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li>
<li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">rclose<span class="token punctuation">:</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	recvOK <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token keyword">if</span> cas<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> cas<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">goto</span> retc

sclose<span class="token punctuation">:</span>
	<span class="token function">selunlock</span><span class="token punctuation">(</span>scases<span class="token punctuation">,</span> lockorder<span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"send on closed channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p>
<h2><span id="小结">小结 </span></h2><p> 我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p>
<ol>
<li><p>空的 <code>select</code> 语句会被转换成 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106"><code>runtime.block</code></a> 函数的调用，直接挂起当前 Goroutine；</p>
</li>
<li><p>如果</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">select<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   语句中只包含一个</p>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   ，就会被转换成</p>
   <pre class="line-numbers language-none"><code class="language-none">if ch &#x3D;&#x3D; nil &#123; block &#125;; n;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   表达式；</p>
<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 <code>case</code> 结构中的内容；</li>
</ul>
<ol>
<li><p>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664"><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</p>
</li>
<li><p>在默认情况下会通过 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</p>
</li>
</ol>
<p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497"><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p>
<ol>
<li><p>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</p>
</li>
<li><p>根据</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">pollOrder<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   遍历所有的</p>
   <pre class="line-numbers language-none"><code class="language-none">case<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   查看是否有可以立刻处理的 Channel；</p>
<ol>
<li>如果存在就直接获取 <code>case</code> 对应的索引并返回；</li>
<li>如果不存在就会创建 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305"><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li>
</ol>
<ol>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368"><code>runtime.sudog</code></a> 结构对应的索引；</li>
</ol>
<p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="http://man7.org/linux/man-pages/man2/select.2.html">SELECT(2) · Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的上下文与 Context</title>
    <url>/2020/01/19/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8EContext/</url>
    <content><![CDATA[<p>上下文 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系。<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p>
<a id="more"></a>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是 Go 语言在 1.7 版本中引入标准库的接口，该接口定义了四个需要实现的方法，其中包括：</p>
<ol>
<li><p><code>Deadline</code> — 返回 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 被取消的时间，也就是完成工作的截止日期；</p>
</li>
<li><p><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</p>
</li>
<li><p>```<br>Err</p>
<pre class="line-numbers language-none"><code class="language-none">
 

— 返回

 

&#96;context.Context&#96;

 

结束的原因，它只会在

 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Done</p>
<pre class="line-numbers language-none"><code class="language-none">
    

   返回的 Channel 被关闭时才会返回非空的值；

   1. 如果 [&#96;context.Context&#96;](https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;df2999ef43ea49ce1578137017949c0ee660608a&#x2F;src&#x2F;context&#x2F;context.go#L62-L154) 被取消，会返回 &#96;Canceled&#96; 错误；
   2. 如果 [&#96;context.Context&#96;](https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;df2999ef43ea49ce1578137017949c0ee660608a&#x2F;src&#x2F;context&#x2F;context.go#L62-L154) 超时，会返回 &#96;DeadlineExceeded&#96; 错误；

4. &#96;Value&#96; — 从 [&#96;context.Context&#96;](https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;df2999ef43ea49ce1578137017949c0ee660608a&#x2F;src&#x2F;context&#x2F;context.go#L62-L154) 中获取键对应的值，对于同一个上下文来说，多次调用 &#96;Value&#96; 并传入相同的 &#96;Key&#96; 会返回相同的结果，该方法可以用来传递请求特定的数据；

&#96;&#96;&#96;go
type Context interface &#123;
	Deadline() (deadline time.Time, ok bool)
	Done() &lt;-chan struct&#123;&#125;
	Err() error
	Value(key interface&#123;&#125;) interface&#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><a href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中提供的 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210"><code>context.Background</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218"><code>context.TODO</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236"><code>context.WithDeadline</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L513-L521"><code>context.WithValue</code></a> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p>
<h2><span id="设计原理">设计原理 </span></h2><p> 在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 的最大作用。Go 服务的每一个请求的都是通过单独的 Goroutine 处理的，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p>
<p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 的作用就是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p>
<p><img src="https://img.draveness.me/golang-context-usage.png" alt="golang-context-usage"></p>
<p>每一个 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 都会从最顶层的 Goroutine 一层一层传递到最下层。<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p>
<p><img src="https://img.draveness.me/golang-without-context.png" alt="golang-without-context"></p>
<p>如上图所示，当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗：</p>
<p><img src="https://img.draveness.me/golang-with-context.png" alt="golang-with-context"></p>
<p>我们可以通过一个代码片段了解 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 <code>handle</code> 函数，该方法会使用 500ms 的时间处理传入的『请求』：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token function">handle</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">500</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">handle</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> duration time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"handle"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"process request with"</span><span class="token punctuation">,</span> duration<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为过期时间大于处理时间，所以我们有足够的时间处理该『请求』，运行上述代码会打印出如下所示的内容：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> run context<span class="token punctuation">.</span><span class="token keyword">go</span>
process request with <span class="token number">500</span>ms
main context deadline exceeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>handle</code> 函数没有进入超时的 <code>select</code> 分支，但是 <code>main</code> 函数的 <code>select</code> 却会等待 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 的超时并打印出 <code>main context deadline exceeded</code>。</p>
<p>如果我们将处理『请求』时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> run context<span class="token punctuation">.</span><span class="token keyword">go</span>
main context deadline exceeded
handle context deadline exceeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>相信这两个例子能够帮助各位读者理解 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 的使用方法和设计原理 — 多个 Goroutine 同时订阅 <code>ctx.Done()</code> 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。</p>
<h2><span id="默认上下文">默认上下文</span></h2><p><a href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中最常用的方法还是 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210"><code>context.Background</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218"><code>context.TODO</code></a>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>，它们会在同一个 Go 程序中被复用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> background
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> todo
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个私有变量都是通过 <code>new(emptyCtx)</code> 语句初始化的，它们是指向私有结构体 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L171"><code>context.emptyCtx</code></a> 的指针，这是最简单、最常用的上下文类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> emptyCtx <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述代码，我们不难发现 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L171"><code>context.emptyCtx</code></a> 通过返回 <code>nil</code> 实现了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 接口，它没有任何特殊的功能。</p>
<p><img src="https://img.draveness.me/golang-context-hierarchy.png" alt="golang-context-hierarchy"></p>
<p><strong>图 6-4 Context 层级关系</strong></p>
<p>从源代码来看，<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210"><code>context.Background</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218"><code>context.TODO</code></a> 函数其实也只是互为别名，没有太大的差别。它们只是在使用和语义上稍有不同：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210"><code>context.Background</code></a> 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来；</li>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218"><code>context.TODO</code></a> 应该只在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210"><code>context.Background</code></a> 作为起始的上下文向下传递。</p>
<h2><span id="取消信号">取消信号</span></h2><p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236"><code>context.WithCancel</code></a> 函数能够从 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154"><code>context.Context</code></a> 中衍生出一个新的子上下文并返回用于取消该上下文的函数（CancelFunc）。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<p><img src="https://img.draveness.me/2020-01-20-15795072700927-golang-parent-cancel-context.png" alt="golang-parent-cancel-context"></p>
<p>我们直接从 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236"><code>context.WithCancel</code></a> 函数的实现来看它到底做了什么：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
	<span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L239-L241"><code>context.newCancelCtx</code></a> 将传入的上下文包装成私有结构体 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348"><code>context.cancelCtx</code></a>；</li>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L247-L283"><code>context.propagateCancel</code></a> 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> child canceler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	done <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> done <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token comment">// 父上下文不会触发取消信号</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>done<span class="token punctuation">:</span>
		child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 父上下文已经被取消</span>
		<span class="token keyword">return</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
		p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> p<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>err<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">case</span> <span class="token operator">&lt;-</span>parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
				child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">case</span> <span class="token operator">&lt;-</span>child<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述函数总共与父上下文相关的三种不同的情况：</p>
<ol>
<li><p>当 <code>parent.Done() == nil</code>，也就是 <code>parent</code> 不会触发取消事件时，当前函数会直接返回；</p>
</li>
<li><p>当</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">child<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   的继承链包含可以取消的上下文时，会判断</p>
   <pre class="line-numbers language-none"><code class="language-none">parent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   是否已经触发了取消信号；</p>
<ul>
<li>如果已经被取消，<code>child</code> 会立刻被取消；</li>
<li>如果没有被取消，<code>child</code> 会被加入 <code>parent</code> 的 <code>children</code> 列表中，等待 <code>parent</code> 释放取消信号；</li>
</ul>
<ol>
<li><p>在默认情况下</p>
<ol>
<li>运行一个新的 Goroutine 同时监听 <code>parent.Done()</code> 和 <code>child.Done()</code> 两个 Channel</li>
<li>在 <code>parent.Done()</code> 关闭时调用 <code>child.cancel</code> 取消子上下文；</li>
</ol>
</li>
</ol>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L247-L283"><code>context.propagateCancel</code></a> 的作用是在 <code>parent</code> 和 <code>child</code> 之间同步取消和结束的信号，保证在 <code>parent</code> 被取消时，<code>child</code> 也会收到对应的信号，不会发生状态不一致的问题。</p>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348"><code>context.cancelCtx</code></a> 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 <code>cancel</code>，这个方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>err <span class="token operator">=</span> err
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>done <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>done <span class="token operator">=</span> closedchan
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>done<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> child <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>children <span class="token punctuation">&#123;</span>
		child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token boolean">nil</span>
	c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> removeFromParent <span class="token punctuation">&#123;</span>
		<span class="token function">removeChild</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236"><code>context.WithCancel</code></a> 之外，<a href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的另外两个函数 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L427-L450"><code>context.WithDeadline</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L496-L498"><code>context.WithTimeout</code></a> 也都能创建可以被取消的计时器上下文 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460"><code>context.timerCtx</code></a>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> d time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> cur<span class="token punctuation">,</span> ok <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span><span class="token function">Before</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">&#123;</span>
		cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>
		deadline<span class="token punctuation">:</span>  d<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
	dur <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token keyword">if</span> dur <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment">// 已经过了截止日期</span>
		<span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>dur<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L427-L450"><code>context.WithDeadline</code></a> 方法在创建 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460"><code>context.timerCtx</code></a> 的过程中，判断了父上下文的截止日期与当前日期，并通过 <a href="https://github.com/golang/go/blob/001fe7f33f1d7aed9e3a047bd8e784bdc103c28c/src/time/sleep.go#L155-L165"><code>time.AfterFunc</code></a> 创建定时器，当时间超过了截止日期后会调用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L472-L484"><code>context.timerCtx.cancel</code></a> 方法同步取消信号。</p>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460"><code>context.timerCtx</code></a> 结构体内部不仅通过嵌入了<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348"><code>context.cancelCtx</code></a> 结构体继承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消这一功能：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timerCtx <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	cancelCtx
	timer <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer <span class="token comment">// Under cancelCtx.mu.</span>

	deadline time<span class="token punctuation">.</span>Time
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>timerCtx<span class="token punctuation">)</span> <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>deadline<span class="token punctuation">,</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>timerCtx<span class="token punctuation">)</span> <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token keyword">if</span> removeFromParent <span class="token punctuation">&#123;</span>
		<span class="token function">removeChild</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>timer <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		c<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		c<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L472-L484"><code>context.timerCtx.cancel</code></a> 方法不仅调用了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L391-L416"><code>context.cancelCtx.cancel</code></a>，还会停止持有的定时器减少不必要的资源浪费。</p>
<h2><span id="传值方法">传值方法 </span></h2><p> 在最后我们需要了解如何使用上下文传值，<a href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L513-L521"><code>context.WithValue</code></a> 函数能从父上下文中创建一个子上下文，传值的子上下文使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528"><code>context.valueCtx</code></a> 类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Context <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>reflectlite<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"key is not comparable"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">&#123;</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528"><code>context.valueCtx</code></a> 结构体会将除了 <code>Value</code> 之外的 <code>Err</code>、<code>Deadline</code> 等方法代理到父上下文中，它只会响应 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L549-L554"><code>context.valueCtx.Value</code></a> 方法，这个方法的实现也很简单：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Context
	key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> c<span class="token punctuation">.</span>val
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528"><code>context.valueCtx</code></a> 中存储的键值对与 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L549-L554"><code>context.valueCtx.Value</code></a> 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到在某个父上下文中返回 <code>nil</code> 或者查找到对应的值。</p>
<h2><span id="小结">小结</span></h2><p>Go 语言中的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154"><code>context.Context</code></a> 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，使用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154"><code>context.Context</code></a> 进行传递参数请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://golang.org/pkg/context/">Package context · Golang</a></li>
<li><a href="https://blog.golang.org/context">Go Concurrency Patterns: Context</a></li>
<li><a href="https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/">Using context cancellation in Go</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的函数调用</title>
    <url>/2020/01/08/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>函数是 Go 语言中的一等公民，理解和掌握函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数的传递方法两个方面分别介绍函数的执行过程。</p>
<a id="more"></a>
<h2><span id="调用惯例">调用惯例 </span></h2><p> 无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">somefunction</span><span class="token punctuation">(</span>arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，我们将在这里为各位读者分别介绍 C 和 Go 语言的调用惯例。</p>
<h3><span id="c-语言">C 语言 </span></h3><p> 我们先来研究 C 语言的调用惯例，使用 <a href="https://gcc.gnu.org/">GCC</a>和 <a href="https://clang.llvm.org/">Clang</a>编译器将 C 语言编译成汇编代码是分析它调用惯例的最好方法，从汇编语言中可以一窥函数调用的具体过程。</p>
<p>GCC 和 Clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 GCC 编译器来编译 C 语言：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc --version
gcc <span class="token punctuation">(</span>Ubuntu <span class="token number">9.3</span>.0-10ubuntu2<span class="token punctuation">)</span> <span class="token number">9.3</span>.0
Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2019</span> Free Software Foundation, Inc.
This is <span class="token function">free</span> software<span class="token punctuation">;</span> see the <span class="token builtin class-name">source</span> <span class="token keyword">for</span> copyingconditions.  There is NO
warranty<span class="token punctuation">;</span> not even <span class="token keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设我们有以下的 C 语言代码，代码中只包含两个函数，其中一个是主函数 <code>main</code>，另一个是我们定义的函数 <code>my_function</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ch04/my_function.c</span>
<span class="token keyword">int</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以使用 <code>cc -S my_function.c</code> 命令将上述文件编译成如下所示的汇编代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">main<span class="token operator">:</span>
	pushq	<span class="token operator">%</span>rbp
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rbp
	subq	$<span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
	movl	$<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">%</span>esi  <span class="token comment">// 设置第二个参数</span>
	movl	$<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>edi  <span class="token comment">// 设置第一个参数</span>
	call	my_function
	movl	<span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>
my_function<span class="token operator">:</span>
	pushq	<span class="token operator">%</span>rbp
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rbp
	movl	<span class="token operator">%</span>edi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>    <span class="token comment">// 取出第一个参数，放到栈上</span>
	movl	<span class="token operator">%</span>esi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>    <span class="token comment">// 取出第二个参数，放到栈上</span>
	movl	<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax    <span class="token comment">// eax = esi = 1</span>
	movl	<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>edx    <span class="token comment">// edx = edi = 2</span>
	addl	<span class="token operator">%</span>edx<span class="token punctuation">,</span> <span class="token operator">%</span>eax        <span class="token comment">// eax = eax + edx = 1 + 2 = 3</span>
	popq	<span class="token operator">%</span>rbp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们按照 <code>my_function</code> 函数调用前、调用时以及调用后三个部分分析上述调用过程：</p>
<ul>
<li>在 <code>my_function</code> 调用之前，调用方 <code>main</code> 函数将 <code>my_function</code> 的两个参数分别存到 edi 和 esi 寄存器中；</li>
<li>在 <code>my_function</code> 执行时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 <code>addl</code> 计算两个入参之和；</li>
<li>在 <code>my_function</code> 调用之后，使用寄存器 eax 传递返回值，<code>main</code> 函数将 <code>my_function</code> 的返回值存储到栈上的 <code>i</code> 变量中；</li>
</ul>
<p>当 <code>my_function</code> 函数的入参增加至八个，这时重新编译当前的程序可以会得到不同的汇编语言：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">main<span class="token operator">:</span>
	pushq	<span class="token operator">%</span>rbp
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rbp
	subq	$<span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp     <span class="token comment">// 为参数传递申请 16 字节的栈空间</span>
	movl	$<span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span>   <span class="token comment">// 传递第 8 个参数</span>
	movl	$<span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span>    <span class="token comment">// 传递第 7 个参数</span>
	movl	$<span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">%</span>r9d
	movl	$<span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">%</span>r8d
	movl	$<span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">%</span>ecx
	movl	$<span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">%</span>edx
	movl	$<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">%</span>esi
	movl	$<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>edi
	call	my_function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>main</code> 函数调用 <code>my_function</code> 时，前六个参数是使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递的。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存器，第二个参数使用 esi 寄存器，以此类推。</p>
<p>最后的两个参数与前面的完全不同，调用方 <code>main</code> 函数通过传递这两个参数，图 4-1 展示了 <code>main</code> 函数在调用 <code>my_function</code> 前的栈信息：</p>
<p><img src="https://i.loli.net/2020/09/04/siN1dErocqeCAXb.png" alt="c-function-call-stack"></p>
<p>上图中 rbp 寄存器的作用是存储函数调用栈的基址指针，即属于 <code>main</code> 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 <code>main</code> 函数调用栈结束的位置，这两个寄存器共同表示了一个函数的栈空间。</p>
<p>在调用 <code>my_function</code> 之前，<code>main</code> 函数通过 <code>subq $16, %rsp</code> 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 <code>call my_function</code> 指令会调用 <code>my_function</code> 函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">my_function<span class="token operator">:</span>
	pushq	<span class="token operator">%</span>rbp
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rbp
	movl	<span class="token operator">%</span>edi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>    <span class="token comment">// rbp-4 = edi = 1</span>
	movl	<span class="token operator">%</span>esi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>    <span class="token comment">// rbp-8 = esi = 2</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	movl	<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax    <span class="token comment">// eax = 2</span>
	movl	<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>edx    <span class="token comment">// edx = 1</span>
	addl	<span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>edx        <span class="token comment">// edx = eax + edx = 3</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	movl	<span class="token number">16</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax    <span class="token comment">// eax = 7</span>
	addl	<span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>edx        <span class="token comment">// edx = eax + edx = 28</span>
	movl	<span class="token number">24</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax    <span class="token comment">// eax = 8</span>
	addl	<span class="token operator">%</span>edx<span class="token punctuation">,</span> <span class="token operator">%</span>eax        <span class="token comment">// edx = eax + edx = 36</span>
	popq	<span class="token operator">%</span>rbp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>my_function</code> 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p>
<p>我们可以将本节的发现和分析简单总结成 —— 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ul>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li>
</ul>
<p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p>
<h3><span id="go-语言">Go 语言 </span></h3><p> 分析了 C 语言函数的调用惯例之后，我们再来剖析一下 Go 语言中函数的调用惯例。我们以下面这个非常简单的代码片段为例简要分析一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> a <span class="token operator">-</span> b
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述的 <code>myFunction</code> 函数接受两个整数并返回两个整数，<code>main</code> 函数在调用 <code>myFunction</code> 时将 66 和 77 两个参数传递到当前函数中，使用 <code>go tool compile -S -N -l main.go</code> 命令编译上述代码可以得到如下所示的汇编指令：</p>
<blockquote>
<p>注：如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化，编译结果会有较大差别。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token string">""</span><span class="token punctuation">.</span>main STEXT size<span class="token operator">=</span><span class="token number">68</span> args<span class="token operator">=</span><span class="token number">0x0</span> locals<span class="token operator">=</span><span class="token number">0x28</span>
	<span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	MOVQ	<span class="token punctuation">(</span>TLS<span class="token punctuation">)</span><span class="token punctuation">,</span> CX
	<span class="token number">0x0009</span> <span class="token number">00009</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	CMPQ	SP<span class="token punctuation">,</span> <span class="token function">16</span><span class="token punctuation">(</span>CX<span class="token punctuation">)</span>
	<span class="token number">0x000d</span> <span class="token number">00013</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	JLS	<span class="token number">61</span>
	<span class="token number">0x000f</span> <span class="token number">00015</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	SUBQ	$<span class="token number">40</span><span class="token punctuation">,</span> SP      <span class="token comment">// 分配 40 字节栈空间</span>
	<span class="token number">0x0013</span> <span class="token number">00019</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	MOVQ	BP<span class="token punctuation">,</span> <span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>   <span class="token comment">// 将基址指针存储到栈上</span>
	<span class="token number">0x0018</span> <span class="token number">00024</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>	LEAQ	<span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP
	<span class="token number">0x001d</span> <span class="token number">00029</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">)</span>	MOVQ	$<span class="token number">66</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>    <span class="token comment">// 第一个参数</span>
	<span class="token number">0x0025</span> <span class="token number">00037</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">)</span>	MOVQ	$<span class="token number">77</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>   <span class="token comment">// 第二个参数</span>
	<span class="token number">0x002e</span> <span class="token number">00046</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">)</span>	CALL	<span class="token string">""</span><span class="token punctuation">.</span><span class="token function">myFunction</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	<span class="token number">0x0033</span> <span class="token number">00051</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	MOVQ	<span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP
	<span class="token number">0x0038</span> <span class="token number">00056</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	ADDQ	$<span class="token number">40</span><span class="token punctuation">,</span> SP
	<span class="token number">0x003c</span> <span class="token number">00060</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据 <code>main</code> 函数生成的汇编指令，我们可以分析出 <code>main</code> 函数调用 <code>myFunction</code> 之前的栈情况：</p>
<p><img src="https://i.loli.net/2020/09/04/JRUEtl4yHBY6TXq.png" alt="golang-function-call-stack-before-calling"></p>
<p><code>main</code> 函数通过 <code>SUBQ $40, SP</code> 指令一共在栈上分配了 40 字节的内存空间：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>空间</th>
<th>大小</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SP+32 ~ BP</td>
<td>8 字节</td>
<td><code>main</code> 函数的栈基址指针</td>
</tr>
<tr>
<td>SP+16 ~ SP+32</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个返回值</td>
</tr>
<tr>
<td>SP ~ SP+16</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个参数</td>
</tr>
</tbody>
</table>
</div>
<p><code>myFunction</code> 入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 SP ~ SP+8，第二个参数存储在 SP+8 ~ SP+16 的空间中。</p>
<p>当我们准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并开始执行 <code>myFunction</code> 的汇编指令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token string">""</span><span class="token punctuation">.</span>myFunction STEXT nosplit size<span class="token operator">=</span><span class="token number">49</span> args<span class="token operator">=</span><span class="token number">0x20</span> locals<span class="token operator">=</span><span class="token number">0x0</span>
	<span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>	MOVQ	$<span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r2<span class="token operator">+</span><span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// 初始化第一个返回值</span>
	<span class="token number">0x0009</span> <span class="token number">00009</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>	MOVQ	$<span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r3<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// 初始化第二个返回值</span>
	<span class="token number">0x0012</span> <span class="token number">00018</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token comment">// AX = 66</span>
	<span class="token number">0x0017</span> <span class="token number">00023</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	ADDQ	<span class="token string">""</span><span class="token punctuation">.</span>b<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX   <span class="token comment">// AX = AX + 77 = 143</span>
	<span class="token number">0x001c</span> <span class="token number">00028</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r2<span class="token operator">+</span><span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// (24)SP = AX = 143</span>
	<span class="token number">0x0021</span> <span class="token number">00033</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token comment">// AX = 66</span>
	<span class="token number">0x0026</span> <span class="token number">00038</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	SUBQ	<span class="token string">""</span><span class="token punctuation">.</span>b<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX   <span class="token comment">// AX = AX - 77 = -11</span>
	<span class="token number">0x002b</span> <span class="token number">00043</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r3<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// (32)SP = AX = -11</span>
	<span class="token number">0x0030</span> <span class="token number">00048</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>	RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述的汇编代码中我们可以看出，当前函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如图 4-3 所示：</p>
<p><img src="https://i.loli.net/2020/09/04/VY1tQJNkSi94sDv.png" alt="golang-function-call-stack-before-return"></p>
<p>在 <code>myFunction</code> 返回之后，<code>main</code> 函数会通过以下的指令来恢复栈基址指针并销毁已经失去作用的 40 字节的栈空间：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">0x0033</span> <span class="token number">00051</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>    MOVQ    <span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP
<span class="token number">0x0038</span> <span class="token number">00056</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>    ADDQ    $<span class="token number">40</span><span class="token punctuation">,</span> SP
<span class="token number">0x003c</span> <span class="token number">00060</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>    RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过分析 Go 语言编译后的汇编指令，我们发现 Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<h3><span id="思考">思考</span></h3><p>C 语言和 Go 语言在设计函数的调用惯例时选择也不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li>CPU 访问栈的开销比访问寄存器高几十倍；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h2><span id="参数传递">参数传递 </span></h2><p> 除了函数的调用惯例之外，Go 语言在传递参数时是传值还是传引用也是一个有趣的问题，这个问题影响的是当我们在函数中对入参进行修改时会不会影响调用方看到的数据。我们先来介绍一下传值和传引用两者的区别：</p>
<ul>
<li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li>
<li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li>
</ul>
<p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式，<strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。本节剩下的内容将会验证这个结论的正确性。</p>
<h3><span id="整型和数组">整型和数组 </span></h3><p> 我们先来分析 Go 语言是如何传递基本类型和数组的。如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> arr <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">:=</span> <span class="token number">30</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"before calling - i=(%d, %p) arr=(%v, %p)\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span>
	<span class="token function">myFunction</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"after  calling - i=(%d, %p) arr=(%v, %p)\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
before calling <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0xc00009a000</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc00009a010</span><span class="token punctuation">)</span>
in my_funciton <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0xc00009a008</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc00009a020</span><span class="token punctuation">)</span>
after  calling <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0xc00009a000</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc00009a010</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们通过命令运行这段代码我们会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p>
<p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。那么如果我们在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？我们更新 <code>myFunction</code> 函数并重新执行这段代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> arr <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">=</span> <span class="token number">29</span>
	arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">88</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
before calling <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0xc000072008</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc000072010</span><span class="token punctuation">)</span>
in my_funciton <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">0xc000072028</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc000072040</span><span class="token punctuation">)</span>
after  calling <span class="token operator">-</span> i<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0xc000072008</span><span class="token punctuation">)</span> arr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">66</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xc000072010</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以我们能给出如下的结论 - <strong>Go 语言中对于整型和数组类型的参数都是值传递的</strong>，也就是在调用函数时会对内容进行拷贝，需要注意的是如果当前数组的大小非常的大，这种传值方式就会对性能造成比较大的影响。</p>
<h3><span id="结构体和指针">结构体和指针 </span></h3><p> 接下来我们继续分析 Go 语言另外两种常见类型 —— 结构体和指针。在这段代码中定义一个只包含一个成员变量的简单结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	i <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>a MyStruct<span class="token punctuation">,</span> b <span class="token operator">*</span>MyStruct<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">31</span>
	b<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">41</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"in my_function - a=(%d, %p) b=(%v, %p)\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> MyStruct<span class="token punctuation">&#123;</span>i<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">&#125;</span>
	b <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyStruct<span class="token punctuation">&#123;</span>i<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"before calling - a=(%d, %p) b=(%v, %p)\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
	<span class="token function">myFunction</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"after calling  - a=(%d, %p) b=(%v, %p)\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
before calling <span class="token operator">-</span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc000018178</span><span class="token punctuation">)</span> b<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">&#123;</span><span class="token number">40</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc00000c028</span><span class="token punctuation">)</span>
in my_function <span class="token operator">-</span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">31</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc000018198</span><span class="token punctuation">)</span> b<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">&#123;</span><span class="token number">41</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc00000c038</span><span class="token punctuation">)</span>
after calling  <span class="token operator">-</span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc000018178</span><span class="token punctuation">)</span> b<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">&#123;</span><span class="token number">41</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0xc00000c028</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从运行的结果我们可以得出如下结论：</p>
<ul>
<li>传递结构体时：会对结构体中的全部内容进行拷贝；</li>
<li>传递结构体指针时：会对结构体指针进行拷贝；</li>
</ul>
<p>对结构体指针的修改是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是我们先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	i <span class="token builtin">int</span>
	j <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>ms <span class="token operator">*</span>MyStruct<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ptr <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		c <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">*</span>c <span class="token operator">+=</span> i <span class="token operator">+</span> <span class="token number">1</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[%p] %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyStruct<span class="token punctuation">&#123;</span>i<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span> j<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">&#125;</span>
	<span class="token function">myFunction</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[%p] %v\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token punctuation">[</span><span class="token number">0xc000018180</span><span class="token punctuation">]</span> <span class="token number">41</span>
<span class="token punctuation">[</span><span class="token number">0xc000018188</span><span class="token punctuation">]</span> <span class="token number">52</span>
<span class="token punctuation">[</span><span class="token number">0xc000018180</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span><span class="token punctuation">&#123;</span><span class="token number">41</span> <span class="token number">52</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这段代码中，我们通过指针的方式修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p>
<p>如果我们将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	i <span class="token builtin">int</span>
	j <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>ms <span class="token operator">*</span>MyStruct<span class="token punctuation">)</span> <span class="token operator">*</span>MyStruct <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> ms
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> tool compile <span class="token operator">-</span>S <span class="token operator">-</span>N <span class="token operator">-</span>l main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token string">""</span><span class="token punctuation">.</span>myFunction STEXT nosplit size<span class="token operator">=</span><span class="token number">20</span> args<span class="token operator">=</span><span class="token number">0x10</span> locals<span class="token operator">=</span><span class="token number">0x0</span>
	<span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">)</span>	MOVQ	$<span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r1<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// 初始化返回值</span>
	<span class="token number">0x0009</span> <span class="token number">00009</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>ms<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX   <span class="token comment">// 复制引用</span>
	<span class="token number">0x000e</span> <span class="token number">00014</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r1<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// 返回引用</span>
	<span class="token number">0x0013</span> <span class="token number">00019</span> <span class="token punctuation">(</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">)</span>	RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这段汇编语言中我们发现当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令对引用进行复制，然后将复制后的指针作为返回值传递回调用方。</p>
<p><img src="https://i.loli.net/2020/09/04/DIEtN3Tvl764BZi.png" alt="golang-pointer-as-argument"></p>
<p>所以将指针作为参数传入某一个函数时，在函数内部会对指针进行复制，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中『传指针』也是传值。</p>
<h3><span id="传值">传值 </span></h3><p> 当我们对 Go 语言中大多数常见的数据结构进行验证之后，其实就能够推测出 Go 语言在传递参数时其实使用的就是传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数类型来避免发生大量数据的拷贝而影响性能。</p>
<h2><span id="小结">小结 </span></h2><p> 这一节我们详细分析了 Go 语言的调用惯例，包括传递参数和返回值的过程和原理。Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，我们可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的反射</title>
    <url>/2020/01/18/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射是 Go 语言比较重要的特性。虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制实现简化代码的逻辑。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包能够弥补它在语法上的一些劣势。</p>
<a id="more"></a>
<p><a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 实现了运行时的反射能力，能够让程序操作不同类型的对象。反射包中有两对非常重要的函数和类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 能获取类型信息，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 能获取数据的运行时表示，另外两个类型是 <code>Type</code> 和 <code>Value</code>，它们与函数是一一对应的关系：</p>
<p><img src="https://i.loli.net/2020/09/11/ed6U9csrRv57onb.png" alt="golang-reflection"></p>
<p>类型 <code>Type</code> 是反射包定义的一个接口，我们可以使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 函数获取任意变量的的类型，<code>Type</code> 接口中定义了一些有趣的方法，<code>MethodByName</code> 可以获取当前类型对应方法的引用、<code>Implements</code> 可以判断当前类型是否实现了某个接口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Type <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
        <span class="token function">Align</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
        <span class="token function">FieldAlign</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
        <span class="token function">Method</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> Method
        <span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Method<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
        <span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
        <span class="token operator">...</span>
        <span class="token function">Implements</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>
        <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反射包中 <code>Value</code> 的类型与 <code>Type</code> 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Value <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// contains filtered or unexported fields</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">Addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Value
<span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">Bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反射包中的所有方法基本都是围绕着 <code>Type</code> 和 <code>Value</code> 这两个类型设计的。我们通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 可以将一个普通的变量转换成『反射』包中提供的 <code>Type</code> 和 <code>Value</code>，随后就可以使用反射包中的方法对它们进行复杂的操作。</p>
<h2><span id="三大法则">三大法则 </span></h2><p> 运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码，其中包括：</p>
<ol>
<li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li>
<li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<h3><span id="第一法则">第一法则 </span></h3><p> 反射的第一法则是我们能将 Go 语言的 <code>interface&#123;&#125;</code> 变量转换成反射对象。很多读者可能会对这以法则产生困惑 —— 为什么是从 <code>interface&#123;&#125;</code> 变量到反射对象？当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface&#123;&#125;</code> 类型，所以在方法执行的过程中发生了类型转换。</p>
<p>在 <a href="http://draveness.me/golang-function-call"> 函数调用 </a> 一节中曾经介绍过，Go 语言的函数调用都是值传递的，变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface&#123;&#125;</code> 类型，这也就是为什么第一条法则是『从接口到反射对象』。</p>
<p>上面提到的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的『世界』，那么这两个函数就是连接这两个世界的桥梁。</p>
<p><img src="https://i.loli.net/2020/09/11/4itVukPmpZM73dg.png" alt="golang-interface-to-reflection"></p>
<p><strong>接口到反射对象</strong></p>
<p>我们通过以下例子简单介绍这两个函数的作用，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 获取了变量 <code>author</code> 的类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 获取了变量的值 <code>draven</code>。如果我们知道了一个变量的类型和值，那么就意味着知道了这个变量的全部信息。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"reflect"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	author <span class="token operator">:=</span> <span class="token string">"draven"</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"TypeOf author:"</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ValueOf author:"</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
TypeOf author<span class="token punctuation">:</span> <span class="token builtin">string</span>
ValueOf author<span class="token punctuation">:</span> draven<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了变量的类型之后，我们可以通过 <code>Method</code> 方法获得类型实现的方法，通过 <code>Field</code> 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p>
<ul>
<li>结构体：获取字段的数量并通过下标和字段名获取字段 <code>StructField</code>；</li>
<li>哈希表：获取哈希表的 <code>Key</code> 类型；</li>
<li>函数或方法：获取入参和返回值的类型；</li>
<li>…</li>
</ul>
<p>总而言之，使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p>
<h3><span id="第二法则">第二法则 </span></h3><p> 反射的第二法则是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 中的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994"><code>reflect.Value.Interface</code></a> 方法就能完成这项工作：</p>
<p><img src="https://i.loli.net/2020/09/11/bvghG2u3EILPRrx.png" alt="golang-reflection-to-interface"></p>
<p><strong>反射对象到接口</strong></p>
<p>不过调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994"><code>reflect.Value.Interface</code></a> 方法只能获得 <code>interface&#123;&#125;</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
v<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从反射对象到接口值的过程就是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p>
<ul>
<li>从接口值到反射对象：<ul>
<li>从基本类型到接口类型的类型转换；</li>
<li>从接口类型到反射对象的转换；</li>
</ul>
</li>
<li>从反射对象到接口值：<ul>
<li>反射对象转换成接口类型；</li>
<li>通过显式类型转换变成原始类型；</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/11/WUurJpdtQ9fTa7Z.png" alt="golang-bidirectional-reflection"><strong>接口和反射对象的双向转换</strong></p>
<p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是 <code>interface&#123;&#125;</code> 类型，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p>
<h3><span id="第三法则">第三法则</span></h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的，假设我们有以下代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">:=</span> <span class="token number">1</span>
	v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	v<span class="token punctuation">.</span><span class="token function">SetInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run reflect<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token builtin">panic</span><span class="token punctuation">:</span> reflect<span class="token punctuation">:</span> reflect<span class="token punctuation">.</span>flag<span class="token punctuation">.</span>mustBeAssignable using unaddressable value

goroutine <span class="token number">1</span> <span class="token punctuation">[</span>running<span class="token punctuation">]</span><span class="token punctuation">:</span>
reflect<span class="token punctuation">.</span>flag<span class="token punctuation">.</span><span class="token function">mustBeAssignableSlow</span><span class="token punctuation">(</span><span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x1014c0</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>reflect<span class="token operator">/</span>value<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">247</span> <span class="token operator">+</span><span class="token number">0x180</span>
reflect<span class="token punctuation">.</span>flag<span class="token punctuation">.</span><span class="token function">mustBeAssignable</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>reflect<span class="token operator">/</span>value<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">234</span>
reflect<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token function">SetInt</span><span class="token punctuation">(</span><span class="token number">0x100dc0</span><span class="token punctuation">,</span> <span class="token number">0x414020</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x1840</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>reflect<span class="token operator">/</span>value<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">1606</span> <span class="token operator">+</span><span class="token number">0x40</span>
main<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">/</span>tmp<span class="token operator">/</span>sandbox590309925<span class="token operator">/</span>prog<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span> <span class="token operator">+</span><span class="token number">0xe0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行上述代码会导致程序崩溃并报出 <code>reflect: reflect.flag.mustBeAssignable using unaddressable value</code> 错误，仔细思考一下就能够发现出错的原因，Go 语言的 <a href="http://draveness.me/golang-function-call"> 函数调用 </a> 都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，所以直接对它修改会导致崩溃。</p>
<p>想要修改原有的变量只能通过如下的方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">:=</span> <span class="token number">1</span>
	v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span>
	v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run reflect<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 函数获取变量指针；</li>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821"><code>reflect.Value.Elem</code></a> 方法获取指针指向的变量；</li>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L1600-L1616"><code>reflect.Value.SetInt</code></a> 方法更新变量的值：</li>
</ol>
<p>由于 Go 语言的函数调用都是值传递的，所以我们只能先获取指针对应的 <code>reflect.Value</code>，再通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821"><code>reflect.Value.Elem</code></a> 方法迂回的方式得到可以被设置的变量，我们通过如下所示的代码理解这个过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">:=</span> <span class="token number">1</span>
	v <span class="token operator">:=</span> <span class="token operator">&amp;</span>i
	<span class="token operator">*</span>v <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不能直接操作 <code>i</code> 变量修改其持有的值，我们就只能获取 <code>i</code> 变量所在地址并使用 <code>*v</code> 修改所在地址中存储的整数。</p>
<h2><span id="类型和值">类型和值</span></h2><p>Go 语言的 <code>interface&#123;&#125;</code> 类型在语言内部是通过 <code>emptyInterface</code> 这个结体来表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> emptyInterface <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	typ  <span class="token operator">*</span>rtype
	word unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>用于获取变量类型的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 函数将传入的变量隐式转换成 <code>emptyInterface</code> 类型并获取其中存储的类型信息 <code>rtype</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TypeOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Type <span class="token punctuation">&#123;</span>
	eface <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>emptyInterface<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">toType</span><span class="token punctuation">(</span>eface<span class="token punctuation">.</span>typ<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">toType</span><span class="token punctuation">(</span>t <span class="token operator">*</span>rtype<span class="token punctuation">)</span> Type <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> t
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>rtype</code> 就是一个实现了 <code>Type</code> 接口的结构体，我们能在 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包中找到如下所示的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L752-L758"><code>reflect.rtype.String</code></a> 方法帮助我们获取当前类型的名称等信息：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>rtype<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> t<span class="token punctuation">.</span>tflag<span class="token operator">&amp;</span>tflagExtraStar <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> s
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 函数的实现原理其实并不复杂，它只是将一个 <code>interface&#123;&#125;</code> 变量转换成了内部的 <code>emptyInterface</code> 表示，然后从中获取相应的类型信息。</p>
<p>用于获取接口值 <code>Value</code> 的函数 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 实现也非常简单，在该函数中我们先调用了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2779-L2783"><code>reflect.escapes</code></a> 函数保证当前值逃逸到堆上，然后通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152"><code>reflect.unpackEface</code></a> 方法从接口中获取 <code>Value</code> 结构体：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ValueOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Value <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">escapes</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

	<span class="token keyword">return</span> <span class="token function">unpackEface</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">unpackEface</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Value <span class="token punctuation">&#123;</span>
	e <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyInterface<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
	t <span class="token operator">:=</span> e<span class="token punctuation">.</span>typ
	<span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	f <span class="token operator">:=</span> <span class="token function">flag</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">ifaceIndir</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		f <span class="token operator">|=</span> flagIndir
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span>t<span class="token punctuation">,</span> e<span class="token punctuation">.</span>word<span class="token punctuation">,</span> f<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152"><code>reflect.unpackEface</code></a> 函数会将传入的接口转换成 <code>emptyInterface</code> 结构体，然后将具体类型和指针包装成 <code>Value</code> 结构体并返回。</p>
<p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 函数的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"reflect"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	i <span class="token operator">:=</span> <span class="token number">20</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token string">"-S -N"</span> main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token operator">...</span>
MOVQ	$<span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_20<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// autotmp = 20</span>
LEAQ	<span class="token keyword">type</span><span class="token punctuation">.</span><span class="token function">int</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX           <span class="token comment">// AX = type.int(SB)</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_19<span class="token operator">+</span><span class="token function">280</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// autotmp_19+280(SP) = type.int(SB)</span>
LEAQ	<span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_20<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> CX  <span class="token comment">// CX = 20</span>
MOVQ	CX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_19<span class="token operator">+</span><span class="token function">288</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span> <span class="token comment">// autotmp_19+288(SP) = 20</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面这段截取的汇编语言，我们发现在函数调用之前已经发生了类型转换，上述指令将 <code>int</code> 类型的变量转换成了占用 16 字节 <code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code> 的接口，两个 <code>LEAQ</code> 指令分别获取了类型的指针 <code>type.int(SB)</code> 以及变量 <code>i</code> 所在的地址。</p>
<p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 <code>interface&#123;&#125;</code> 并等待运行期间使用 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包获取接口中存储的信息。</p>
<h2><span id="更新变量">更新变量 </span></h2><p> 当我们想要更新一个 <code>reflect.Value</code>，就需要调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538"><code>reflect.Value.Set</code></a> 方法更新反射对象，该方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L232-L236"><code>reflect.flag.mustBeAssignable</code></a> 和 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L214-L218"><code>reflect.flag.mustBeExported</code></a> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>x Value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	v<span class="token punctuation">.</span><span class="token function">mustBeAssignable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	x<span class="token punctuation">.</span><span class="token function">mustBeExported</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> target unsafe<span class="token punctuation">.</span>Pointer
	<span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Interface <span class="token punctuation">&#123;</span>
		target <span class="token operator">=</span> v<span class="token punctuation">.</span>ptr
	<span class="token punctuation">&#125;</span>
	x <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">assignTo</span><span class="token punctuation">(</span><span class="token string">"reflect.Set"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
	<span class="token function">typedmemmove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> v<span class="token punctuation">.</span>ptr<span class="token punctuation">,</span> x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538"><code>reflect.Value.Set</code></a> 方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404"><code>reflect.Value.assignTo</code></a> 并返回一个新的反射对象，这个返回的反射对象指针就会直接覆盖原始的反射变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">assignTo</span><span class="token punctuation">(</span>context <span class="token builtin">string</span><span class="token punctuation">,</span> dst <span class="token operator">*</span>rtype<span class="token punctuation">,</span> target unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> Value <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token function">directlyAssignable</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> v<span class="token punctuation">.</span>typ<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token operator">...</span>
		<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span>dst<span class="token punctuation">,</span> v<span class="token punctuation">.</span>ptr<span class="token punctuation">,</span> fl<span class="token punctuation">&#125;</span>
	<span class="token keyword">case</span> <span class="token function">implements</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> v<span class="token punctuation">.</span>typ<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Interface <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span>dst<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token function">flag</span><span class="token punctuation">(</span>Interface<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		x <span class="token operator">:=</span> <span class="token function">valueInterface</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> dst<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">=</span> x
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token function">ifaceE2I</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> x<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span>dst<span class="token punctuation">,</span> target<span class="token punctuation">,</span> flagIndir <span class="token operator">|</span> <span class="token function">flag</span><span class="token punctuation">(</span>Interface<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">panic</span><span class="token punctuation">(</span>context <span class="token operator">+</span> <span class="token string">": value of type"</span> <span class="token operator">+</span> v<span class="token punctuation">.</span>typ<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"is not assignable to type"</span> <span class="token operator">+</span> dst<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404"><code>reflect.Value.assignTo</code></a> 会根据当前和被设置的反射对象类型创建一个新的 <code>Value</code> 结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接将目标反射对象返回；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会将目标对象简单包装成接口值；</li>
</ul>
<p>在变量更新的过程中，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404"><code>reflect.Value.assignTo</code></a> 返回的 <code>reflect.Value</code> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<h2><span id="实现协议">实现协议</span></h2><p><a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包还为我们提供了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438"><code>reflect.rtypes.Implements</code></a> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 <code>reflect.Type</code> 还是比较容易的，但是想要获得接口的类型就需要通过以下方式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&lt;</span><span class="token keyword">interface</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 <code>CustomError</code> 是否实现了 Go 语言标准库中的 <code>error</code> 接口：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> CustomError <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>CustomError<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token string">""</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	typeOfError <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	customErrorPtr <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>CustomError<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	customError <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>CustomError<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>customErrorPtr<span class="token punctuation">.</span><span class="token function">Implements</span><span class="token punctuation">(</span>typeOfError<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// #=> true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>customError<span class="token punctuation">.</span><span class="token function">Implements</span><span class="token punctuation">(</span>typeOfError<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// #=> false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码的运行结果正如我们在 <a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/"> 接口 </a> 一节中介绍的：</p>
<ul>
<li><code>CustomError</code> 类型并没有实现 <code>error</code> 接口；</li>
<li><code>*CustomError</code> 指针类型实现了 <code>error</code> 接口；</li>
</ul>
<p>抛开上述的执行结果不谈，我们来分析一下 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438"><code>reflect.rtypes.Implements</code></a> 方法的工作原理：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>rtype<span class="token punctuation">)</span> <span class="token function">Implements</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> u <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect: nil type passed to Type.Implements"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> u<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Interface <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect: non-interface type passed to Type.Implements"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token function">implements</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>rtype<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438"><code>reflect.rtypes.Implements</code></a> 方法会检查传入的类型是不是接口，如果不是接口或者是空值就会直接 panic 中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543"><code>reflect.implements</code></a> 判断类型之间是否有实现关系：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">implements</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> V <span class="token operator">*</span>rtype<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	t <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>interfaceType<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	v <span class="token operator">:=</span> V<span class="token punctuation">.</span><span class="token function">uncommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	i <span class="token operator">:=</span> <span class="token number">0</span>
	vmethods <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">int</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>mcount<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		tm <span class="token operator">:=</span> <span class="token operator">&amp;</span>t<span class="token punctuation">.</span>methods<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		tmName <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>tm<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
		vm <span class="token operator">:=</span> vmethods<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
		vmName <span class="token operator">:=</span> V<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
		<span class="token keyword">if</span> vmName<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> tmName<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> V<span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>mtyp<span class="token punctuation">)</span> <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>tm<span class="token punctuation">.</span>typ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> i<span class="token operator">++</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时就会直接返回 <code>true</code>。</p>
<p><img src="https://i.loli.net/2020/09/11/kUQRuvsaTMynx5q.png" alt="golang-type-implements-interface"></p>
<p><strong>类型实现接口</strong></p>
<p>在其他情况下，由于方法都是按照字母序存储的，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543"><code>reflect.implements</code></a> 会维护两个用于遍历接口和类型方法的索引 <code>i</code> 和 <code>j</code> 判断类型是否实现了接口，因为最多只会进行 <code>n</code> 次比较（类型的方法数量），所以整个过程的时间复杂度是 <code>O(n)</code>。</p>
<h2><span id="方法调用">方法调用 </span></h2><p> 作为一门静态语言，如果我们想要通过 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 <code>Add(0, 1)</code> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>Add<span class="token punctuation">)</span>
	<span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Func <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	t <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	argv <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>reflect<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">NumIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> argv <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">In</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Int <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
		argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	result <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Int <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// #=> 1</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 获取函数 <code>Add</code> 对应的反射对象；</li>
<li>根据反射对象 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L979-L985"><code>reflect.rtype.NumIn</code></a> 方法返回的参数个数创建 <code>argv</code> 数组；</li>
<li>多次调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328"><code>reflect.ValueOf</code></a> 函数逐一设置 <code>argv</code> 数组中的各个参数；</li>
<li>调用反射对象 <code>Add</code> 的 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322"><code>reflect.Value.Call</code></a> 方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">Call</span><span class="token punctuation">(</span>in <span class="token punctuation">[</span><span class="token punctuation">]</span>Value<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Value <span class="token punctuation">&#123;</span>
	v<span class="token punctuation">.</span><span class="token function">mustBe</span><span class="token punctuation">(</span>Func<span class="token punctuation">)</span>
	v<span class="token punctuation">.</span><span class="token function">mustBeExported</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"Call"</span><span class="token punctuation">,</span> in<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322"><code>reflect.Value.Call</code></a> 方法是运行时调用方法的入口，它通过两个 <code>MustBe</code> 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L339-L501"><code>reflect.Value.call</code></a> 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p>
<ol>
<li>检查输入参数以及类型的合法性；</li>
<li>将传入的 <code>reflect.Value</code> 参数数组设置到栈上；</li>
<li>通过函数指针和输入参数调用函数；</li>
<li>从栈上获取函数的返回值；</li>
</ol>
<p>我们将按照上面的顺序分析使用 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 进行函数调用的几个过程。</p>
<h3><span id="参数检查">参数检查 </span></h3><p> 参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 <code>unsafe.Pointer</code>，如果该函数指针是方法，那么我们就会通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L612-L645"><code>reflect.methodReceiver</code></a> 函数获取方法的接受者和函数指针。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>v Value<span class="token punctuation">)</span> <span class="token function">call</span><span class="token punctuation">(</span>op <span class="token builtin">string</span><span class="token punctuation">,</span> in <span class="token punctuation">[</span><span class="token punctuation">]</span>Value<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Value <span class="token punctuation">&#123;</span>
	t <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>funcType<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>typ<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> v<span class="token punctuation">.</span>flag<span class="token operator">&amp;</span>flagMethod <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		rcvr <span class="token operator">=</span> v
		rcvrtype<span class="token punctuation">,</span> t<span class="token punctuation">,</span> fn <span class="token operator">=</span> <span class="token function">methodReceiver</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token operator">>></span>flagMethodShift<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
	n <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">NumIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect: Call with too few input arguments"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token punctuation">&#123;</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect: Call with too many input arguments"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> xt<span class="token punctuation">,</span> targ <span class="token operator">:=</span> in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">In</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>xt<span class="token punctuation">.</span><span class="token function">AssignableTo</span><span class="token punctuation">(</span>targ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect:"</span> <span class="token operator">+</span> op <span class="token operator">+</span> <span class="token string">"using"</span> <span class="token operator">+</span> xt<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"as type"</span> <span class="token operator">+</span> targ<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述方法中，上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p>
<h3><span id="准备参数">准备参数 </span></h3><p> 当我们已经对当前方法的参数完成验证之后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面的章节 <a href="https://draveness.me/golang/basic/golang-function-call.html"> 函数调用 </a> 中我们已经介绍过 Go 语言的函数调用惯例，函数或者方法在调用时，所有的参数都会被依次放置到栈上。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">nout <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">NumOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
frametype<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> retOffset<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> framePool <span class="token operator">:=</span> <span class="token function">funcLayout</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> rcvrtype<span class="token punctuation">)</span>

<span class="token keyword">var</span> args unsafe<span class="token punctuation">.</span>Pointer
<span class="token keyword">if</span> nout <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
	args <span class="token operator">=</span> framePool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
	args <span class="token operator">=</span> <span class="token function">unsafe_New</span><span class="token punctuation">(</span>frametype<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
off <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> rcvrtype <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token function">storeRcvr</span><span class="token punctuation">(</span>rcvr<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
	off <span class="token operator">=</span> ptrSize
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">&#123;</span>
	targ <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">In</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>rtype<span class="token punctuation">)</span>
	a <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>targ<span class="token punctuation">.</span>align<span class="token punctuation">)</span>
	off <span class="token operator">=</span> <span class="token punctuation">(</span>off <span class="token operator">+</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;^</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	n <span class="token operator">:=</span> targ<span class="token punctuation">.</span>size
	<span class="token operator">...</span>
	addr <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> off<span class="token punctuation">,</span> <span class="token string">"n > 0"</span><span class="token punctuation">)</span>
	v <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">assignTo</span><span class="token punctuation">(</span><span class="token string">"reflect.Value.Call"</span><span class="token punctuation">,</span> targ<span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>ptr
	off <span class="token operator">+=</span> n
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><p>通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048"><code>reflect.funcLayout</code></a> 函数计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</p>
</li>
<li><p>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 <code>args</code>；</p>
</li>
<li><p>如果当前函数是方法，需要向将方法的接受者拷贝到 <code>args</code> 内存中；</p>
</li>
<li><p>将所有函数的参数按照顺序依次拷贝到对应</p>
</li>
</ol>
   <pre class="line-numbers language-none"><code class="language-none">args<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>   内存中</p>
<ol>
<li>使用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048"><code>reflect.funcLayout</code></a> 返回的参数计算参数在内存中的位置；</li>
<li>将参数拷贝到内存空间中；</li>
</ol>
<p>准备参数的过程是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应的位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p>
<h3><span id="调用函数">调用函数 </span></h3><p> 准备好调用函数需要的全部参数之后，就会通过以下的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">call</span><span class="token punctuation">(</span>frametype<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token function">uint32</span><span class="token punctuation">(</span>frametype<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint32</span><span class="token punctuation">(</span>retOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述函数实际上并不存在，它会在编译期间被链接到 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L489-L526"><code>runtime.reflectcall</code></a> 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p>
<h3><span id="处理返回值">处理返回值 </span></h3><p> 当函数调用结束之后，就会开始处理函数的返回值：</p>
<ul>
<li>如果函数没有任何返回值，会直接清空 <code>args</code> 中的全部内容来释放内存空间；</li>
<li>如果当前函数有返回值；<ol>
<li>将 <code>args</code> 中与输入参数有关的内存空间清空；</li>
<li>创建一个 <code>nout</code> 长度的切片用于保存由反射对象构成的返回值数组；</li>
<li>从函数对象中获取返回值的类型和内存大小，将 <code>args</code> 内存中的数据转换成 <code>reflect.Value</code> 类型并存储到切片中；</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token keyword">var</span> ret <span class="token punctuation">[</span><span class="token punctuation">]</span>Value
	<span class="token keyword">if</span> nout <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemclr</span><span class="token punctuation">(</span>frametype<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
		framePool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">typedmemclrpartial</span><span class="token punctuation">(</span>frametype<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> retOffset<span class="token punctuation">)</span>
		ret <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Value<span class="token punctuation">,</span> nout<span class="token punctuation">)</span>
		off <span class="token operator">=</span> retOffset
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nout<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			tv <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">Out</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
			a <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>tv<span class="token punctuation">.</span><span class="token function">Align</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			off <span class="token operator">=</span> <span class="token punctuation">(</span>off <span class="token operator">+</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;^</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> tv<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
				fl <span class="token operator">:=</span> flagIndir <span class="token operator">|</span> <span class="token function">flag</span><span class="token punctuation">(</span>tv<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Value<span class="token punctuation">&#123;</span>tv<span class="token punctuation">.</span><span class="token function">common</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> off<span class="token punctuation">,</span> <span class="token string">"tv.Size() != 0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fl<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Zero</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>
			off <span class="token operator">+=</span> tv<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">return</span> ret
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由 <code>reflect.Value</code> 构成的 <code>ret</code> 数组会被返回到上层，到这里为止使用反射实现函数调用的过程就结束了。</p>
<h2><span id="小结">小结</span></h2><p>Go 语言的 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包为我们提供的多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过对反射包中方法原理的分析能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://blog.golang.org/laws-of-reflection">The Laws of Reflection</a></li>
<li><a href="https://github.com/golang/go/commit/3d1699ea787f38be6088f9a098d6e08dafca9387">runtime: new itab lookup table</a></li>
<li><p><a href="https://github.com/golang/go/issues/20505">runtime: need a better itab table</a></p>
</li>
<li><p><a href="https://golang.org/pkg/reflect/">Package reflect</a></p>
</li>
<li><p><a href="https://blog.golang.org/laws-of-reflection">The Laws of Reflection</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>实现 JavaScript 中的 Promise</title>
    <url>/2017/07/26/javascript/JavaScript%E4%B8%AD%E7%9A%84Promise/</url>
    <content><![CDATA[<p>Promise 类似于一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<a id="more"></a>
<h2><span id="回调地狱的解决方案">“回调地狱”的解决方案 </span></h2><p>Promise 是处理异步编码的一个解决方案，在 Promise 出现以前，异步代码的编写都是通过回调函数来处理的，虽然单层回调代码相当直观，但多次回调就显得比较复杂，被称为<strong> 回调地狱</strong>。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'3.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 可能还有后续代码</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于回调代码必须作为参数传递给调用函数，所以很容易出现这种回调穿插回调的代码，可读性不高。</p>
<p>为了解决这个问题，引入了 <code>Promise</code> 对象，<code>Promise</code>作为一个容器，接受一个未来会发生的事件。它有三个状态 <code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code> 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p><code>Promise</code>对象构造函数接受一个函数作为参数，该函数有两个参数，<code>resolve</code>和 <code>reject</code>。这两个函数由 Promise 的实现库来提供。<code>resolve</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// ... some code</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="实现一个-promise">实现一个 Promise</span></h2><h3><span id="基本结构">基本结构 </span></h3><p> 为了实现 Promise，Promise 对象需要一个状态指示器 <code>state</code>，一个<code>value</code> 代表要传递的数据，一个 <code>reason</code> 代表错误原因。还有 <code>resolve</code> 和<code>reject</code>函数作为状态转换函数。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span> <span class="token comment">// 状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 成功结果</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 失败原因</span>

    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Promise<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实现执行器函数-executor">实现执行器函数 executor</span></h3><p>Promise 对象就是为了立即执行传入的 executor，这个 executor 返回一个异步结果。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 运行结果 执行了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现立即执行</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 马上执行</span>
    
    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实现状态更新函数-resolve-和-reject">实现状态更新函数 resolve 和 reject</span></h3><p>只有 <code>pending</code> 状态才可以更新，<code>resolve</code>和 <code>reject</code> 需要实现这一点。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当状态为 pending 时再做更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        _this<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token comment">// 保存成功结果</span>
        _this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">// 当状态为 pending 时再做更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        _this<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span><span class="token comment">// 保存失败原因</span>
        _this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="实现-then-方法和链式调用">实现 then 方法和链式调用 </span></h3><p><code>then</code> 方法用于处理异步返回结果，定义在 <code>prototype</code> 上。<code>then</code>需要实现的是，根据不同的 <code>Promise</code> 状态来进行不同的“回调”操作。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'resolved'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 判断参数类型，是函数执行之</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Promise 的链式调用的关键在于 <code>then</code> 方法返回一个 <code>Promise</code> 对象，这样就可以继续<code>then()</code>，规范有</p>
<ol>
<li>每个 then 方法都返回一个新的 Promise 对象（<strong>原理的核心</strong>）</li>
<li>如果 then 方法中显示地返回了一个 Promise 对象就以此对象为准，返回它的结果</li>
<li>如果 then 方法中返回的是一个普通值（如 Number、String 等）就使用此值包装成一个新的 Promise 对象返回。</li>
<li>如果 then 方法中没有 return 语句，就视为返回一个用 Undefined 包装的 Promise 对象</li>
<li>若 then 方法中出现异常，则调用失败态方法（reject）跳转到下一个 then 的 onRejected</li>
<li>如果 then 方法没有传入任何回调，则继续向下传递（值的传递特性）。</li>
</ol>
<p>第三点：如果 then 方法中返回的是一个普通值（如 Number、String 等）就使用此值包装成一个新的 Promise 对象返回。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个普通值</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第四点，如果 then 方法中没有 return 语句，就视为返回一个用 Undefined 包装的 Promise 对象</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 没有 return 语句</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第六点，如果 then 方法没有传入任何回调，则继续向下传递，这就是 Promise 中值的穿透</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在第一个 then 方法之后连续调用了两个空的 then 方法 ，没有传入任何回调函数，也没有返回值，此时 Promise 会将值一直向下传递，直到接收处理它，这就是所谓的值的穿透。</p>
<h3><span id="实现异步-executor-支持">实现异步 executor 支持 </span></h3><p> 设想如果 <code>executor</code> 中包含异步过程</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>，<span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码不输出任何结果，原因是 <code>setTimeout</code> 函数使得 <code>resolve</code> 是异步执行的，有延迟，当调用 <code>then</code> 方法的时候，此时此刻的状态还是等待态（pending），因此 then 方法即没有调用 <code>onFulfilled</code> 也没有调用<code>onRejected</code>。</p>
<p>需要做到的事 <code>then</code> 方法执行时，如果还在 Promise 处于 pending 状态，那么把回调函数 push 到一个回调队列中，状态发生改变了就依次从该队列中取出执行。用 Array 来实现。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 成功回调队列</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 失败回调队列</span>
    <span class="token comment">// 其它代码略...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现 <code>then</code> 的回调队列。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 等待态，此时异步代码还没有走完</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledFunc<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保存回调</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedFunc<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保存回调</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token comment">// 省略...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>寄存好了回调，接下来就是当状态改变时执行就好了：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        _this<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token comment">// 依次执行成功回调</span>
        _this<span class="token punctuation">.</span>onFulfilledFunc<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        _this<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>
        <span class="token comment">// 依次执行失败回调</span>
        _this<span class="token punctuation">.</span>onRejectedFunc<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，Promise 已经支持了异步操作，setTimeout 延迟后也可正确执行 then 方法返回结果。</p>
<h3><span id="实现">实现 </span></h3><p> 搞清楚了这些点，我们就可以动手实现 then 方法的链式调用，一起来完善它：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 代码略...</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，不论何种情况 then 都返回 Promise 对象，我们就实例化一个新 promise2 并返回。</p>
<p>接下来就处理根据上一个 then 方法的返回值来生成新 Promise 对象，由于这块逻辑较复杂且有很多处调用，我们抽离出一个方法来操作，这也是规范中说明的：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/**
 * 解析 then 返回值与新 Promise 对象
 * @param &#123;Object&#125; promise2 新的 Promise 对象 
 * @param &#123;*&#125; x 上一个 then 的返回值
 * @param &#123;Function&#125; resolve promise2 的 resolve
 * @param &#123;Function&#125; reject promise2 的 reject
 */</span>
<span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>resolvePromise</code>方法用来封装链式调用产生的结果，下面我们分别一个个情况的写出它的逻辑，首先规范中说明，如果 <code>promise2</code> 和 <code>x</code> 指向同一对象，就使用 TypeError 作为原因转为失败。原文如下：</p>
<blockquote>
<p>If promise and x refer to the same object, reject promise with a TypeError as the reason.</p>
</blockquote>
<p>这是什么意思？其实就是循环引用，当 then 的返回值与新生成的 Promise 对象为同一个（引用地址相同），则会抛出 TypeError 错误：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise2 <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">TypeError: Chaining cycle detected <span class="token keyword">for</span> promise <span class="token comment">#&lt;Promise></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>很显然，如果返回了自己的 Promise 对象，状态永远为等待态（pending），再也无法成为 resolved 或是 rejected，程序会死掉，因此首先要处理它：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Promise 发生了循环引用'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就是分各种情况处理。当 <code>x</code> 就是一个 Promise，那么就执行它，成功即成功，失败即失败。若 <code>x</code> 是一个对象或是函数，再进一步处理它，否则就是一个普通值：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Promise 发生了循环引用'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 可能是个对象或是函数</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 否则是个普通值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时规范中说明，若是个对象，则尝试将对象上的 then 方法取出来，此时如果报错，那就将 promise2 转为失败态。原文：</p>
<blockquote>
<p>If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 代码略...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 可能是个对象或是函数</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span><span class="token comment">// 取出 then 方法引用</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 否则是个普通值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多说几句，为什么取对象上的属性有报错的可能？Promise 有很多实现（bluebird，Q 等），Promises/A+ 只是一个规范，大家都按此规范来实现 Promise 才有可能通用，因此所有出错的可能都要考虑到，假设另一个人实现的 Promise 对象使用 <code>Object.defineProperty()</code> 恶意的在取值时抛错，我们可以防止代码出现 Bug。</p>
<p>此时，如果对象中有 then，且 then 是函数类型，就可以认为是一个 Promise 对象，之后，使用 <code>x</code> 作为 this 来调用 then 方法。</p>
<blockquote>
<p>If then is a function, call it with x as this</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 其他代码略...</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 可能是个对象或是函数</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//then 是 function，那么执行 Promise</span>
            <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 否则是个普通值</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样链式写法就基本完成了。但是还有一种极端的情况，如果 Promise 对象转为成功态或是失败时传入的还是一个 Promise 对象，此时应该继续执行，直到最后的 Promise 执行完。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
        <span class="token comment">//resolve 传入的还是 Promise</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时就要使用递归操作了。</p>
<p>规范中原文如下：</p>
<blockquote>
<p>If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of <a href="promise, thenable">[Resolve]</a> eventually causes <a href="promise, thenable">[Resolve]</a> to be called again, following the above algorithm will lead to infinite recursion. Implementations are encouraged, but not required, to detect such recursion and reject promise with an informative TypeError as the reason.</p>
</blockquote>
<p>很简单，把调用 resolve 改写成递归执行 resolvePromise 方法即可，这样直到解析 Promise 成一个普通值才会终止，即完成此规范：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 其他代码略...</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 可能是个对象或是函数</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 递归调用，传入 y 若是 Promise 对象，继续循环</span>
                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 是个普通值，最终结束递归</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，链式调用的代码已全部完毕。在相应的地方调用 <code>resolvePromise</code> 方法即可。</p>
<h2><span id="测试">测试 </span></h2><p> 其实，写到此处 Promise 的真正源码已经写完了，但是距离 100 分还差一分，是什么呢？</p>
<p>规范中说明，Promise 的 then 方法是异步执行的。</p>
<blockquote>
<p>onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</p>
</blockquote>
<p>ES6 的原生 Promise 对象已经实现了这一点，但是我们自己的代码是同步执行，不相信可以试一下，那么如何将同步代码变成异步执行呢？可以使用 setTimeout 函数来模拟一下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 此处的代码会异步执行</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>利用此技巧，将代码 then 执行处的所有地方使用 setTimeout 变为异步即可，举个栗子：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以利用 promises-aplus-tests 来测试代码</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之堆排序与 JavaScript 实现</title>
    <url>/2016/04/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3><span id="成堆-heapify">成堆 <code>Heapify</code></span></h3><p>对于一个给定的数组，我们不一定实现堆这个类，而是通过 <strong> 成堆 (Heapify)</strong> 这样的操作来使得数组具有堆的性质。</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/Heapify.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/Heapify.png" alt="img"></a></p>
<p>如图所示，要使得这个数组所对应的完全二叉树形成一个最大堆，只需要使得每一棵子树都形成最大堆即可。那么不难看出，所有的叶子结点都可以看作是一个仅有一个元素的最大堆，所以我们只需要从最后一个非叶子结点开始，通过前一节的 <code>shiftDown</code> 操作，就可以很容易的构建出最大堆来。</p>
<blockquote>
<p>一个显而易见的数学关系是: 完全二叉树最后一个非叶子节点的索引是 $n\div{2}$，例如这里有 <code>10</code> 个元素，那么最后一个非叶子结点的索引就是 <code>5</code>；类似的，如果有 <code>11</code> 个元素，那么同样 <code>5</code>是最后一个非叶子结点的索引；不过要注意的是，这里的索引是从 <code>1</code> 开始的，如果是从 <code>0</code> 开始的索引只需使 <code>i-1</code> ($n\div{2}-1$) 即可。这很容易就能用数学归纳法证明。</p>
</blockquote>
<p>简单来说，<code>Heapify</code> 的算法过程可以简述为:</p>
<ol>
<li>从最后一个非叶子结点开始向前遍历数组；</li>
<li>每遇到一个非叶子结点，就通过 <code>shiftDown</code> 使以当前节点为根结点的子树成最大堆；</li>
<li>重复直到根节点完成 <code>shiftDown</code>。</li>
</ol>
<p>动画演示:</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/Heapify.gif"><img src="http://mitscherlich.me/assets/imooc-algorithms/Heapify.gif" alt="img"></a></p>
<p>示例代码</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> PrintableMaxHeap <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./02-Max-Heap-Class-Basic'</span><span class="token punctuation">)</span>

<span class="token comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span>
<span class="token comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为 O(nlogn)</span>
<span class="token comment">// 整个堆排序的整体时间复杂度为 O(nlogn)</span>
exports<span class="token punctuation">.</span><span class="token function-variable function">heapSort1</span> <span class="token operator">=</span> <span class="token parameter">array</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token keyword">const</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintableMaxHeap</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> i <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">&#125;</span>

<span class="token comment">// heapSort2, 借助我们的 heapify 过程创建堆</span>
<span class="token comment">// 此时, 创建堆的过程时间复杂度为 O(n), 将所有元素依次从堆中取出来, 时间复杂度为 O(nlogn)</span>
<span class="token comment">// 堆排序的总体时间复杂度依然是 O(nlogn), 但是比上述 heapSort1 性能更优, 因为创建堆的性能更优</span>
exports<span class="token punctuation">.</span><span class="token function-variable function">heapSort2</span> <span class="token operator">=</span> <span class="token parameter">array</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token keyword">const</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintableMaxHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">MaxHeap</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 新的构造函数，传入一个数组使其成最大堆</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#capacity <span class="token operator">=</span> n
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">=</span> n
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span>  <span class="token comment">// 见【慕课】重学算法 - part.3 堆排序 (1)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="通过堆进行排序">通过堆进行排序 </span></h4><p> 通过新的构造函数，我们可以方便的将一个数组构造为最大堆，显而易见的，我们将数组放入再取出最大堆的过程，其实就完成了一次排序。我们可以这样实现:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/**
 * generateRandomArray @see https://github.com/Mitscherlich/Play-with-Algorithms-JS/blob/master/test/utils/index.js#L8
 */</span>
<span class="token keyword">const</span> sorted <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token function">generateRandomArray</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>maxHeap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  sorted<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>sorted<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>值得注意的是，这种通过 <code>Heapify</code> 来成堆的操作并进行堆排序速度由于上一节我们一个一个将元素插入进堆的操作，事实上，这两种操作的算法复杂度的确有所不同的：</p>
<ul>
<li>将 <code>n</code> 个元素注意插入空堆中：$O(nlog{n})$</li>
<li><code>Heapfiy</code>：$O(n)$</li>
</ul>
<p>由于堆算法复杂度的证明不是本系列的重点并且有点难，感兴趣的同学可以自己来进行详细地推导证明，这里并不展开。</p>
<h3><span id="数组的原地堆排序">数组的原地堆排序 </span></h3><p> 无论是将元素逐一插入空堆还是通过 <code>Heapify</code> 来使数组成堆，我们实际上都开辟了一个堆的空间 (也就是使用了额外的 $O(n)$ 的空间复杂度)。但结合上面 <code>Heapify</code> 的思想，我们也可以很容易的改造堆排序的过程，使数组原地完成堆排序的操作。</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/HeapSort0.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/HeapSort0.png" alt="img"></a></p>
<blockquote>
<p>一个已经形成最大堆的数组</p>
</blockquote>
<p>我们假定通过 <code>Heapify</code> 已经使一个数组形成最大堆，这时数组中第一个元素也就是最大的元素，要是数组从小到大排序，只需使现在数组第一个位置的元素与最后一个元素交换位置：</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/HeapSort1.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/HeapSort1.png" alt="img"></a></p>
<p>而此时由于 <code>w</code> 并不一定是最大元素，也就使得原有最大堆的性质遭到了破坏。这时只需通过对 <code>w</code> 元素进行一次 <code>shiftDown</code> 操作，就能使数组的前部重新形成最大堆：</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/HeapSort2.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/HeapSort2.png" alt="img"></a></p>
<p>那么重复上述操作就可以使整个数组完成排序。</p>
<p>示例代码 </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">shiftDown</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      j<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">>=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// swap(arr[k] , arr[j])</span>
    <span class="token punctuation">[</span>array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span>
    k <span class="token operator">=</span> j
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">heapSort</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token comment">// heapify</span>
  <span class="token comment">// 注意，此时我们的堆是从 0 开始索引的</span>
  <span class="token comment">// 从(最后一个元素的索引 -1)/2 开始</span>
  <span class="token comment">// 最后一个元素的索引 = n-1</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">shiftDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// swap(arr[0], arr[i])</span>
    <span class="token punctuation">[</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token function">shiftDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似的，最后使用一步交换进行优化:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 优化的 shiftDown 过程, 使用赋值的方式取代不断的 swap,</span>
<span class="token comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span>
<span class="token keyword">const</span> <span class="token function-variable function">shiftDownEnhance</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> e <span class="token operator">=</span> array<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      j<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">>=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">&#125;</span>
    array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    k <span class="token operator">=</span> j
  <span class="token punctuation">&#125;</span>
  array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e
<span class="token punctuation">&#125;</span>

<span class="token comment">// 优化的堆排序</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">heapSortEnhance</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// swap(arr[0], arr[i])</span>
    <span class="token punctuation">[</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="索引堆">索引堆 </span></h3><p> 在上面的实现的堆中，我们总是直接操作原右数组元素。这在处理基本数据或者简单类型时没有问题，但往往我们面对的数据类型并非如此。例如，我们在处理 <code>CMS</code> 内容时如果使用对这种结构，一旦要交换的数据量非常大，交换操作本身变得非常慢；而这种问题还可以通过技术手段解决；又例如在操作系统的进程调度时，我们可能根据进程的 <code>pid</code> 数组构建了最大堆来表示进程的优先级，一旦我们直接交换了堆中元素的位置，我们就无法根据新的索引找到原来的进程，也就使得 <code>pid</code> 和进程脱离了关系；像这种情况使用 <strong> 索引堆 </strong> 就更为方便。</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/IndexMaxHeap.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/IndexMaxHeap.png" alt="img"></a></p>
<blockquote>
<p>索引最大堆示意图</p>
</blockquote>
<p>示例代码</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shiftUp</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> e <span class="token operator">=</span> indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// swap(indexes[k/2], indexes[k])</span>
    indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> indexes<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">shiftDown</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> k<span class="token punctuation">,</span> count</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> e <span class="token operator">=</span> indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token comment">// 此轮循环中, swap(indexes[k], indexes[j])</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> count <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      j<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// swap(indexes[k], indexes[j])</span>
    indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    k <span class="token operator">=</span> j
  <span class="token punctuation">&#125;</span>
  indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">IndexMaxHeap</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 构造函数, 构造一个空堆, 可容纳 capacity 个元素</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#capacity <span class="token operator">=</span> capacity
  <span class="token punctuation">&#125;</span>
  <span class="token function">size</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token punctuation">&#125;</span>
  <span class="token function">isEmpty</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>
  <span class="token comment">// 获取最大索引堆中的堆顶元素</span>
  <span class="token function">getItem</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>
  <span class="token comment">// 传入的 i 是从 0 开始索引的</span>
  <span class="token function">insert</span> <span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> item
    <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token operator">++</span>
    <span class="token function">shiftUp</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">extractMax</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token comment">// swap(data[indexes[1]], data[indexes[count]])</span>
    <span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">-=</span> <span class="token number">1</span>
    <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">&#125;</span>
  <span class="token function">extractMaxIndex</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment">// swap(data[indexes[1]], data[indexes[count]])</span>
    <span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">-=</span> <span class="token number">1</span>
    <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 将最大索引堆中索引为 i 的元素修改为 newItem</span>
  <span class="token function">change</span> <span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item
    <span class="token comment">// 找到 indexes[j] = i, j 表示 data[i] 在堆中的位置</span>
    <span class="token comment">// 之后 shiftUp(j), 再 shiftDown(j)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">shiftUp</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
        <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这个索引堆的类不仅实现了最基本的堆的操作，还实现了一些索引堆可以完成的特殊操作；而最重要的就是 <code>change</code> 操作，用户可以通过给定一个索引来方便的修改堆中某个元素的值。但可以注意到，修改完这个元素后，要使得堆继续形成最大堆，我们仍需要对新插入的元素进行 <code>shiftUp</code> 和 <code>shiftDown</code> 来维持堆的性质，而这使得修改元素的复杂度变成了 $O(n+log{n}) ~ O(n)$，这与堆的插入删除元素 $O(nlog{n})$ 的复杂度并不相符，我们可以尝试建立对 <strong> 索引的索引 </strong> 来优化这个过程：</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/RevIndexMaxHeap.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/RevIndexMaxHeap.png" alt="img"></a></p>
<blockquote>
<p>优化索引最大堆示意图</p>
</blockquote>
<p>用 <code>reverse</code> 数组来表示 <code>i</code> 在 <code>indexes</code>(堆)中的位置：</p>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">if 
	indexes[i] &#x3D; j
	reverse[j] &#x3D; i
then 
	indexes[reverse[i]] &#x3D; i
	reverse[indexes[i]] &#x3D; i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，我们就可以在 $O(1)$ 内找到一个索引对应的元素：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shiftUpEnhance</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> reverse<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> e <span class="token operator">=</span> indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// swap(indexes[k/2], indexes[k])</span>
    indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> indexes<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    reverse<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
    reverse<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> k
    k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>k <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">shiftDownEnhance</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> reverse<span class="token punctuation">,</span> k<span class="token punctuation">,</span> count</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> e <span class="token operator">=</span> indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token comment">// 此轮循环中, swap(indexes[k], indexes[j])</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> count <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      j<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">>=</span> data<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// swap(indexes[k], indexes[j])</span>
    indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    reverse<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> k
    reverse<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j
    k <span class="token operator">=</span> j
  <span class="token punctuation">&#125;</span>
  indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">IndexMaxHeap</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 构造函数, 构造一个空堆, 可容纳 capacity 个元素</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 填入 0 使得默认的索引索引位置为 0 (总是无效的元素)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#capacity <span class="token operator">=</span> capacity
  <span class="token punctuation">&#125;</span>
  <span class="token operator">...</span>
  <span class="token comment">// 传入的 i 是从 0 开始索引的</span>
  <span class="token function">insert</span> <span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> item
    <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token operator">++</span>
    <span class="token function">shiftUpEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">extractMax</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token comment">// swap(data[indexes[1]], data[indexes[count]])</span>
    <span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">-=</span> <span class="token number">1</span>
    <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">&#125;</span>
  <span class="token function">extractMaxIndex</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment">// swap(data[indexes[1]], data[indexes[count]])</span>
    <span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#count <span class="token operator">-=</span> <span class="token number">1</span>
    <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 将最大索引堆中索引为 i 的元素修改为 newItem</span>
  <span class="token function">change</span> <span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item
    <span class="token comment">// 找到 indexes[j] = i, j 表示 data[i] 在堆中的位置</span>
    <span class="token comment">// 之后 shiftUp(j), 再 shiftDown(j)</span>
    <span class="token comment">// for (let j = i; j &lt;= this.size(); j++) &#123;</span>
    <span class="token comment">//   if (this.#indexes[j] === i) &#123;</span>
    <span class="token comment">//     shiftUpEnhance(this.#data, this.#indexes, j)</span>
    <span class="token comment">//     shiftDownEnhance(this.#data, this.#indexes, j, this.#count)</span>
    <span class="token comment">//     return</span>
    <span class="token comment">//   &#125;</span>
    <span class="token comment">// &#125;</span>
    <span class="token comment">// 有了 reverse 之后,</span>
    <span class="token comment">// 我们可以非常简单的通过 reverse 直接定位索引 i 在 indexes 中的位置</span>
    <span class="token keyword">const</span> j <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token function">shiftUpEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
    <span class="token function">shiftDownEnhance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>#data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#indexes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#reverse<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#count<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="排序总结">排序总结</span></h3><p><a href="http://mitscherlich.me/assets/imooc-algorithms/SortSummary.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/SortSummary.png" alt="img"></a></p>
<blockquote>
<p>四大重要排序算法比较</p>
</blockquote>
<p>本系列的排序算法到这里就完结了。我们一共只为大家介绍了 <strong> 两</strong>类 <strong> 七</strong>种排序算法，大家也许还知道或者学习过其他更多的排序算法，这里限于篇幅就不一一为大家介绍了。</p>
<p>我们主要学习的就是上图四种 <strong> 基于比较的排序算法</strong>。除了插入排序复杂度为 $O(n^2)$ 以外，其余几种排序算法复杂度均为 $O(nlog{n})$，但这也并不是说明插入排序不好，事实上我们在测试中可以发现在完全有序的数组上插入排序的复杂度退化为 $O(n)$，甚至优于同等的高级排序算法。这说明我们在编程开发时应学会结合实际情况，选择最优的排序算法，而不是只会做一个 <code>API caller</code>。</p>
<h4><span id="排序算法的稳定性">排序算法的稳定性 </span></h4><p> 再看图中，我们看到了一个概念：<strong>稳定排序 </strong>。这是指对于<strong> 相等的 </strong> 元素，在排序前后，想等元素的 <strong> 相对位置 </strong> 没有发生改变。例如对一组学生成绩排序时，不仅要对成绩进行排序，还在在学生成绩想等时按姓名的字典序排序，很可能大部分时候原始数据都已经按姓名的字典序排好序了，但是快速排序和堆排序就有可能打乱原来的顺序。</p>
<p><a href="http://mitscherlich.me/assets/imooc-algorithms/SortStable.png"><img src="http://mitscherlich.me/assets/imooc-algorithms/SortStable.png" alt="img"></a></p>
<blockquote>
<p>排序算法遇到相等的元素时行为有所不同</p>
</blockquote>
<p>但这并不是评价算法优劣的关键，因为我们可以通过修改排序比较的逻辑，或者干脆把比较的过程形成一个回调接口传递给用户，让用户自己完成比较的逻辑，从而使不稳定的排序变得稳定。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统内存管理</title>
    <url>/2017/10/12/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>操作系统的内存管理分为物理内存管理和虚拟内存管理。</p>
<p>物理内存管理包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。</p>
<p>虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。</p>
<p>我们以计算机存储结构来开始探讨。<br><a id="more"></a><br><!-- ttoc --></p>
<h2><span id="计算机存储体系">计算机存储体系 </span></h2><p> 内存是计算机很重要的一个资源，因为程序只有被加载到内存中才可以运行；此外，CPU 所需要的指令与数据也都是来自内存的。可以说，内存是影响计算机性能的一个很重要的因素。</p>
<h3><span id="分层存储器体系">分层存储器体系 </span></h3><p> 在介绍内存管理的细节前，先要了解一下分层存储器体系：</p>
<p>大部分的计算机都有一个存储器层次结构，即少量的非常快速、昂贵、易变的高速缓存(cache)；若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；数百兆或数千兆的低速、廉价、不易变的磁盘。这些资源的合理使用与否直接关系着系统的效率。</p>
<p>CPU 缓存（Cache Memory）：是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。缓存的出现主要是为了解决 CPU 运算速度与内存 读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。</p>
<p>计算机是一种数据处理设备，它由 CPU 和内存以及外部设备组成。CPU 负责数据处理，内存负责存储，外部设备负责数据的输入和输出，它们之间通过总线连接在一起。CPU 内部主要由控制器、运算器和寄存器组成。控制器负责指令的读取和调度，运算器负责指令的运算执行，寄存器负责数据的存储，它们之间通过 CPU 内的总线连接在一起。每个外部设备 (例如：显示器、硬盘、键盘、鼠标、网卡等等) 则是由外设控制器、I/O 端口、和输入输出硬件组成。外设控制器负责设备的控制和操作，I/O 端口负责数据的临时存储，输入输出硬件则负责具体的输入输出，它们间也通过外部设备内的总线连接在一起。</p>
<p><img src="https://i.loli.net/2020/08/25/4hBHAztiTFZW9y1.png" alt="20191014095110829"></p>
<p>上面计算机系统结构图中我们可以看出硬件系统的这种组件化的设计思路总是贯彻到各个环节。</p>
<p><strong>在冯诺伊曼设计体系中：总是有一部分负责控制、一部分负责执行、一部分则负责存储，它之间进行交互以及接口通信则总是通过总线来完成</strong>。这种设计思路一样的可以应用在我们的软件设计体系里面：组件和组件之间通信通过事件的方式来进行解耦处理，而一个组件内部同样也需要明确好各个部分的职责(一部分负责调度控制、一部分负责执行实现、一部分负责数据存储)。</p>
<h3><span id="计算存储的层次结构">计算存储的层次结构 </span></h3><p> 当前技术没有能够提供这样的存储器，因此大部分的计算机都有一个存储器层次结构:</p>
<p>高速缓存(cache): 少量的非常快速、昂贵、易变的高速缓存(cache)；</p>
<p>主存储器(RAM): 若干兆字节的中等速度、中等价格、易变的主存储器(RAM)；</p>
<p>磁盘: 数百兆或数千兆的低速、廉价、不易变的磁盘。</p>
<p>这些资源的合理使用与否直接关系着系统的效率。</p>
<p> <img src="https://i.loli.net/2020/08/25/TkhiHs5lWJj6Kg9.png" alt="20200616002500431"></p>
<h2><span id="内存使用演化">内存使用演化 </span></h2><h3><span id="没有内存抽象"> 没有内存抽象 </span></h3><p> 在早些的操作系统中，并没有引入内存抽象的概念。<strong>程序直接访问和操作的都是物理内存</strong>，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：<code>mov reg1,1000</code></p>
<p><strong>1、无内存抽象存在的问题：</strong></p>
<p>这条指令会毫无想象力的将物理地址 1000 中的内容赋值给寄存器。不难想象，这种内存操作方式使得操作系统中存在多进程变得完全不可能，比如 MS-DOS，你必须执行完一条指令后才能接着执行下一条。如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址 1000 赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p>
<p><strong>带来两个问题：</strong></p>
<ol>
<li>用户程序可以访问任意内存，容易破坏操作系统，造成崩溃</li>
<li>同时运行多个程序特别困难</li>
</ol>
<p>随着计算机技术发展，要求操作系统支持多进程的需求，所谓多进程，并不需要同时运行这些进程，只要它们都处于 ready 状态，操作系统快速地在它们之间切换，就能达到同时运行的假象。每个进程都需要内存，Context Switch 时，之前内存里的内容怎么办？简单粗暴的方式就是先 dump 到磁盘上，然后再从磁盘上 restore 之前 dump 的内容（如果有的话），但效果并不好，太慢了！</p>
<h3><span id="内存抽象地址空间">内存抽象：地址空间 </span></h3><p> 那怎么才能不慢呢？把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。这就涉及到了内存的保护机制，毕竟进程之间可以随意读取、写入内容就乱套了，非常不安全。因此操作系统需要对物理内存做一层抽象，也就是「地址空间」(Address Space)，一个进程的地址空间包含了该进程所有相关内存，比如 code / stack / heap。一个 16 KB 的地址空间可能长这样：</p>
<p><img src="https://i.loli.net/2020/08/25/CxqIod9BtTOuYKA.jpg" alt="aHR0cDovL3d3dy50ZWNodWcuY29tL3dvcmRwcmVzcy93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8yLmpwZw"></p>
<p>当程序运行时，heap 和 stack 共用中间 free 的区域，当然这只是 OS 层面的抽象。比如下面这段代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">;</span>
x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// this is the line of code we are interested in</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>变成汇编指令后，大概是这样：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">128: movl 0x0(%ebx), %eax  ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最前面的是 PC (Program Counter)，用来表示当前 code 的索引，比如 CPU 执行到 128 时，进行了 Context Switch（上下文切换），那么在 Switch 回来后，还可以接着从 132 开始执行（当然需要先把 PC 存起来）。之后的就是汇编代码，告诉 CPU 该如何操作。</p>
<p>从进程的角度看，内存可能是这样的：</p>
<p><img src="https://i.loli.net/2020/08/25/xZ4tQLTicmazWGf.png" alt="20191012183602799"></p>
<p><strong>基址寄存器与界限寄存器可以简单的动态重定位：</strong>每个内存地址送到内存之前，都会自动加上基址寄存器的内容。</p>
<p>从 32KB 处作为开始，48KB 作为结束。那 32 / 48 可不可以动态设置呢，只要在 CPU 上整两个寄存器，<strong>基址寄存器 </strong>base 和 <strong> 界限寄存器</strong>bounds 就可以了，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p>
<p>因此真实物理地址和虚拟地址之间的关系是：</p>
<blockquote>
<p>physical address = virtual address + base</p>
</blockquote>
<p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」(Memory Management Unit)，随着功能越来越强大，MMU 也会变得越来越复杂。</p>
<p>base and bounds 这种做法最大的问题在于空间浪费，Stack 和 Heap 中间有一块 free space，即使没有用，也被占着，那如何才能解放这块区域呢，进入虚拟内存。</p>
<h3><span id="虚拟内存">虚拟内存 </span></h3><p> 虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的 <strong> 抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求</strong>。物理内存不够用的情况下，如何解决呢？</p>
<p><strong>覆盖 overlays：</strong>在早期的操作系统曾使用覆盖技术来解决这个问题，将一个程序分为多个块，基本思想是先将块 0 加入内存，块 0 执行完后，将块 1 加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</p>
<p><strong>交换 swapping：</strong>可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读入保存在外存中而处于就绪状态的程序。</p>
<p><strong>虚拟内存：</strong>虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块, 称为 <strong> 页</strong>(Page). 每个页都是一段连续的地址。对于进程来看, 逻辑上貌似有很多内存空间，其中 <strong> 一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)</strong>，还有一些没加载在内存中的对应在硬盘上。</p>
<h2><span id="物理内存分配方式">物理内存分配方式 </span></h2><p> 物理内存分配分为连续内存分配管理和非连续内存分配管理，其中非连续内存分配分为页式、段式和段页式。</p>
<h3><span id="连续内存分配管理">连续内存分配管理 </span></h3><p> 连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。</p>
<h4><span id="单一连续存储管理">单一连续存储管理 </span></h4><p> 在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M 和 DOS 2．0 以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。</p>
<h4><span id="分区式存储管理">分区式存储管理 </span></h4><p> 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。</p>
<p>分区式存储管理引入了两个新的问题：内碎片和外碎片。内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。</p>
<p>为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。</p>
<p>分区式存储管理常采用的一项技术就是 <strong> 内存紧缩(compaction)。</strong></p>
<h5><span id="固定分区">固定分区 </span></h5><p> 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</p>
<p><strong>优点</strong>：易于实现，开销小。</p>
<p><strong>缺点</strong>：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目</p>
<h5><span id="动态分区">动态分区 </span></h5><p> 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</p>
<p>下面列出了几种常用的分区分配算法：</p>
<p><strong>最先适配法 (nrst-fit)：</strong> 按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</p>
<p><strong>下次适配法 (循环首次适应算法 next fit)：</strong> 按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</p>
<p><strong>最佳适配法 (best-fit)：</strong> 按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</p>
<p><strong>最坏适配法 (worst- fit)：</strong> 按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</p>
<h4><span id="伙伴系统">伙伴系统 </span></h4><p> 固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一种折衷方案。<br>伙伴系统规定，无论已分配分区或空闲分区，其大小均为 $2^k$，$k$ 为整数， $l≤k≤m$，其中：</p>
<p>$2^l$ 表示分配的最小分区的大小，</p>
<p>$2^m$ 表示分配的最大分区的大小，</p>
<p>通常 $2^m$ 是整个可分配内存的大小。<br>假设系统的可利用空间容量为 $2^m$ 个字， 则系统开始运行时， 整个内存区是一个大小为 $2^m$ 的空闲分区。在系统运行过中， 由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了 $k(0≤k≤m)$ 个空闲分区链表。 </p>
<h5><span id="分配步骤">分配步骤 </span></h5><p> 当需要为进程分配一个长度为 $n$ 的存储空间时:</p>
<p>首先计算一个 $i$ 值，使 $2^{i－1} &lt;n ≤ 2^i$，</p>
<p>然后在空闲分区大小为 $2^i$ 的空闲分区链表中查找。</p>
<p>若找到，即把该空闲分区分配给进程。</p>
<p>否则，表明长度为 $2^i$ 的空闲分区已经耗尽，则在分区大小为 $2^{i＋1}$ 的空闲分区链表中寻找。</p>
<p>若存在 $2^{i＋1}$ 的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于分配，  而把另一个加入分区大小为 $2^i$ 的空闲分区链表中。</p>
<p>若大小为 $2^{i＋1}$ 的空闲分区也不存在，则需要查找大小为 $2^{i＋2}$ 的空闲分区， 若找到则对其进行两次分割：</p>
<p>第一次，将其分割为大小为 $2^{i＋1}$ 的两个分区，一个用于分配，一个加入到大小为 $2^{i＋1}$ 的空闲分区链表中；</p>
<p>第二次，将第一次用于分配的空闲区分割为 $2^i$ 的两个分区，一个用于分配，一个加入到大小为 $2^i$ 的空闲分区链表中。</p>
<p>若仍然找不到，则继续查找大小为 $2^{i＋3}$ 的空闲分区，以此类推。</p>
<p>由此可见，在最坏的情况下，可能需要对 $2^k$ 的空闲分区进行 $k$ 次分割才能得到所需分区。</p>
<p>与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小为 $2^i$ 的空闲分区时，若事先已存在 $2^i$ 的空闲分区时，则应将其与伙伴分区合并为大小为 $2^{i＋1}$ 的空闲分区，若事先已存在 $2^{i＋1}$ 的空闲分区时，又应继续与其伙伴分区合并为大小为 $2^{i＋2}$ 的空闲分区，依此类推。</p>
<p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。 需要指出的是，在当前的操作系统中，普遍采用的是下面将要讲述的基于分页和分段机制的虚拟内存机制，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。</p>
<h4><span id="内存紧缩">内存紧缩 </span></h4><p> 内存紧缩是一种内存碎片化处理的方案。它将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。这种技术在提供了某种程度上的灵活性的同时，也存在着一些弊端，例如：对占用分区进行内存数据搬移占用 CPU 时间；如果对占用分区中的程序进行“浮动”，则其重定位需要硬件支持。</p>
<p>紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时。</p>
<p><img src="https://i.loli.net/2020/08/25/TiQOxfhp4YAnckV.jpg" alt="图"></p>
<h5><span id="堆结构的存储管理的分配算法">堆结构的存储管理的分配算法 </span></h5><p> 在动态存储过程中，不管哪个时刻，可利用空间都是 - 一个地址连续的存储区，在编译程序中称之为”堆”，每次分配都是从这个可利用空间中划出一块。其实现办法是：设立一个指針，称之为堆指针，始终指向堆的最低（或锻联）地址。当用户申请 N 个单位的存储块时，堆指针向高地址（或 低地址）称动 N 个存储单位，而移动之前的堆指针的值就是分配给用户的占用块的初始地址。例如，某个串处理系统中有 A、B、C、D 这 4 个串，其串值长度分别為 12, 6, 10 和 8. 假设堆指针 free 的初值为零，则分配给这 4 个串值的存储空间的初始地址分别为 0.12.18 和 28, 如图所示，分配后的堆指针的值为 36。 因此，<strong>这种堆结构的存储管理的分配算法非常简单</strong>，</p>
<h5><span id="释放内存空间执行内存紧缩">释放内存空间执行内存紧缩 </span></h5><p> 回收用户释放的空闲块就比较麻烦. 由于系统的可利用空间始终是一个绝址连续的存储块，因此回收时必须将所释放的空间块合并到整个堆上去才 能重新使用，这就是”存储策缩”的任务. 通常，有两种做法：</p>
<p>一种是一旦有用户释放存储块即进行回收紧缩，例始，上图中 a 的堆，在 c 串释放存储块时即回收紧缩，例如 b 的堆，同时修改串的存储映像成 c 的状态；</p>
<p>另一种是在程序执行过程中不回收用户随时释放的存储块，直到可利用空同不够分配或堆指针指向最高地址时才进行存储紧缩。此时紧缩的目的是将堆中所有的空间块连成一块，即将所有的占用块部集中到 可利用空间的低地地区，而剩余的高地址区成为一整个地继连续的空闲块，如下图所示，其中（a）为紧缩前的状态，(b)为紧缩后的状态</p>
<p><img src="https://i.loli.net/2020/08/25/hrMuO3gatlBIdk8.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDMwNzkyNV8xMzg5LmpwZw"></p>
<p>和无用单元收集类似，为实现存储紧编, 首先要对占用块进行“标志”，标志算法和无用单元收集类同(存储块的结构可能不同）, 其次需进行下列 4 步雄作：</p>
<ol>
<li>计算占用块的新地址。从最低地址开始巡査整个存储空间，对每一个占用块找到它在紧缩后的新地址。 为此, 需设立两个指针随巡查向前移动, 这两个指针分别指示占用 块在紧缩之前和之后的原地址和新地址。因此, 在每个占用块的第 -·个存储单位中，除了 设立长度域(存储该占用换的大小）和标志域(存储区别该存储块是占用块或空闲块的标 志）之外，还需设立一个新地址城，以存储占用块在紧缩后应有的新地址，即建立一张新， 旧地址的对照表 m</li>
<li>修改用户触初始变量表，以便在存储紧缩后用户程序能继续正常运行。</li>
<li>检查每个占用块中存储的数据， 若有指向其他存储换的指针，则需作相应修改。</li>
<li>将所有占用块迁移到新地址走，这实质上是作传送数据的工作。</li>
</ol>
<p>至此，完成了存储紧缩的操作，最后, 将堆指针赋以新值（即紧缩后的空闲存储区的最低地址）。</p>
<p>可见, 存储紧缩法比无用单元收集法更为复杂，前者不仅要传送数据（进行占用块迁移），而且还有需要修改所有占用块中的指针值。因此，存储紧缩也是个系统操作，且非不得已就不用。</p>
<h4><span id="覆盖技术">覆盖技术 </span></h4><p><strong> 引入覆盖 </strong> <strong>(overlay)</strong> 技术的目标是在较小的可用内存中运行较大的程序。这种技术常用于多道程序系统之中，与分区式存储管理配合使用。</p>
<p>覆盖技术的原理：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分 (常用功能) 的代码和数据常驻内存；可选部分 (不常用功能) 平时存放在外存 (覆盖文件) 中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。</p>
<p>在任何时候只在内存中保留所需的指令和数据；当需要其它指令时，它们会装入到刚刚不再需要的指令所占用的内存空间；</p>
<p>如在同一时刻，CPU 只能执行 B，C 中某一条。B，C 之间就可以做覆盖。</p>
<p><img src="https://i.loli.net/2020/08/25/RY2srW83VcawoFk.png" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTYvMTM1MDM1NzUzOV83MjI5LnBuZw"></p>
<p>覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。</p>
<p>覆盖的实现方式有两种：以函数库方式实现或操作系统支持。</p>
<h4><span id="交换技术">交换技术 </span></h4><p><strong> 交换 (swapping)</strong>技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读入保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。</p>
<p><strong>原理：</strong>暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出 swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入 swap in）。</p>
<p><strong>交换 </strong> 技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换入和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。</p>
<p>与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。</p>
<h3><span id="非连续内存分配管理">非连续内存分配管理 </span></h3><p> 在前面的几种存储管理方法中，<strong>为进程分配的空间是连续的，使用的地址都是物理地址</strong>。如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。地址空间和存储空间两个基本概念的定义如下：</p>
<p>地址空间：将源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。</p>
<p>存储空间：指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址存储空间是物理地址的集合。</p>
<p>根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：</p>
<p><strong>页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。</strong></p>
<h4><span id="页式存储管理">页式存储管理 </span></h4><p> 将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要 CPU 的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址 w（位移量），如图所示：</p>
<p><img src="https://i.loli.net/2020/08/25/D5HJrxfIRU3nsGe.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDI5ODA0MF8zNDQwLmpwZw"></p>
<p><strong>页式管理方式的优点是：</strong></p>
<ol>
<li>没有外碎片，每个内碎片不超过页大</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</li>
</ol>
<p><strong>缺点 </strong> 是：要求程序全部装入内存，没有足够的内存，程序就不能执行。</p>
<h5><span id="数据结构">数据结构 </span></h5><p> 在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。为了完成上述的功能，—个页式系统中，一般要采用如下的数据结构。</p>
<p><strong>进程页表 </strong>：完成逻辑页号(本进程的地址空间) 到物理页面号 (实际内存空间，也叫块号) 的映射。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的 PCB 中，当该进程被调度时，就将它们装入页表寄存器。<br>每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序，如图</p>
<p><img src="https://i.loli.net/2020/08/25/ELZsFn9WKQXSYHP.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDI5ODI0MF80MTI3LmpwZw"></p>
<p><strong>物理页面表：</strong>整个系统有一个物理页面表，描述物理内存空间的分配使用状况，其数据结构可 <strong> 采用位示图和空闲页链表</strong>。</p>
<p>对于位示图法，即如果该页面已被分配，则对应比特位置 1，否置 0.</p>
<p><img src="https://i.loli.net/2020/08/25/DYKkzTCBXlnjb45.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDI5ODQ4M18zNTM2LmpwZw"></p>
<p><strong>请求表：</strong>整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换也可以结合到各进程的 PCB(进程控制块)里。如图：</p>
<p><img src="https://i.loli.net/2020/08/25/7vXAMBziLPGdDxJ.jpg" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDI5ODY5OF8yMzY3LmpwZw"></p>
<h5><span id="地址变换">地址变换 </span></h5><p> 在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。CPU 中的内存管理单元 (MMU) 按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。逻辑页号，页内偏移地址－&gt; 查进程页表，得物理页号－&gt; 物理地址。</p>
<p><img src="https://i.loli.net/2020/08/25/LHryoqOBdNEKk3h.png" alt="aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDI4MTMyMF85MDk1LnBuZw"></p>
<p>上述过程通常由处理器的硬件直接完成，不需要软件参与。通常，操作系统只需在进程切换时，把进程页表的首地址装入处理器特定的寄存器中即可。一般来说，页表存储在主存之中。这样处理器每访问一个在内存中的操作数，就要访问两次内存。</p>
<p>第一次用来查找页表将操作数的逻辑地址变换为物理地址；</p>
<p>第二次完成真正的读写操作。    </p>
<p>这样做时间上耗费严重。为缩短查找时间，可以将页表从内存装入 CPU 内部的关联存储器(例如，快表) 中，实现按内容查找。此时的地址变换过程是：在 CPU 给出有效地址后，由地址变换机构自动将页号送入快表，并将此页号与快表中的所有页号进行比较，而且这 种比较是同时进行的。若其中有与此相匹配的页号，表示要访问的页的页表项在快表中。于是可直接读出该页所对应的物理页号，这样就无需访问内存中的页表。由于关联存储器的访问速度比内存的访问速度快得多。</p>
<h5><span id="快表">快表 </span></h5><p> 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样 CPU 存一个数据必须访问两次内存，从而使计算机的处理速度降低了 1/2。</p>
<p>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</p>
<p>其地址变换过程：</p>
<ol>
<li>CPU 给出有效地址</li>
<li>地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中</li>
<li>若是，则直接读出该页所对应的物理块号，送入物理地址寄存器</li>
<li>若快表中未找到对应的页表项，则需再访问内存中的页表</li>
<li>找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项</li>
</ol>
<h5><span id="两级和多级页表">两级和多级页表 </span></h5><p> 主要是有的时候页表太多了，要化简。格式：外层页号 P1+ 外层页内地址 P2+ 页内地址 d</p>
<p>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</p>
<h5><span id="反置页表">反置页表 </span></h5><p> 为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</p>
<h4><span id="段式存储管理">段式存储管理 </span></h4><p> 在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。</p>
<p>在为某个段分配物理内存时，可以采用首先适配法、下次适配法、最佳适配法等方法。</p>
<p>在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</p>
<p>段式存储管理也需要硬件支持，实现逻辑地址到物理地址的映射。</p>
<p>程序通过分段划分为多个模块，如代码段、数据段、共享段：</p>
<ul>
<li>可以分别编写和编译</li>
<li>可以针对不同类型的段采取不同的保护</li>
<li>可以按段为单位来进行共享，包括通过动态链接进行代码共享</li>
</ul>
<p>这样做的优点是：可以分别编写和编译源程序的一个文件，并且可以针对不同类型的段采取不同的保护，也可以按段为单位来进行共享。</p>
<p>总的来说，<strong>段式存储管理的优点是</strong>：没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。</p>
<h5><span id="数据结构">数据结构 </span></h5><p> 为了实现段式管理，操作系统需要如下的数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。</p>
<p><strong>进程段表</strong>：描述组成进程地址空间的各段，可以是指向系统段表中表项的索引。每段有段基址(baseaddress)，即段内地址。在系统中为每个进程建立一张段映射表，如图：</p>
<p>​     <img src="https://i.loli.net/2020/08/25/uFYaBxo7hv36qer.jpg" alt="img"></p>
<p><strong>系统段表</strong>：系统所有占用段（已经分配的段）。</p>
<p><strong>空闲段表</strong>：内存中所有空闲段，可以结合到系统段表中。</p>
<h5><span id="地址变换">地址变换</span></h5><p>​    <img src="https://i.loli.net/2020/08/25/rEelMt4JRhT8jyW.png" alt="img"></p>
<p>在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。这个过程也是由处理器的硬件直接完成的，操作系统只需在进程切换时，将进程段表的首地址装入处理器的特定寄存器当中。这个寄存器一般被称作段表地址寄存器。</p>
<h4><span id="页式和段式的区别">页式和段式的区别 </span></h4><p> 页式和段式系统有许多相似之处。比如，两者都采用离散分配方式，且都通过地址映射机构来实现地址变换。但概念上两者也有很多区别，主要表现在：</p>
<ol>
<li>需求：是信息的物理单位，分页是为了实现离散分配方式，以减少内存的碎片，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好地满足用户的需要。</li>
<li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
<li>大小：页大小固定且由系统决定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的。段的长度不固定，且决定于用户所编写的程序，通常由编译系统在对源程序进行编译时根据信息的性质来划分。</li>
<li>逻辑地址表示：页式系统地址空间是一维的，即单一的线性地址空间，程序员只需利用一个标识符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li>
<li>比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>
</ol>
<h4><span id="段页式存储管理">段页式存储管理 </span></h4><p><strong> 页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享 </strong>。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。段页式管理就是<strong> 将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用</strong>。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷。如果我们将每个段看做一个单独的程序，则逻辑分段就相当于同时加载多个程序。</p>
<p><img src="https://i.loli.net/2020/08/25/JXQL5gPaymSxYCs.jpg" alt="在这里插入图片描述"></p>
<h5><span id="数据结构">数据结构 </span></h5><p> 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图所示。</p>
<p><img src="https://i.loli.net/2020/08/25/VUKg5aXRm9ZqcG6.png" alt="在这里插入图片描述"></p>
<h5><span id="地址变换">地址变换 </span></h5><p><strong> 为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）</strong>。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。</p>
<p>在进行地址变换时，首先通过 <strong> 段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址</strong>。如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。<br><img src="https://i.loli.net/2020/08/25/1E2kzDQFg6wscxe.jpg" alt="在这里插入图片描述"></p>
<p>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</p>
<p><img src="https://i.loli.net/2020/08/25/euGV9ATN6PqyDQW.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 核心技术与原理初探</title>
    <url>/2018/03/01/docker/Docker%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>提到虚拟化技术，我们首先想到的一定是 Docker，经过四年的快速发展 Docker 已经成为了很多公司的标配，也不再是一个只能在开发阶段使用的玩具了。作为在生产环境中广泛应用的产品，Docker 有着非常成熟的社区以及大量的使用者，代码库中的内容也变得非常庞大。</p>
<p>Docker 目前的组件相当多，并且实现也非常复杂，本文忽略繁杂的细节，集中探讨 Docker 的一些基础技术原理。</p>
<a id="more"></a>
<h2><span id="容器虚拟机">容器？虚拟机？</span></h2><p>容器和虚拟机是非常相似的技术概念，因为他们都提供了隔离应用和依赖环境的能力，都可以看作是提供了一个沙箱环境，使得应用都可以部署在任意宿主机。但两者的底层原理有所不同。</p>
<h3><span id="虚拟机">虚拟机 </span></h3><p> 虚拟机理论上是一个真实的计算机操作系统的封装，它运行在物理设备之上，通过 Hypervisor 进行建立和运行虚拟机体系。常见的虚拟基本架构如下：</p>
<p><img src="https://i.loli.net/2020/09/02/Crgxi5A8OtdD6V1.png" alt="2019-07-31-15-40-55"></p>
<p>在 Host OS 的基础上，通过 Hypervisor 来进行虚拟机资源控制，并拥有自己的 Guest OS，虽然隔离得更彻底，但是显然资源的开销会更大。</p>
<h3><span id="容器">容器 </span></h3><p> 不同于虚拟机提供在物理硬件级别的操作系统隔离，容器技术提供的是操作系统级别的进程隔离，Docker 本身只是操作系统的一个进程，只是在容器技术下，进程之间网络、空间等等是隔离的，互不知道彼此。</p>
<p><img src="https://i.loli.net/2020/08/29/rhYdmqNQnzajc3f.png" alt="docker-core-techs"></p>
<p><strong>容器与虚拟机技术最大的区别在于：多个容器之间是共享了宿主机的操作系统内核</strong>。在 Host OS 上，通过 Docker Engine 共享 Host OS 的内核：</p>
<p><img src="https://i.loli.net/2020/09/02/OgkzsIcBhWbL1nH.png" alt="img"></p>
<p>首先，Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。</p>
<h2><span id="资源隔离命名空间-namespaces">资源隔离：命名空间 Namespaces</span></h2><p>命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到 <strong> 完全隔离</strong>，就像运行在多台不同的机器上一样。</p>
<p><img src="https://i.loli.net/2020/08/29/7XbSceY8OupAmgN.png" alt="multiple-servers-on-linux"></p>
<p>在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这也是我们不想看到的，而 Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。</p>
<p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 <code>CLONE_NEWCGROUP</code>、<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWNS</code>、<code>CLONE_NEWPID</code>、<code>CLONE_NEWUSER</code> 和 <code>CLONE_NEWUTS</code>，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p>
<h3><span id="进程">进程 </span></h3><p> 进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。在每一个 *nix 的操作系统上，我们都能够通过 <code>ps</code> 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> Apr08 ?        00:00:09 /sbin/init
root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:05 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">7</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:07:10 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
root        <span class="token number">39</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:00:00 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span>
root        <span class="token number">40</span>     <span class="token number">2</span>  <span class="token number">0</span> Apr08 ?        00:01:54 <span class="token punctuation">[</span>watchdog/0<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 <code>pid</code> 为 1 的 <code>/sbin/init</code> 进程，另一个是 <code>pid</code> 为 2 的 <code>kthreadd</code> 进程，这两个进程都是被 Linux 中的上帝进程 <code>idle</code> 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 <code>getty</code> 的注册进程，而后者负责管理和调度其他的内核进程。</p>
<p><img src="https://i.loli.net/2020/08/29/ecHLJgxUOtnXKGa.png" alt="linux-processes"></p>
<p>如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 <code>exec</code> 进入其内部的 <code>bash</code> 并打印其中的全部进程，我们会得到以下的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@iZ255w13cy6Z:~<span class="token comment"># docker run -it -d ubuntu</span>
b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79
root@iZ255w13cy6Z:~<span class="token comment"># docker exec -it b809a2eb3630 /bin/bash</span>
root@b809a2eb3630:/<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">15</span>:42 pts/0    00:00:00 /bin/bash
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">15</span>:42 pts/1    00:00:00 /bin/bash
root        <span class="token number">17</span>     <span class="token number">9</span>  <span class="token number">0</span> <span class="token number">15</span>:43 pts/1    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在新的容器内部执行 <code>ps</code> 命令打印出了非常干净的进程列表，只有包含当前 <code>ps -ef</code> 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。</p>
<p>当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root     <span class="token number">29407</span>     <span class="token number">1</span>  <span class="token number">0</span> Nov16 ?        00:08:38 /usr/bin/dockerd --raw-logs
root      <span class="token number">1554</span> <span class="token number">29407</span>  <span class="token number">0</span> Nov19 ?        00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval<span class="token operator">=</span><span class="token number">0</span> --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc
root      <span class="token number">5006</span>  <span class="token number">1554</span>  <span class="token number">0</span> 08:38 ?        00:00:00 docker-containerd-shim b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 /var/run/docker/libcontainerd/b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 docker-runc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树：</p>
<p><img src="https://i.loli.net/2020/08/29/jrcaVNQ1OYteB3h.png" alt="docker-process-group"></p>
<p>这就是在使用 <code>clone(2)</code> 创建新进程时传入 <code>CLONE_NEWPID</code> 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">containerRouter.postContainersStart
└── daemon.ContainerStart
    └── daemon.createSpec
        └── setNamespaces
            └── setNamespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 <code>docker run</code> 或者 <code>docker start</code> 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">)</span> <span class="token function">createSpec</span><span class="token punctuation">(</span>c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> oci<span class="token punctuation">.</span><span class="token function">DefaultSpec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"linux spec namespaces: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>setNamespaces</code> 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">setNamespaces</span><span class="token punctuation">(</span>daemon <span class="token operator">*</span>Daemon<span class="token punctuation">,</span> s <span class="token operator">*</span>specs<span class="token punctuation">.</span>Spec<span class="token punctuation">,</span> c <span class="token operator">*</span>container<span class="token punctuation">.</span>Container<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// user</span>
	<span class="token comment">// network</span>
	<span class="token comment">// ipc</span>
	<span class="token comment">// uts</span>

	<span class="token comment">// pid</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ns <span class="token operator">:=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"pid"</span><span class="token punctuation">&#125;</span>
		pc<span class="token punctuation">,</span> err <span class="token operator">:=</span> daemon<span class="token punctuation">.</span><span class="token function">getPidContainer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">&#125;</span>
		ns<span class="token punctuation">.</span>Path <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"/proc/%d/ns/pid"</span><span class="token punctuation">,</span> pc<span class="token punctuation">.</span>State<span class="token punctuation">.</span><span class="token function">GetPID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c<span class="token punctuation">.</span>HostConfig<span class="token punctuation">.</span>PidMode<span class="token punctuation">.</span><span class="token function">IsHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		oci<span class="token punctuation">.</span><span class="token function">RemoveNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> specs<span class="token punctuation">.</span><span class="token function">LinuxNamespaceType</span><span class="token punctuation">(</span><span class="token string">"pid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		ns <span class="token operator">:=</span> specs<span class="token punctuation">.</span>LinuxNamespace<span class="token punctuation">&#123;</span>Type<span class="token punctuation">:</span> <span class="token string">"pid"</span><span class="token punctuation">&#125;</span>
		<span class="token function">setNamespace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有命名空间相关的设置 <code>Spec</code> 最后都会作为 <code>Create</code> 函数的入参在创建新的容器时进行设置：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">daemon<span class="token punctuation">.</span>containerd<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> container<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> spec<span class="token punctuation">,</span> createOptions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔离。</p>
<h3><span id="网络">网络 </span></h3><p> 如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却又没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p>
<p>每一个使用 <code>docker run</code> 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。</p>
<p><img src="https://i.loli.net/2020/08/29/PvBQqfkS3N1mpxi.png" alt="docker-network"></p>
<p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。</p>
<p><img src="https://i.loli.net/2020/08/29/J7uD3G9gSd6eO1l.png" alt="docker-network-topology"></p>
<p>在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。我们可以使用如下的命令来查看当前网桥的接口：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ brctl show
bridge name	bridge <span class="token function">id</span>		STP enabled	interfaces
docker0		<span class="token number">8000</span>.0242a6654980	no		veth3e84d4f
							            veth9953b75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>docker0 会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ iptables -t nat -L
Chain PREROUTING <span class="token punctuation">(</span>policy ACCEPT<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>               destination
RETURN     all  --  anywhere             anywhere<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在当前的机器上使用 <code>docker run -d -p 6379:6379 redis</code> 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 <code>iptables</code> 的 NAT 配置就会看到在 <code>DOCKER</code> 的链中出现了一条新的规则：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">DNAT       tcp  --  anywhere             anywhere             tcp dpt:6379 to:192.168.0.4:6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。</p>
<p>这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ping</span> <span class="token number">192.168</span>.0.4
PING <span class="token number">192.168</span>.0.4 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.4<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.069</span> ms
<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.4: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.043</span> ms
^C
--- <span class="token number">192.168</span>.0.4 <span class="token function">ping</span> statistics ---
<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 999ms
rtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.043</span>/0.056/0.069/0.013 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。</p>
<p><img src="https://i.loli.net/2020/08/29/dax5mACvb6NHfEF.png" alt="docker-network-forward"></p>
<p>当我们使用 <code>redis-cli</code> 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6379</span> <span class="token function">ping</span>
PONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p>
<h4><span id="libnetwork">libnetwork</span></h4><p>整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的 <strong> 容器网络模型</strong>。</p>
<blockquote>
<p>The goal of libnetwork is to deliver a robust Container Network Model that provides a consistent programming interface and the required network abstractions for applications.</p>
</blockquote>
<p>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network：</p>
<p><img src="https://i.loli.net/2020/08/29/T5mjHLCXvh4J3tu.png" alt="container-network-model"></p>
<p>在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</p>
<blockquote>
<p>想要获得更多与 libnetwork 或者容器网络模型相关的信息，可以阅读 <a href="https://github.com/docker/libnetwork/blob/master/docs/design.md">Design · libnetwork</a> 了解更多信息，当然也可以阅读源代码了解不同 OS 对容器网络模型的不同实现。</p>
</blockquote>
<h3><span id="挂载点">挂载点 </span></h3><p> 虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p>
<p>在新的进程中创建隔离的挂载点命名空间需要在 <code>clone</code> 函数中传入 <code>CLONE_NEWNS</code>，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数 <strong> 子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统</strong>。</p>
<p>如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。</p>
<p><img src="https://i.loli.net/2020/08/29/YL8jAqxevWuZPSy.png" alt="libcontainer-filesystem"></p>
<p>想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。</p>
<p><img src="https://i.loli.net/2020/08/29/M7dcRLkSNeVHbj6.png" alt="libcontainer-symlinks-and-io"></p>
<p>为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcontainer 提供的 <code>pivot_root</code> 或者 <code>chroot</code> 函数改变进程能够访问个文件目录的根节点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// pivor_root</span>
put_old <span class="token operator">=</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pivot_root</span><span class="token punctuation">(</span>rootfs<span class="token punctuation">,</span> put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unmount</span><span class="token punctuation">(</span>put_old<span class="token punctuation">,</span> MS_DETACH<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">rmdir</span><span class="token punctuation">(</span>put_old<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chroot</span>
<span class="token function">mount</span><span class="token punctuation">(</span>rootfs<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> MS_MOVE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chroot</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。</p>
<blockquote>
<p>这一部分的内容是作者在 libcontainer 中的 <a href="https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md">SPEC.md</a> 文件中找到的，其中包含了 Docker 使用的文件系统的说明，对于 Docker 是否真的使用 <code>chroot</code> 来确保当前的进程无法访问宿主机器的目录，作者其实也 <strong> 没有确切的答案 </strong>，一是 Docker 项目的代码太多庞大，不知道该从何入手，作者尝试通过 Google 查找相关的结果，但是既找到了无人回答的 <a href="https://forums.docker.com/t/does-the-docker-engine-use-chroot/25429"> 问题 </a>，也得到了与 SPEC 中的描述有冲突的 <a href="https://www.quora.com/Do-Docker-containers-use-a-chroot-environment"> 答案</a> ，如果各位读者有明确的答案可以在博客下面留言，非常感谢。</p>
</blockquote>
<h3><span id="chroot">chroot</span></h3><p>在这里不得不简单介绍一下 <code>chroot</code>（change root），在 Linux 系统中，系统默认的目录就都是以 <code>/</code> 也就是根目录开头的，<code>chroot</code> 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p>
<blockquote>
<p>与 chroot 的相关内容部分来自 <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html">理解 chroot</a> 一文，各位读者可以阅读这篇文章获得更详细的信息。</p>
</blockquote>
<h2><span id="资源限制cgroups">资源限制：CGroups</span></h2><p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。</p>
<p><img src="https://i.loli.net/2020/08/29/os4E8KvWazui521.png" alt="docker-shared-resources"></p>
<p>如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p>
<p>每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p>
<p><img src="https://i.loli.net/2020/08/29/AfvxM3omeE7Tudp.png" alt="cgroups-inheritance"></p>
<p>Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配，CGroup 能够提供以下的几种功能：</p>
<p><img src="https://i.loli.net/2020/08/29/kI4HhGTte6aAymd.png" alt="groups-features"></p>
<blockquote>
<p>在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。</p>
<p>– <a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">CGroup 介绍、应用实例及原理描述</a></p>
</blockquote>
<p>Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ lssubsys -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。</p>
<p>如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 docker 的文件夹：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ls</span> cpu
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
docker  
notify_on_release 
release_agent 
tasks

$ <span class="token function">ls</span> cpu/docker/
9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 
cgroup.clone_children  
<span class="token punctuation">..</span>.
cpu.stat  
notify_on_release 
release_agent 
tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>9c3057xxx</code> 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：</p>
<p><img src="https://i.loli.net/2020/08/29/wXYPHcUyBrVfTWN.png" alt="linux-cgroups"></p>
<p>每一个 CGroup 下面都有一个 <code>tasks</code> 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，<code>cpu.cfs_quota_us</code> 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<p>如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 <code>docker</code> 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -it -d --cpu-quota<span class="token operator">=</span><span class="token number">50000</span> busybox
53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274
$ <span class="token builtin class-name">cd</span> 53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274/
$ <span class="token function">ls</span>
cgroup.clone_children  cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.shares  cpu.stat  notify_on_release  tasks
$ <span class="token function">cat</span> cpu.cfs_quota_us
<span class="token number">50000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。</p>
<h2><span id="存储驱动unionfs">存储驱动：UnionFS</span></h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p>
<p>镜像到底是什么，它又是如何组成和组织的是作者使用 Docker 以来的一段时间内一直比较让作者感到困惑的问题，我们可以使用 <code>docker run</code> 非常轻松地从远程下载 Docker 的镜像并在本地运行。</p>
<p>Docker 镜像其实本质就是一个压缩包，我们可以使用下面的命令将一个 Docker 镜像中的文件导出：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker <span class="token builtin class-name">export</span> <span class="token variable"><span class="token variable">$(</span>docker create busybox<span class="token variable">)</span></span> <span class="token operator">|</span> <span class="token function">tar</span> -C rootfs -xvf -
$ <span class="token function">ls</span>
bin  dev  etc  home proc root sys  tmp  usr  var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可以看到这个 busybox 镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 <strong>Docker 镜像就是一个文件</strong>。</p>
<h3><span id="存储驱动">存储驱动</span></h3><p>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与 Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。</p>
<p>想要理解 Docker 使用的存储驱动，我们首先需要理解 Docker 是如何构建并且存储镜像的，也需要明白 Docker 的镜像是如何被每一个容器所使用的；Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntu:15.04
COPY . &#x2F;app
RUN make &#x2F;app
CMD python &#x2F;app&#x2F;app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>容器中的每一层都只对当前容器进行了非常小的修改，上述的 Dockerfile 文件会构建一个拥有四层 layer 的镜像：</p>
<p><img src="https://i.loli.net/2020/08/29/OjlPgrkvCB6QdA4.png" alt="docker-container-laye"></p>
<p>当镜像被 <code>docker run</code> 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。</p>
<p>容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。</p>
<p><img src="https://i.loli.net/2020/08/29/I3DQBAdHYpEbXWq.png" alt="docker-images-and-container"></p>
<h3><span id="aufs">AUFS</span></h3><p>其实在有了 Namespace 和 cgroups 的情况下，对于 Docker 项目的初始化可以简单抽象为：</p>
<ol>
<li>启动 Namespace 配置</li>
<li>设置 cgroups 参数，对资源进行限制</li>
<li>切换进程的根目录</li>
</ol>
<p>但是还有另外一个问题，<strong>是否每次打包、升级镜像都要重新走一遍整个初始化流程</strong>？这显然是不合理的。</p>
<p>Docker 中最典型的存储驱动就是 AUFS（Advanced Multi-layered unification filesytem），可以将 AUFS 想象为一个可以 “栈式叠加” 的文件系统，AUFS 允许在一个基础的文件系统的上，“增量式” 的增加文件。AUFS 支持将不同目录挂载到同一个目录下，这种挂载对用户来说是透明的。通常，AUFS 最上层是可读写层，而最底层是只读层，每一层都是一个普通的文件系统。</p>
<p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p>
<p>AUFS 作为联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为 <em> 联合挂载（Union Mount）</em>：</p>
<p><img src="https://i.loli.net/2020/08/29/GgsoNJSW7kFymVu.png" alt="docker-aufs"></p>
<p>每一个镜像层或者容器层都是 <code>/var/lib/docker/</code> 目录下的一个子文件夹；在 Docker 中，所有镜像层和容器层的内容都存储在 <code>/var/lib/docker/aufs/diff/</code> 目录中：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">ls</span> /var/lib/docker/aufs/diff/00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c       93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8
00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c-init  93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8-init
019a8283e2ff6fca8d0a07884c78b41662979f848190f0658813bb6a9a464a90       93b06191602b7934fafc984fbacae02911b579769d0debd89cf2a032e7f35cfa
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而 <code>/var/lib/docker/aufs/layers/</code> 中存储着镜像层的元数据，每一个文件都保存着镜像层的元数据，最后的 <code>/var/lib/docker/aufs/mnt/</code> 包含镜像或者容器层的挂载点，最终会被 Docker 通过联合的方式进行组装。</p>
<p><img src="https://i.loli.net/2020/08/29/XxoDKUnTwsmidc5.png" alt="docker-filesystems"></p>
<p>上面的这张图片非常好的展示了组装的过程，每一个镜像层都是建立在另一个镜像层之上的，同时所有的镜像层都是只读的，只有每个容器最顶层的容器层才可以被用户直接读写，所有的容器都建立在一些底层服务（Kernel）上，包括命名空间、控制组、rootfs 等等，这种容器的组装方式提供了非常大的灵活性，只读的镜像层通过共享也能够减少磁盘的占用。</p>
<h4><span id="aufs-的读写操作">AUFS 的读写操作 </span></h4><h5><span id="读操作"> 读操作 </span></h5><p> 当需要 <strong> 写入 </strong> 一个文件时，不存在时则在可读写层新建一个，否则一直从向下寻找。</p>
<h5><span id="写操作">写操作 </span></h5><p> 当<strong>删除 </strong> 一个文件中，如果文件仅存在可读写层，则直接删除这个文件。</p>
<p>但是又有一个问题，如果删除的是只读层的文件呢？所以在这种情况下，会先删除可读写层中的备份，之后通过创建一个 whiteout 文件来标记文件不存在，这其实是一种 “遮挡”，只读层文件却不会被真正的删除，但是表现上确是已经被 “删除” 了。</p>
<p>当 <strong> 新建 </strong> 文件时，由于 whiteout 的 存在，所以需要先检查 whiteout 是否存在，存在的情况下，需要先删除再创建。</p>
<p>AUFS 只是 Docker 存储驱动的其中一种，在有些场景下并不是最优的选择，但都是属于 Union File System，主要是基于 “写时复制” 以及 “用时配置” 两种方式，但它能够有效帮助我们理解 Docker 的分层结构以及原理。其他的 Docker 存储驱动还有 OverlayFS、Devicemapper、Btrfs、ZFS 等，这里不再赘述。</p>
<h3><span id="其他存储驱动">其他存储驱动</span></h3><p>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 <code>aufs</code>、<code>devicemapper</code>、<code>overlay2</code>、<code>zfs</code> 和 <code>vfs</code> 等等，在最新的 Docker 中，<code>overlay2</code> 取代了 <code>aufs</code> 成为了推荐的存储驱动，但是在没有 <code>overlay2</code> 驱动的机器上仍然会使用 <code>aufs</code> 作为 Docker 的默认驱动。</p>
<p><img src="https://i.loli.net/2020/08/29/FaMDlpWB1UKAzYk.png" alt="docker-storage-driver"></p>
<p>不同的存储驱动在存储镜像和容器文件时也有着完全不同的实现，有兴趣的读者可以在 Docker 的官方文档 <a href="https://docs.docker.com/engine/userguide/storagedriver/selectadriver/">Select a storage driver</a> 中找到相应的内容。</p>
<p>想要查看当前系统的 Docker 上使用了哪种存储驱动只需要使用以下的命令就能得到相对应的信息：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker info <span class="token operator">|</span> <span class="token function">grep</span> Storage
Storage Driver: aufs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="总结">总结</span></h2><p>Docker 目前已经成为了非常主流的技术，已经在很多成熟公司的生产环境中使用，但是 Docker 的核心技术其实已经有很多年的历史了，Linux 命名空间、控制组 Cgroups 和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。</p>
<h2><span id="参考文献">参考文献</span></h2><ul>
<li><a href="https://www.safaribooksonline.com/library/view/using-docker/9781491915752/ch04.html">Chapter 4. Docker Fundamentals · Using Docker by Adrian Mount</a></li>
<li><a href="https://washraf.gitbooks.io/the-docker-ecosystem/content/Chapter 1/Section 3/techniques_behind_docker.html">TECHNIQUES BEHIND DOCKER</a></li>
<li><a href="https://docs.docker.com/engine/docker-overview/#the-underlying-technology">Docker overview</a></li>
<li><a href="https://lwn.net/Articles/312641/">Unifying filesystems with union mounts</a></li>
<li><a href="https://coolshell.cn/articles/17061.html">DOCKER 基础技术：AUFS</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/">RESOURCE MANAGEMENT GUIDE</a></li>
<li><a href="http://www.linuxjournal.com/article/7714">Kernel Korner - Unionfs: Bringing Filesystems Together</a></li>
<li><a href="https://lwn.net/Articles/325369/">Union file systems: Implementations, part I</a></li>
<li><a href="https://blog.docker.com/2016/05/docker-unikernels-open-source/">IMPROVING DOCKER WITH UNIKERNELS: INTRODUCING HYPERKIT, VPNKIT AND DATAKIT</a></li>
<li><a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces">Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html">理解 chroot</a></li>
<li><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialInitProcess.html">Linux Init Process / PC Boot Procedure</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice#">Docker 网络详解及 pipework 源码解读与实践</a></li>
<li><a href="https://docs.docker.com/engine/userguide/networking/default_network/container-communication/#communication-between-containers">Understand container communication</a></li>
<li><a href="https://github.com/docker/labs/blob/master/networking/concepts/05-bridge-networks.md">Docker Bridge Network Driver Architecture</a></li>
<li><a href="http://www.thegeekstuff.com/2011/01/iptables-fundamentals/">Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></li>
<li><a href="http://www.iptables.info/en/structure-of-iptables.html">Traversing of tables and chains</a></li>
<li><a href="http://dockone.io/article/1255">Docker 网络部分执行流分析（Libnetwork 源码解读）</a></li>
<li><a href="https://github.com/docker/libnetwork/blob/master/docs/design.md">Libnetwork Design</a></li>
<li><a href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper">剖析 Docker 文件系统：Aufs 与 Devicemapper</a></li>
<li><a href="https://stackoverflow.com/questions/22889241/linux-understanding-the-mount-namespace-clone-clone-newns-flag">Linux - understanding the mount namespace &amp; clone CLONE_NEWNS flag</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation">Docker 背后的内核知识 —— Namespace 资源隔离</a></li>
<li><a href="https://linuxcontainers.org/">Infrastructure for container projects</a></li>
<li><a href="https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md">Spec · libcontainer</a></li>
<li><a href="https://coolshell.cn/articles/17010.html">DOCKER 基础技术：LINUX NAMESPACE（上）</a></li>
<li><a href="https://coolshell.cn/articles/17049.html">DOCKER 基础技术：LINUX CGROUP</a></li>
<li><a href="https://yq.aliyun.com/articles/65034">《自己动手写 Docker》书摘之三： Linux UnionFS</a></li>
<li><a href="http://www.programering.com/a/MDMzAjMwATk.html">Introduction to Docker</a></li>
<li><a href="https://docs.docker.com/v1.9/engine/userguide/storagedriver/imagesandcontainers/">Understand images, containers, and storage drivers</a></li>
<li><a href="https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/#configure-docker-with-the-aufs-storage-driver">Use the AUFS storage driver</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言数组与切片</title>
    <url>/2020/01/05/go/Go%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<p>初学 Go，对于数组与切片往往理解不清，在 Python 中，只有 List 这种数据结构，只有切片，而在 Go 中，作为一种编译性语言，数组与切片在底层原理上有所区别，在此需要结合编译运行时来介绍它们的实现原理。</p>
<a id="more"></a>
<h2><span id="数组">数组 </span></h2><h3><span id="数组的数据结构与创建"> 数组的数据结构与创建 </span></h3><p> 数组是由相同类型元素的集合组成的数据结构，<strong>计算机会为数组分配一块连续的内存来保存其中的元素</strong>，我们可以利用数组中元素的索引快速访问元素对应的存储地址，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用。</p>
<p><img src="https://i.loli.net/2020/09/04/QoATkRlvJutEDmx.jpg" alt="2019-02-20-3D-array"></p>
<p>数组作为一种基本的数据类型，我们通常都会从两个维度描述数组，我们首先需要描述数组中存储的元素类型，还需要描述数组最大能够存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewArray</span><span class="token punctuation">(</span>elem <span class="token operator">*</span>Type<span class="token punctuation">,</span> bound <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token operator">*</span>Type <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> bound <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"NewArray: invalid bound %v"</span><span class="token punctuation">,</span> bound<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	t <span class="token operator">:=</span> <span class="token function">New</span><span class="token punctuation">(</span>TARRAY<span class="token punctuation">)</span>
	t<span class="token punctuation">.</span>Extra <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">&#123;</span>Elem<span class="token punctuation">:</span> elem<span class="token punctuation">,</span> Bound<span class="token punctuation">:</span> bound<span class="token punctuation">&#125;</span>
	t<span class="token punctuation">.</span><span class="token function">SetNotInHeap</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">NotInHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> t
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译期间的数组类型是由上述的 <a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L473-L481"><code>cmd/compile/internal/types.NewArray</code></a> 函数生成的，类型 <code>Array</code> 包含两个字段，一个是元素类型 <code>Elem</code>，另一个是数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p>
<h3><span id="初始化">初始化</span></h3><p>Go 语言中的数组有两种不同的创建方式，一种是显式的指定数组的大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码对数组的大小进行推断：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">arr1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
arr2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种，这也就是编译器对数组大小的推导，下面我们来介绍编译器的推导过程。</p>
<h4><span id="上限推导">上限推导 </span></h4><p> 两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 <code>[10]T</code>，那么变量的类型在编译进行到类型检查阶段段就会被提取出来，随后会使用 <a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L473-L481"><code>cmd/compile/internal/types.NewArray</code></a> 函数创建包含数组大小的 <code>Array</code> 类型。</p>
<p>当我们使用 <code>[...]T</code> 的方式声明数组时，虽然在这一步也会创建一个 <code>Array</code> 类型 <code>Array&#123;Elem: elem, Bound: -1&#125;</code>，但是其中的数组大小上限会是 <code>-1</code>，这里的 <code>-1</code> 只是一个占位符，编译器会在后面的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">typecheckcomplit</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>

	<span class="token keyword">switch</span> t<span class="token punctuation">.</span>Etype <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> TARRAY<span class="token punctuation">,</span> TSLICE<span class="token punctuation">:</span>
		<span class="token keyword">var</span> length<span class="token punctuation">,</span> i <span class="token builtin">int64</span>
		nl <span class="token operator">:=</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> i2<span class="token punctuation">,</span> l <span class="token operator">:=</span> <span class="token keyword">range</span> nl <span class="token punctuation">&#123;</span>
			i<span class="token operator">++</span>
			<span class="token keyword">if</span> i <span class="token operator">></span> length <span class="token punctuation">&#123;</span>
				length <span class="token operator">=</span> i
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>

		<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">IsDDDArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			t<span class="token punctuation">.</span><span class="token function">SetNumElem</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个删减后的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数通过遍历元素的方式来计算数组中元素的数量。上述代码中的 <code>DDDArray</code> 指的就是使用 <code>[...]T</code> 声明的数组，因为声明这种数组时需要使用三个点（Dot），所以在编译器中就被称作 <code>DDDArray</code>。</p>
<p>所以我们可以看出 <code>[...]T&#123;1, 2, 3&#125;</code> 和 <code>[3]T&#123;1, 2, 3&#125;</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时就可以通过这种方法较少一些工作。</p>
<h4><span id="语句转换">语句转换 </span></h4><p> 对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L875-L967"><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">anylit</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> var_ <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t <span class="token operator">:=</span> n<span class="token punctuation">.</span>Type
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> OSTRUCTLIT<span class="token punctuation">,</span> OARRAYLIT<span class="token punctuation">:</span>
		<span class="token keyword">if</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">&#123;</span>
			<span class="token operator">...</span>
		<span class="token punctuation">&#125;</span>

		<span class="token function">fixedlit</span><span class="token punctuation">(</span>inInitFunction<span class="token punctuation">,</span> initKindLocalCode<span class="token punctuation">,</span> n<span class="token punctuation">,</span> var_<span class="token punctuation">,</span> init<span class="token punctuation">)</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当数组的元素 <strong> 小于或者等于四个 </strong> 时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583"><code>cmd/compile/internal/gc.fixedlit</code></a> 会负责在函数编译之前将 <code>[3]&#123;1, 2, 3&#125;</code> 转换成更加原始的语句：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fixedlit</span><span class="token punctuation">(</span>ctxt initContext<span class="token punctuation">,</span> kind initKind<span class="token punctuation">,</span> n <span class="token operator">*</span>Node<span class="token punctuation">,</span> var_ <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> splitnode <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>Node<span class="token punctuation">,</span> value <span class="token operator">*</span>Node<span class="token punctuation">)</span>
	<span class="token operator">...</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		a<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token function">splitnode</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
		a <span class="token operator">=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OAS<span class="token punctuation">,</span> a<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
		a <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> ctxStmt<span class="token punctuation">)</span>
		<span class="token keyword">switch</span> kind <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> initKindStatic<span class="token punctuation">:</span>
			<span class="token function">genAsStatic</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
		<span class="token keyword">case</span> initKindLocalCode<span class="token punctuation">:</span>
			a <span class="token operator">=</span> <span class="token function">orderStmtInPlace</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
			a <span class="token operator">=</span> <span class="token function">walkstmt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
			init<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当数组中元素的个数小于四个时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数接受的 <code>kind</code> 是 <code>initKindLocalCode</code>，上述代码会将原有的初始化语句 <code>[3]int&#123;1, 2, 3&#125;</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果当前数组的元素大于 4 个，<code>anylit</code> 方法会先获取一个唯一的 <code>staticname</code>，然后调用 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数在静态存储区初始化数组中的元素并将临时变量赋值给当前的数组：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">anylit</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> var_ <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t <span class="token operator">:=</span> n<span class="token punctuation">.</span>Type
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> OSTRUCTLIT<span class="token punctuation">,</span> OARRAYLIT<span class="token punctuation">:</span>
		<span class="token keyword">if</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">&#123;</span>
			vstat <span class="token operator">:=</span> <span class="token function">staticname</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
			vstat<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">SetReadonly</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

			<span class="token function">fixedlit</span><span class="token punctuation">(</span>inNonInitFunction<span class="token punctuation">,</span> initKindStatic<span class="token punctuation">,</span> n<span class="token punctuation">,</span> vstat<span class="token punctuation">,</span> init<span class="token punctuation">)</span>

			a <span class="token operator">:=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OAS<span class="token punctuation">,</span> var_<span class="token punctuation">,</span> vstat<span class="token punctuation">)</span>
			a <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> ctxStmt<span class="token punctuation">)</span>
			a <span class="token operator">=</span> <span class="token function">walkexpr</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> init<span class="token punctuation">)</span>
			init<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
		
		<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设我们在代码中初始化 <code>[5]int&#123;1, 2, 3, 4, 5&#125;</code> 数组，那么我们可以将上述过程理解成以下的伪代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span>
statictmp_0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
statictmp_0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
statictmp_0<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
statictmp_0<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
statictmp_0<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
arr <span class="token operator">=</span> statictmp_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总结起来，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/"> 中间代码生成 </a> 和<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/">机器码生成 </a> 两个阶段，最后生成可以执行的二进制文件。</p>
<h3><span id="访问和赋值">访问和赋值 </span></h3><p> 无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据：</p>
<p><img src="https://i.loli.net/2020/09/04/5dHu9LZRQck3EKS.png" alt="golang-array-memory"></p>
<p>数组访问越界是非常严重的错误，Go 语言中对越界的判断是可以在编译期间由静态类型检查完成的，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2081"><code>cmd/compile/internal/gc.typecheck1</code></a> 函数会对访问数组的索引进行验证：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">typecheck1</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> top <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> OINDEX<span class="token punctuation">:</span>
		ok <span class="token operator">|=</span> ctxExpr
		l <span class="token operator">:=</span> n<span class="token punctuation">.</span>Left  <span class="token comment">// array</span>
		r <span class="token operator">:=</span> n<span class="token punctuation">.</span>Right <span class="token comment">// index</span>
		<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>Etype <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> TSTRING<span class="token punctuation">,</span> TARRAY<span class="token punctuation">,</span> TSLICE<span class="token punctuation">:</span>
			<span class="token operator">...</span>
			<span class="token keyword">if</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Type <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">IsInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">"non-integer array index %v"</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>
				<span class="token keyword">break</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>n<span class="token punctuation">.</span><span class="token function">Bounded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Isconst</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Right<span class="token punctuation">,</span> CTINT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				x <span class="token operator">:=</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
					<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">"invalid array index %v (index must be non-negative)"</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>
				<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">IsArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">>=</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">NumElem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">"invalid array index %v (out of bounds for %d-element array)"</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">,</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">NumElem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>访问数组的索引是非整数时会直接报错 —— <code>non-integer array index %v</code>；</li>
<li>访问数组的索引是负数时会直接报错 —— <code>&quot;invalid array index %v (index must be non-negative)&quot;</code>；</li>
<li>访问数组的索引越界时会直接报错 —— <code>&quot;invalid array index %v (out of bounds for %d-element array)&quot;</code>；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，比如我们直接使用整数或者常量访问数组，但是如果使用变量去访问数组或者字符串时，编译器就无法发现对应的错误了，这时就需要 Go 语言运行时发挥作用了。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> invalid array index <span class="token number">4</span> <span class="token punctuation">(</span>out of bounds <span class="token keyword">for</span> <span class="token number">3</span><span class="token operator">-</span>element array<span class="token punctuation">)</span>
arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">panic</span><span class="token punctuation">:</span> runtime <span class="token builtin">error</span><span class="token punctuation">:</span> index out of <span class="token keyword">range</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> with length <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>panicIndex</code> 和 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L86-L89"><code>runtime.goPanicIndex</code></a> 函数触发程序的运行时错误并导致崩溃退出：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">TEXT runtime·<span class="token function">panicIndex</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">8</span>
	MOVL	AX<span class="token punctuation">,</span> x<span class="token operator">+</span><span class="token function">0</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	MOVL	CX<span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token function">4</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	JMP	runtime·<span class="token function">goPanicIndex</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">goPanicIndex</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">panicCheck1</span><span class="token punctuation">(</span><span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"index out of range"</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span>boundsError<span class="token punctuation">&#123;</span>x<span class="token punctuation">:</span> <span class="token function">int64</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> signed<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> y<span class="token punctuation">,</span> code<span class="token punctuation">:</span> boundsIndex<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查之后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 <code>ssa.html</code> 文件：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> check

<span class="token keyword">func</span> <span class="token function">outOfRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
	i <span class="token operator">:=</span> <span class="token number">4</span>
	elem <span class="token operator">:=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token keyword">return</span> elem
<span class="token punctuation">&#125;</span>

$ GOSSAFUNC<span class="token operator">=</span>outOfRange <span class="token keyword">go</span> build array<span class="token punctuation">.</span><span class="token keyword">go</span>
dumped SSA to <span class="token punctuation">.</span><span class="token operator">/</span>ssa<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>start</code> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分就是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">b1<span class="token punctuation">:</span>
    <span class="token operator">...</span>
    v22 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> LocalAddr <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>arr<span class="token punctuation">&#125;</span> v2 v20
    v23 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> IsInBounds <span class="token operator">&lt;</span><span class="token builtin">bool</span><span class="token operator">></span> v21 v11
If v23 → b2 b3 <span class="token punctuation">(</span>likely<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>

b2<span class="token punctuation">:</span> ← b1<span class="token operator">-</span>
    v26 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> PtrIndex <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token operator">></span> v22 v21
    v27 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> Copy <span class="token operator">&lt;</span>mem<span class="token operator">></span> v20
    v28 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> Load <span class="token operator">&lt;</span><span class="token builtin">int</span><span class="token operator">></span> v26 v27 <span class="token punctuation">(</span>elem<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
Ret v30 <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span>

b3<span class="token punctuation">:</span> ← b1<span class="token operator">-</span>
    v24 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> Copy <span class="token operator">&lt;</span>mem<span class="token operator">></span> v20
    v25 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> PanicBounds <span class="token operator">&lt;</span>mem<span class="token operator">></span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> v21 v11 v24
Exit v25 <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PanicBounds</code> 指令最终会被转换成上面提到的 <code>panicIndex</code> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标，然后利用 <code>PtrIndex</code> 计算出目标元素的地址，再使用 <code>Load</code> 操作将指针中的元素加载到内存中。</p>
<p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时就会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">b1<span class="token punctuation">:</span>
    <span class="token operator">...</span>
    v21 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> LocalAddr <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>arr<span class="token punctuation">&#125;</span> v2 v20
    v22 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> PtrIndex <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token operator">></span> v21 v14
    v23 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> Load <span class="token operator">&lt;</span><span class="token builtin">int</span><span class="token operator">></span> v22 v20 <span class="token punctuation">(</span>elem<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p>
<p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 操作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">b1<span class="token punctuation">:</span>
    <span class="token operator">...</span>
    v21 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> LocalAddr <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>arr<span class="token punctuation">&#125;</span> v2 v19
    v22 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> PtrIndex <span class="token operator">&lt;</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token operator">></span> v21 v13
    v23 <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> Store <span class="token operator">&lt;</span>mem<span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token builtin">int</span><span class="token punctuation">&#125;</span> v22 v20 v19
    <span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。</p>
<h2><span id="切片">切片 </span></h2><p> 更常用的数据结构其实是切片，切片就是动态数组，它的长度并不固定，我们可以随意向切片中追加元素，而切片会在容量不足时自动扩容。</p>
<p>在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 <code>int</code> 或者 <code>interface&#123;&#125;</code> 等。<a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L484-L496"><code>cmd/compile/internal/types.NewSlice</code></a> 就是编译期间用于创建 <code>Slice</code> 类型的函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewSlice</span><span class="token punctuation">(</span>elem <span class="token operator">*</span>Type<span class="token punctuation">)</span> <span class="token operator">*</span>Type <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> t <span class="token operator">:=</span> elem<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span>slice<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> elem <span class="token punctuation">&#123;</span>
			<span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"elem mismatch"</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> t
	<span class="token punctuation">&#125;</span>

	t <span class="token operator">:=</span> <span class="token function">New</span><span class="token punctuation">(</span>TSLICE<span class="token punctuation">)</span>
	t<span class="token punctuation">.</span>Extra <span class="token operator">=</span> Slice<span class="token punctuation">&#123;</span>Elem<span class="token punctuation">:</span> elem<span class="token punctuation">&#125;</span>
	elem<span class="token punctuation">.</span>Cache<span class="token punctuation">.</span>slice <span class="token operator">=</span> t
	<span class="token keyword">return</span> t
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述方法返回的结构体 <code>TSLICE</code> 中的 <code>Extra</code> 字段是一个只包含切片内元素类型的 <code>Slice&#123;Elem: elem&#125;</code> 结构，也就是说 <strong> 切片内元素的类型是在编译期间确定的</strong>，编译器确定了类型之后，会将类型存储在 <code>Extra</code> 字段中帮助程序在运行时动态获取。</p>
<h3><span id="数据结构">数据结构 </span></h3><p> 编译期间的切片是 <code>Slice</code> 类型的，但是在运行时切片由如下的 <code>SliceHeader</code> 结构体表示，其中 <code>Data</code> 字段是指向数组的指针，<code>Len</code> 表示当前切片的长度，而 <code>Cap</code> 表示当前切片的容量，也就是 <code>Data</code> 数组的大小：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> SliceHeader <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Data <span class="token builtin">uintptr</span>
	Len  <span class="token builtin">int</span>
	Cap  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Data</code> 作为一个指针指向的数组是一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p><img src="https://i.loli.net/2020/09/04/xH4o6IVjtbU7Prk.png" alt="golang-slice-struct"></p>
<p>从上图我们会发现切片与数组的关系非常密切，切片引入了一个抽象层，提供了对数组中部分片段的引用，作为数组的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。</p>
<p>我们在上一节介绍过，获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化，由于数组的内存固定且连续，很多操作都会变成对内存的直接读写。但是切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成，我们接下来就会介绍切片一些常见操作的实现原理。</p>
<h3><span id="初始化">初始化</span></h3><p>Go 语言中的切片有三种初始化的方式：</p>
<ol>
<li><p>通过下标的方式获得数组或者切片的一部分；</p>
</li>
<li><p>使用字面量初始化新的切片；</p>
</li>
<li><p>使用关键字 <code>make</code> 创建切片：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> or slice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
slice <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h4><span id="使用下标">使用下标 </span></h4><p> 使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，<code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 这些操作会由编译器转换成 <code>OpSliceMake</code> 操作，我们可以通过下面的代码来验证一下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ch03/op_slice_make.go</span>
<span class="token keyword">package</span> opslicemake

<span class="token keyword">func</span> <span class="token function">newSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
	slice <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>
	<span class="token keyword">return</span> slice
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到如下所示的 SSA 中间代码，在 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/"> 中间代码生成 </a> 的 <code>decompose builtin</code> 阶段，<code>slice := arr[0:1]</code> 对应的部分：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v27 <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> SliceMake <span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token operator">></span> v11 v14 v17

name <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span> v11
name slice<span class="token punctuation">.</span>ptr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span> v11
name slice<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span> v14
name slice<span class="token punctuation">.</span><span class="token builtin">cap</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span> v17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>SliceMake</code> 这个操作会接受三个参数创建新的切片，元素类型、数组指针、切片大小和容量，这也就是我们在数据结构一节中提到的切片的几个字段。</p>
<h4><span id="字面量">字面量 </span></h4><p> 当我们使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建新的切片时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L595-L766"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> vstat <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>
vstat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
vstat<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
vstat<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">var</span> vauto <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token operator">*</span>vauto <span class="token operator">=</span> vstat
slice <span class="token operator">:=</span> vauto<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<h4><span id="关键字">关键字 </span></h4><p> 如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2126"><code>cmd/compile/internal/gc.typecheck1</code></a> 会对参数进行校验：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">typecheck1</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> top <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">case</span> OMAKE<span class="token punctuation">:</span>
		args <span class="token operator">:=</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		i <span class="token operator">:=</span> <span class="token number">1</span>
		<span class="token keyword">switch</span> t<span class="token punctuation">.</span>Etype <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> TSLICE<span class="token punctuation">:</span>
			<span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">"missing len argument to make(%v)"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>
				<span class="token keyword">return</span> n
			<span class="token punctuation">&#125;</span>

			l <span class="token operator">=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			i<span class="token operator">++</span>
			<span class="token keyword">var</span> r <span class="token operator">*</span>Node
			<span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				r <span class="token operator">=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			<span class="token punctuation">&#125;</span>
			<span class="token operator">...</span>
			<span class="token keyword">if</span> <span class="token function">Isconst</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> CTINT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Isconst</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> CTINT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span><span class="token function">Val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>U<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mpint<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>U<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Mpint<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
				<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">"len larger than cap in make(%v)"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>
				<span class="token keyword">return</span> n
			<span class="token punctuation">&#125;</span>

			n<span class="token punctuation">.</span>Left <span class="token operator">=</span> l
			n<span class="token punctuation">.</span>Right <span class="token operator">=</span> r
			n<span class="token punctuation">.</span>Op <span class="token operator">=</span> OMAKESLICE
		<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述函数不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1315"><code>OMAKESLICE</code></a> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>当切片发生逃逸或者非常大时，我们需要 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50"><code>runtime.makeslice</code></a> 函数在堆上初始化，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span>
n <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上述代码会初始化数组并且直接通过下标 <code>[:3]</code> 来得到数组的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组，<code>[:3]</code> 会被转换成上一节提到的 <code>OpSliceMake</code> 操作。</p>
<p>分析了主要由编译器处理的分支之后，我们回到用于创建切片的运行时函数 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50"><code>runtime.makeslice</code></a>，这个函数的实现非常简单：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makeslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">></span> maxAlloc <span class="token operator">||</span> <span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token builtin">len</span> <span class="token operator">></span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>
		mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">></span> maxAlloc <span class="token operator">||</span> <span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			<span class="token function">panicmakeslicelen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">panicmakeslicecap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> et<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的主要工作就是计算当前切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p>
<pre class="line-numbers language-none"><code class="language-none">内存空间 &#x3D; 切片中元素大小 x 切片容量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然大多的错误都可以在编译期间被检查出来，但是在创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>mallocgc</code> 就是用于申请内存的函数，这个函数的实现还是比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的一些对象会在堆上初始化，我们会在后面的章节中详细介绍 Go 语言的内存分配器，在这里就不展开分析了。</p>
<p>目前的 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50"><code>runtime.makeslice</code></a> 会返回指向底层数组的指针，之前版本的 Go 语言中，数组指针、长度和容量会被合成一个 <code>slice</code> 结构并返回，但是从 <a href="https://github.com/golang/go/commit/020a18c545bf49ffc087ca93cd238195d8dcc411#diff-d9238ca551e72b3a80da9e0da10586a4">cmd/compile: move slice construction to callers of makeslice</a> 这次提交之后，构建结构体 <code>SliceHeader</code> 的工作就都交给 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50"><code>runtime.makeslice</code></a> 的调用方处理了，这些调用方会在编译期间构建切片结构体：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">typecheck1</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> top <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">case</span> OSLICEHEADER<span class="token punctuation">:</span>
	<span class="token keyword">switch</span> 
		t <span class="token operator">:=</span> n<span class="token punctuation">.</span>Type
		n<span class="token punctuation">.</span>Left <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> ctxExpr<span class="token punctuation">)</span>
		l <span class="token operator">:=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ctxExpr<span class="token punctuation">)</span>
		c <span class="token operator">:=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ctxExpr<span class="token punctuation">)</span>
		l <span class="token operator">=</span> <span class="token function">defaultlit</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> types<span class="token punctuation">.</span>Types<span class="token punctuation">[</span>TINT<span class="token punctuation">]</span><span class="token punctuation">)</span>
		c <span class="token operator">=</span> <span class="token function">defaultlit</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> types<span class="token punctuation">.</span>Types<span class="token punctuation">[</span>TINT<span class="token punctuation">]</span><span class="token punctuation">)</span>

		n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">SetFirst</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>
		n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">SetSecond</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>OSLICEHEADER</code> 操作会创建我们在上面介绍过的结构体 <code>SliceHeader</code>，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> SliceHeader <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Data <span class="token builtin">uintptr</span>
	Len  <span class="token builtin">int</span>
	Cap  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正是因为大多数对切片类型的操作并不需要直接操作原 <code>slice</code> 结构体，所以 <code>SliceHeader</code> 的引入能够减少切片初始化时的少量开销，这个改动能够减少 ~0.2% 的 Go 语言包大小并且能够减少 92 个 <code>panicindex</code> 的调用，占整个 Go 语言二进制的 ~3.5%。</p>
<h3><span id="访问元素">访问元素 </span></h3><p> 对切片常见的操作就是获取它的长度或者容量，这两个不同的函数 <code>len</code> 和 <code>cap</code> 被 Go 语言的编译器看成是两种特殊的操作，即 <code>OLEN</code> 和 <code>OCAP</code>，它们会在 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/">SSA 生成阶段 </a> 被 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L1975-L2724"><code>cmd/compile/internal/gc.epxr</code></a> 函数转换成 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>state<span class="token punctuation">)</span> <span class="token function">expr</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>ssa<span class="token punctuation">.</span>Value <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> OLEN<span class="token punctuation">,</span> OCAP<span class="token punctuation">:</span>
		<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">IsSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			op <span class="token operator">:=</span> ssa<span class="token punctuation">.</span>OpSliceLen
			<span class="token keyword">if</span> n<span class="token punctuation">.</span>Op <span class="token operator">==</span> OCAP <span class="token punctuation">&#123;</span>
				op <span class="token operator">=</span> ssa<span class="token punctuation">.</span>OpSliceCap
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">newValue1</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> types<span class="token punctuation">.</span>Types<span class="token punctuation">[</span>TINT<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">expr</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">...</span>
		<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问切片中的字段可能会触发 <code>decompose builtin</code> 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会被直接替换成切片的长度或者容量，不需要运行时从切片结构中获取：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">(</span>SlicePtr <span class="token punctuation">(</span>SliceMake ptr <span class="token boolean">_</span> <span class="token boolean">_</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ptr
<span class="token punctuation">(</span>SliceLen <span class="token punctuation">(</span>SliceMake <span class="token boolean">_</span> <span class="token builtin">len</span> <span class="token boolean">_</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">len</span>
<span class="token punctuation">(</span>SliceCap <span class="token punctuation">(</span>SliceMake <span class="token boolean">_</span> <span class="token boolean">_</span> <span class="token builtin">cap</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">cap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>state<span class="token punctuation">)</span> <span class="token function">expr</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>ssa<span class="token punctuation">.</span>Value <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> OINDEX<span class="token punctuation">:</span>
		<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">IsSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			p <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">addr</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
		<span class="token operator">...</span>
		<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 <code>range</code> 遍历切片时也会在编译期间转换成形式更简单的代码，我们会在后面的 <code>range</code> 关键字一节中介绍使用 <code>range</code> 遍历切片的过程。</p>
<h3><span id="追加和扩容">追加和扩容 </span></h3><p> 向切片中追加元素应该是最常见的切片操作，在 Go 语言中我们会使用 <code>append</code> 关键字向切片追加元素，中间代码生成阶段的 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884"><code>cmd/compile/internal/gc.state.append</code></a> 方法会拆分 <code>append</code> 关键字，该方法追加元素会根据返回值是否会覆盖原变量，分别进入两种流程，如果 <code>append</code> 返回的『新切片』不需要赋值回原有的变量，就会进入如下的处理流程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// append(slice, 1, 2, 3)</span>
ptr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token operator">:=</span> slice
newlen <span class="token operator">:=</span> <span class="token builtin">len</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token keyword">if</span> newlen <span class="token operator">></span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>
    ptr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token operator">=</span> <span class="token function">growslice</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span>
    newlen <span class="token operator">=</span> <span class="token builtin">len</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">return</span> <span class="token function">makeslice</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> newlen<span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>我们会先对切片结构体进行解构获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191"><code>runtime.growslice</code></a> 对切片进行扩容并将新的元素依次加入切片；如果 <code>append</code> 后的切片会覆盖原切片，即 <code>slice = append(slice, 1, 2, 3)</code>， <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884"><code>cmd/compile/internal/gc.state.append</code></a> 就会使用另一种方式改写关键字：</strong></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// slice = append(slice, 1, 2, 3)</span>
a <span class="token operator">:=</span> <span class="token operator">&amp;</span>slice
ptr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token operator">:=</span> slice
newlen <span class="token operator">:=</span> <span class="token builtin">len</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token keyword">if</span> <span class="token function">uint</span><span class="token punctuation">(</span>newlen<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">uint</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   newptr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> newcap <span class="token operator">=</span> <span class="token function">growslice</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span>
   <span class="token function">vardef</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
   <span class="token operator">*</span>a<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">=</span> newcap
   <span class="token operator">*</span>a<span class="token punctuation">.</span>ptr <span class="token operator">=</span> newptr
<span class="token punctuation">&#125;</span>
newlen <span class="token operator">=</span> <span class="token builtin">len</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token operator">*</span>a<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> newlen
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">+</span><span class="token builtin">len</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是否覆盖原变量的逻辑其实差不多，最大的区别在于最后的结果是不是赋值会原有的变量，如果我们选择覆盖原有的变量，也不需要担心切片的拷贝，因为 Go 语言的编译器已经对这种情况作了优化。</p>
<p><img src="https://i.loli.net/2020/09/04/iNK7eyh8BL6obQA.png" alt="golang-slice-append"></p>
<p>到这里我们已经通过 <code>append</code> 关键字被转换的控制流了解了在切片容量足够时如何向切片中追加元素，但是当切片的容量不足时就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191"><code>runtime.growslice</code></a> 函数为切片扩容，扩容就是为切片分配一块新的内存空间并将原切片的元素全部拷贝过去，我们分几部分分析该方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span>
	newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>
	doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap
	<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>
		newcap <span class="token operator">=</span> <span class="token builtin">cap</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>
			newcap <span class="token operator">=</span> doublecap
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>
				newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
				newcap <span class="token operator">=</span> <span class="token builtin">cap</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在分配内存空间之前需要先确定新的切片容量，Go 语言根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，在这时就会直接 <code>panic</code>，不过相关的代码在这里就被省略了：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token keyword">var</span> overflow <span class="token builtin">bool</span>
	<span class="token keyword">var</span> newlenmem<span class="token punctuation">,</span> capmem <span class="token builtin">uintptr</span>
	<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>size
		newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>size
		capmem<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span><span class="token punctuation">)</span>
		capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span>capmem<span class="token punctuation">)</span>
		newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">/</span> et<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
	<span class="token keyword">var</span> p unsafe<span class="token punctuation">.</span>Pointer
	<span class="token keyword">if</span> et<span class="token punctuation">.</span>kind<span class="token operator">&amp;</span>kindNoPointers <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
		<span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> newlenmem<span class="token punctuation">)</span><span class="token punctuation">,</span> capmem<span class="token operator">-</span>newlenmem<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> et<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> writeBarrier<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>
			<span class="token function">bulkBarrierPreWriteSrcOnly</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span>
	<span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> newcap<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中。这里的 <code>memclrNoHeapPointers</code> 和 <code>memmove</code> 都是用目标机器上的汇编指令实现的。</p>
<p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191"><code>runtime.growslice</code></a> 函数最终会返回一个新的 <code>slice</code> 结构，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会改变原有的切片，帮助 <code>append</code> 完成元素追加的功能。</p>
<h3><span id="拷贝切片">拷贝切片 </span></h3><p> 切片的拷贝虽然不是一个常见的操作类型，但是却是我们学习切片实现原理必须要谈及的一个问题，当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2980-L3040"><code>cmd/compile/internal/gc.copyany</code></a> 函数也会分两种情况进行处理，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">if</span> n <span class="token operator">></span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    n <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> a<span class="token punctuation">.</span>ptr <span class="token operator">!=</span> b<span class="token punctuation">.</span>ptr <span class="token punctuation">&#123;</span>
    <span class="token function">memmove</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>ptr<span class="token punctuation">,</span> b<span class="token punctuation">.</span>ptr<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token function">elem</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>memmove</code> 会负责对内存进行拷贝，在其他情况下，编译器会使用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L197-L230"><code>runtime.slicecopy</code></a> 函数替换运行期间调用的 <code>copy</code>，例如：<code>go copy(a, b)</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">slicecopy</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> fm slice<span class="token punctuation">,</span> width <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> fm<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> to<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	n <span class="token operator">:=</span> fm<span class="token punctuation">.</span><span class="token builtin">len</span>
	<span class="token keyword">if</span> to<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> n <span class="token punctuation">&#123;</span>
		n <span class="token operator">=</span> to<span class="token punctuation">.</span><span class="token builtin">len</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> width <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> n
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>

	size <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">*</span> width
	<span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>array<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fm<span class="token punctuation">.</span>array<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">memmove</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>array<span class="token punctuation">,</span> fm<span class="token punctuation">.</span>array<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> n
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述函数的实现非常直接，两种不同的拷贝方式一般都会通过 <code>memmove</code> 将整块内存中的内容拷贝到目标的内存区域中：</p>
<p><img src="https://i.loli.net/2020/09/04/FyjzandcAUmoJB8.png" alt="golang-slice-copy"></p>
<p>相比于依次对元素进行拷贝，这种方式能够提供更好的性能，但是需要注意的是，哪怕使用 <code>memmove</code> 对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p>
<h2><span id="总结">总结 </span></h2><p> 数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 <code>panicIndex</code> 调用防止发生越界错误。</p>
<p>切片的很多功能都是在运行时实现的了，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要在使用时减少这种情况的发生避免对程序的性能造成影响。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://blog.golang.org/slices">Arrays, slices (and strings): The mechanics of ‘append’</a></li>
<li><a href="https://stackoverflow.com/questions/30525184/array-vs-slice-accessing-speed">Array vs Slice: accessing speed</a></li>
<li><a href="https://blog.golang.org/slices">Arrays, slices (and strings): The mechanics of ‘append’</a></li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices: usage and internals</a></li>
<li><a href="https://stackoverflow.com/questions/30525184/array-vs-slice-accessing-speed">Array vs Slice: accessing speed</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的哈希表</title>
    <url>/2020/01/13/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>很多编程语言都实现了哈希表这种 数据结构，例如 Java 的 Map，Python 的 Set，Java 的 Object 等等。但他们的底层原理都有所不同。哈希表是一种以空间换时间的数据结构，它的查找的时间复杂度为<code>O(n)</code>。它根据键直接访问内存存储位置。我们结合哈希表的原理探索一下 Go 中的哈希——Map。</p>
<a id="more"></a>
<h2><span id="哈希原理">哈希原理 </span></h2><p> 哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 <code>O(1)</code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求 <strong> 哈希函数输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p>
<p><img src="https://i.loli.net/2020/09/04/4keU1Kiw6AqtWM3.png" alt="perfect-hash-function"></p>
<p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p>
<p><img src="https://i.loli.net/2020/09/04/VepMsj8D2Q7rgPF.png" alt="bad-hash-function"></p>
<p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 <code>O(1)</code> 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 <code>O(n)</code> 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p>
<h3><span id="冲突解决">冲突解决 </span></h3><p> 就像我们之前所提到的，在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突。</p>
<p>然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<h4><span id="开放寻址法">开放寻址法 </span></h4><p><a href="https://en.wikipedia.org/wiki/Open_addressing"> 开放寻址法 </a> 是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是 <strong> 对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中</strong>，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 <code>(author, draven)</code> 这个键值对时会从如下的索引开始遍历：</p>
<p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置：</p>
<p><img src="https://i.loli.net/2020/09/04/y2R9jbHzApUl5KN.png" alt="open-addressing-and-set"></p>
<p>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p>
<p><img src="https://i.loli.net/2020/09/04/473thb6OaIZz9Sg.png" alt="open-addressing-and-get"></p>
<p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p>
<p>开放寻址法中对性能影响最大的就是 <strong> 装载因子</strong>，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛)O(n) 的，它们可能需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。</p>
<h4><span id="拉链法">拉链法 </span></h4><p> 与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能（例如 Java 1.8 的 <code>LinkedHashMap</code>），拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：</p>
<p><img src="https://i.loli.net/2020/09/04/xVQlw6abu2vjZAz.png" alt="separate-chaing-and-set"></p>
<p>如上图所示，当我们需要将一个键值对 <code>(Key6, Value6)</code> 写入哈希表时，键值对中的键 <code>Key6</code> 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">index <span class="token operator">:=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token string">"Key6"</span><span class="token punctuation">)</span> <span class="token operator">%</span> array<span class="token punctuation">.</span><span class="token builtin">len</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>选择了 2 号桶之后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li>找到键相同的键值对 —— 更新键对应的值；</li>
<li>没有找到键相同的键值对 —— 在链表的末尾追加新键值对；</li>
</ol>
<p>将键值对写入哈希之后，要通过某个键在其中获取映射的值，就会经历如下的过程：</p>
<p><img src="https://i.loli.net/2020/09/04/e1ykREfm7TXKPJF.png" alt="separate-chaing-and-get"></p>
<p>Key11 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中 4 号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有找到期望的键，所以哈希表中没有该键对应的值。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0~1 个元素，有时会有 2~3 个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<pre class="line-numbers language-none"><code class="language-none">装载因子 :&#x3D; 元素数量 &#x2F; 桶数量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍。</p>
<h2><span id="数据结构">数据结构</span></h2><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 <a href="https://github.com/golang/go/blob/ed15e82413c7b16e21a493f5a647f68b46e965ee/src/runtime/map.go#L115-L129"><code>hmap</code></a> 结构体来表示哈希，我们先来看一下这个结构体内部的字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	count     <span class="token builtin">int</span>
	flags     <span class="token builtin">uint8</span>
	B         <span class="token builtin">uint8</span>
	noverflow <span class="token builtin">uint16</span>
	hash0     <span class="token builtin">uint32</span>

	buckets    unsafe<span class="token punctuation">.</span>Pointer
	oldbuckets unsafe<span class="token punctuation">.</span>Pointer
	nevacuate  <span class="token builtin">uintptr</span>

	extra <span class="token operator">*</span>mapextra
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img src="https://img.draveness.me/2019-12-30-15777168478811-hmap-and-buckets.png" alt="hmap-and-buckets"></p>
<p><strong>图 3-12 哈希表的数据结构</strong></p>
<p>如上图所示哈希表 <code>hmap</code> 的桶就是 <code>bmap</code>，每一个 <code>bmap</code> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.overflow</code> 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <code>bmap</code> 就是正常桶，绿色的 <code>bmap</code> 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时就使用的设计，由于它能够减少扩容的频率所以一直使用至今。</p>
<p>这个桶的结构体 <code>bmap</code> 在 Go 语言源代码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	tophash <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span><span class="token builtin">uint8</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，但是我们能根据编译期间的 <a href="https://github.com/golang/go/blob/be64a19d99918c843f8555aad580221207ea35bc/src/cmd/compile/internal/gc/reflect.go#L82-L187"><code>cmd/compile/internal/gc.bmap</code></a> 函数对它的结构重建：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    topbits  <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token builtin">uint8</span>
    keys     <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>keytype
    values   <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>valuetype
    pad      <span class="token builtin">uintptr</span>
    overflow <span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果哈希表存储的数据逐渐增多，我们会对哈希表进行扩容或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p>
<p>从 Go 语言哈希的定义中就可以发现，它比前面两节提到的数组和切片复杂得多，结构体中不仅包含大量字段，还使用了较多的复杂结构，在后面的小节中我们会详细介绍不同字段的作用。</p>
<h2><span id="初始化">初始化 </span></h2><p> 既然已经介绍了常见哈希表的基本原理和实现方法，那么可以开始分析 Go 语言中哈希表的实现，首先要分析的就是在 Go 语言中初始化哈希的两种方法 — 通过字面量和运行时。</p>
<h3><span id="字面量">字面量 </span></h3><p> 目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">hash <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span>
	<span class="token string">"1"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
	<span class="token string">"3"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
	<span class="token string">"5"</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L768-L873"><code>cmd/compile/internal/gc.maplit</code></a> 函数初始化，我们来分析一下 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L768-L873"><code>cmd/compile/internal/gc.maplit</code></a> 函数初始化哈希的过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">maplit</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> m <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OMAKE<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	a<span class="token punctuation">.</span>Esc <span class="token operator">=</span> n<span class="token punctuation">.</span>Esc
	a<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Set2</span><span class="token punctuation">(</span><span class="token function">typenod</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nodintconst</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">litas</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> a<span class="token punctuation">,</span> init<span class="token punctuation">)</span>

	<span class="token keyword">var</span> stat<span class="token punctuation">,</span> dyn <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		stat <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stat<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>stat<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">25</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">addMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> stat<span class="token punctuation">,</span> init<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当哈希表中的元素数量少于或者等于 25 个时，编译器会直接调用 <code>addMapEntries</code> 将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">hash <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
hash<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
hash<span class="token punctuation">[</span><span class="token string">"3"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
hash<span class="token punctuation">[</span><span class="token string">"5"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种初始化的方式与前面两节分析的 <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/"> 数组 </a> 和<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">切片 </a> 的几乎完全相同，由此看来集合类型的初始化在 Go 语言中有着相同的处理方式和逻辑。</p>
<p>一旦哈希表中元素的数量超过了 25 个，就会在编译期间创建两个数组分别存储键和值的信息，这些键值对会通过一个如下所示的 for 循环加入目标的哈希：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">hash <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span>
vstatk <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token operator">...</span> ， <span class="token string">"26"</span><span class="token punctuation">&#125;</span>
vstatv <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>vstak<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
    hash<span class="token punctuation">[</span>vstatk<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> vstatv<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里展开的两个切片 <code>vstatk</code> 和 <code>vstatv</code> 还会被编辑器继续展开，具体的展开方式可以阅读上一节了解 <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/"> 切片的初始化</a>，不过无论使用哪种方法，使用字面量初始化的过程都会使用 Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[]</code> 语法向哈希追加元素。</p>
<h3><span id="运行时">运行时 </span></h3><p> 无论 <code>make</code> 是从哪里来的，只要我们使用 <code>make</code> 创建哈希，Go 语言编译器都会在 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/"> 类型检查 </a> 期间将它们转换成对 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336"><code>runtime.makemap</code></a> 的调用，使用字面量来初始化哈希也只是语言提供的辅助工具，最后调用的都是 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336"><code>runtime.makemap</code></a>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makemap</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> hint <span class="token builtin">int</span><span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">)</span> <span class="token operator">*</span>hmap <span class="token punctuation">&#123;</span>
	mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>hint<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
	<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">></span> maxAlloc <span class="token punctuation">&#123;</span>
		hint <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		h <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>hmap<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	h<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	B <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>hint<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		B<span class="token operator">++</span>
	<span class="token punctuation">&#125;</span>
	h<span class="token punctuation">.</span>B <span class="token operator">=</span> B

	<span class="token keyword">if</span> h<span class="token punctuation">.</span>B <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">var</span> nextOverflow <span class="token operator">*</span>bmap
		h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> nextOverflow <span class="token operator">=</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> nextOverflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			h<span class="token punctuation">.</span>extra <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>mapextra<span class="token punctuation">)</span>
			h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>nextOverflow <span class="token operator">=</span> nextOverflow
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> h
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数的执行过程会分成以下几个部分：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 <code>fastrand</code> 获取一个随机的哈希种子；</li>
<li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li>
<li>使用 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387"><code>runtime.makeBucketArray</code></a> 创建用于保存桶的数组；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387"><code>runtime.makeBucketArray</code></a> 函数会根据传入的 <code>B</code> 计算出的需要创建的桶数量在内存中分配一片连续的空间用于存储数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> b <span class="token builtin">uint8</span><span class="token punctuation">,</span> dirtyalloc unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>buckets unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> nextOverflow <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	base <span class="token operator">:=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	nbuckets <span class="token operator">:=</span> base
	<span class="token keyword">if</span> b <span class="token operator">>=</span> <span class="token number">4</span> <span class="token punctuation">&#123;</span>
		nbuckets <span class="token operator">+=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span>
		sz <span class="token operator">:=</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size <span class="token operator">*</span> nbuckets
		up <span class="token operator">:=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>
		<span class="token keyword">if</span> up <span class="token operator">!=</span> sz <span class="token punctuation">&#123;</span>
			nbuckets <span class="token operator">=</span> up <span class="token operator">/</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	buckets <span class="token operator">=</span> <span class="token function">newarray</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucket<span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>nbuckets<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> base <span class="token operator">!=</span> nbuckets <span class="token punctuation">&#123;</span>
		nextOverflow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> base<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		last <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>nbuckets<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		last<span class="token punctuation">.</span><span class="token function">setoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> buckets<span class="token punctuation">,</span> nextOverflow
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当桶的数量小于 $2^4$ 时，由于数据较少、使用溢出桶的可能性较低，这时就会省略创建的过程以减少额外开销；当桶的数量多于 $2^4$ 时，就会额外创建 $2^{B-4}$ 个溢出桶，根据上述代码，我们能确定在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <code>hmap</code> 中的不同字段引用，当溢出桶数量较多时会通过 <a href="https://github.com/golang/go/blob/921ceadd2997f2c0267455e13f909df044234805/src/runtime/malloc.go#L1164"><code>runtime.newobject</code></a> 创建新的溢出桶。</p>
<h2><span id="读写操作">读写操作 </span></h2><p> 哈希表作为一种数据结构，我们肯定需要分析它的常见操作，首先就需要了解其读写操作的实现原理，访问哈希表一般都是通过下标或者遍历两种方式进行的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token boolean">_</span> <span class="token operator">=</span> hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> hash <span class="token punctuation">&#123;</span>
    <span class="token comment">// k, v</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两种方式虽然都能读取哈希表中的数据，但是使用的函数和底层的原理完全不同，前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键，在这里我们会介绍前一种访问方式，第二种访问方式会在 <code>range</code> 一节中详细分析。</p>
<p>数据结构的写一般指的都是增加、删除和修改，增加和修改字段都使用索引和赋值语句，而删除字典中的数据需要使用关键字 <code>delete</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newValue
<span class="token function">delete</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>除了这些操作之外，我们还会分析哈希的扩容过程，这能帮助我们深入理解哈希是如何对数据进行存储的。</p>
<h3><span id="访问">访问 </span></h3><p> 在编译的 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/"> 类型检查 </a> 期间，<code>hash[key]</code> 以及类似的操作都会被转换成对哈希的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1089"><code>OINDEXMAP</code></a> 操作，<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/">中间代码生成 </a> 阶段会在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中将这些 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1089"><code>OINDEXMAP</code></a> 操作转换成如下的代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">v     <span class="token operator">:=</span> hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment">// => v     := *mapaccess1(maptype, hash, &amp;key)</span>
v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment">// => v, ok := mapaccess2(maptype, hash, &amp;key)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p>
<ol>
<li>当接受参数仅为一个时，会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450"><code>runtime.mapaccess1</code></a>，该函数仅会返回一个指向目标值的指针；</li>
<li>当接受两个参数时，会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L452-L508"><code>runtime.mapaccess2</code></a>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的布尔值：</li>
</ol>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450"><code>runtime.mapaccess1</code></a> 函数会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <code>bucketMask</code> 和 <code>add</code> 函数拿到该键值对所在的桶序号和哈希最上面的 8 位数字。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapaccess1</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	alg <span class="token operator">:=</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>alg
	hash <span class="token operator">:=</span> alg<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	m <span class="token operator">:=</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
	b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
bucketloop<span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">&#123;</span>
					<span class="token keyword">break</span> bucketloop
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> alg<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				v <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> v
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zeroVal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>bucketloop</code> 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它会比较这 8 位数字和桶中存储的 <code>tophash</code>，每一个桶都存储键对应的 <code>tophash</code>，每一次读写操作都会与桶中所有的 <code>tophash</code> 进行比较，用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 <code>tophash</code> 的概率。</p>
<p><img src="https://i.loli.net/2020/09/04/ZHbqORLj6hmgN2K.png" alt="hashtable-mapaccess"></p>
<p><strong>图 3-13 访问哈希表中的数据</strong></p>
<p>如上图所示，每一个桶都是一整片的内存空间，当发现桶中的 <code>tophash</code> 与传入键的 <code>tophash</code> 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 <code>keys[0]</code> 并与 <code>key</code> 比较，如果两者相同就会获取目标值的指针 <code>values[0]</code> 并返回。</p>
<p>另一个同样用于访问哈希表中数据的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L452-L508"><code>runtime.mapaccess2</code></a> 只是在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450"><code>runtime.mapaccess1</code></a> 的基础上多返回了一个标识键值对是否存在的布尔值：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapaccess2</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
bucketloop<span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">&#123;</span>
					<span class="token keyword">break</span> bucketloop
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> alg<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				v <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> v<span class="token punctuation">,</span> <span class="token boolean">true</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zeroVal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>v, ok := hash[k]</code> 的形式访问哈希表中元素时，我们能够通过这个布尔值更准确地知道当 <code>v == nil</code> 时，<code>v</code> 到底是哈希中存储的元素还是表示该键对应的元素不存在，所以在访问哈希时，更推荐使用这一种方式先判断元素是否存在。</p>
<p>上面的过程其实是在正常情况下，访问哈希表中元素时的表现，然而与数组一样，哈希表可能会在装载因子过高或者溢出桶过多时进行扩容，哈希表的扩容并不是一个原子的过程，在扩容的过程中保证哈希的访问是比较有意思的话题，我们在这里其实也省略了相关的代码，不过会在下面展开介绍。</p>
<h3><span id="写入">写入 </span></h3><p> 当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 函数，该函数与 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450"><code>runtime.mapaccess1</code></a> 比较相似，我们将该其分成几个部分分析，首先是函数会根据传入的键拿到对应的哈希和桶：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapassign</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	alg <span class="token operator">:=</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>alg
	hash <span class="token operator">:=</span> alg<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>

	h<span class="token punctuation">.</span>flags <span class="token operator">^=</span> hashWriting

again<span class="token punctuation">:</span>
	bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
	b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">)</span> <span class="token operator">+</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后通过遍历比较桶中存储的 <code>tophash</code> 和键的哈希，如果找到了相同结果就会获取目标位置的地址并返回，其中 <code>inserti</code> 表示目标元素的在桶中的索引，<code>insertk</code> 和 <code>val</code> 分别表示键值对的地址，获得目标地址之后会直接通过算术计算进行寻址获得键值对 <code>k</code> 和 <code>val</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token keyword">var</span> inserti <span class="token operator">*</span><span class="token builtin">uint8</span>
	<span class="token keyword">var</span> insertk unsafe<span class="token punctuation">.</span>Pointer
	<span class="token keyword">var</span> val unsafe<span class="token punctuation">.</span>Pointer
bucketloop<span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
					inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
					insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
					val <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">&#123;</span>
					<span class="token keyword">break</span> bucketloop
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>alg<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			val <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> done
		<span class="token punctuation">&#125;</span>
		ovf <span class="token operator">:=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token keyword">if</span> ovf <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">&#125;</span>
		b <span class="token operator">=</span> ovf
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述的 for 循环中会依次遍历正常桶和溢出桶中存储的数据，整个过程会依次判断 <code>tophash</code> 是否相等、<code>key</code> 是否相等，遍历结束后会从循环中跳出。</p>
<p><img src="https://img.draveness.me/2019-12-30-15777168478823-hashtable-overflow-bucket.png" alt="hashtable-overflow-bucket"></p>
<p>如果当前桶已经满了，哈希会调用 <code>newoverflow</code> 函数创建新桶或者使用 <code>hmap</code> 预先在 <code>noverflow</code> 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token keyword">if</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		newb <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">newoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
		inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>newb<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
		insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newb<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
		val <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>insertk<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> insertk<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
	<span class="token operator">*</span>inserti <span class="token operator">=</span> top
	h<span class="token punctuation">.</span>count<span class="token operator">++</span>

done<span class="token punctuation">:</span>
	<span class="token keyword">return</span> val
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果当前键值对在哈希中不存在，哈希为新键值对规划存储的内存地址，通过 <code>typedmemmove</code> 将键移动到对应的内存空间中并返回键对应值的地址 <code>val</code>，如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址。哈希并不会在 <code>mapassign</code> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">00018</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span> CALL runtime<span class="token punctuation">.</span><span class="token function">mapassign_fast64</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
<span class="token number">00020</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> MOVQ <span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> DI               <span class="token punctuation">;</span><span class="token punctuation">;</span> DI <span class="token operator">=</span> <span class="token operator">&amp;</span>value
<span class="token number">00026</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> LEAQ <span class="token keyword">go</span><span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token string">"88"</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX   <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"88"</span>
<span class="token number">00027</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> MOVQ AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>DI<span class="token punctuation">)</span>                 <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">*</span>DI <span class="token operator">=</span> AX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map_fast64.go#L92-L180"><code>runtime.mapassign_fast64</code></a> 与 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 函数的实现差不多，我们需要关注的是后面的三行代码，<code>24(SP)</code> 就是该函数返回的值地址，我们通过 <code>LEAQ</code> 指令将字符串的地址存储到寄存器 <code>AX</code> 中，<code>MOVQ</code> 指令将字符串 <code>&quot;88&quot;</code> 存储到了目标地址上完成了这次哈希的写入。</p>
<h3><span id="扩容">扩容 </span></h3><p> 我们在介绍哈希的写入过程时省略了扩容操作，随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapassign</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">tooManyOverflowBuckets</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>noverflow<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">hashGrow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> again
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 函数会在以下两种情况发生时触发哈希的扩容：</p>
<ol>
<li>装载因子已经超过 6.5；</li>
<li>哈希使用了太多溢出桶；</li>
</ol>
<p>不过由于 Go 语言哈希的扩容不是一个原子的过程，所以 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</p>
<p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，<code>sameSizeGrow</code> 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏。<a href="https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c">runtime: limit the number of map overflow buckets</a> 引入了 <code>sameSizeGrow</code> 通过重用已有的哈希扩容机制，一旦哈希中出现了过多的溢出桶，它就会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存。</p>
<p>扩容的入口是 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1017-L1058"><code>runtime.hashGrow</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hashGrow</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	bigger <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		bigger <span class="token operator">=</span> <span class="token number">0</span>
		h<span class="token punctuation">.</span>flags <span class="token operator">|=</span> sameSizeGrow
	<span class="token punctuation">&#125;</span>
	oldbuckets <span class="token operator">:=</span> h<span class="token punctuation">.</span>buckets
	newbuckets<span class="token punctuation">,</span> nextOverflow <span class="token operator">:=</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token operator">+</span>bigger<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

	h<span class="token punctuation">.</span>B <span class="token operator">+=</span> bigger
	h<span class="token punctuation">.</span>flags <span class="token operator">=</span> flags
	h<span class="token punctuation">.</span>oldbuckets <span class="token operator">=</span> oldbuckets
	h<span class="token punctuation">.</span>buckets <span class="token operator">=</span> newbuckets
	h<span class="token punctuation">.</span>nevacuate <span class="token operator">=</span> <span class="token number">0</span>
	h<span class="token punctuation">.</span>noverflow <span class="token operator">=</span> <span class="token number">0</span>

	h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow <span class="token operator">=</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow
	h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow <span class="token operator">=</span> <span class="token boolean">nil</span>
	h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>nextOverflow <span class="token operator">=</span> nextOverflow
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>哈希在扩容的过程中会通过 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387"><code>runtime.makeBucketArray</code></a> 创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 <code>oldbuckets</code> 上并将新的空桶设置到 <code>buckets</code> 上，溢出桶也使用了相同的逻辑进行更新，下图展示了触发扩容后的哈希：</p>
<p><img src="https://i.loli.net/2020/09/04/OkjylzLq4FM57n3.png" alt="hashtable-hashgrow"></p>
<p>我们在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1017-L1058"><code>runtime.hashGrow</code></a> 中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移，哈希表的数据迁移的过程在是 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240"><code>runtime.evacuate</code></a> 函数中完成的，它会对传入桶中的元素进行『再分配』。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">evacuate</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> oldbucket <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	newbit <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">noldbuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">var</span> xy <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>evacDst
		x <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
		x<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		x<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
		x<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>

		y <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
		y<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>oldbucket<span class="token operator">+</span>newbit<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		y<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
		y<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240"><code>runtime.evacuate</code></a> 函数会将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的 <code>evacDst</code> 结构体，这两个结构体分别指向了一个新桶：</p>
<p><img src="https://i.loli.net/2020/09/04/F1VxHTbfNpuQl4o.png" alt="hashtable-evacuate-destination"></p>
<p>如果这是一等量扩容，旧桶与新桶之间是一对一的关系，所以两个 <code>evacDst</code> 结构体只会初始化一个，当哈希表的容量翻倍时，每个旧桶的元素会都被分流到新创建的两个桶中，我们仔细分析一下分流元素的逻辑：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">		<span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
			v <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				top <span class="token operator">:=</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
				k2 <span class="token operator">:=</span> k
				<span class="token keyword">var</span> useY <span class="token builtin">uint8</span>
				hash <span class="token operator">:=</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> hash<span class="token operator">&amp;</span>newbit <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
					useY <span class="token operator">=</span> <span class="token number">1</span>
				<span class="token punctuation">&#125;</span>
				b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> evacuatedX <span class="token operator">+</span> useY
				dst <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span>useY<span class="token punctuation">]</span>

				<span class="token keyword">if</span> dst<span class="token punctuation">.</span>i <span class="token operator">==</span> bucketCnt <span class="token punctuation">&#123;</span>
					dst<span class="token punctuation">.</span>b <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">newoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
					dst<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span>
					dst<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
					dst<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#125;</span>
				dst<span class="token punctuation">.</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>dst<span class="token punctuation">.</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>bucketCnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> top
				<span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
				<span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>v<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
				dst<span class="token punctuation">.</span>i<span class="token operator">++</span>
				dst<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
				dst<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只使用哈希函数是不能定位到具体某一个桶的，哈希函数只会返回很长的哈希，例如：<code>b72bfae3f3285244c4732ce457cca823bc189e0b</code>，我们还需一些方法将哈希映射到具体的桶上，在很多时候我们都会使用取模或者位操作来获取桶的编号，假如当前哈希中包含 4 个桶，那么它的桶掩码就是 <code>0b11(3)</code>，使用位操作就会得到 3， 我们就会在 3 号桶中存储该数据：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token number">0xb72bfae3f3285244c4732ce457cca823bc189e0b</span> <span class="token operator">&amp;</span> <span class="token number">0</span>b11 <span class="token comment">#=> 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果新的哈希表有 8 个桶，在大多数情况下，原来经过桶掩码 <code>0b11</code> 结果为 3 的数据会因为桶掩码增加了一位编程 <code>0b111</code> 而分流到新的 3 号和 7 号桶，所有数据也都会被 <code>typedmemmove</code> 拷贝到目标桶中：</p>
<p><img src="https://i.loli.net/2020/09/04/dWYKxN8PgSXV1fE.png" alt="hashtable-bucket-evacuate"></p>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240"><code>runtime.evacuate</code></a> 最后会调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1242-L1264"><code>runtime.advanceEvacuationMark</code></a> 增加哈希的 <code>nevacuate</code> 计数器，在所有的旧桶都被分流后清空哈希的 <code>oldbuckets</code> 和 <code>oldoverflow</code> 字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">advanceEvacuationMark</span><span class="token punctuation">(</span>h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> newbit <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	h<span class="token punctuation">.</span>nevacuate<span class="token operator">++</span>
	stop <span class="token operator">:=</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">+</span> <span class="token number">1024</span>
	<span class="token keyword">if</span> stop <span class="token operator">></span> newbit <span class="token punctuation">&#123;</span>
		stop <span class="token operator">=</span> newbit
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">!=</span> stop <span class="token operator">&amp;&amp;</span> <span class="token function">bucketEvacuated</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>nevacuate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		h<span class="token punctuation">.</span>nevacuate<span class="token operator">++</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">==</span> newbit <span class="token punctuation">&#123;</span> <span class="token comment">// newbit == # of oldbuckets</span>
		h<span class="token punctuation">.</span>oldbuckets <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token keyword">if</span> h<span class="token punctuation">.</span>extra <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token punctuation">&#125;</span>
		h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> sameSizeGrow
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之前在分析哈希表访问函数 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450"><code>runtime.mapaccess1</code></a> 时其实省略了扩容期间获取键值对的逻辑，当哈希表的 <code>oldbuckets</code> 存在时，就会先定位到旧桶并在该桶没有被分流时从中获取键值对。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapaccess1</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	alg <span class="token operator">:=</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>alg
	hash <span class="token operator">:=</span> alg<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	m <span class="token operator">:=</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
	b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> c <span class="token operator">:=</span> h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">;</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			m <span class="token operator">>>=</span> <span class="token number">1</span>
		<span class="token punctuation">&#125;</span>
		oldb <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>oldb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			b <span class="token operator">=</span> oldb
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
bucketloop<span class="token punctuation">:</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为旧桶中还没有被 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240"><code>runtime.evacuate</code></a> 函数分流，其中还保存着我们需要使用的数据，会替代新创建的空桶提供数据。</p>
<p>我们在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 函数中也省略了一段逻辑，当哈希表正在处于扩容状态时，每次向哈希表写入值时都会触发 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113"><code>runtime.growWork</code></a> 对哈希表的内容进行增量拷贝：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapassign</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
again<span class="token punctuation">:</span>
	bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然除了写入操作之外，删除操作也会在哈希表扩容期间触发 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113"><code>runtime.growWork</code></a>，触发的方式和代码与这里的逻辑几乎完全相同，都是计算当前值所在的桶，然后对该桶中的元素进行拷贝。</p>
<p>我们简单总结一下哈希表的扩容设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，整个扩容过程并不是原子的，而是通过 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113"><code>runtime.growWork</code></a> 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流；除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会对哈希进行『内存整理』减少对空间的占用。</p>
<h3><span id="删除">删除 </span></h3><p> 如果想要删除哈希中的元素，就需要使用 Go 语言中的 <code>delete</code> 关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p>
<p><img src="https://i.loli.net/2020/09/04/j8GoTZ4Ob6cV5Aa.png" alt="hashtable-delete"></p>
<p>在编译期间，<code>delete</code> 关键字会被转换成操作为 <code>ODELETE</code> 的节点，而 <code>ODELETE</code> 会被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532">cmd/compile/internal/gc.walkexpr</a> 转换成 <code>mapdelete</code> 函数簇中的一个，包括 <code>mapdelete</code>、<code>mapdelete_faststr</code>、<code>mapdelete_fast32</code> 和 <code>mapdelete_fast64</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">walkexpr</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> init <span class="token operator">*</span>Nodes<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> n<span class="token punctuation">.</span>Op <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> ODELETE<span class="token punctuation">:</span>
		init<span class="token punctuation">.</span><span class="token function">AppendNodes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>Ninit<span class="token punctuation">)</span>
		map_ <span class="token operator">:=</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		key <span class="token operator">:=</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		map_ <span class="token operator">=</span> <span class="token function">walkexpr</span><span class="token punctuation">(</span>map_<span class="token punctuation">,</span> init<span class="token punctuation">)</span>
		key <span class="token operator">=</span> <span class="token function">walkexpr</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> init<span class="token punctuation">)</span>

		t <span class="token operator">:=</span> map_<span class="token punctuation">.</span>Type
		fast <span class="token operator">:=</span> <span class="token function">mapfast</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token keyword">if</span> fast <span class="token operator">==</span> mapslow <span class="token punctuation">&#123;</span>
			key <span class="token operator">=</span> <span class="token function">nod</span><span class="token punctuation">(</span>OADDR<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		n <span class="token operator">=</span> <span class="token function">mkcall1</span><span class="token punctuation">(</span><span class="token function">mapfndel</span><span class="token punctuation">(</span>mapdelete<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> init<span class="token punctuation">,</span> <span class="token function">typename</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> map_<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些函数的实现其实差不多，我们来分析其中的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685-L791"><code>runtime.mapdelete</code></a> 函数，哈希表的删除逻辑与写入逻辑非常相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会对即将操作的桶进行分流，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mapdelete</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
search<span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">&#123;</span>
					<span class="token keyword">break</span> search
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			k2 <span class="token operator">:=</span> k
			<span class="token keyword">if</span> <span class="token operator">!</span>alg<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">&#125;</span>
			<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
			v <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>valuesize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
			b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> emptyOne
			<span class="token operator">...</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们其实只需要知道 <code>delete</code> 关键字在编译期间经过 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/"> 类型检查 </a> 和<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/">中间代码生成 </a> 阶段被转换成 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685-L791"><code>runtime.mapdelete</code></a> 函数簇中的一员就可以，用于处理删除逻辑的函数与哈希表的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683"><code>runtime.mapassign</code></a> 几乎完全相同，不太需要刻意关注。</p>
<h2><span id="小结">小结</span></h2><p>Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。</p>
<p>哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 <code>tophash</code> 就成为了一级缓存帮助哈希快速遍历桶中元素，每一个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会被存储到哈希的溢出桶中。</p>
<p>随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fnref:5">Separate Chaining: Concept, Advantages &amp; Disadvantages</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的接口</title>
    <url>/2020/01/11/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>Go 语言中的接口就是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们更好地组织并写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的最大阻碍。</p>
<p>本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。</p>
<a id="more"></a>
<h2><span id="概述">概述 </span></h2><p> 在计算机科学中，接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。接口的本质就是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p><img src="https://i.loli.net/2020/09/04/3T9UIE5lVObWHPA.png" alt="golang-interface"></p>
<p>这种面向接口的编程方式有着非常强大的生命力，无论是在框架还是操作系统中我们都能够找到接口的身影。可移植操作系统接口（Portable Operating System Interface，POSIX)就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。</p>
<p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。《SICP》中有这么一句话：</p>
<blockquote>
<p>代码必须能够被人阅读，只是机器恰好可以执行。</p>
</blockquote>
<p>人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。</p>
<p><img src="https://i.loli.net/2020/09/04/m4MfiP7ypZVzA1n.png" alt="sql-and-databases"></p>
<p>计算机科学中的接口是一个比较抽象的概念，但是编程语言中接口的概念就更加具体。Go 语言中的接口是一种内置的类型，它定义了一组方法的签名，这一小节会先介绍 Go 语言接口的几个基本概念以及常见问题，为之后介绍实现原理做一些铺垫。</p>
<h3><span id="隐式接口">隐式接口 </span></h3><p> 很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> hello <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码定义了一个必须实现的方法 <code>sayHello</code> 和一个会注入到实现类的变量 <code>hello</code>。在下面的代码中，<code>MyInterfaceImpl</code> 就实现了 <code>MyInterface</code> 接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">MyInterface</span><span class="token punctuation">.</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Java 中的类必须通过上述方式显式地声明实现的接口，但是在 Go 语言中实现接口就不需要使用类似的方式。首先，我们简单了解一下在 Go 语言中如何定义接口。定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RPCError <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Code    <span class="token builtin">int64</span>
	Message <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>RPCError<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s, code=%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>Message<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Code<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>细心的读者可能会发现上述代码根本就没有 <code>error</code> 接口的影子，这是为什么呢？Go 语言中 <strong> 接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法实现了 <code>error</code> 接口。Go 语言实现接口的方式与 Java 完全不同：</p>
<ul>
<li>在 Java 中：实现接口需要显式的声明接口并实现所有方法；</li>
<li>在 Go 中：实现接口的所有方法就隐式的实现了接口；</li>
</ul>
<p>我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查，这里举几个例子来演示发生接口类型检查的时机：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> rpcErr <span class="token builtin">error</span> <span class="token operator">=</span> <span class="token function">NewRPCError</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"unknown err"</span><span class="token punctuation">)</span> <span class="token comment">// typecheck1</span>
	err <span class="token operator">:=</span> <span class="token function">AsErr</span><span class="token punctuation">(</span>rpcErr<span class="token punctuation">)</span> <span class="token comment">// typecheck2</span>
	<span class="token function">println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> 
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewRPCError</span><span class="token punctuation">(</span>code <span class="token builtin">int64</span><span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>RPCError<span class="token punctuation">&#123;</span> <span class="token comment">// typecheck3</span>
		Code<span class="token punctuation">:</span>    code<span class="token punctuation">,</span>
		Message<span class="token punctuation">:</span> msg<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">AsErr</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Go 语言会 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/"> 编译期间 </a> 对代码进行类型检查，上述代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才对类型进行检查，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p>
<h3><span id="类型">类型 </span></h3><p> 接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface&#123;&#125;</code>：</p>
<p><img src="https://i.loli.net/2020/09/04/9myUgL3BKMN4hnw.png" alt="golang-different-interface"></p>
<p>Go 语言使用 <code>iface</code> 结构体表示第一种接口，使用 <code>eface</code> 结构体表示第二种空接口，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中非常常见，所以在实现时使用了特殊的类型。</p>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface&#123;&#125;</code> 类型 <strong> 不是任意类型</strong>，如果我们将类型转换成了 <code>interface&#123;&#125;</code> 类型，这边变量在运行期间的类型也发生了变化，获取变量类型时就会得到 <code>interface&#123;&#125;</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">type</span> Test <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	v <span class="token operator">:=</span> Test<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">Print</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述函数不接受任意类型的参数，只接受 <code>interface&#123;&#125;</code> 类型的值，在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface&#123;&#125;</code> 类型，我们会在本节后面介绍类型转换的过程和原理。</p>
<h3><span id="指针和接口">指针和接口 </span></h3><p> 在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到『一个类型』实现接口的两种方式：</p>
<p><img src="https://i.loli.net/2020/09/04/5PDUBJtxu28VZlO.png" alt="golang-interface-and-pointer"></p>
<p>这是因为结构体类型和指针类型是完全不同的，就像我们不能向一个接受指针的函数传递结构体，在实现接口时这两种类型也不能划等号。但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 —— <code>method redeclared</code>。</p>
<p>对 <code>Cat</code> 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c  Cat<span class="token punctuation">)</span> Quack <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 使用结构体实现接口</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cat<span class="token punctuation">)</span> Quack <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 使用结构体指针实现接口</span>

<span class="token keyword">var</span> d Duck <span class="token operator">=</span> Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token comment">// 使用结构体初始化变量</span>
<span class="token keyword">var</span> d Duck <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token comment">// 使用结构体指针初始化变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现接口的类型和初始化返回的类型两个维度组成了四种情况，这四种情况并不都能通过编译器的检查：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th>结构体指针实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td>不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td>通过</td>
</tr>
</tbody>
</table>
</div>
<p>四种中只有『使用指针实现接口，使用结构体初始化变量』无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p>
<ul>
<li>方法接受者和初始化类型都是结构体；</li>
<li>方法接受者和初始化类型都是结构体指针；</li>
</ul>
<p>而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？我们先来看一下能够通过编译的情况，也就是方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Cat <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"meow"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为指针的 <code>&amp;Cat&#123;&#125;</code> 变量能够 <strong> 隐式地获取 </strong> 到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。我们可以将这里的调用理解成 C 语言中的 <code>d-&gt;Walk()</code> 和 <code>d-&gt;Speak()</code>，它们都会先获取指向的结构体再执行对应的方法。</p>
<p>但是如果我们将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"meow"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> build <span class="token keyword">interface</span><span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token punctuation">.</span><span class="token operator">/</span><span class="token keyword">interface</span><span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span> cannot use Cat literal <span class="token punctuation">(</span><span class="token keyword">type</span> Cat<span class="token punctuation">)</span> as <span class="token keyword">type</span> Duck in assignment<span class="token punctuation">:</span>
	Cat does not implement Duck <span class="token punctuation">(</span>Quack method has pointer receiver<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器会提醒我们：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。这两个报错对于刚刚接触 Go 语言的开发者比较难以理解，如果我们想要搞清楚这个问题，首先要知道 Go 语言在 <a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/"> 传递参数 </a> 时都是传值的。</p>
<p><img src="https://i.loli.net/2020/09/04/4dSzOu7GJYiXxfP.png" alt="golang-interface-method-receive"></p>
<p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat&#123;&#125;</code> 还是 <code>&amp;Cat&#123;&#125;</code>，使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝：</p>
<ul>
<li>上图左侧，对于 <code>&amp;Cat&#123;&#125;</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat&#123;&#125;</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；</li>
<li>上图右侧，对于 <code>Cat&#123;&#125;</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat&#123;&#125;</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>上面的分析解释了指针类型的现象，当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。当然这并不意味着我们应该一律使用结构体实现接口，这个问题在实际工程中也没那么重要，在这里我们只想解释现象背后的原因。</p>
<h3><span id="nil-和-non-nil">nil 和 non-nil</span></h3><p>我们可以通过一个例子理解 <strong>『Go 语言的接口类型不是任意类型』</strong> 这一句话，下面的代码在 <code>main</code> 函数中初始化了一个 <code>*TestStruct</code> 结构体指针，由于指针的零值是 <code>nil</code>，所以变量 <code>s</code> 在初始化之后也是 <code>nil</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> TestStruct <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NilOrNot</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> v <span class="token operator">==</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> s <span class="token operator">*</span>TestStruct
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>      <span class="token comment">// #=> true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">NilOrNot</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// #=> false</span>
<span class="token punctuation">&#125;</span>

$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们简单总结一下上述代码执行的结果：</p>
<ul>
<li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li>
<li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li>
</ul>
<p>出现上述现象的原因是 —— 调用 <code>NilOrNot</code> 函数时发生了 <strong> 隐式的类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>*TestStruct</code> 类型会转换成 <code>interface&#123;&#125;</code> 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p>
<h2><span id="数据结构">数据结构 </span></h2><p> 接下来我们从源代码和汇编指令层面介绍接口的底层数据结构。</p>
<p>Go 语言根据接口类型『是否包含一组方法』对类型做了不同的处理。我们使用 <code>iface</code> 结构体表示包含方法的接口；使用 <code>eface</code> 结构体表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型，<code>eface</code> 结构体在 Go 语言的定义是这样的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> eface <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 16 bytes</span>
	_type <span class="token operator">*</span>_type
	data  unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 <code>interface&#123;&#125;</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言中的任意类型都可以转换成 <code>interface&#123;&#125;</code> 类型。</p>
<p>另一个用于表示接口的结构体就是 <code>iface</code>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <code>itab</code> 类型的 <code>tab</code> 字段。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> iface <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 16 bytes</span>
	tab  <span class="token operator">*</span>itab
	data unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们将详细分析 Go 语言接口中的这两个类型，即 <code>_type</code> 和 <code>itab</code>。</p>
<h3><span id="类型结构体">类型结构体</span></h3><p><code>_type</code> 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，结构体包含了很多元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> _type <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	size       <span class="token builtin">uintptr</span>
	ptrdata    <span class="token builtin">uintptr</span>
	hash       <span class="token builtin">uint32</span>
	tflag      tflag
	align      <span class="token builtin">uint8</span>
	fieldAlign <span class="token builtin">uint8</span>
	kind       <span class="token builtin">uint8</span>
	equal      <span class="token keyword">func</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span>
	gcdata     <span class="token operator">*</span><span class="token builtin">byte</span>
	str        nameOff
	ptrToThis  typeOff
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li>
<li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li>
<li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的；</li>
</ul>
<p>我们只需要对 <code>_type</code> 结构体中的字段有一个大体的概念，不需要详细理解所有字段的作用和意义。</p>
<h3><span id="itab-结构体">itab 结构体</span></h3><p><code>itab</code> 结构体是接口类型的核心组成部分，每一个 <code>itab</code> 都占 32 字节的空间，我们可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> itab <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 32 bytes</span>
	inter <span class="token operator">*</span>interfacetype
	_type <span class="token operator">*</span>_type
	hash  <span class="token builtin">uint32</span>
	<span class="token boolean">_</span>     <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	fun   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了 <code>inter</code> 和 <code>_type</code> 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用：</p>
<ul>
<li><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>_type</code> 是否一致；</li>
<li><code>fun</code> 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</li>
</ul>
<p>我们会在类型断言中介绍 <code>hash</code> 字段的使用，在动态派发一节中介绍 <code>fun</code> 数组中存储的函数指针是如何被使用的。</p>
<h2><span id="类型转换">类型转换 </span></h2><p> 既然我们已经了解了接口在运行时的数据结构，接下来会通过几个例子来深入理解接口类型是如何初始化和传递的，这里会介绍在实现接口时使用指针类型和结构体类型的区别。这两种不同的接口实现方式会导致 Go 语言编译器生成不同的汇编代码，带来执行过程上的一些差异。</p>
<h3><span id="指针类型">指针类型 </span></h3><p> 首先我们回到这一节开头提到的 <code>Duck</code> 接口的例子，我们使用 <code>//go:noinline</code> 指令禁止 <code>Quack</code> 方法的内联编译：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//go:noinline</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Name <span class="token operator">+</span> <span class="token string">"meow"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们使用编译器将上述代码编译成汇编语言，删掉其中一些对理解接口原理无用的指令并保留与赋值语句 <code>var c Duck = &amp;Cat&#123;Name: &quot;grooming&quot;&#125;</code> 相关的代码，我们将生成的汇编指令拆分成三部分分析：</p>
<ol>
<li>结构体 <code>Cat</code> 的初始化；</li>
<li>赋值触发的类型转换过程；</li>
<li>调用接口的方法 <code>Quack()</code>；</li>
</ol>
<p>我们先来分析结构体 <code>Cat</code> 的初始化过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">LEAQ	<span class="token keyword">type</span><span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Cat</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">type</span><span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>Cat
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">type</span><span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>Cat
CALL	runtime<span class="token punctuation">.</span><span class="token function">newobject</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
MOVQ	<span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> DI                          <span class="token punctuation">;</span><span class="token punctuation">;</span> DI <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
MOVQ	$<span class="token number">8</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span>DI<span class="token punctuation">)</span>                          <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>DI<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span>Len <span class="token operator">=</span> <span class="token number">8</span>
LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token string">"grooming"</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX       <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"grooming"</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>DI<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>DI<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"grooming"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>获取 <code>Cat</code> 结构体类型指针并将其作为参数放到栈上；</li>
<li>通过 <code>CALL</code> 指定调用 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164"><code>runtime.newobject</code></a> 函数，这个函数会以 <code>Cat</code> 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li>
<li>SP+8 现在存储了一个指向 <code>Cat</code> 结构体的指针，我们将栈上的指针拷贝到寄存器 <code>DI</code> 上方便操作；</li>
<li>由于 <code>Cat</code> 中只包含一个字符串类型的 <code>Name</code> 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;grooming&quot;</code> 和字符串长度 <code>8</code> 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;grooming&quot;</code>；</li>
</ol>
<p>字符串在运行时的表示其实就是指针加上字符串长度，在前面的章节 <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/"> 字符串 </a> 已经介绍过它的底层表示和实现原理，但是我们这里要看一下初始化之后的 <code>Cat</code> 结构体在内存中的表示是什么样的：</p>
<p><img src="https://img.draveness.me/golang-new-struct-pointer.png" alt="golang-new-struct-pointe"></p>
<p>因为 <code>Cat</code> 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 <code>Cat</code> 结构体的大小都是 16 字节。初始化 <code>Cat</code> 结构体之后就进入了将 <code>*Cat</code> 转换成 <code>Duck</code> 类型的过程了：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Duck</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">itab</span><span class="token punctuation">(</span><span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck<span class="token punctuation">)</span>
MOVQ	DI<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> AX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>类型转换的过程比较简单，<code>Duck</code> 作为一个包含方法的接口，它在底层使用 <code>iface</code> 结构体表示。<code>iface</code> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 <code>tab</code> 字段，我们已经通过上一段代码 SP+8 初始化了 <code>Cat</code> 结构体指针，这段代码只是将编译期间生成的 <code>itab</code> 结构体指针复制到 SP 上：</p>
<p><img src="https://img.draveness.me/golang-struct-pointer-to-iface.png" alt="golang-struct-pointer-to-iface"></p>
<p>到这里，我们会发现 SP ~ SP+16 共同组成了 <code>iface</code> 结构体，而栈上的这个 <code>iface</code> 结构体也是 <code>Quack</code> 方法的第一个入参。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">CALL    <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>                <span class="token punctuation">;</span><span class="token punctuation">;</span> SP<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述代码会直接通过 <code>CALL</code> 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是 <code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p>
<h3><span id="结构体类型">结构体类型 </span></h3><p> 在这里，我们继续修改上一节中的代码，使用结构体类型实现 <code>Duck</code> 接口并初始化结构体类型的变量：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//go:noinline</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Name <span class="token operator">+</span> <span class="token string">"meow"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们在初始化变量时使用指针类型 <code>&amp;Cat&#123;Name: &quot;grooming&quot;&#125;</code> 也能够通过编译，不过生成的汇编代码和上一节中的几乎完全相同，所以这里也就不分析这个情况了。</p>
<p>编译上述的代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不会影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p>
<ol>
<li>初始化 <code>Cat</code> 结构体；</li>
<li>完成从 <code>Cat</code> 到 <code>Duck</code> 接口的类型转换；</li>
<li>调用接口的 <code>Quack</code> 方法；</li>
</ol>
<p>我们先来看一下上述汇编代码中用于初始化 <code>Cat</code> 结构体的部分：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">XORPS   X0<span class="token punctuation">,</span> X0                          <span class="token punctuation">;</span><span class="token punctuation">;</span> X0 <span class="token operator">=</span> <span class="token number">0</span>
MOVUPS  X0<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_1<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>SP<span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token number">0</span>
LEAQ    <span class="token keyword">go</span><span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token string">"grooming"</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"grooming"</span>
MOVQ    AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_1<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>SP<span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Data <span class="token operator">=</span> AX
MOVQ    $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_1<span class="token operator">+</span><span class="token function">40</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>SP<span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Len <span class="token operator">=</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段汇编指令会在栈上初始化 <code>Cat</code> 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 <code>Cat</code> 的指针。</p>
<p>初始化结构体后就进入类型转换的阶段，编译器会将 <code>go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck</code> 的地址和指向 <code>Cat</code> 结构体的指针作为参数一并传入 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411"><code>runtime.convT2I</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Duck</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX     <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck<span class="token punctuation">)</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> AX
LEAQ	<span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_1<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX           <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>SP<span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                          <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">=</span> AX
CALL	runtime<span class="token punctuation">.</span><span class="token function">convT2I</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>                <span class="token punctuation">;</span><span class="token punctuation">;</span> runtime<span class="token punctuation">.</span><span class="token function">convT2I</span><span class="token punctuation">(</span>SP<span class="token punctuation">,</span> SP<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数会获取 <code>itab</code> 中存储的类型，根据类型的大小申请一片内存空间并将 <code>elem</code> 指针中的内容拷贝到目标的内存空间中：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">convT2I</span><span class="token punctuation">(</span>tab <span class="token operator">*</span>itab<span class="token punctuation">,</span> elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>i iface<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t <span class="token operator">:=</span> tab<span class="token punctuation">.</span>_type
	x <span class="token operator">:=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>size<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> x<span class="token punctuation">,</span> elem<span class="token punctuation">)</span>
	i<span class="token punctuation">.</span>tab <span class="token operator">=</span> tab
	i<span class="token punctuation">.</span>data <span class="token operator">=</span> x
	<span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411"><code>runtime.convT2I</code></a> 会返回一个 <code>iface</code> 结构体，其中包含 <code>itab</code> 指针和 <code>Cat</code> 变量。当前函数返回之后，<code>main</code> 函数的栈上会包含以下数据：</p>
<p><img src="https://img.draveness.me/golang-struct-to-iface.png" alt="golang-struct-to-iface"></p>
<p>SP 和 SP+8 中存储的 <code>itab</code> 和 <code>Cat</code> 指针就是 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411"><code>runtime.convT2I</code></a> 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 <code>iface</code> 结构体，SP+32 存储的就是在栈上的 <code>Cat</code> 结构体，它会在 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411"><code>runtime.convT2I</code></a> 执行的过程中拷贝到堆上。</p>
<p>在最后，我们会通过以下的指令调用 <code>Cat</code> 实现的接口方法 <code>Quack()</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">MOVQ	<span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck<span class="token punctuation">)</span>
MOVQ	<span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> CX <span class="token punctuation">;</span><span class="token punctuation">;</span> CX <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
MOVQ	<span class="token function">24</span><span class="token punctuation">(</span>AX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> AX<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Cat<span class="token punctuation">.</span>Quack
MOVQ	CX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>   <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> CX
CALL	AX         <span class="token punctuation">;</span><span class="token punctuation">;</span> CX<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <code>itab</code> 结构体中取出 <code>Cat.Quack</code> 方法指针作为 <code>CALL</code> 指令调用时的参数。接口变量的第 24 字节是 <code>itab.fun</code> 数组开始的位置，由于 <code>Duck</code> 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 <code>Quack</code> 方法的指针了。</p>
<h2><span id="类型断言">类型断言 </span></h2><p> 上一节介绍是如何把具体类型转换成接口类型，而这一节介绍的是如何将一个接口类型转换成具体类型。本节会根据接口中是否存在方法分两种情况介绍类型断言的执行过程。</p>
<h3><span id="非空接口">非空接口 </span></h3><p> 首先分析接口中包含方法的情况，<code>Duck</code> 接口一个非空的接口，我们来分析从 <code>Duck</code> 转换回 <code>Cat</code> 结构体的过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">switch</span> c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token operator">*</span>Cat<span class="token punctuation">:</span>
		cat <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span>
		cat<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们将编译得到的汇编指令分成两部分分析，第一部分是变量的初始化，第二部分是类型断言，第一部分的代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">00000</span> TEXT	<span class="token string">""</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> ABIInternal<span class="token punctuation">,</span> $<span class="token number">32</span><span class="token operator">-</span><span class="token number">0</span>
<span class="token operator">...</span>
<span class="token number">00029</span> XORPS	X0<span class="token punctuation">,</span> X0
<span class="token number">00032</span> MOVUPS	X0<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_4<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>
<span class="token number">00037</span> LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token string">"grooming"</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX
<span class="token number">00044</span> MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_4<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>
<span class="token number">00049</span> MOVQ	$<span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_4<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>0037 ~ 0049 三个指令初始化了 <code>Duck</code> 变量，<code>Cat</code> 结构体初始化在 SP+8 ~ SP+24 上。因为 Go 语言的编译器做了一些优化，所以代码中没有<code>iface</code> 的构建过程，不过对于这一节要介绍的类型断言和转换没有太多的影响。下面进入类型转换的部分：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">00058</span> CMPL  <span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token number">593696792</span>  
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>tab<span class="token punctuation">.</span>hash <span class="token operator">!=</span> <span class="token number">593696792</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">00068</span> JEQ   <span class="token number">80</span>                          <span class="token punctuation">;</span><span class="token punctuation">;</span>      
<span class="token number">00070</span> MOVQ  <span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP                  <span class="token punctuation">;</span><span class="token punctuation">;</span>      BP <span class="token operator">=</span> SP<span class="token operator">+</span><span class="token number">24</span>
<span class="token number">00075</span> ADDQ  $<span class="token number">32</span><span class="token punctuation">,</span> SP                     <span class="token punctuation">;</span><span class="token punctuation">;</span>      SP <span class="token operator">+=</span> <span class="token number">32</span>
<span class="token number">00079</span> RET                               <span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token keyword">return</span>
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
<span class="token number">00080</span> LEAQ  <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_4<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX     <span class="token punctuation">;</span><span class="token punctuation">;</span>      AX <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
<span class="token number">00085</span> MOVQ  AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                    <span class="token punctuation">;</span><span class="token punctuation">;</span>      SP <span class="token operator">=</span> AX
<span class="token number">00089</span> CALL  <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>      SP<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">00094</span> JMP   <span class="token number">70</span>                          <span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token operator">...</span>
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span>      BP <span class="token operator">=</span> SP<span class="token operator">+</span><span class="token number">24</span>
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span>      SP <span class="token operator">+=</span> <span class="token number">32</span>
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token keyword">return</span>
                                        <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>switch 语句生成的汇编指令会将目标类型的 <code>hash</code> 与接口变量中的 <code>itab.hash</code> 进行比较：</p>
<ul>
<li>如果两者相等意味着变量的具体类型是</li>
</ul>
  <pre class="line-numbers language-none"><code class="language-none">Cat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  ，我们会跳转到 0080 所在的分支完成类型转换。</p>
<ol>
<li>获取 SP+8 存储的 <code>Cat</code> 结构体指针；</li>
<li>将结构体指针拷贝到栈顶；</li>
<li>调用 <code>Quack</code> 方法；</li>
<li>恢复函数的栈并返回；</li>
</ol>
<ul>
<li>如果接口中存在的具体类型不是 <code>Cat</code>，就会直接恢复栈指针并返回到调用方；</li>
</ul>
<p><img src="https://img.draveness.me/golang-interface-to-struct.png" alt="golang-interface-to-struct"></p>
<p>上图展示了调用 <code>Quack</code> 方法时的堆栈情况，其中 <code>Cat</code> 结构体存储在 SP+8 ~ SP+24 上，<code>Cat</code> 指针存储在栈顶并指向上述结构体。</p>
<h3><span id="空接口">空接口 </span></h3><p> 当我们使用空接口类型 <code>interface&#123;&#125;</code> 进行类型断言时，如果不关闭 Go 语言编译器的优化选项，生成的汇编指令是差不多的。编译器会省略将 <code>Cat</code> 结构体转换成 <code>eface</code> 的过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">switch</span> c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token operator">*</span>Cat<span class="token punctuation">:</span>
		cat <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span>
		cat<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果禁用编译器优化，上述代码会在类型断言时就不是直接获取变量中具体类型的 <code>_type</code>，而是从 <code>eface._type</code> 中获取，汇编指令仍然会使用目标类型的 <code>hash</code> 字段与变量的类型比较。</p>
<h2><span id="动态派发">动态派发 </span></h2><p> 动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是一种在面向对象语言中常见的特性。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p>
<p>在如下所示的代码中，<code>main</code> 函数调用了两次 <code>Quack</code> 方法：</p>
<ol>
<li>第一次以 <code>Duck</code> 接口类型的身份调用，调用时需要经过运行时的动态派发；</li>
<li>第二次以 <code>*Cat</code> 具体类型的身份调用，编译期就会确定调用的函数：</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Duck <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为编译器优化影响了我们对原始汇编指令的理解，所以需要使用编译参数 <code>-N</code> 关闭编译器优化。如果不指定这个参数，编译器会对代码进行重写，与最初生成的执行过程有一些偏差，例如：</p>
<ul>
<li>因为接口类型中的 <code>tab</code> 参数并没有被使用，所以优化从 <code>Cat</code> 转换到 <code>Duck</code> 的过程；</li>
<li>因为变量的具体类型是确定的，所以删除从 <code>Duck</code> 接口类型转换到 <code>*Cat</code> 具体类型时可能会发生 <code>panic</code> 的分支；</li>
<li>…</li>
</ul>
<p>在具体分析调用 <code>Quack</code> 方法的两种姿势之前，我们要先了解 <code>Cat</code> 结构体究竟是如何初始化的，以及初始化完成后的栈上有哪些数据：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">LEAQ	<span class="token keyword">type</span><span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Cat</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>
CALL	runtime<span class="token punctuation">.</span><span class="token function">newobject</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>              <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>
MOVQ	<span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> DI                          <span class="token punctuation">;</span><span class="token punctuation">;</span> DI <span class="token operator">=</span> SP <span class="token operator">+</span> <span class="token number">8</span>
MOVQ	DI<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_2<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">+</span> <span class="token number">32</span> <span class="token operator">=</span> DI
MOVQ	$<span class="token number">8</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span>DI<span class="token punctuation">)</span>                          <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">.</span>Len <span class="token operator">=</span> <span class="token number">8</span>
LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token string">"grooming"</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX       <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"grooming"</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>DI<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">StringHeader</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">.</span>Data <span class="token operator">=</span> AX
MOVQ	<span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_2<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX           <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_1<span class="token operator">+</span><span class="token function">40</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">+</span> <span class="token number">40</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Duck</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> CX    <span class="token punctuation">;</span><span class="token punctuation">;</span> CX <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck
MOVQ	CX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                    <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab <span class="token operator">=</span> SP <span class="token operator">+</span> <span class="token number">48</span> <span class="token operator">=</span> CX
MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                    <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>data <span class="token operator">=</span> SP <span class="token operator">+</span> <span class="token number">56</span> <span class="token operator">=</span> AX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的初始化过程其实和上两节中的过程没有太多的差别，它先初始化了 <code>Cat</code> 结构体指针，再将 <code>Cat</code> 和 <code>tab</code> 打包成了一个 <code>iface</code> 类型的结构体，我们直接来看初始化结束后的栈情况：</p>
<p><img src="https://i.loli.net/2020/09/04/KWUkzZ8r4b2CH3p.png" alt="stack-after-initialize"></p>
<p><strong>图 4-14 接口类型初始化后的栈</strong></p>
<ul>
<li>SP 是 <code>Cat</code> 类型，它也是运行时 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164"><code>runtime.newobject</code></a> 方法的参数；</li>
<li>SP+8 是 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164"><code>runtime.newobject</code></a> 方法的返回值，也就是指向堆上的 <code>Cat</code> 结构体的指针；</li>
<li>SP+32、SP+40 是对 SP+8 的拷贝，这两个指针都会指向栈上的 <code>Cat</code> 结构体；</li>
<li>SP+48 ~ SP+64 是接口变量 <code>iface</code> 结构体，其中包含了 <code>tab</code> 结构体指针和 <code>*Cat</code> 指针；</li>
</ul>
<p>初始化过程结束之后，我们进入到了动态派发的过程，<code>c.Quack()</code> 语句展开的汇编指令会在运行时确定函数指针。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab
MOVQ	<span class="token function">24</span><span class="token punctuation">(</span>AX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                         <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Cat<span class="token punctuation">.</span>Quack
MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> CX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> CX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>data
MOVQ	CX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> CX <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
CALL	AX                                 <span class="token punctuation">;</span><span class="token punctuation">;</span> SP<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的执行过程可以分成以下三个步骤：</p>
<ol>
<li>从接口变量中获取了保存 <code>Cat.Quack</code> 方法指针的 <code>tab.func[0]</code>；</li>
<li>接口变量在中的数据会被拷贝到栈顶；</li>
<li>方法指针会被拷贝到寄存器中并通过汇编指令 <code>CALL</code> 触发：</li>
</ol>
<p>另一个调用 <code>Quack</code> 方法的语句 <code>c.(*Cat).Quack()</code> 生成的汇编指令看起来会有一些复杂，但是代码前半部分都是在做类型转换，将接口类型转换成 <code>*Cat</code> 类型，只有最后两行代码才是函数调用相关的指令：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> CX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> CX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab
LEAQ	<span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">Duck</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> DX    <span class="token punctuation">;</span><span class="token punctuation">;</span> DX <span class="token operator">=</span> <span class="token operator">&amp;&amp;</span><span class="token keyword">go</span><span class="token punctuation">.</span>itab<span class="token punctuation">.</span><span class="token operator">*</span><span class="token string">""</span><span class="token punctuation">.</span>Cat<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">.</span>Duck
CMPQ	CX<span class="token punctuation">,</span> DX                             <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token function">CMP</span><span class="token punctuation">(</span>CX<span class="token punctuation">,</span> DX<span class="token punctuation">)</span>
JEQ	<span class="token number">163</span>
JMP	<span class="token number">201</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">.</span>autotmp_3<span class="token operator">+</span><span class="token function">24</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP<span class="token operator">+</span><span class="token number">24</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
MOVQ	AX<span class="token punctuation">,</span> <span class="token punctuation">(</span>SP<span class="token punctuation">)</span>                           <span class="token punctuation">;</span><span class="token punctuation">;</span> SP <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>
CALL	<span class="token string">""</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Cat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>                <span class="token punctuation">;</span><span class="token punctuation">;</span> SP<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的几行代码只是将 <code>Cat</code> 指针拷贝到了栈顶并调用 <code>Quack</code> 方法。这一次调用的函数指针在编译期就已经确定了，所以运行时就不需要动态查找方法的实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab
MOVQ	<span class="token function">24</span><span class="token punctuation">(</span>AX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX                         <span class="token punctuation">;</span><span class="token punctuation">;</span> AX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>tab<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Cat<span class="token punctuation">.</span>Quack
MOVQ	<span class="token string">""</span><span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> CX                    <span class="token punctuation">;</span><span class="token punctuation">;</span> CX <span class="token operator">=</span> <span class="token function">iface</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>两次方法调用对应的汇编指令差异就是动态派发带来的额外开销，这些额外开销在有低延时、高吞吐量需求的服务中是不能被忽视的，我们来详细分析一下产生的额外汇编指令对性能造成的影响。</p>
<h4><span id="基准测试">基准测试 </span></h4><p> 下面代码中的两个方法 <code>BenchmarkDirectCall</code> 和 <code>BenchmarkDynamicDispatch</code> 分别会调用结构体方法和接口方法，在接口上调用方法时会使用动态派发机制，我们以直接调用作为基准分析动态派发带来了多少额外开销：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkDirectCall</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// MOVQ	AX, "".c+24(SP)</span>
		<span class="token comment">// MOVQ	AX, (SP)</span>
		<span class="token comment">// CALL	"".(*Cat).Quack(SB)</span>
		c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">BenchmarkDynamicDispatch</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> <span class="token function">Duck</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// MOVQ	"".d+56(SP), AX</span>
		<span class="token comment">// MOVQ	24(AX), AX</span>
		<span class="token comment">// MOVQ	"".d+64(SP), CX</span>
		<span class="token comment">// MOVQ	CX, (SP)</span>
		<span class="token comment">// CALL	AX</span>
		c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们直接运行下面的命令，使用 1 个 CPU 运行上述代码，每一个基准测试都会被执行 3 次：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> test <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token operator">-</span>N <span class="token operator">-</span>benchmem <span class="token operator">-</span>test<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">3</span> <span class="token operator">-</span>test<span class="token punctuation">.</span>cpu<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>test<span class="token punctuation">.</span>benchtime<span class="token operator">=</span><span class="token number">1</span>s <span class="token operator">-</span>bench<span class="token operator">=</span><span class="token punctuation">.</span>
goos<span class="token punctuation">:</span> darwin
goarch<span class="token punctuation">:</span> amd64
pkg<span class="token punctuation">:</span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>playground
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">3.11</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">2.94</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">3.04</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">500000000</span>	         <span class="token number">3.40</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">500000000</span>	         <span class="token number">3.79</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">500000000</span>	         <span class="token number">3.55</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>调用结构体方法时，每一次调用需要 <code>~3.03ns</code>；</li>
<li>使用动态派发时，每一调用需要 <code>~3.58ns</code>；</li>
</ul>
<p>在关闭编译器优化的情况下，从上面的数据来看，动态派发生成的指令会带来 <code>~18%</code> 左右的额外性能开销。</p>
<p>这些性能开销在一个复杂的系统中不会带来太多的影响。一个项目不可能只使用动态派发，而且如果我们开启编译器优化后，动态派发的额外开销会降低至 <code>~5%</code>，这对应用性能的整体影响就更小了，所以与使用接口带来的好处相比，动态派发的额外开销往往可以忽略。</p>
<p>上面的性能测试建立在实现和调用方法的都是结构体指针上，当我们将结构体指针换成结构体又会有比较大的差异：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkDirectCall</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// MOVQ	AX, (SP)</span>
		<span class="token comment">// MOVQ	$8, 8(SP)</span>
		<span class="token comment">// CALL	"".Cat.Quack(SB)</span>
		c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">BenchmarkDynamicDispatch</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> <span class="token function">Duck</span><span class="token punctuation">(</span>Cat<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"grooming"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// MOVQ	16(SP), AX</span>
		<span class="token comment">// MOVQ	24(SP), CX</span>
		<span class="token comment">// MOVQ	AX, "".d+32(SP)</span>
		<span class="token comment">// MOVQ	CX, "".d+40(SP)</span>
		<span class="token comment">// MOVQ	"".d+32(SP), AX</span>
		<span class="token comment">// MOVQ	24(AX), AX</span>
		<span class="token comment">// MOVQ	"".d+40(SP), CX</span>
		<span class="token comment">// MOVQ	CX, (SP)</span>
		<span class="token comment">// CALL	AX</span>
		c<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们重新执行相同的基准测试时，会得到如下所示的结果：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> test <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token operator">-</span>N <span class="token operator">-</span>benchmem <span class="token operator">-</span>test<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">3</span> <span class="token operator">-</span>test<span class="token punctuation">.</span>cpu<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span>test<span class="token punctuation">.</span>benchtime<span class="token operator">=</span><span class="token number">1</span>s <span class="token punctuation">.</span>
goos<span class="token punctuation">:</span> darwin
goarch<span class="token punctuation">:</span> amd64
pkg<span class="token punctuation">:</span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>playground
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">3.15</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">3.02</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDirectCall      	<span class="token number">500000000</span>	         <span class="token number">3.09</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">200000000</span>	         <span class="token number">6.92</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">200000000</span>	         <span class="token number">6.91</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op
BenchmarkDynamicDispatch 	<span class="token number">200000000</span>	         <span class="token number">7.10</span> ns<span class="token operator">/</span>op	       <span class="token number">0</span> B<span class="token operator">/</span>op	       <span class="token number">0</span> allocs<span class="token operator">/</span>op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直接调用方法需要消耗时间的平均值和使用指针实现接口时差不多，约为 <code>~3.09ns</code>，而使用动态派发调用方法却需要 <code>~6.98ns</code> 相比直接调用额外消耗了 <code>~125%</code> 的时间，从生成的汇编指令我们也能看出后者的额外开销会高很多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>直接调用</th>
<th>动态派发</th>
</tr>
</thead>
<tbody>
<tr>
<td>指针</td>
<td>~3.03ns</td>
<td>~3.58ns</td>
</tr>
<tr>
<td>结构体</td>
<td>~3.09ns</td>
<td>~6.98ns</td>
</tr>
</tbody>
</table>
</div>
<p>从上述表格我们可以看到使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。</p>
<p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。</p>
<h2><span id="小结">小结 </span></h2><p> 重新回顾一下本节介绍的内容，我们在开头简单介绍了使用 Go 语言接口的常见问题，例如使用不同类型实现接口带来的差异、函数调用时发生的隐式类型转换；我们还分析了接口的类型转换、类型断言以及动态派发机制。</p>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://www.tapirgames.com/blog/golang-interface-implementation">How Interfaces Work in Go</a></li>
<li><a href="https://golang.org/doc/effective_go.html#interfaces_and_types">Interfaces and other types · Effective Go</a></li>
<li><a href="https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">How to use interfaces in Go</a></li>
<li><a href="https://research.swtch.com/interfaces">Go Data Structures: Interfaces</a></li>
<li><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck typing · Wikipedia</a></li>
<li><a href="http://www.robelle.com/smugbook/posix.html">What is POSIX?</a></li>
<li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md">Chapter II: Interfaces</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何建立高效知识笔记管理系统</title>
    <url>/2018/02/01/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E9%AB%98%E6%95%88%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>转载自：<a href="https://zhuanlan.zhihu.com/p/191519306">如何建立知识笔记管理系统？</a></p>
<p>人脑的工作其实很大程度上与计算机的工作机制相似，人脑的思维区是 CPU 处理思考任务 ，人脑的工作记忆区是 CPU 缓存处理工作瞬时记忆，人脑的短期记忆区是内存处理短期记忆，人脑的建立的神经突触则是数据库。但是人脑的容量毕竟有限，一种更经济的做法是，把关键的知识节点存储在大脑中，作为领域知识的索引，而大量细节问题存储于各种数字化存储设备。这便是个人知识管理系统。</p>
<a id="more"></a>
<h2><span id="什么是知识管理系统"><strong>什么是知识管理系统？</strong></span></h2><p>假设有一个场景，床头有 10 本书，要在其中找到一本书，你会怎么找？一本本翻找。</p>
<p>但假如在美国国会图书馆中，藏书超 2.1 亿本，在里边找到某一本书，请问你如何找？</p>
<p>仅凭人脑是没有办法处理这么大的信息量的。那么图书馆的管理人员，是如何解决这些问题的？</p>
<p>当让是靠着一套管理系统，让一切规律化，规则化，系统化，把人解放出来。</p>
<p><img src="https://i.loli.net/2020/08/24/MIpzQ8NPBhdAw5a.jpg" alt></p>
<p>同理，我们的知识管理系统就相当于这个图书管理系统，而知识就如同这一本本图书，当有了套系统去管理它们以后，我们就相当于拥有了另外的一个大脑，如此就可以把我们大脑不擅长的东西，全部扔给这个外脑，让它帮助我们记忆，整理等等。</p>
<h2><span id="为什么你必须要建立外脑"><strong>为什么你必须要建立外脑？</strong></span></h2><p><strong>1. 大脑是用来思考的，不是用来记忆的。</strong></p>
<p>记忆，尤其是死记硬背，是最反人性的，进化论告诉我们，大脑只会记住最能帮助我们生存的信息，至于无关紧要的，它为了节省脑力资源会尽可能的忘记它们，同样的大脑也只能处理眼下的小部分信息，而面对大量信息处理的时候，大脑就会罢工。</p>
<p>我们平常用脑的时候，感觉思绪乱，头昏脑涨，就是因为大脑处理的信息已经超过了它的负荷。<strong>大脑的机制天生就不是为了记忆和处理大量信息而设计的！！！</strong></p>
<p>但是在现实生活中，我们又需要处理和记住很多信息和知识点，以便使用的时候可以随用随取，那应该怎么办呢？</p>
<p>当然是建立外脑！！！</p>
<p><strong>前面说了我们大脑不擅长的记忆和大规模信息管理，但这却是我们外脑所擅长的。我们的大脑会遗忘，但是外脑它永远也不会忘的，你建立的这个外脑就会和你的大脑形成互补，各发挥其所长。</strong></p>
<p>正如上面的图书管理案例，我们不需要记住每本书的信息，我们想要的时候，只要知道怎么从图书管理系统中找到它们即可。</p>
<p><strong>所以想发挥大脑真正的威力，就把它从记忆中解放出来，让它去思考，而不是让它去记忆。</strong></p>
<p><img src="https://i.loli.net/2020/08/24/HkrCVtuxdainy2X.jpg" alt></p>
<p><strong>有同学看到这里可能会抬杠：有必要弄这么一个外脑吗，我大脑就够用了啊。</strong></p>
<p>当你只想做个 “撸瑟” 的时候，觉得这辈子能搬个砖，扛个水泥就够了，那么你就可以离开了，因为你确实没有这个需求。</p>
<p>但是你想获得不断成长，要获得更强的能力，想要在社会的激烈竞争中有足够的竞争力，你的知识储备必然需要被扩大，这种情况下，你要靠脑子记忆吗？回想你上学的生涯就知道了，那是多么痛的领悟~</p>
<p>正如上文案例，你只有十本书的时候，当然不需要建立外脑，想要啥扫一眼就够了，但是当你有 1000 本、10000 本、一百万、一个亿本的时候呢？</p>
<p>以上只是我们必须建立外脑的一个理由之一，除此之外，还有一个更重要的理由。</p>
<p><strong>2. 外脑是为了帮助大脑更好的记住：有逻辑关系的知识，你用的时候才能想起来。</strong></p>
<p>为什么会这样说呢？</p>
<p>同样我们先不回答这个问题，给你来个小测试。</p>
<p>现在思考一下：我让你说水果的名字，你看看你能说出多少个水果。</p>
<p>你可能会说，这有什么难的：苹果，香蕉，梨、橘子、火龙果、西瓜….</p>
<p>但是你发现越往下，你思考的时间就越长，越说不出来。</p>
<p>你可以先暂停阅读试试~</p>
<p>那么我再换一个问题，请告诉如西红柿炒鸡蛋怎么做？</p>
<p>你可能想都不用想，直接就可以脱口而出：准备食材 —&gt; 洗菜切菜 —-&gt; 爆锅开炒 —-&gt;…..</p>
<p>为什么会这样？</p>
<p>因为前者大脑索引的是一个点一个点的信息，后者索引的一整个结构，一整套流程，一整张知识的网。</p>
<p>你看，点状的东西被大脑索引是很困难的，但是有逻辑有结构的东西则不同，后者一索引就是一大片，一整个体系。当你把点状的知识编织成一张网后，它们就会形成你的思维模型，这样，你用的时候才能想起来。</p>
<p>很多人抱怨，学过的东西用不出来，反思一下，从小到大，你调用你知识储备的时候是不是都像是上面想水果一样，想到哪是哪。</p>
<p>你整理过你的知识吗？你的知识是成结构的吗？你脑中有这么一张庞大的知识结构网吗？</p>
<p>而把知识打入外脑的过程就是在编织你这张网，所以 <strong> 建立外脑的本质就是体系化你知识的过程！！！</strong></p>
<p><img src="https://i.loli.net/2020/08/24/7TditOLD8hZF3ES.jpg" alt></p>
<h2><span id="如何建立外脑">如何建立外脑？</span></h2><p><strong>整个外脑是由两个系统构成。</strong></p>
<blockquote>
<p>第一个是储存笔记的系统。<br>第二个则是索引笔记的系统。</p>
</blockquote>
<p>你可以理解成一个放，一个拿，这里知道有这么个东西即可，后文会展开介绍。</p>
<p><img src="https://i.loli.net/2020/08/24/navSjTKx6VoIMzm.jpg" alt></p>
<p><strong>而整个外脑的搭建可以归纳为三步走~</strong></p>
<blockquote>
<p>第一步：把收集知识有序的装进去 <br> 第二步：把知识整理好，设立规则，以供随时提用。<br>第三步：用的时候可以迅速的把需要的知识拿出来。</p>
</blockquote>
<p><strong>整篇文章的核心下面一张图就概括了，但是为了让你彻底搞定这件事，我会掰开了揉碎了，一步步手把手带你搭出你的知识管理系统。</strong></p>
<p><img src="https://i.loli.net/2020/08/24/uQ7hqe8rLIDkFiH.png" alt></p>
<p><strong>下面我们先从搭建储存体入手，从零开始搭建整个外脑系统~</strong></p>
<h3><span id="一选择外脑载体">一：选择外脑载体 </span></h3><p> 一台能正常跑的电脑系统，前提就是主机，显示屏这些硬件载体，你操作系统再牛逼，没有主机你也跑不起来。</p>
<p>同理，我们的外脑的搭建也是如此，所以建立外脑的第一步，就是找到外脑的载体，即存放我们知识的工具。</p>
<p>那么市面上提供给我们现成的外脑载体都有哪些呢？</p>
<p><img src="https://i.loli.net/2020/08/24/oZnYvQfGDe91u7J.jpg" alt></p>
<p>太多太多了，主流的有道云笔记、印象笔记、onenote 等，都可以作为我们外脑的载体，它们各有优缺点，想详细了解的同学请自行了解，我这里就不展开了，大家凭借喜好选择，总之，都是现成的，任君选择~</p>
<p>我本人的外脑载体为有道云笔记，下文演示，均以此笔记做案例，其他载体同理~</p>
<p><strong>当我们确定了大脑的载体以后呢？</strong></p>
<p>建立几个文件夹后，就开始一顿操作猛如虎，类似下面这样的吗？</p>
<p><img src="https://i.loli.net/2020/08/24/PbwXspTIK2k67hg.jpg" alt></p>
<p><strong>这样的外脑系统有什么问题呢？</strong></p>
<blockquote>
<p><strong>① 层次结构混乱：</strong>这样长长的列下来，我不知道你头大没有，别说提取了，我单单看到这一串，头就先大一圈了。<br>因为这样混乱的结构，含糊其辞的目录，会让你翻看这些东西的时候，对这种凌乱有一种厌恶感。<br><strong>② 提取困难：</strong>混乱的内容，会让真正用的时候找不到，所有的笔记，如果用的时候找不到，或者需要很大的功夫才能找到，那这个外脑系统就没多大意义了，当你笔记内容少的时候，你还能记得那是哪，但是当大到一定量级了呢，你的外脑一定会崩溃。<br><strong>③ 知识碎片化 </strong>：以上所建立的文件夹，之间都是割裂的，笔记与笔记间连接不起来。<br> 我们在文章开始的时候就说了，外脑的作用除了帮我们承担记忆的负担，还有一项职能就是辅助我们大脑为我们建立起知识体系，如果你的笔记之间都是一个个散乱的点，那么外脑的意义就要被砍掉一半。</p>
</blockquote>
<p><strong>一句话来说，上面的那些都不是一个好的外脑，因为它并没有解决我们为什么建立外脑的本质问题。</strong></p>
<p><strong>那么什么是好的外脑呢？</strong></p>
<blockquote>
<p><strong>1. 知识结构体系化：</strong>笔记与笔记间的知识点不分散，不是乱七八糟的，不是碎片化的。<br><strong>2. 方便管理：</strong>看到不头大，结构清晰，一目了然。<br><strong>3. 提取方便，高效：</strong>最好高效到如同探囊取物，想到就能秒拿到。如果这一点满足不了，找一个想要的信息要半天，那么这套系统就没有多少意义。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/24/S2w4osnQHAK3rvk.jpg" alt></p>
<p>好了，到了这里你知道了，一个好的外脑的标准，随着而来的一个问题就是，如何才能让你的外脑达成以上标准。</p>
<p><strong>那么如何让外脑满足以上条件呢？</strong></p>
<p>正如电脑的 windows 系统一样，装上了，我们就无需用乱七八糟反人性的 dos 命令去让计算机工作，所有的一切都有序的跑在这套清爽的图形化系统之上。</p>
<p><strong>同理想让外脑不乱，你必须部署一套规则化的操作系统，让我们的知识笔记全部跑在这套管理系统之上，保证底盘不乱，根基稳，而不是随性而建。</strong></p>
<p>所以找到载体之后，不是一顿操作猛如虎，而是要给我们的外脑装上一个类似 windows 一样的底层系统，而我们这套跑在外脑载体上的系统就是 GTD 系统，所以我们建立外脑的第二步就是给它装上这套系统。</p>
<h3><span id="二部署-gtd-操作系统">二：部署 GTD 操作系统</span></h3><p><strong>① 什么是 GTD 系统？</strong></p>
<p>GTD 的英文全称是：Getting Things Done</p>
<p>这是由著名的时间管理人戴维・艾伦在他的著作《尽管去做》里提出的一套移动硬盘式的任务管理方法，它的核心精髓是把所有待办任务都从大脑里移出去，清空大脑，用外部的工具去管理任务，让大脑的全部资源都用来思考，而又不会遗漏任何一件事。</p>
<p>部署了 GTD 系统在笔记本上，我们就可以借助 GTD 的工作流，不仅拥有了知识管理系统，而且还把我们的日程管理系统也都囊括其中了，极大幅度的解放了我们的大脑。</p>
<p><img src="https://i.loli.net/2020/08/24/Z26TjanLCMIP8gQ.jpg" alt></p>
<p><strong>② 如何部署 GTD 系统到笔记本上？</strong></p>
<p>GTD 工作流总共有 5 个步骤：收集、厘清、整理、归档、回顾。</p>
<p>而把它用到我们的外脑上就变成了信息管理流，同样也是五个步骤：</p>
<p>GTD 信息流：收集箱、等待处理、将来可能、归档资料、专题研究。</p>
<p><img src="https://i.loli.net/2020/08/24/PYXr54Wy1tTxd3Q.jpg" alt></p>
<p>下面分别介绍一下，我们设置的这五个文件夹可以干什么。</p>
<p><strong>1. 收集箱</strong></p>
<p>这个就相当于你在各大平台点的收藏，比如我们拿手机刷到好文了（比如这篇文章哈~），我们就可以把各大平台的好文，一键集中扔到这个收集箱中。</p>
<p>这个东西的作用就是负责收集，你不必操心该放到那个分类，所有的好东西，一股脑扔进去就 OK 了，这样就可以大幅度的解放我们分类归类的时间，等到了一个固定的时间，比如晚上统一处理，这样既不打断我们当前手头的事情，同时又确保了收藏的文件不会乱七八糟，又能让你认真的评估和精读这篇文章，确保进入你笔记的都是精品。</p>
<p><img src="https://i.loli.net/2020/08/24/HfBtsrGiSpFnjLT.jpg" alt></p>
<p><strong>2. 等待处理</strong></p>
<p>这个文件夹承载我们当天的日程，备忘录，记事本，沉思录、日记本等等。</p>
<p>你应该有体会，大脑凭记忆力处理这些事情有多坑爹，我们就可以把这些事情交给外脑处理，把日程，待办事项等全部移到这个文件夹里，把这些事情全部从大脑中清理出去，想知道接下来要做什么事情直接来翻这个文件夹，效率高的飞起。</p>
<p><img src="https://i.loli.net/2020/08/24/C7KdH45qMBcOV3X.jpg" alt></p>
<p><strong>3. 将来可能</strong></p>
<p>这里主要承载计划、规划、想法、点子类的东西。</p>
<p>比如你看到了一个点子，发现了一个项目，你就可以先把它扔到这里，作为你的灵感库。</p>
<p><img src="https://i.loli.net/2020/08/24/Prpod8FtVSux5si.jpg" alt></p>
<p><strong>4. 归档资料</strong></p>
<p>这个是我们的知识的大本营，最终所有的信息和笔记都会被归入到这个文件夹中，我们收集到的信息通过整理完毕以后，就放入这里，以供随手复习和使用的时候随时调取。</p>
<p><img src="https://i.loli.net/2020/08/24/En5uQeaCl1x6ZUG.jpg" alt></p>
<p><strong>5. 专题研究</strong></p>
<p>比如我最近对唱歌比较感兴趣，那么我就可以单独这专题这里建立一个文件夹，专门服务于唱歌，当研究出成果了，再把它归入到归档资料中。</p>
<p><img src="https://i.loli.net/2020/08/24/Any4i5R3JcVpIg1.jpg" alt></p>
<p>当你在你的笔记本上，创建了这个 5 个文件夹后，你的 GTD 系统就部署完成了。</p>
<p>你看，部署了 GTD，通过 GTD 来处理信息后，你的外脑是不是特别有层次感，是不是感觉外脑像是有了灵魂一样~，而不是类似于上面那四个笔记长长的一串。</p>
<p><img src="https://i.loli.net/2020/08/24/H8uaZgQ1wy756l2.jpg" alt></p>
<p>那么部署完 GTD 系统后就完了吗？当然不是。</p>
<p>完成了最底层系统的搭建，我们就要开始去处理输入进来的笔记了，前面说了，<strong>最终所有的笔记都会被汇总归档到『归档资料』这个文件夹之中，所以我们管理笔记的核心就在此文件夹中</strong>，但是那么多的笔记，怎么去管理啊，还是像上面图中那四个案例一样，列出长长的一串文件夹吗？</p>
<p>下面我们进入本文的第三个模块，来解决以上问题。</p>
<h3><span id="三规则化信息给外脑立结构-给笔记立规矩">三：规则化信息——给外脑立结构、给笔记立规矩。</span></h3><p>我们都知道无规矩不成方圆，如果归入进来的笔记没有规则，那就会乱七八糟，完全没效率可言，所以我们必须要给输入进来的笔记进行处理，教给它们规矩，让它们变得清晰有规律，只有这样，你提取它的时候才能迅速找到你想要的。</p>
<p>但是要设立那些规矩呢？如何设立呢？</p>
<p>下面提供四大原则，保证让你的笔记规规矩矩的。</p>
<p><strong>① 最简层原则</strong></p>
<p><strong>什么是最简层原则？</strong></p>
<p>所谓最简层原则就是让文件夹尽可能的少，层级尽可能的少，因为只有数量少，你看起来才不会头大，如果还是一层又一层的文件夹，那就和前面你看到的那四张笔记没啥差别了。</p>
<p><strong>那么如何才能尽可能的少呢？</strong></p>
<p>当然是找一个可以把所有东西都包括进来的维度，它符合之前文章提到的 MECE 原则，既涵盖了所有笔记特性，又不遗漏，同时又不冗长。</p>
<p>我这里就提供给你一个这样的维度，以笔记的 “用处” 这一个维度进行划分，即：『学习』『工作』『生活』。</p>
<p>你可以随便想，从用处来论，任何笔记都不会逃过这个三个分类的，所以它是符合 MECE 的，我们就以它作为划分知识的标准，作为『归档资料』的打底文件夹，这样我们就实现了最简层。</p>
<p><img src="https://i.loli.net/2020/08/24/hfjAVnl4GDOXC7r.jpg" alt></p>
<p>打底文件夹有了，我们就需要根据自己的需求对文件夹做一些进一步细分，但如果你还是建立一串文件夹，整个笔记体系必然会乱，那么如何管理下一级的文件夹呢？</p>
<p>这就用到了让你笔记规矩的第二个原则！！！</p>
<p><strong>② 目录编码原则</strong></p>
<p><strong>什么是目录编码原则？</strong></p>
<p>你可以先思考下这个问题，一本书有那么多的知识点，它是怎么排版才让内容清晰一目了然的？</p>
<p>当然是把图书知识结构整理成目录按照层次编码啊，如下图，这样你看起来结构就会非常清晰，一目了然，同理，我们对文件夹的层级管理，同样采用这种方式，让文件夹的层级与层级之间建立起逻辑关系。</p>
<p><img src="https://i.loli.net/2020/08/24/cQxRyXtFm3PdEIr.jpg" alt></p>
<p><strong>那如何目录编码呢?</strong></p>
<p>这里不进行赘述，我给你做了一张图，扫一眼估计你就会了。</p>
<p><img src="https://i.loli.net/2020/08/24/AsFWJrC8PnVfHOw.jpg" alt></p>
<p><strong>除了建立起清晰的逻辑层次外，为什么你一定要用目录编码？</strong></p>
<p>因为有了目录编码后，笔记就能实现自动排序！！  </p>
<p>笔记本一般都是按照名称排序的，比如，数字 1 在数字 2 前面，字母 A 在字母 B 前面，如此就会非常有序，可参考微信好友目录哈~  </p>
<p>如果你没给它这样规则化命名，则会出现乱序情况，会让笔记看起来乱七八糟的，但如果你设置了编码，就能实现自动排序，非常爽啊~</p>
<p>所以我们采用图书目录编码，一箭双雕，不仅让结构逻辑层次清晰，而且还能实现自动排序。</p>
<p>以上我们说了让你笔记规矩的四个原则的前两个原则，有了它们可以让你的笔记结构层次有了一个质的提升，但仅仅是层次清晰还远远不够，想要你的笔记规矩，你还需要第三个原则。</p>
<p><strong>③ 统一命名原则</strong></p>
<p><strong>什么是统一命名的原则？</strong></p>
<p>即：<strong>无论是文件夹还是笔记本身，都要遵循一套标准的命名原则</strong>，只有这样你的笔记才不会乱，切记把笔记命名成这样的无格式笔记，一旦养成这样的习惯，后期会让你有一种想锤死你自己的感觉，相信我~</p>
<p><img src="https://i.loli.net/2020/08/24/c1WHEDpQyoViwnY.jpg" alt></p>
<p><strong>那么用什么标准命名呢？怎么命名？</strong></p>
<p>下面我给出三个方法，让你解决这个问题。</p>
<p><strong>1. 用黄金圈法则命名文件夹</strong></p>
<p>你学习的任何一个知识点或专题都逃不过黄金圈的终极三问，即：是什么（what）、为什么（why）、如何做（how）。</p>
<p>比如你想研究演讲的话题，那么你就可以创建三个文件夹：</p>
<blockquote>
<ol>
<li>什么是演讲？（what is 演讲）  </li>
<li>为什么要学习和训练演讲？（why 演讲）  </li>
<li>如何训练演讲？（how to 演讲）</li>
</ol>
</blockquote>
<p>当你创建了这个三个文件夹后，你就可以把演讲相关的所有知识点按照黄金圈分出的三个文件夹分别归属，如此每个文件夹对应啥内容，一眼望穿~</p>
<p>你看，三个文件夹解决一切，而且看起来是那么的清晰，那么的一目了然~~</p>
<p><img src="https://i.loli.net/2020/08/24/5pBFYTOg6ynuZWw.jpg" alt></p>
<p><strong>2. 笔记文件规范化命名</strong></p>
<p>上面讲的是文件夹的命名方法，这里则是具体到的某个笔记文件命名。</p>
<p>这里也没有太多可讲的，我给你做了一张图，提供了一个公式，你看一眼就秒懂了。</p>
<p><img src="https://i.loli.net/2020/08/24/WhfLvAFT8E2t6GU.jpg" alt></p>
<p><strong>规则化命名，效果示范~~</strong></p>
<p>你看，这样的笔记标题命名和上图的两小人那张笔记标题命名，那个看起来让人爽？</p>
<p><img src="https://i.loli.net/2020/08/24/cM9JvKWDPp3sNAL.jpg" alt></p>
<p><strong>3. 意义不明的层，坚决不要。</strong></p>
<p>还有很多同学会建一个『其他』的文件夹，请问，你这个『其他』是什么？</p>
<p>你之所以建这个『其他』就是因为，你也搞不通某个笔记文件属于那个类别了，不好分类的所幸一股脑的扔到这里边。</p>
<p>我告诉你，你在用的时候是根本不会去翻『其他』这个分类的，因为它在你脑中就没有啥概念，你都不知道你放了些啥，应该放些啥，又怎么能指望提取的时候找到呢？</p>
<p>所以，这种意义不明的层，坚决不要。</p>
<p><img src="https://i.loli.net/2020/08/24/DNhV4jMyrcdHuW2.png" alt></p>
<p>到了这里，你知道了让笔记规矩的三个原则，但是仅仅知道以上三个原则，还不能让它们很规矩，想要他们更规矩一些，你还需要第四个原则。</p>
<p><strong>④ 标签化原则</strong></p>
<p>什么是标签化原则？以及为什么要用标签去管理我们的笔记？</p>
<p>我先不回答这个问题，给你出道小题~</p>
<p>假如让你给伟人归类，你会把毛爷爷归到哪一类？</p>
<p><img src="https://i.loli.net/2020/08/24/P54UKve7nYoxaF9.jpg" alt></p>
<p>你会把毛爷爷归到政治家？思想家？军事家？…… 抱歉，这些头衔毛爷爷都占了~</p>
<p><img src="https://i.loli.net/2020/08/24/wjNF4pAlCiGRLde.jpg" alt></p>
<p>你看，你是没有办法把他按单一的维度归类的。</p>
<p>如果你单一的把毛爷爷归到一个分类中，比如 “诗人”，那么搜索其他分类，就找不到毛爷爷了，那你就把毛爷爷给定住在某个分类中了，这样做就是有漏的，同理，我们再来看个案例~</p>
<p>你会把前两年大火的《战狼 2》归到什么分类中？你能对它进行单一归类吗？</p>
<p><img src="https://i.loli.net/2020/08/24/hJG4QNmktdIuPzf.jpg" alt></p>
<p>我们之前的文章中讲维度的时候就已经说了，<strong>任何一件事物都可以有很多个维度。</strong>如果你把某事物按照一个维度归类，你就相当于把它给定死了，同理我们的知识依旧如此。</p>
<p><strong>你笔记里的知识，大部分都被你给定死了。</strong></p>
<p>很多人的笔记之所以没有效率，用的时候找不到，很大的原因就是你把知识给限定死了。</p>
<p>比如你学到了一个写作技巧 “如何煽情” ，如果你单纯的把这个技巧归入到 “写小说” 这个分类中，只有写小说的时候，你才会想起它，那么这个这个知识点就让你学死了，因为这个技巧完全可能套用到写文案，写报告等等….</p>
<p><strong>那么如何解决这个问题呢？</strong></p>
<p>这就回答了上面，为什么要用标签来管理笔记了的问题了。</p>
<p><strong>打标签就是为解决这个问题设置的，你可以给一个知识点打上无数个标签，当你搜索任何一个标签维度的时候都能够索引到这个知识点。</strong></p>
<p>正如上面案例中，只要你给毛爷爷打上了标签，无论你搜 XX 家，都能找到毛爷爷。而《战狼 2》中你搜索商业片也能找到它，搜索战争片也能找到它，搜索吴京也能找到它….</p>
<p><strong>如此，我们就不用纠结于某个知识点具体该归入『储存体』的那个文件夹中，无论是你放到那，只要标签打上了，就不用担心索引问题。</strong></p>
<p>当你部署了一系列标签的时候，你的知识就活了。</p>
<blockquote>
<p>比如：『记忆』这个标签，当你想要这个标签的内容的时候，云笔记就会帮助你，把所有这个被你标记过这个标签的文章给找出来，无论它是你过去的读书笔记，或者是电视剧看到的，演讲听到的，课程中学到的，总之，只要包含这个标签的，一股脑的都会给你抓出来，供你调遣使用……</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/24/N6neIJh19QYZzLl.jpg" alt></p>
<p>下面给你展示一下，<strong>我是如何给一个课程打标签的！！！</strong></p>
<p><img src="https://i.loli.net/2020/08/24/pqxOFNe8ETknfJZ.jpg" alt></p>
<p>好了 ，看到这里你可能会说，完成以上部署，笔记的整体效率是高了很多，知识也给盘活了，但是以上知识之间仍然是割裂的，笔记与笔记间仍然形成不了体系，而且笔记量和标签一多，标签本身也就乱了，都不知道标签那个是哪个了，那如何解决这一系列问题呢？</p>
<p>下面，我们就进入本文的最后一个模块，部署索引体，让你的外脑的效率彻底飞起来~~</p>
<h3><span id="四部署索引体系统">四：部署索引体系统 </span></h3><h4><span id="什么是储存体和索引体系统"> 什么是储存体和索引体系统？</span></h4><p>储存体就是我们以上忙活的，那都是在部署储存体的系统，即在文件夹里的那一套。</p>
<p>我们前面说了，我们通过标签调取笔记或信息，而索引体系统，就是 <strong> 把标签与标签之间也建立起逻辑关系，形成体系和结构，最后内化成我们的知识体系。</strong>  </p>
<p>一句话解释，储存体用于管理 “文件夹的系统”，而索引体则用于管理 “标签的系统”。</p>
<p>为了让两者更有辨识度，文件夹系统作为储存体识别符号『C』，标签系统作为索引体，识别符『S』。</p>
<p><img src="https://i.loli.net/2020/08/24/G1RjTF2hEZAovYB.jpg" alt></p>
<p><strong>2. 如何搭建索引体？</strong></p>
<p><strong>① 底层系统搭建</strong>  </p>
<p>储存体有 GTD 作为底层操作系统，那么索引体同样也应该有操作系统作为分类。索引体的分类规则就是我们前文说的『学习』、『工作』、『生活』三个分类，因为你笔记上所有的东西都逃不过这三点，它是符合 MECE 的。</p>
<p><img src="https://i.loli.net/2020/08/24/q4WVghOablC6TLP.jpg" alt></p>
<p>工作和生活的分类我这里不多介绍，因为这个体系不体系无所谓，大家按照自己的喜好打标签即可。这里主要介绍的是『学习』，因为这才是承载我们知识标签的大本营，我们所有的知识标签都以这个分类为底。  </p>
<p>那么在『学习』这个分类底下，应该怎么去构建知识架构呢？</p>
<p><strong>② 一个维度分类所有知识标签</strong>  </p>
<p>体系的构成一定有底层分类作为支撑的，所以想要把零散的标签，编织成系统就需要对他们进行分类，那么从作用的维度，你会把 “所有的知识” 标签分成哪几类？  </p>
<p>可能每个人都有自己的标准~  </p>
<p>我本人按照和参考了 “儒家的最高理想” 把一个人的一生所有的知识分成了四类：</p>
<p>即：修身的知识、齐家的知识、治国的知识、平天下的知识~  </p>
<p>哈哈，比较中二，不过我看着很顺眼，这个分类仅供参考，如果你也觉得这个维度不错，可以直接拿去用~</p>
<p><img src="https://i.loli.net/2020/08/24/YHBgFJ3pS2Pi4Ia.jpg" alt></p>
<p>好了，有了这个维度，你就可以把你在储存体里打上的标签，按照这四个维度，分门别类的整理在这里边即可，我截取一段我『索引体』系统中的整理效果，供大家参考~  </p>
<p>你可以看出来，当『索引体』逐渐完善以后，它就是一套完整，清晰的知识体系~~</p>
<p><img src="https://i.loli.net/2020/08/24/oakgDsqN6xcyCHm.jpg" alt></p>
<p><strong>③ 区别符号</strong>  </p>
<p>你可能看到索引体中每个对象的前面都有个符号，有的符号是『 # 』有的符号是『 - 』，这是什么意思呢？</p>
<p>这两个符号是区别符号，前面有『 # 』的，说明它是标签。  </p>
<p>而前面有『 - 』的说明它不是标签，这些东西的存在仅仅是为了连接标签，把标签串联成系统的连接符号，帮助我们看的更清晰，更有结构和层次感，它们是不参与索引的，当然『 - 』符号你可加可不加，但是『 # 』这个符号，我建议一定要加上，原因会在下面说。</p>
<p><strong>④ 通过『索引体』快速提取内容</strong>  </p>
<p>当一切都搭建完毕以后，剩下的就是我们提取东西的时候了，你可以通过单击标签提取，但是我最常用的就是搜索提取，想要啥，直接搜索，如探囊取物一样酸爽。</p>
<p>比如：在我笔记中，我搜索『写作』这个标签，你看~，云笔记会把我打这个标签的所有内容都给我找了出来。</p>
<p>无论是我个人的随手感想、我读书的笔记，或者我收集到的任何东西，只要它是在这个标签之下，瞬间提取~~</p>
<p><strong>⑤ 如何让提取效率更高？</strong></p>
<p>我们在实际的提取笔记的场景中，经常会遇到一个问题~</p>
<p>比如一本书的读书笔记，就在这一篇笔记中，它就可能涵盖无数个知识点，即使我用标签定位到了这篇笔记，想要找到笔记中的我想要的东西，也要翻看好久，那么有没有瞬间就能找到我想要的信息的方法呢？</p>
<p>有的，<strong>解决方案就是在笔记文件内处处打标签</strong>，如此可以瞬间找到我们想要的内容。</p>
<p>比如下图，我就在这个笔记的某一处的知识点，打上了三个标签，当我需要找这三个标签任意一个的时候，云笔记会迅速帮我找到它所在的位置，并且打上高亮，这样整篇文章都变成了我标签系统中的一个个知识点，它不再属于原作者，而是属于我体系中的一部分。</p>
<p>这就回答了上面所说的为什么要在标签上加一个 #，原因就在这，如果你不加这个识别符号，搜索到的东西就会乱七八糟，异常痛苦啊，这是坑，我已经替你们踩过了~</p>
<p><img src="https://i.loli.net/2020/08/24/8kRTrF2aMSJ1xof.jpg" alt></p>
<p>好了，到了这里，整篇文章也到了结尾了，这个剩下的你只需要在不断的学习过程中去完善和填充这个骨架，最终它就会形成一张庞大的知识结构网，到时候你就神功大成，就可以任意纵横了。</p>
<h4><span id="打造完毕后最重要的事情是什么">打造完毕后最重要的事情是什么？</span></h4><p><strong>1. 把笔记软件本身玩熟</strong></p>
<p>因为这篇文章不是介绍软件功能的，所以几乎没有提到软件本身提供给我们的功能，包括日程模板、思维导图、ORC 等等太多太多了，你要是懂得笔记软件提供给我们的各种功能，那么你一定可以玩的非常 6，这个大家请自行了解，网上有的是介绍的，我这里不进行赘述了。</p>
<p><strong>2. 规律性的清理收集箱</strong></p>
<p>正如你装修房子一样，在装修的时候你可以一次性装修的美轮美奂，但是在生活中如果你邋邋遢遢，臭袜子，脏东西到处扔，很快你的新房子也就破旧了，想要让他一直焕然一新，高效运行，你就必须养成干净，卫生，自律的生活习惯。</p>
<p>同理我们的笔记系统依然如此，我们这次打造了一套超级牛逼的系统，但是如果你收集到的资料，长期堆积在收集箱中不去清理，内容被到处归类，那么这套系统很快就会被你搞残。</p>
<p>所以你的习惯，才是保持这套系统高效运转的关键！！！！！！！！</p>
<blockquote>
<p><strong>我个人的清理习惯是，每个周末拿出固定的时间，清理一次收集箱，当然如果你比我勤快，且时间充裕，完全可以一天一清理，这样肯定会更好。</strong></p>
</blockquote>
<p><strong>3. 迭代内容，删掉过时的东西，填充空白的内容。</strong></p>
<p>刚开始建立起你的外脑的时候，不可能一下子就建成类似我外脑那样的丰富，肯定会有很多需要完善的地方，不断迭代，更新，这才是你的外脑能持续运转，并且越用越顺手的核心。</p>
<p>最后提醒一句：<strong>外脑要时常翻阅，只有你时常翻阅它，它才会内化到你的大脑中。</strong></p>
<p><img src="https://i.loli.net/2020/08/24/MAxE1tm9bngfN3d.jpg" alt></p>
<h2><span id="总结">总结 </span></h2><p><strong> 一：什么是知识管理系统？</strong></p>
<blockquote>
<p>知识管理系统就是我们的外脑。</p>
</blockquote>
<p><strong>二：为什么要搭建外脑？</strong></p>
<blockquote>
<ol>
<li>信息量多了，我们的大脑是无法记住的，我们需要通过别的方式记住它，并且在用的时候，可以随手提取。  </li>
<li>搭建外脑，本身就是把零碎的东西体系化的过程，就是搭建知识体系的过程，大脑喜欢有结构的东西。</li>
</ol>
</blockquote>
<p><strong>三：如何搭建外脑?</strong></p>
<p><strong>外脑的构成分成两个部分，第一部分为储存体搭建，第二部分为索引体搭建。</strong></p>
<p><strong>①：搭建储存体</strong></p>
<blockquote>
<p><strong>什么是储存体？</strong><br>储存体就是管理文件夹、储存笔记的系统 <br><strong> 如何搭建储存体？</strong>  </p>
<ol>
<li>以 GTD 信息流作为底层系统  </li>
<li>规则化信息需要遵循四大原则，即：<br>（1）最简层原则<br>（2）目录编码原则<br>（3）统一命名原则<br>（4）标签化原则</li>
</ol>
</blockquote>
<p><strong>②：搭建索引体</strong></p>
<blockquote>
<p><strong>什么是索引体？</strong><br>索引体就是管理标签的系统。<br><strong>如何搭建索引体？</strong>  </p>
<ol>
<li>以『学习』、『工作』、『生活』三分类为底层。  </li>
<li>用一个维度涵盖所有『学习』的知识标签：修身的知识、齐家的知识、治国的知识、平天下的知识。<br><strong>如何进一步提升索引效率？</strong><br>笔记内处处打标签</li>
</ol>
</blockquote>
<p><strong>三：保证外脑的高效运转</strong></p>
<blockquote>
<ol>
<li>玩转笔记软件功能  </li>
<li>规律的清理收集箱  </li>
<li>不断的填充完善，迭代更新笔记。</li>
</ol>
</blockquote>
<p><img src="https://i.loli.net/2020/08/24/T41gLqIiX9AoDrC.jpg" alt></p>
<hr>
<h2><span id="参考资料">参考资料 </span></h2><p><a href="[https://xueshu.baidu.com/usercenter/paper/show?paperid=2d66dce9a805fe0fce1ef025d30889b1&amp;site=xueshu\_se"> 文献分类法</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/a533c6906bec0975f465e272.html">美国国会图书馆分类法简表</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ixueshu.com/document/c2f1afb362c2fded3ba5746287489d5d318947a18e7f9386.html">美国国会图书馆的计算机应用系统</a></p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>方法论</tag>
        <tag>知识管理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之 TCP 协议</title>
    <url>/2016/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>TCP 协议作为 TCP/IP 协议栈中最重要的一个协议之一，是因特网的基础。</p>
<a id="more"></a>
<h2><span id="端口与进程">端口与进程 </span></h2><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。<br> 就是说，端口这一东西，是属于 TCP 知识范畴的。</p>
<p>我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。<br>而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 <strong>「PID(进程标识符)」</strong> 来唯一标识一个进程。<br>但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。</p>
<p>解决这个问题的方法就是在运输层使用 <strong>「协议端口号 (protocol port number)」</strong>，简称 <strong>「端口 (port)」</strong>.<br>我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：<strong>「ip 地址＋协议＋端口号」</strong>唯一标示网络中的一个进程。<br>在一些场合，也把这种唯一标识的模式称为<strong>「套接字 (Socket)」</strong>。</p>
<p>这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。</p>
<p>TCP 用一个 16 位端口号来标识一个端口，可允许有 65536 (2 的 16 次方) 个不同的端口号，范围在 0 ~ 65535 之间。</p>
<p>端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：</p>
<ol>
<li>服务器端使用的端口号<ul>
<li>熟知端口号</li>
<li>登记端口号</li>
</ul>
</li>
<li>客户端使用的端口号</li>
</ol>
<p>下面展开来说说。</p>
<h3><span id="端口号的分类">端口号的分类 </span></h3><h4><span id="服务器端使用的端口号"> 服务器端使用的端口号 </span></h4><p><strong> 熟知端口号 </strong>：<br> 取值范围：0 ~ 1023。<br>可以在 www.iana.org 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。</p>
<p>一些常见的端口号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>HTTPS</th>
<th>SNMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>熟知端口号</td>
<td><strong>21</strong></td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td><strong>80</strong></td>
<td><strong>443</strong></td>
<td>161</td>
</tr>
</tbody>
</table>
</div>
<p><strong>登记端口号 </strong>：<br> 取值范围：1024 ~ 49151。<br>这类端口没有熟知的应用程序使用，但是需要登记，以防重复</p>
<h4><span id="客户端使用的端口号">客户端使用的端口号 </span></h4><p> 取值范围：49152 ~ 65535。<br>这类端口仅在客户端进程运行时才动态选择。<br>又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。</p>
<p><strong>在 <code>/etc/services</code> 文件中可以查看所有知名服务使用的端口。</strong></p>
<h2><span id="tcp-报文结构">TCP 报文结构</span></h2><p>TCP 是面向字节流的，但传送的数据单元却是报文段。</p>
<p><strong>什么是报文？</strong><br>例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。<br>而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。<br>一共四个 TCP 报文，发送到另外一个端。<br>另外一端收到数据包，然后再剔除 TCP 首部，组装起来。<br>等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。</p>
<p>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。</p>
<p>TCP 报文 (Segment)，包括首部和数据部分。</p>
<p>而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。<br>TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的。<br>下图是把 TCP 报文中的首部放大来看。</p>
<p>TCP 的首部包括以下内容：</p>
<ol>
<li>源端口 source port</li>
<li>目的端口 destination port</li>
<li>序号 sequence number</li>
<li>确认号 acknowledgment number</li>
<li>数据偏移 offset</li>
<li>保留 reserved</li>
<li>标志位 tcp flags</li>
<li>窗口大小 window size</li>
<li>检验和 checksum</li>
<li>紧急指针 urgent pointer</li>
<li>选项 tcp options</li>
</ol>
<p>下面展开来描述个字段的意义和作用。</p>
<h3><span id="tcp-首部各字段的意义和作用">TCP 首部各字段的意义和作用 </span></h3><h4><span id="源端口和目的端口-port"> 源端口和目的端口 Port</span></h4><p>各占 2 个 字节，共 4 个字节。<br>用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。<br>进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。</p>
<h4><span id="序号-sequence-number">序号 Sequence Number</span></h4><p>占 4 个字节。<br>TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。<br>例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。</p>
<p>序号字段值指的是 <strong> 本报文段 </strong> 所发送的数据的第一个字节的序号。<br>那么 100 的 HTML 文档分割成四个等分之后，<br>第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0<br>第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600<br>……</p>
<p>根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。<br>序号增加到最大值的时候，下一个序号又回到了 0.<br>也就是说 TCP 协议可对 4GB 的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。</p>
<h4><span id="确认号-acknowledgemt-number">确认号 Acknowledgemt Number</span></h4><p>占 4 个字节。<br>表示 <strong> 期望收到对方下一个报文段的序号值 </strong>。<br>TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。<br> 就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。<br><strong>那么，确认报文，就会包含确认号 </strong>。<br> 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值 =0，那么就需要回复一个 <strong> 确认报文</strong>，其中的确认号 = 25600.</p>
<h4><span id="数据偏移-offset">数据偏移 Offset</span></h4><p>占 0.5 个字节 (4 位)。<br>这个字段实际上是指出了 <strong>TCP 报文段的首部长度</strong> ，它指出了 TCP 报文段的数据起始处 距离 TCP 报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）</p>
<p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。</p>
<h4><span id="保留-reserved">保留 Reserved</span></h4><p>占 0.75 个字节 (6 位)。<br>保留为今后使用，但目前应置为 0。</p>
<h4><span id="标志位-tcp-flags">标志位 TCP Flags</span></h4><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。<br>每一位的值只有 0 和 1，分别表达不同意思。</p>
<h5><span id="紧急-urg-urgent">紧急 URG (Urgent)</span></h5><p>当 <code>URG = 1</code> 的时候，表示紧急指针（Urgent Pointer）有效。<br>它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。<br>URG 要与首部中的 紧急指针 字段配合使用。</p>
<h5><span id="确认-ack-acknowlegemt">确认 ACK (Acknowlegemt)</span></h5><p>当 <code>ACK = 1</code> 的时候，确认号（Acknowledgemt Number）有效。<br>一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。</p>
<h5><span id="推送-psh-push">推送 PSH (Push)</span></h5><p>当 <code>PSH = 1</code> 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。</p>
<h5><span id="复位-rst-reset">复位 RST (Reset)</span></h5><p>当 <code>RST = 1</code> 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。<br>一般称携带 RST 标志的 TCP 报文段为「复位报文段」。</p>
<h5><span id="同步-syn-synchronization">同步 SYN (SYNchronization)</span></h5><p>当 <code>SYN = 1</code> 的时候，表明这是一个请求连接报文段。<br>一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。<br>在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p>
<h5><span id="终止-fin-finis">终止 FIN (Finis)</span></h5><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p>
<h4><span id="窗口大小-window-size">窗口大小 Window Size</span></h4><p>占 2 字节。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。<br>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。</p>
<h4><span id="校验和-tcp-checksum">校验和 TCP Checksum</span></h4><p>占 2 个字节。<br>由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。<br>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p>
<h4><span id="紧急指针-urgent-pointer">紧急指针 Urgent Pointer</span></h4><p>占 2 个字节。<br>仅在 <code>URG = 1</code> 时才有意义，它指出本报文段中的紧急数据的字节数。<br>当 <code>URG = 1</code> 时，发送方 TCP 就把紧急数据插入到本报文段数据的 <strong> 最前面 </strong>，而在紧急数据后面的数据仍是普通数据。<br> 因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<p>TCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。</p>
<h2><span id="tcp-连接和关闭">TCP 连接和关闭 </span></h2><h3><span id="tcp-三次握手建立连接">TCP 三次握手，建立连接</span></h3><p>TCP 连接建立要解决的首要问题就是：<strong> 要使每一方能够确知对方的存在。</strong></p>
<p>三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。<br>你喊了一句：Hello？I’am JerryC，Who are you？<br>对面回了一句：Hi! I’am David, and nice to meet you!<br>然后你回了一句：Nice to meet you too!<br>……(自此，你们才算真正认识了双方，开始了后面省略 3000 字的谈话)</p>
<p>所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）</p>
<p>其实，网络上的传输是没有连接的，TCP 也是一样的。<br>而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。</p>
<h4><span id="连接建立过程">连接建立过程 </span></h4><p>TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫<strong> 客户端（Client）</strong>，被动等待连接建立的一方叫 <strong> 服务器（Server）</strong>。</p>
<p>最初的时候，两端都处于 <strong>CLOSED</strong> 的状态，然后服务器打开了 TCP 服务，进入 <strong>LISTEN</strong> 状态，监听特定端口，等待客户端的 TCP 请求。</p>
<p>我们可以利用 wireshark 来抓取一个简单的 TCP 三次握手的包。</p>
<p><strong>第一次握手 </strong>： 客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 <strong>SYN_SEND</strong> 状态，等待服务器发回确认报文。<br> 这时首部的同步位 <code>SYN = 1</code>，同时初始化一个序号 <code>Sequence Number = J</code>。<br>TCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。</p>
<p><strong>第二次握手 </strong>： 服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 <strong>SYN_RCVD</strong> 状态。<br> 这时首部的 <code>SYN = 1，ACK = 1</code>，而确认号 <code>Acknowledgemt Number = J + 1</code>，同时也为自己初始化一个序号 <code>Sequence Number = K</code>。<br>这个报文同样不携带数据。</p>
<p><strong>第三次握手 </strong>：<br> 客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 <strong>ESTABLISHED</strong> 状态。<br>这时首部的 SYN 不再置为 1，而 <code>ACK = 1</code>，确认号 <code>Acknowledgemt Number = K + 1</code>，序号 <code>Sequence Number = J + 1</code>。<br>第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 <strong>ESTABLISHED</strong> 状态。 此时，TCP 连接已经建立。</p>
<p>对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。<br>这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为 TCP 会用这个序号来拼接数据。</p>
<h4><span id="利用连接设计缺陷实施-tcp-flood-攻击">利用连接设计缺陷实施 TCP Flood 攻击 </span></h4><p> 知道了 TCP 建立一个连接，需要进行三次握手。<br>但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。<br>如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。<br>这就是三次握手的必要性。<br>但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。<br>如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。<br>那么很多小人都这样做，你就要一直记住你在等待着小人 1 号、小人 2 号、小人 3 号……直到你的脑容量爆棚，烧坏脑袋。<br>黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。<br>想了解更多 SYN Flood 攻击请看：<a href="https://www.wikiwand.com/en/SYN_flood">SYN flood - wiki</a></p>
<h3><span id="tcp-四次挥手释放连接">TCP 四次挥手，释放连接 </span></h3><p>TCP 有一个特别的概念叫做<strong> 半关闭 </strong>，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。<br> 客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。</p>
<h4><span id="释放连接过程">释放连接过程 </span></h4><p> 在结束之前，通信双方都是处于 <strong>ESTABLISHED</strong> 状态，然后其中一方主动断开连接。<br>下面假如客户端先主动断开连接。</p>
<p><strong>第一次挥手：</strong><br>客户端向服务器发送结束报文段，然后进入 <strong>FIN_WAIT_1</strong> 状态。<br>此报文段 <code>FIN = 1</code>， <code>Sequence Number = M</code>。</p>
<p><strong>第二次挥手：</strong><br>服务端收到客户端的结束报文段，然后发送确认报文段，进入 <strong>CLOSE_WAIT</strong> 状态。<br>此报文段 <code>ACK = 1</code>， <code>Sequence Number = M + 1</code>。</p>
<p>客户端收到该报文，会进入 <strong>FIN_WAIT_2</strong> 状态。</p>
<p><strong>第三次挥手：</strong><br>同时服务端向客户端发送结束报文段，然后进入 <strong>LAST_ACK</strong> 状态。<br>此报文段 <code>FIN = 1</code>，<code>Sequence Number = N</code>。</p>
<p><strong>第四次挥手：</strong><br>客户端收到服务端的结束报文段，然后发送确认报文段，进入 <strong>TIME_WAIT</strong> 状态，经过 2MSL 之后，自动进入 <strong>CLOSED</strong> 状态。<br>此报文段 <code>ACK = 1</code>, <code>Sequence Number = N + 1</code>。</p>
<p>服务端收到该报文之后，进入 <strong>CLOSED</strong> 状态。</p>
<p><strong>关于 TIME_WAIT 过渡到 CLOSED 状态说明 </strong>：<br> 从 <strong>TIME_WAIT</strong> 进入 <strong>CLOSED</strong> 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 <strong>CLOSED</strong> 状态。</p>
<h2><span id="状态流转">状态流转 </span></h2><p> 无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。</p>
<h3><span id="tcp-状态流转图">TCP 状态流转图 </span></h3><h3><span id="各种状态表示的意思"> 各种状态表示的意思</span></h3><ul>
<li><p><strong>CLOSED</strong>：表示初始状态</p>
</li>
<li><p><strong>LISTEN</strong>：表示服务器端的某个 socket 处于监听状态，可以接受连接</p>
</li>
<li><p><strong>SYN_SENT</strong>：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。</p>
</li>
<li><p><strong>SYN_RCVD</strong>：表示服务端接收到了 SYN 报文。</p>
</li>
<li><p><strong>ESTABLISHED</strong>：表示连接已经建立了。</p>
</li>
<li><p><strong>FIN_WAIT_1</strong>：其中一方请求终止连接，等待对方的 FIN 报文。</p>
</li>
<li><p><strong>FIN_WAIT_2</strong>：在 <strong>FIN_WAIT_2</strong> 之后， 当对方回应 ACK 报文之后，进入该状态。</p>
</li>
<li><p><strong>TIME_WAIT</strong>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。</p>
</li>
<li><p><strong>CLOSING</strong>：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。</p>
</li>
<li><p><strong>CLOSE_WAIT</strong>：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。</p>
</li>
<li><p><strong>LAST_ACK</strong>：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。</p>
</li>
<li><p><strong>CLOSED</strong>：当收到 ACK 保温后，就可以进入 CLOSED 状态了。</p>
</li>
</ul>
<h2><span id="tcp-可靠性">TCP 可靠性 </span></h2><p>TCP 是一种提供可靠性交付的协议。<br> 也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：</p>
<ol>
<li>滑动窗口</li>
<li>超时重传</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ol>
<p>下面来分别讲一下这几种技术的实现原理。</p>
<h3><span id="超时重传">超时重传 </span></h3><h4><span id="重传时机"> 重传时机</span></h4><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>
<ol>
<li>数据包中途丢失；</li>
<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>
<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>
</ol>
<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。</p>
<h4><span id="重传算法">重传算法 </span></h4><h5><span id="rto-retransmission-time-out-重传超时时间">RTO (Retransmission Time-Out) 重传超时时间</span></h5><p> 指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。</p>
<p>RTO 的设置对于重传非常重要：</p>
<ol>
<li>设长了，重发就慢，没有效率，性能差；</li>
<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ol>
<h5><span id="rtt-round-trip-time-连接往返时间">RTT (Round Trip Time) 连接往返时间 </span></h5><p> 指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。</p>
<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href="https://tools.ietf.org/html/rfc793">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609"><code>tcp_rtt_estimator</code></a>）。</p>
<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。</p>
<h5><span id="jacobson-karels-算法">Jacobson / Karels 算法 </span></h5><p>1988 年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="https://tools.ietf.org/html/rfc2988">RFC6298</a>）。<br> 其计算公式：</p>
<blockquote>
<p>SRTT = SRTT + α (RTT – SRTT) —— 计算平滑 RTT</p>
<p>DevRTT = (1-β) <em>DevRTT + β</em> (| RTT - SRTT |) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>
<p>RTO= µ <em>SRTT + ∂</em> DevRTT</p>
</blockquote>
<p>其中：</p>
<ul>
<li><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在 Linux 下，<code>α = 0.125，β = 0.25， μ = 1，∂ = 4</code>；</li>
<li>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</li>
<li>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</li>
</ul>
<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>
<h3><span id="拥塞控制">拥塞控制 </span></h3><h4><span id="慢启动slow-start-与-拥塞避免congestion-avoidance"> 慢启动（Slow Start） 与 拥塞避免（Congestion Avoidance）</span></h4><h4><span id="快速重传fast-retransmit-与-快速恢复fast-recovery">快速重传（Fast Retransmit） 与 快速恢复（Fast Recovery）</span></h4><h3><span id="滑动窗口-sliding-window">滑动窗口 Sliding Window</span></h3><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。</p>
<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p>
<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。</p>
<h4><span id="发送窗口">发送窗口 </span></h4><p> 大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。</p>
<p>下图是发送窗口的示意图：</p>
<p>对于发送窗口，在缓存内的数据有四种状态：</p>
<ul>
<li>#1 已发送，并得到接收方 ACK 确认；</li>
<li>#2 已发送，但还未收到接收方 ACK；</li>
<li>#3 未发送，但接收方允许发送，接收方还有空间</li>
<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>
</ul>
<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。</p>
<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。</p>
<h4><span id="接收窗口">接收窗口 </span></h4><p> 大小取决于应用、系统、硬件的限制。</p>
<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：</p>
<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>
<ul>
<li>已接收已确认；</li>
<li>未接收，准备接收；</li>
<li>未接收，并未准备接收；</li>
</ul>
<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。</p>
<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。</p>
<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。</p>
<h2><span id="网络编程接口-socket">网络编程接口 - Socket</span></h2><p>我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？ socket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。 socket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。</p>
<p>使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：<strong>UNIX BSD 的套接字接口（Socket Interfaces）</strong> 以此来实现网络进程之间的通信。 就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，<strong>一切皆 socket</strong></p>
<h3><span id="套接字接口-socket-interfaces">套接字接口 Socket Interfaces</span></h3><p>套接字接口是一组函数，由操作系统提供，用以创建网络应用。 大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。</p>
<blockquote>
<p><strong>套接字接口的起源</strong> 套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。 伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。 这在因特网的历史成为了一个重大事件。 —— 《深入理解计算机系统》</p>
</blockquote>
<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。 从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。 普通文件的打开操作返回一个文件描述字，而 <code>socket()</code> 用于创建一个 socket 描述符，唯一标识一个 socket。 这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。</p>
<p>常用的函数有：</p>
<ul>
<li><code>socket()</code></li>
<li><code>bind()</code></li>
<li><code>listen()</code></li>
<li><code>connect()</code></li>
<li><code>accept()</code></li>
<li><code>write()</code></li>
<li><code>read()</code></li>
<li><code>close()</code></li>
</ul>
<h3><span id="socket-的交互流程">Socket 的交互流程</span></h3><p><img src="/Users/maywzh/Library/Application Support/typora-user-images/image-20181016181108554.png" alt="image-20181016181108554"></p>
<p>图中展示了 TCP 协议的 socket 交互流程，描述如下：</p>
<ol>
<li>服务器根据地址类型、socket 类型、以及协议来创建 socket。</li>
<li>服务器为 socket 绑定 IP 地址和端口号。</li>
<li>服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。</li>
<li>客户端创建 socket。</li>
<li>客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。</li>
<li>服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。</li>
<li>客户端连接成功，向服务器发送连接状态信息。</li>
<li>服务器 accept() 方法返回，连接成功。</li>
<li>服务器和客户端通过网络 I/O 函数进行数据的传输。</li>
<li>客户端关闭 socket。</li>
<li>服务器关闭 socket。</li>
</ol>
<p>这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。</p>
<p>下面详细讲一下 socket 的各函数。</p>
<h3><span id="socket-接口">Socket 接口</span></h3><p>socket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。</p>
<h4><span id="socket-函数">socket 函数 </span></h4><p> 该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。 如何完成打开套接字的工作，取决于我们是客户端还是服务器。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><ul>
<li><p><strong>domain</strong>: 协议域，决定了 socket 的地址类型，在通信中必须采用对应的地址。 常用的协议族有：<code>AF_INET</code>（ipv4 地址与端口号的组合）、<code>AF_INET6</code>（ipv6 地址与端口号的组合）、<code>AF_LOCAL</code>（绝对路径名作为地址）。 该值的常量定义在 <code>sys/socket.h</code> 文件中。</p>
</li>
<li><p><strong>type</strong>: 指定 socket 类型。 常用的类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等。 其中 <code>SOCK_STREAM</code> 表示提供面向连接的稳定数据传输，即 TCP 协议。 该值的常量定义在 <code>sys/socket.h</code> 文件中。</p>
</li>
<li><p><strong>protocol</strong>: 指定协议。 常用的协议有：<code>IPPROTO_TCP</code>（TCP 协议）、<code>IPPTOTO_UDP</code>（UDP 协议）、<code>IPPROTO_SCTP</code>（STCP 协议）。 当值位 0 时，会自动选择 <code>type</code> 类型对应的默认协议。</p>
</li>
</ul>
<h4><span id="bind-函数">bind 函数 </span></h4><p> 由服务端调用，把一个地址族中的特定地址和 socket 联系起来。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>

<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><p><strong>sockfd</strong>: 即 socket 描述字，由 socket() 函数创建。</p>
<p><strong>*addr</strong>： 一个 <code>const struct sockaddr</code> 指针，指向要绑定给 <code>sockfd</code> 的协议地址。 这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 <code>sockaddr_in</code>，ipv6 对应 <code>sockaddr_in6</code>. 这几个结构体在使用的时候，都可以强制转换成 <code>sockaddr</code>。 下面是这几个结构体对应的所在的头文件：</p>
<ol>
<li><code>sockaddr</code>： <code>sys/socket.h</code></li>
<li><code>sockaddr_in</code>： <code>netinet/in.h</code></li>
<li><code>sockaddr_in6</code>： <code>netinet6/in.h</code></li>
</ol>
<blockquote>
<p>_in 后缀意义：互联网络 (internet) 的缩写，而不是输入 (input) 的缩写。</p>
</blockquote>
<h4><span id="listen-函数">listen 函数 </span></h4><p> 服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。 在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><ul>
<li><p><strong>sockfd</strong>: 即 socket 描述字，由 socket() 函数创建。</p>
</li>
<li><p><strong>backlog</strong>: 指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。</p>
</li>
</ul>
<h4><span id="connect-函数">connect 函数 </span></h4><p> 由客户端调用，与目的服务器的套接字建立一个连接。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> clientfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><ul>
<li><p><strong>clientfd</strong>: 目的服务器的 socket 描述符</p>
</li>
<li><p><strong>*addr</strong>: 一个 <code>const struct sockaddr</code> 指针，包含了目的服务器 IP 和端口。</p>
</li>
<li><p><strong>addrlen</strong>： 协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>;</p>
</li>
</ul>
<h4><span id="accept-函数">accept 函数 </span></h4><p> 服务器调用，等待来自客户端的连接请求。 当客户端连接，accept 函数会在 <code>addr</code> 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">indclude</span> <span class="token expression"><span class="token operator">&lt;</span>sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h<span class="token operator">></span></span></span>
<span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><ul>
<li><p><strong>listenfd</strong>: 服务器的 socket 描述字，由 socket() 函数创建。</p>
</li>
<li><p><strong>*addr</strong>: 一个 <code>const struct sockaddr</code> 指针，用来存放提出连接请求客户端的主机的信息</p>
</li>
<li><p><strong>addrlen</strong>: 协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>。</p>
</li>
</ul>
<h4><span id="close-函数">close 函数 </span></h4><p> 在数据传输完成之后，手动关闭连接。</p>
<h5><span id="函数原型">函数原型</span></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5><span id="参数说明">参数说明</span></h5><ul>
<li><strong>fd</strong>: 需要关闭的连接 socket 描述符</li>
</ul>
<h4><span id="网络-io-函数">网络 I/O 函数 </span></h4><p> 当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。 网络 I/O 操作有下面几组：</p>
<ol>
<li><code>read()/write()</code></li>
<li><code>recv()/send()</code></li>
<li><code>readv()/writev()</code></li>
<li><code>recvmsg()/sendmsg()</code></li>
<li><code>recvfrom()/sendto()</code></li>
</ol>
<p>最常用的是 read()/write() 他们的原型是：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。</p>
<h3><span id="实验-一个简单-tcp-通信程序">实验 - 一个简单 TCP 通信程序 </span></h3><h4><span id="服务端"> 服务端</span></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// socket_server.cpp</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAXLINE <span class="token number">4096</span> </span><span class="token comment">// 4 * 1024</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> <span class="token comment">// 监听端口的 socket 描述符</span>
        connfd<span class="token punctuation">;</span>   <span class="token comment">// 连接端 socket 描述符</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buff<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token comment">// 创建 socket，并且进行错误处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create socket error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 初始化 sockaddr_in 数据结构</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 绑定 socket 和 端口</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bind socket error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 监听连接</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"listen socket error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"====== Waiting for client's request======\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 持续接收客户端的连接请求</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"accept socket error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        n <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buff<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"recv msg from client: %s\n"</span><span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="客户端">客户端</span></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// socket_client.cpp</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAXLINE <span class="token number">4096</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
    <span class="token keyword">char</span> recvline<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sendline<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage: ./client &lt;ipaddress>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 创建 socket 描述符</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create socket error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 初始化目标服务器数据结构</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从参数中读取 IP 地址</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inet_pton error for %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 连接目标服务器，并和 sockfd 联系起来。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connect error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send msg to server: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 从标准输入流中读取信息</span>
    <span class="token function">fgets</span><span class="token punctuation">(</span>sendline<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 通过 sockfd，向目标服务器发送信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> sendline<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sendline<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send msg error: %s(errno: %d)\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 数据传输完毕，关闭 socket 连接</span>
    <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="run">Run</span></h4><p>首先创建 <code>makefile</code> 文件</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRCDIR<span class="token operator">=</span>./src
BINDIR<span class="token operator">=</span>./bin
TMPDIR<span class="token operator">=</span>./tmp
<span class="token comment"># VPATH=$(SRCDIR):$(TMPDIR)</span>
SRC<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCDIR<span class="token punctuation">)</span>/*.cpp<span class="token punctuation">)</span>
BIN<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCDIR<span class="token punctuation">)</span>/%.cpp, <span class="token variable">$</span><span class="token punctuation">(</span>BINDIR<span class="token punctuation">)</span>/%, <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>
TMP<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCDIR<span class="token punctuation">)</span>/%.cpp, <span class="token variable">$</span><span class="token punctuation">(</span>TMPDIR<span class="token punctuation">)</span>/%.o, <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># SHARE=--share</span>
<span class="token comment"># CFLAG= -Wall -I../inc</span>
<span class="token comment"># LFLAG=-L../lib -ldynamic_test -lstatic_test</span>
CC<span class="token operator">=</span>gcc
CPP<span class="token operator">=</span>g++
AR<span class="token operator">=</span>ar -cr

CO<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CPP<span class="token punctuation">)</span>
<span class="token comment"># 用静态模式来做</span>
<span class="token builtin">.PHONY</span><span class="token punctuation">:</span>clean all
<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span>
<span class="token symbol"><span class="token variable">$</span>(BIN)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BINDIR<span class="token punctuation">)</span>/% <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TMPDIR<span class="token punctuation">)</span>/%.o
	<span class="token variable">$</span><span class="token punctuation">(</span>CO<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token symbol"><span class="token variable">$</span>(TMP)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TMPDIR<span class="token punctuation">)</span>/%.o <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCDIR<span class="token punctuation">)</span>/%.cpp
	<span class="token variable">$</span><span class="token punctuation">(</span>CO<span class="token punctuation">)</span> -c  <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token symbol">clean</span><span class="token punctuation">:</span>all
	rm <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TMP<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后使用命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>会生成两个可执行文件：</p>
<ol>
<li><code>socket_server</code></li>
<li><code>socket_client</code></li>
</ol>
<p>分别打开两个终端，运行：</p>
<ol>
<li><code>./socket_server</code></li>
<li><code>./socket_client 127.0.0.1</code></li>
</ol>
<p>然后在 <code>socket_client</code> 中键入发送内容，可以再 <code>socket_server</code> 接收到同样的信息。</p>
<h2><span id="对比-udp">对比 UDP</span></h2><p>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。</p>
<p>而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。</p>
<p>简单来说就是：</p>
<p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p>
<p><strong>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></p>
<h3><span id="udp-概述">UDP 概述</span></h3><p>UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。</p>
<p><strong>UDP 的主要特点是：</strong></p>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<p><strong>UDP 的常用场景：</strong></p>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h3><span id="udp-报文结构">UDP 报文结构 </span></h3><p>UDP 数据报分为数据字段和首部字段。<br> 首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>
<h3><span id="udp-如何进行校验和">UDP 如何进行校验和 </span></h3><h4><span id="伪首部"> 伪首部 </span></h4><p>UDP 数据报首部中检验和的计算方法比较特殊。<br> 在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。<br>伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。</p>
<p><strong>伪首部个字段意义</strong>：</p>
<ol>
<li>第一字段，源 IP 地址</li>
<li>第二字段，目的 IP 地址</li>
<li>第三字段，字段全 0</li>
<li>第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17</li>
<li>第五字段，UDP 用户数据报的长度</li>
</ol>
<h4><span id="校验和计算方法">校验和计算方法 </span></h4><p> 校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：</p>
<p><strong>二进制反码求和运算</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> + <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">1</span> + <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0</span> + <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">1</span> + <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。</p>
<p><strong>检验和计算过程</strong></p>
<ol>
<li>把首部的检验和字段设置为全 0</li>
<li>把伪首部以及数据段看成是许多 16 位的字串接起来。</li>
<li>若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。</li>
<li>通过二进制反码运算，计算出 16 位字的和。<ol>
<li>让第一行和第二行做二进制反码运算。</li>
<li>将第一行和第二行的结果与第三行做二进制反码计算，以此类推。</li>
</ol>
</li>
<li>最后运算结果取反，得到校验和。</li>
<li>把计算出来的校验和值，填入首部校验和字段。</li>
</ol>
<p>接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。</p>
<p>可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。</p>
<p><strong>一个校验和例子</strong> </p>
<p>假设一个 UDP 数据报：</p>
<p>各字段以二进制表示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1001</span> <span class="token number">1001</span> 0001 0011 // 伪首部源 IP 地址前 16 位，值：153.19
0000 <span class="token number">1000</span> 0110 <span class="token number">1000</span> // 伪首部源 IP 地址后 16 位，值：8.104
<span class="token number">1010</span> <span class="token number">1011</span> 0000 0011 // 伪首部目的 IP 地址前 16 位，值：171.3
0000 <span class="token number">1110</span> 0000 <span class="token number">1011</span> // 伪首部目的 IP 地址后 16 位，值：14.11
0000 0000 0001 0001 // 伪首部 UDP 协议字段代表号，值：17
0000 0000 0000 <span class="token number">1111</span> // 伪首部 UDP 长度字段，值：15
0000 0100 0011 <span class="token number">1111</span> //UDP 头部源 IP 地址对应的进程端口号，值：1087
0000 0000 0000 <span class="token number">1101</span> //UDP 头部目的 IP 地址对应的进程端口号，值：13
0000 0000 0000 <span class="token number">1111</span> //UDP 头部 UDP 长度字段，值：15
0000 0000 0000 0000 //UDP 头部 UDP 检验和，值：0
0101 0100 0100 0101 // 数据字段
0101 0011 0101 0100 // 数据字段
0100 <span class="token number">1001</span> 0100 <span class="token number">1110</span> // 数据字段
0100 0111 0000 0000 // 数据字段 + 填充 0 字段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照二进制反码运算求和，结果：<code>10010110 11101101</code><br>结果求反码得出校验和：<code>01101001 00010010</code></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 面试题解答</title>
    <url>/2017/04/03/Redis/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<p>对常见 Redis 面试题做个记录。</p>
<a id="more"></a>
<h2><span id="概念题">概念题 </span></h2><h3><span id="什么是-redis"> 什么是 Redis</span></h3><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>
<h3><span id="redis-有哪些优缺点">Redis 有哪些优缺点 </span></h3><p> 优点</p>
<ul>
<li>读写性能优异， Redis 能读的速度是 110000 次 /s，写的速度是 81000 次 /s。</li>
<li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li>
<li>支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h3><span id="为什么要用-redis-为什么要用缓存">为什么要用 Redis / 为什么要用缓存 </span></h3><p> 主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS02N2YxOGVmY2FmZTQ2NjlhLmpwZw?x-oss-process=image/format,png" alt="img"></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS0wOWIxZDI3OWEwNWVmNWJjLmpwZw?x-oss-process=image/format,png" alt="img"></p>
<h3><span id="为什么要用-redis-而不用-mapguava-做缓存">为什么要用 Redis 而不用 map/guava 做缓存?</span></h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。</p>
<h3><span id="redis-为什么这么快">Redis 为什么这么快</span></h3><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<h2><span id="数据类型">数据类型</span></h2><h3><span id="redis-有哪些数据类型">Redis 有哪些数据类型</span></h3><p>Redis 主要有 5 种数据类型，包括 String，List，Set，Zset，Hash，满足大部分的使用要求</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td>
<td>做简单的键值对缓存</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td>
<td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td>
<td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td>
<td>结构化的数据，比如一个对象</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td>
<td>去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="redis-的应用场景">Redis 的应用场景 </span></h3><p><strong> 总结一</strong></p>
<p>计数器</p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p>缓存</p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p>会话缓存</p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p>全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>查找表</p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p>消息队列(发布 / 订阅功能)</p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p>分布式锁实现</p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p>其它</p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<p><strong>总结二</strong></p>
<p>Redis 相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<p>数据类型说明 string 字符串，最简单的 k-v 存储 hashhash 格式，value 为 field 和 value，适合 ID-Detail 这样的场景。list 简单的 list，顺序列表，支持首位或者末尾插入数据 set 无序 list，查找速度快，适合交集、并集、差集处理 sorted set 有序的 set</p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p>
<p>string——适合最简单的 k-v 存储，类似于 memcached 的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p>
<p>hash——一般 key 为 ID 或者唯一标示，value 对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p>
<p>list——因为 list 是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为 list 是有序的，适合根据写入的时间来排序，如：最新的<em>*</em>，消息队列等。</p>
<p>set——可以简单的理解为 ID-List 的模式，如微博中一个人有哪些好友，set 最牛的地方在于，可以对两个 set 提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p>
<p>Sorted Set——是 set 的增强版本，增加了一个 score 参数，自动会根据 score 的值进行排序。比较适合类似于 top 10 等不根据插入的时间来排序的数据。</p>
<p>如上所述，虽然 Redis 不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用 Redis 的性能。</p>
<h2><span id="持久化">持久化 </span></h2><h3><span id="什么是-redis-持久化"> 什么是 Redis 持久化？</span></h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<h3><span id="redis-的持久化机制是什么各自的优缺点">Redis 的持久化机制是什么？各自的优缺点？</span></h3><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p>RDB：是 Redis DataBase 缩写快照</p>
<p>RDB 是 Redis 默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为 dump.rdb。通过配置文件中的 save 参数来定义快照的周期。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4. 相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<p>AOF：持久化</p>
<p>AOF 持久化(即 Append Only File 持久化)，则是将 Redis 执行的每次写命令记录到单独的日志文件中，当重启 Redis 会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复 Redis 会优先选择 AOF 恢复。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p>优缺点是什么？</p>
<ul>
<li>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</li>
<li>AOF 比 RDB 更安全也更大</li>
<li>RDB 性能比 AOF 好</li>
<li>如果两个都配了优先加载 AOF</li>
</ul>
<h3><span id="如何选择合适的持久化方式">如何选择合适的持久化方式</span></h3><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h3><span id="redis-持久化数据和缓存怎么做扩容">Redis 持久化数据和缓存怎么做扩容？</span></h3><ul>
<li>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</li>
</ul>
<h2><span id="过期键的删除策略">过期键的删除策略 </span></h2><h3><span id="redis-的过期键的删除策略">Redis 的过期键的删除策略</span></h3><p> 我们都知道，Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。<br>(expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)</li>
</ul>
<p>Redis 中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3><span id="redis-key-的过期时间和永久有效分别怎么设置">Redis key 的过期时间和永久有效分别怎么设置？</span></h3><p>EXPIRE 和 PERSIST 命令。</p>
<h3><span id="我们知道通过-expire-来设置-key-的过期时间那么对过期的数据怎么处理呢">我们知道通过 expire 来设置 key 的过期时间，那么对过期的数据怎么处理呢?</span></h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2><span id="内存相关">内存相关</span></h2><h3><span id="mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据">MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据</span></h3><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3><span id="redis-的内存淘汰策略有哪些">Redis 的内存淘汰策略有哪些</span></h3><p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。（这个是 <strong> 最常用 </strong> 的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li>
</ul>
<p><strong>总结</strong></p>
<p>Redis 的内存淘汰策略的选取并不会影响过期的 key 的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3><span id="redis-主要消耗什么物理资源">Redis 主要消耗什么物理资源？</span></h3><p>内存。</p>
<h3><span id="redis-的内存用完了会发生什么">Redis 的内存用完了会发生什么？</span></h3><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p>
<h3><span id="redis-如何做内存优化">Redis 如何做内存优化？</span></h3><p>可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2><span id="线程模型">线程模型</span></h2><h3><span id="redis-线程模型">Redis 线程模型</span></h3><p>Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为 4 部分：多个套接字、IO 多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以 Redis 才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<p>参考：<a href="https://www.cnblogs.com/barrywxx/p/8570821.html">https://www.cnblogs.com/barrywxx/p/8570821.html</a></p>
<h2><span id="事务">事务 </span></h2><h3><span id="什么是事务"> 什么是事务？</span></h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h3><span id="redis-事务的概念">Redis 事务的概念</span></h3><p>Redis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h3><span id="redis-事务的三个阶段">Redis 事务的三个阶段</span></h3><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队</p>
<h3><span id="redis-事务相关命令">Redis 事务相关命令</span></h3><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的</p>
<p>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li>
<li><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</li>
<li><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li>
</ol>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</li>
<li>MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH 命令可以取消 watch 对所有 key 的监控。</li>
</ul>
<h3><span id="事务管理acid概述">事务管理（ACID）概述 </span></h3><p> 原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</p>
<p>隔离性（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p><strong>Redis 的事务总是具有 ACID 中的一致性和隔离性 </strong>，其他特性是不支持的。当服务器运行在<em>AOF</em> 持久化模式下，并且 appendfsync 选项的值为 always 时，事务也具有耐久性。</p>
<h3><span id="redis-事务支持隔离性吗">Redis 事务支持隔离性吗</span></h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h3><span id="redis-事务保证原子性吗支持回滚吗">Redis 事务保证原子性吗，支持回滚吗 </span></h3><p>Redis 中，单条命令是原子性执行的，但<strong> 事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3><span id="redis-事务其他实现">Redis 事务其他实现</span></h3><ul>
<li>基于 Lua 脚本，Redis 可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h2><span id="集群方案">集群方案 </span></h2><h3><span id="哨兵模式"> 哨兵模式</span></h3><p><img src="https://img-blog.csdnimg.cn/20200115174006561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>哨兵的介绍</strong></p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是 <strong> 不保证数据零丢失 </strong> 的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3><span id="官方-redis-cluster-方案服务端路由查询"> 官方 Redis Cluster 方案(服务端路由查询)</span></h3><p><img src="https://img-blog.csdnimg.cn/20200115173621637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</p>
<p><strong>简介</strong></p>
<p>Redis Cluster 是一种服务端 Sharding 技术，3.0 版本开始正式提供。Redis Cluster 并没有使用一致性 hash，而是采用 slot(槽)的概念，一共分成 16384 个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽 (哈希值) 区间的数据，默认分配了 16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>节点间的内部通信机制</strong></p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备 Sentinel 的监控和自动 Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连 redis 服务，免去了 proxy 代理的损耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用 0 号数据库</li>
<li>不支持批量操作(pipeline 管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<h3><span id="基于客户端分配">基于客户端分配</span></h3><p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>简介</strong></p>
<p>Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的多 Redis 实例集群方法。其主要思想是采用哈希算法将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key 会映射到特定的 Redis 节点上。Java redis 客户端驱动 jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及结合缓存池的 ShardedJedisPool</p>
<p><strong>优点</strong></p>
<p>优势在于非常简单，服务端的 Redis 实例彼此独立，相互无关联，每个 Redis 实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p>
<p><strong>缺点</strong></p>
<ul>
<li>由于 sharding 处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端 sharding 不支持动态增删节点。服务端 Redis 实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h3><span id="基于代理服务器分片">基于代理服务器分片</span></h3><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>简介</strong></p>
<p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端 Redis 实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter 开源的 Twemproxy</li>
<li>豌豆荚开源的 Codis</li>
</ul>
<h3><span id="redis-主从架构">Redis 主从架构 </span></h3><p> 单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑 <strong> 读高并发 </strong> 的。因此架构做成主从 (master-slave) 架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的 <strong> 读请求全部走从节点 </strong>。这样也可以很轻松实现水平扩容，<strong> 支撑读高并发</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave"></p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p><strong>redis replication 的核心机制</strong></p>
<ul>
<li>redis 采用 <strong> 异步方式 </strong> 复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须 <strong> 开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能 <strong> 确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p><strong>redis 主从复制的核心原理</strong></p>
<p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先 <strong> 写入本地磁盘，然后再从本地磁盘加载到内存 </strong> 中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200115180337645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave-replication"></p>
<p><strong>过程原理</strong></p>
<ol>
<li>当从库和主库建立 MS 关系后，会向主数据库发送 SYNC 命令</li>
<li>主库接收到 SYNC 命令后会开始在后台保存快照(RDB 持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主 Redis 会将快照文件和所有缓存的写命令发送给从 Redis</li>
<li>从 Redis 接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主 Redis 每当接收到写命令时就会将命令发送从 Redis，从而保证数据的一致</li>
</ol>
<p><strong>缺点</strong></p>
<p>所有的 slave 节点数据的复制和同步都由 master 节点来处理，会照成 master 节点压力太大，使用主从从结构来解决</p>
<h3><span id="redis-集群的主从复制模型是怎样的">Redis 集群的主从复制模型是怎样的？</span></h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有 N-1 个复制品</p>
<h3><span id="生产环境中的-redis-是怎么部署的">生产环境中的 redis 是怎么部署的？</span></h3><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求 /s。</p>
<p>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是 10g 内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h3><span id="说说-redis-哈希槽的概念">说说 Redis 哈希槽的概念？</span></h3><p>Redis 集群没有使用一致性 hash, 而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h3><span id="redis-集群会有写操作丢失吗为什么">Redis 集群会有写操作丢失吗？为什么？</span></h3><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h3><span id="redis-集群之间是如何复制的">Redis 集群之间是如何复制的？</span></h3><p>异步复制</p>
<h3><span id="redis-集群最大节点个数是多少">Redis 集群最大节点个数是多少？</span></h3><p>16384 个</p>
<h3><span id="redis-集群如何选择数据库">Redis 集群如何选择数据库？</span></h3><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<h2><span id="分区">分区 </span></h2><h3><span id="redis-是单线程的如何提高多核-cpu-的利用率">Redis 是单线程的，如何提高多核 CPU 的利用率？</span></h3><p> 可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）。</p>
<h3><span id="为什么要做-redis-分区">为什么要做 Redis 分区？</span></h3><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升，Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h3><span id="你知道有哪些-redis-分区实现方案">你知道有哪些 Redis 分区实现方案？</span></h3><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis 和 memcached 的一种代理实现就是 Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到正确的 redis 节点。</li>
</ul>
<h3><span id="redis-分区有什么缺点">Redis 分区有什么缺点？</span></h3><ul>
<li>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个 key, 则不能使用 Redis 事务.</li>
<li>分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集 RDB / AOF 文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h2><span id="分布式问题">分布式问题</span></h2><h3><span id="redis-实现分布式锁">Redis 实现分布式锁</span></h3><p>Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对 Redis 的连接并不存在竞争关系 Redis 中可以使用 SETNX 命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt="img"></p>
<p>使用 SETNX 完成同步锁的流程及事项如下：</p>
<p>使用 SETNX 命令获取锁，若返回 0（key 已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程 / 进程调用 SETNX 命令总是返回 0 而进入死锁状态，需要为该 key 设置一个“合理”的过期时间</p>
<p>释放锁，使用 DEL 命令将锁数据删除</p>
<h3><span id="如何解决-redis-的并发竞争-key-问题">如何解决 Redis 的并发竞争 Key 问题 </span></h3><p> 所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于 zookeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推 Zookeeper。</p>
<p>参考：<a href="https://www.jianshu.com/p/8bddd381de06">https://www.jianshu.com/p/8bddd381de06</a></p>
<h3><span id="分布式-redis-是前期做还是后期规模上来了再做好为什么">分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</span></h3><p>既然 Redis 是如此的轻量（单实例只使用 1M 内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
<h3><span id="什么是-redlock">什么是 RedLock</span></h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2><span id="缓存异常">缓存异常 </span></h2><h3><span id="缓存雪崩"> 缓存雪崩 </span></h3><p><strong> 缓存雪崩 </strong> 是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3><span id="缓存穿透">缓存穿透 </span></h3><p><strong> 缓存穿透 </strong> 是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<p><strong>附加</strong></p>
<p>对于空间的利用到达了一种极致，那就是 Bitmap 和布隆过滤器 (Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br> 缺点是，Bitmap 对于每个元素只能记录 1bit 信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）</p>
<p>就是引入了 k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter 算法的核心思想就是利用多个不同的 Hash 函数来解决“冲突”。<br>Hash 存在一个冲突（碰撞）的问题，用同一个 Hash 得到的两个 URL 的值有可能相同。为了减少冲突，我们可以多引入几个 Hash，如果通过其中的一个 Hash 值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的 Hash 函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是 Bloom-Filter 的基本思想。<br>Bloom-Filter 一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3><span id="缓存击穿">缓存击穿 </span></h3><p><strong> 缓存击穿 </strong> 是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h3><span id="缓存预热">缓存预热 </span></h3><p><strong> 缓存预热 </strong> 就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p><strong>解决方案</strong></p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3><span id="缓存降级">缓存降级 </span></h3><p> 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p><strong>缓存降级 </strong> 的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在 95~100% 之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止 Redis 服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3><span id="热点数据和冷数据">热点数据和冷数据 </span></h3><p> 热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。</p>
<h3><span id="缓存热点-key">缓存热点 key</span></h3><p>缓存中的一个 Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果 KEY 不存在，就加锁，然后查 DB 入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入 DB 查询</p>
<h2><span id="常用工具">常用工具</span></h2><h3><span id="redis-支持的-java-客户端都有哪些官方推荐用哪个">Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</span></h3><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>
<h3><span id="redis-和-redisson-有什么关系">Redis 和 Redisson 有什么关系？</span></h3><p>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h3><span id="jedis-与-redisson-对比有什么优缺点">Jedis 与 Redisson 对比有什么优缺点？</span></h3><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h2><span id="其他问题">其他问题 </span></h2><h3><span id="redis-与-memcached-的区别">Redis 与 Memcached 的区别</span></h3><p> 两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比参数</th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>1. 支持内存 2. 非关系型数据库</td>
<td>1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td><strong>数据存储类型</strong></td>
<td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称 ZSet】</td>
<td>1. 文本型 2. 二进制类型</td>
</tr>
<tr>
<td>查询【操作】类型</td>
<td>1. 批量操作 2. 事务支持 3. 每个类型不同的 CRUD</td>
<td>1. 常用的 CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td>附加功能</td>
<td>1. 发布 / 订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua 脚本】</td>
<td>1. 多线程服务支持</td>
</tr>
<tr>
<td><strong>网络 IO 模型</strong></td>
<td>1. 单线程的多路 IO 复用模型</td>
<td>1. 多线程，非阻塞 IO 模式</td>
</tr>
<tr>
<td>事件库</td>
<td>自封转简易事件库 AeEvent</td>
<td>贵族血统的 LibEvent 事件库</td>
</tr>
<tr>
<td><strong>持久化支持</strong></td>
<td>1. RDB 2. AOF</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>集群模式</strong></td>
<td>原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td>内存管理机制</td>
<td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td>Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>复杂数据结构，有持久化，高可用需求，value 存储内容较大</td>
<td>纯 key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody>
</table>
</div>
<p>(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis 的速度比 memcached 快很多</p>
<p>(3) redis 可以持久化其数据</p>
<h3><span id="如何保证缓存与数据库双写时的数据一致性">如何保证缓存与数据库双写时的数据一致性？</span></h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存 + 数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是 <strong> 先更新数据库，然后再删除缓存。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>问题场景</th>
<th>描述</th>
<th>解决</th>
</tr>
</thead>
<tbody>
<tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="redis-常见性能问题和解决方案">Redis 常见性能问题和解决方案？</span></h3><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h3><span id="redis-官方为什么不提供-windows-版本">Redis 官方为什么不提供 Windows 版本？</span></h3><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p>
<h3><span id="一个字符串类型的值能存储最大容量是多少">一个字符串类型的值能存储最大容量是多少？</span></h3><p>512M</p>
<h3><span id="redis-如何做大量数据插入">Redis 如何做大量数据插入？</span></h3><p>Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<h3><span id="假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如果将它们全部找出来">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></h3><p>使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h3><span id="使用-redis-做过异步队列吗是如何实现的">使用 Redis 做过异步队列吗，是如何实现的 </span></h3><p> 使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h3><span id="redis-如何实现延时队列">Redis 如何实现延时队列 </span></h3><p> 使用 sortedset，使用时间戳做 score, 消息内容作为 key, 调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。</p>
<h3><span id="redis-回收进程如何工作的">Redis 回收进程如何工作的？</span></h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis 检查内存使用情况，如果大于 maxmemory 的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3><span id="redis-回收使用的是什么算法">Redis 回收使用的是什么算法？</span></h3><p>LRU 算法</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>编程之并发编程</title>
    <url>/2018/01/28/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在计算机最早期的时候，没有操作系统，执行程序只需要一种方式，那就是从头到尾依次执行。任何资源都会为这个程序服务，在计算机使用某些资源时，其他资源就会空闲，就会存在 <code>浪费资源</code> 的情况。</p>
<p>操作系统的出现为我们的程序带来了 <code>并发性</code>，操作系统使我们的程序能够同时运行多个程序，一个程序就是一个进程，也就相当于同时运行多个进程。</p>
<a id="more"></a>
<h2><span id="操作系统的并发性">操作系统的并发性 </span></h2><p> 操作系统是一个 <code> 并发系统</code>，并发性是操作系统非常重要的特征，操作系统具有同时处理和调度多个程序的能力，比如多个 I/O 设备同时在输入输出；设备 I/O 和 CPU 计算同时进行；内存中同时有多个系统和用户程序被启动交替、穿插地执行。操作系统在协调和分配进程的同时，操作系统也会为不同进程分配不同的资源。</p>
<p>操作系统实现多个程序同时运行解决了单个程序无法做到的问题，主要有下面三点</p>
<ul>
<li><code>资源利用率</code>，我们上面说到，单个进程存在资源浪费的情况，举个例子，当你在为某个文件夹赋予权限的时候，输入程序无法接受外部的输入字符，只有等到权限赋予完毕后才能接受外部输入。总的来讲，就是在等待程序时无法执行其他工作。如果在等待程序时可以运行另一个程序，那么将会大大提高资源的利用率。（资源并不会觉得累）因为它不会划水～</li>
<li><code>公平性</code>，不同的用户和程序都能够使用计算机上的资源。一种高效的运行方式是为不同的程序划分时间片来使用资源，但是有一点需要注意，操作系统可以决定不同进程的优先级。虽然每个进程都有能够公平享有资源的权利，但是当有一个进程释放资源后的同时有一个优先级更高的进程抢夺资源，就会造成优先级低的进程无法获得资源，进而导致进程饥饿。</li>
<li><code>便利性 </code>，单个进程是是不用通信的，通信的本质就是<code> 信息交换 </code>，及时进行信息交换能够避免<code> 信息孤岛 </code>，做重复性的工作；任何并发能做的事情，单进程也能够实现，只不过这种方式效率很低，它是一种<code> 顺序性 </code> 的。</li>
</ul>
<p>但是，顺序编程（也称为 <code> 串行编程 </code>）也不是<code> 一无是处 </code> 的，串行编程的优势在于其 <strong> 直观性和简单性 </strong>，客观来讲，串行编程更适合我们人脑的思考方式，但是我们并不会满足于顺序编程，<strong>we want it more!!!</strong> 。资源利用率、公平性和便利性促使着进程出现的同时，也促使着<code> 线程 </code> 的出现。</p>
<p>关于进程和线程的区别，简单理解就一句话：<strong>进程是一个应用程序，而线程是应用程序中的一条顺序流</strong>。</p>
<p><img src="https://i.loli.net/2020/08/28/9EQ5HDcLPFhydSm.png" alt="img"></p>
<p>进程中会有多个线程来完成一些任务，这些任务有可能相同有可能不同。每个线程都有自己的执行顺序。</p>
<p><img src="https://i.loli.net/2020/08/28/mCoROYJhPqZegNu.png" alt="img"></p>
<p>每个线程都有自己的栈空间，这是线程私有的，还有一些其他线程内部的和线程共享的资源，如下所示。</p>
<blockquote>
<p>在计算机中，一般堆栈指的就是栈，而堆指的才是堆</p>
</blockquote>
<p>线程会共享进程范围内的资源，例如内存和文件句柄，但是每个线程也有自己私有的内容，比如程序计数器、栈以及局部变量。下面汇总了进程和线程共享资源的区别</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c323cd6f49f40ce88ecf01e1c8ca6dd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>线程是一种 <code> 轻量级 </code> 的进程，轻量级体现在线程的创建和销毁要比进程的开销小很多。</p>
<blockquote>
<p>注意：任何比较都是相对的。</p>
</blockquote>
<p>在大多数现代操作系统中，都以线程为基本的调度单位，所以我们的视角着重放在对 <code> 线程 </code> 的探究。</p>
<h2><span id="线程">线程 </span></h2><h3><span id="什么是多线程"> 什么是多线程 </span></h3><p> 多线程意味着你能够在同一个应用程序中运行多个线程，我们知道，指令是在 CPU 中执行的，多线程应用程序就像是具有多个 CPU 在同时执行应用程序的代码。</p>
<p><img src="https://i.loli.net/2020/08/28/UIT3HkbCR1Mv5tg.png" alt="img"></p>
<p>其实这是一种假象，线程数量并不等于 CPU 数量，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行，如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/c9nG1zNHjkoaiwg.png" alt="28f4eee4f9b146b583775f58bd8499b6_tplv-k3u1fbpfcp-zoom-1"></p>
<h3><span id="并发与并行">并发与并行 </span></h3><p><code> 并发 </code> 意味着应用程序会执行多个的任务，但是如果计算机只有一个 CPU 的话，那么应用程序无法同时执行多个的任务，但是应用程序又需要执行多个任务，所以计算机在开始执行下一个任务之前，它并没有完成当前的任务，只是把状态暂存，进行任务切换，CPU 在多个任务之间进行切换，直到任务完成。如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/MLkJm1wf96hjvEq.png" alt="2b9f5d2444564a4892dae6773ed49dfc_tplv-k3u1fbpfcp-zoom-1"></p>
<p><code>并行 </code> 是指应用程序将其任务分解为较小的子任务，这些子任务可以并行处理，例如在多个 CPU 上同时进行。</p>
<p><img src="https://i.loli.net/2020/08/28/6zmK3IGcHRX7Lfd.png" alt="db5307cfa3454ae19626a6b5d0c0720d_tplv-k3u1fbpfcp-zoom-1"></p>
<h3><span id="优势和劣势">优势和劣势 </span></h3><p> 合理使用线程是一门艺术，合理编写一道准确无误的多线程程序更是一门艺术，如果线程使用得当，能够有效的降低程序的开发和维护成本。</p>
<p>Java 很好的在用户空间实现了开发工具包，并在内核空间提供系统调用来支持多线程编程，Java 支持了丰富的类库 <code>java.util.concurrent</code> 和跨平台的 <code> 内存模型</code>，同时也提高了开发人员的门槛，并发一直以来是一个高阶的主题，但是现在，并发也成为了主流开发人员的必备素质。</p>
<p>虽然线程带来的好处很多，但是编写正确的多线程（并发）程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现又诡异的消失，在当你认为没有问题的时候它就出现了，<code>难以定位</code> 是并发程序的一个特征，所以在此基础上你需要有扎实的并发基本功。那么，并发为什么会出现呢？</p>
<h3><span id="并发为什么会出现">并发为什么会出现 </span></h3><p> 计算机世界的快速发展离不开 CPU、内存和 I/O 设备的高速发展，但是这三者一直存在速度差异性问题，我们可以从存储器的层次结构可以看出</p>
<p><img src="https://i.loli.net/2020/08/28/UsuhfLiE3QcKvog.png" alt="1d414061db36482eb05bac3ca3bc686f_tplv-k3u1fbpfcp-zoom-1"></p>
<p>CPU 内部是寄存器的构造，寄存器的访问速度要高于 <code> 高速缓存</code>，高速缓存的访问速度要高于内存，最慢的是磁盘访问。</p>
<p>程序是在内存中执行的，程序里大部分语句都要访问内存，有些还需要访问 I/O 设备，根据漏桶理论来说，程序整体的性能取决于最慢的操作也就是磁盘访问速度。</p>
<p>因为 CPU 速度太快了，所以为了发挥 CPU 的速度优势，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li>CPU 使用缓存来中和和内存的访问速度差异</li>
<li>操作系统提供进程和线程调度，让 CPU 在执行指令的同时分时复用线程，让内存和磁盘不断交互，不同的 <code>CPU 时间片</code> 能够执行不同的任务，从而均衡这三者的差异</li>
<li>编译程序提供优化指令的执行顺序，让缓存能够合理的使用</li>
</ul>
<p>我们在享受这些便利的同时，多线程也为我们带来了挑战，下面我们就来探讨一下并发问题为什么会出现以及多线程的源头是什么。</p>
<h3><span id="线程带来的安全性问题">线程带来的安全性问题 </span></h3><p> 线程安全性是非常复杂的，在没有采用 <code> 同步机制 </code> 的情况下，多个线程中的执行操作往往是不可预测的，这也是多线程带来的挑战之一，下面我们给出一段代码，来看看安全性问题体现在哪</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TSynchronized</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">TSynchronized</span> tSynchronized <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TSynchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> aThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tSynchronized<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> bThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tSynchronized<span class="token punctuation">)</span><span class="token punctuation">;</span>
        aThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i ="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段程序输出后会发现，i 的值每次都不一样，这不符合我们的预测，那么为什么会出现这种情况呢？我们先来分析一下程序的运行过程。</p>
<p><code>TSynchronized</code> 实现了 Runnable 接口，并定义了一个静态变量 <code>i</code>，然后在 <code>increase</code> 方法中每次都增加 i 的值，在其实现的 run 方法中进行循环调用，共执行 1000 次。</p>
<h4><span id="可见性">可见性 </span></h4><p> 在单核 CPU 时代，所有的线程共用一个 CPU，CPU 缓存和内存的一致性问题容易解决，CPU 和 内存之间</p>
<p>如果用图来表示的话我想会是下面这样：</p>
<p><img src="https://i.loli.net/2020/08/28/Dbr51qVywGNipER.png" alt="74cb25a3dc3a4ff8902c7d0088c393e7_tplv-k3u1fbpfcp-zoom-1"></p>
<p>在多核时代，因为有多核的存在，每个核都能够独立的运行一个线程，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。</p>
<p><img src="https://i.loli.net/2020/08/28/fmU13JXVRC6psQN.png" alt="ad95cb50434c4017a4acd6990ab0e03c_tplv-k3u1fbpfcp-zoom-1"></p>
<p>因为 i 是静态变量，没有经过任何线程安全措施的保护，多个线程会并发修改 i 的值，所以我们认为 i 不是线程安全的，导致这种结果的出现是由于 aThread 和 bThread 中读取的 i 值彼此不可见，所以这是由于 <code>可见性</code> 导致的线程安全问题。</p>
<h4><span id="原子性问题">原子性问题 </span></h4><p> 看起来很普通的一段程序却因为两个线程 <code>aThread</code> 和 <code>bThread</code> 交替执行产生了不同的结果。但是根源不是因为创建了两个线程导致的，多线程只是产生线程安全性的必要条件，最终的根源出现在 <code>i++</code> 这个操作上。</p>
<p>这个操作怎么了？这不就是一个给 i 递增的操作吗？也就是 <strong>i++ =&gt; i = i + 1</strong>，这怎么就会产生问题了？</p>
<p>因为 <code>i++</code> 不是一个 <code>原子性</code> 操作，仔细想一下，i++ 其实有三个步骤，读取 i 的值，执行 i + 1 操作，然后把 i + 1 得出的值重新赋给 i（将结果写入内存）。</p>
<p>当两个线程开始运行后，每个线程都会把 i 的值读入到 CPU 缓存中，然后执行 + 1 操作，再把 + 1 之后的值写入内存。因为线程间都有各自的虚拟机栈和程序计数器，他们彼此之间没有数据交换，所以当 aThread 执行 + 1 操作后，会把数据写入到内存，同时 bThread 执行 + 1 操作后，也会把数据写入到内存，因为 CPU 时间片的执行周期是不确定的，所以会出现当 aThread 还没有把数据写入内存时，bThread 就会读取内存中的数据，然后执行 + 1 操作，再写回内存，从而覆盖 i 的值，导致 aThread 所做的努力白费。</p>
<p><img src="https://i.loli.net/2020/08/28/Fdi2vREeJ7bxDHg.png" alt="0d7fc09c26af41e3902b2773cde6901a_tplv-k3u1fbpfcp-zoom-1"></p>
<p>为什么上面的线程切换会出现问题呢？</p>
<p>我们先来考虑一下正常情况下（即不会出现线程安全性问题的情况下）两条线程的执行顺序</p>
<p><img src="https://i.loli.net/2020/08/28/XSxAnutUPsRjozd.png" alt="d7d9c89021a54f668437e2ad8b2212a3_tplv-k3u1fbpfcp-zoom-1"></p>
<p>可以看到，当 aThread 在执行完整个 i++ 的操作后，操作系统对线程进行切换，由 aThread -&gt; bThread，这是最理想的操作，一旦操作系统在任意 <code>读取 / 增加 / 写入</code> 阶段产生线程切换，都会产生线程安全问题。例如如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/QRMcoE1AWSNzbnF.png" alt="e61fc4b52120487ab632722a3b06f280_tplv-k3u1fbpfcp-zoom-1"></p>
<p>最开始的时候，内存中 i = 0，aThread 读取内存中的值并把它读取到自己的寄存器中，执行 +1 操作，此时发生线程切换，bThread 开始执行，读取内存中的值并把它读取到自己的寄存器中，此时发生线程切换，线程切换至 aThread 开始运行，aThread 把自己寄存器的值写回到内存中，此时又发生线程切换，由 aThread -&gt; bThread，线程 bThread 把自己寄存器的值 +1 然后写回内存，写完后内存中的值不是 2 ，而是 1， 内存中的 i 值被覆盖了。</p>
<p>我们上面提到 <code>原子性</code> 这个概念，那么什么是原子性呢？</p>
<blockquote>
<p>并发编程的原子性操作是完全独立于任何其他进程运行的操作，原子操作多用于现代操作系统和并行处理系统中。</p>
<p>原子操作通常在内核中使用，因为内核是操作系统的主要组件。但是，大多数计算机硬件，编译器和库也提供原子性操作。</p>
<p>在加载和存储中，计算机硬件对存储器字进行读取和写入。为了对值进行匹配、增加或者减小操作，一般通过原子操作进行。在原子操作期间，处理器可以在同一数据传输期间完成读取和写入。 这样，其他输入 / 输出机制或处理器无法执行存储器读取或写入任务，直到原子操作完成为止。</p>
</blockquote>
<p>简单来讲，就是 <strong> 原子操作要么全部执行，要么全部不执行</strong>。数据库事务的原子性也是基于这个概念演进的。</p>
<h4><span id="有序性问题">有序性问题 </span></h4><p> 在并发编程中还有带来让人非常头疼的 <code>有序性 </code> 问题，有序性顾名思义就是顺序性，在计算机中指的就是指令的先后执行顺序。一个非常显而易见的例子就是 JVM 中的<code> 类加载</code></p>
<p><img src="https://i.loli.net/2020/08/28/AgvqPchMZydStnG.png" alt="7522eb69ca384c599bc1f2959bc19209_tplv-k3u1fbpfcp-zoom-1"></p>
<p>这是一个 JVM 加载类的过程图，也称为类的生命周期，类从加载到 JVM 到卸载一共会经历五个阶段 <strong>加载、连接、初始化、使用、卸载 </strong>。这五个过程的执行顺序是一定的，但是在连接阶段，也会分为三个过程，即 <strong> 验证、准备、解析</strong> 阶段，这三个阶段的执行顺序不是确定的，通常交叉进行，在一个阶段的执行过程中会激活另一个阶段。</p>
<p>有序性问题一般是编译器带来的，编译器有的时候确实是 <strong>好心办坏事</strong>，它为了优化系统性能，往往更换指令的执行顺序。</p>
<h4><span id="活跃性问题">活跃性问题 </span></h4><p> 多线程还会带来 <code> 活跃性 </code> 问题，如何定义活跃性问题呢？活跃性问题关注的是 <strong>某件事情是否会发生</strong>。</p>
<p><strong>如果一组线程中的每个线程都在等待一个事件的发生，而这个事件只能由该组中正在等待的线程触发，这种情况会导致死锁</strong>。</p>
<p>简单一点来表述一下，就是每个线程都在等待其他线程释放资源，而其他资源也在等待每个线程释放资源，这样没有线程抢先释放自己的资源，这种情况会产生死锁，所有线程都会无限的等待下去。</p>
<p><strong>死锁的必要条件</strong></p>
<p>造成死锁的原因有四个，破坏其中一个即可破坏死锁</p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持占有。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>循环等待：指在发生死锁时，必然存在一个进程对应的环形链。</li>
</ul>
<p>换句话说，死锁线程集合中的每个线程都在等待另一个死锁线程占有的资源。但是由于所有线程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个线程可以被唤醒。</p>
<p>如果说死锁很 <code> 痴情 </code> 的话，那么 <code> 活锁 </code> 用一则成语来表示就是 <code>弄巧成拙</code>。</p>
<p>某些情况下，当线程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p>
<p>现在假想有一对并行的线程用到了两个资源。它们分别尝试获取另一个锁失败后，两个线程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有线程阻塞，但是线程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p>
<p>如果我们期望的事情一直不会发生，就会产生活跃性问题，比如单线程中的无限循环</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在多线程中，比如 aThread 和 bThread 都需要某种资源，aThread 一直占用资源不释放，bThread 一直得不到执行，就会造成活跃性问题，bThread 线程会产生 <code> 饥饿</code>，我们后面会说。</p>
<h4><span id="性能问题">性能问题 </span></h4><p> 与活跃性问题密切相关的是 <code>性能 </code> 问题，如果说活跃性问题关注的是最终的结果，那么性能问题关注的就是造成结果的过程，性能问题有很多方面：比如<strong> 服务时间过长，吞吐率过低，资源消耗过高</strong>，在多线程中这样的问题同样存在。</p>
<p>在多线程中，有一个非常重要的性能因素那就是我们上面提到的 <code>线程切换 </code>，也称为 <code> 上下文切换(Context Switch)</code>，这种操作开销很大。</p>
<blockquote>
<p>在计算机世界中，老外都喜欢用 context 上下文这个词，这个词涵盖的内容很多，包括上下文切换的资源，寄存器的状态、程序计数器等。context switch 一般指的就是这些上下文切换的资源、寄存器状态、程序计数器的变化等。</p>
</blockquote>
<p>在上下文切换中，会保存和恢复上下文，丢失局部性，把大量的时间消耗在线程切换上而不是线程运行上。</p>
<p>为什么线程切换会开销如此之大呢？线程间的切换会涉及到以下几个步骤</p>
<p><img src="https://i.loli.net/2020/08/28/sdbBQKjY5olEORV.png" alt="6c81b43a91c24533bbcd16ccaf63d5fe_tplv-k3u1fbpfcp-zoom-1"></p>
<p>将 CPU 从一个线程切换到另一线程涉及挂起当前线程，保存其状态，例如寄存器，然后恢复到要切换的线程的状态，加载新的程序计数器，此时线程切换实际上就已经完成了；此时，CPU 不在执行线程切换代码，进而执行新的和线程关联的代码。</p>
<h3><span id="引起线程切换的几种方式">引起线程切换的几种方式 </span></h3><p> 线程间的切换一般是操作系统层面需要考虑的问题，那么引起线程上下文切换有哪几种方式呢？或者说线程切换有哪几种诱因呢？主要有下面几种引起上下文切换的方式</p>
<ul>
<li>当前正在执行的任务完成，系统的 CPU 正常调度下一个需要运行的线程</li>
<li>当前正在执行的任务遇到 I/O 等阻塞操作，线程调度器挂起此任务，继续调度下一个任务。</li>
<li>多个任务并发抢占锁资源，当前任务没有获得锁资源，被线程调度器挂起，继续调度下一个任务。</li>
<li>用户的代码挂起当前任务，比如线程执行 sleep 方法，让出 CPU。</li>
<li>使用硬件中断的方式引起上下文切换</li>
</ul>
<h2><span id="线程安全性">线程安全性 </span></h2><p> 在 Java 中，要实现线程安全性，必须要正确的使用线程和锁，但是这些只是满足线程安全的一种方式，要编写正确无误的线程安全的代码，其核心就是对状态访问操作进行管理。最重要的就是最 <code>共享 (Shared)</code> 的 和 <code>可变 (Mutable)</code> 的状态。只有共享和可变的变量才会出现问题，私有变量不会出现问题，参考 <code> 程序计数器</code>。</p>
<p>对象的状态可以理解为存储在实例变量或者静态变量中的数据，共享意味着某个变量可以被多个线程同时访问、可变意味着变量在生命周期内会发生变化。一个变量是否是线程安全的，取决于它是否被多个线程访问。要使变量能够被安全访问，必须通过同步机制来对变量进行修饰。</p>
<p>如果不采用同步机制的话，那么就要避免多线程对共享变量的访问，主要有下面两种方式</p>
<ul>
<li>不要在多线程之间共享变量</li>
<li>将共享变量置为不可变的</li>
</ul>
<p>我们说了这么多次线程安全性，那么什么是线程安全性呢？</p>
<h3><span id="什么是线程安全性">什么是线程安全性 </span></h3><p> 多个线程可以同时安全调用的代码称为线程安全的，如果一段代码是安全的，那么这段代码就不存在 <code>竞态条件</code>。仅仅当多个线程共享资源时，才会出现竞态条件。</p>
<p>根据上面的探讨，我们可以得出一个简单的结论：<strong>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的</strong>。</p>
<p>单线程就是一个线程数量为 1 的多线程，单线程一定是线程安全的。读取某个变量的值不会产生安全性问题，因为不管读取多少次，这个变量的值都不会被修改。</p>
<h3><span id="原子性">原子性 </span></h3><p> 我们上面提到了原子性的概念，你可以把 <code> 原子性 </code> 操作想象成为一个 <code> 不可分割 </code> 的整体，它的结果只有两种，要么全部执行，要么全部回滚。你可以把原子性认为是 <code> 婚姻关系 </code> 的一种，男人和女人只会产生两种结果，<code> 好好的 </code> 和 <code> 说散就散 </code>，一般男人的一生都可以把他看成是原子性的一种，当然我们不排除<code> 时间管理 (线程切换)</code> 的个例，我们知道线程切换必然会伴随着安全性问题，男人要出去浪也会造成两种结果，这两种结果分别对应安全性的两个结果：线程安全（好好的）和线程不安全（说散就散）。</p>
<h3><span id="竞态条件">竞态条件 </span></h3><p> 有了上面的线程切换的功底，那么竞态条件也就好定义了，它指的就是 <strong> 两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong> ，线程切换是导致竞态条件出现的诱导因素，我们通过一个示例来说明，来看一段代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RaceCondition</span> <span class="token punctuation">&#123;</span>
  
  <span class="token keyword">private</span> <span class="token class-name">Signleton</span> single <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Signleton</span> <span class="token function">newSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>single <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Signleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> single<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，涉及到一个竞态条件，那就是判断 <code>single</code> 的时候，如果 single 判断为空，此时发生了线程切换，另外一个线程执行，判断 single 的时候，也是空，执行 new 操作，然后线程切换回之前的线程，再执行 new 操作，那么内存中就会有两个 Singleton 对象。</p>
<h3><span id="加锁机制">加锁机制 </span></h3><p> 在 Java 中，有很多种方式来对共享和可变的资源进行加锁和保护。Java 提供一种内置的机制对资源进行保护：<code>synchronized</code> 关键字，它有三种保护机制</p>
<ul>
<li>对方法进行加锁，确保多个线程中只有一个线程执行方法；</li>
<li>对某个对象实例（在我们上面的探讨中，变量可以使用对象来替换）进行加锁，确保多个线程中只有一个线程对对象实例进行访问；</li>
<li>对类对象进行加锁，确保多个线程只有一个线程能够访问类中的资源。</li>
</ul>
<p>synchronized 关键字对资源进行保护的代码块俗称 <code>同步代码块(Synchronized Block)</code>，例如</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token comment">// 线程安全的代码</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为 <code>内置锁 (Instrinsic Lock)</code> 或者 <code>监视器锁(Monitor Lock)</code>。线程在进入同步代码之前会自动获得锁，并且在退出同步代码时自动释放锁，而无论是通过正常执行路径退出还是通过异常路径退出，获得内置锁的唯一途径就是进入这个由锁保护的同步代码块或方法。</p>
<p>synchronized 的另一种隐含的语义就是 <code>互斥 </code>，互斥意味着<code> 独占</code>，最多只有一个线程持有锁，当线程 A 尝试获得一个由线程 B 持有的锁时，线程 A 必须等待或者阻塞，直到线程 B 释放这个锁，如果线程 B 不释放锁的话，那么线程 A 将会一直等待下去。</p>
<p>线程 A 获得线程 B 持有的锁时，线程 A 必须等待或者阻塞，但是获取锁的线程 B 可以重入，重入的意思可以用一段代码表示</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Retreent</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doSomething......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doSomethingElse......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取 doSomething() 方法锁的线程可以执行 doSomethingElse() 方法，执行完毕后可以重新执行 doSomething() 方法中的内容。锁重入也支持子类和父类之间的重入，具体的我们后面会进行介绍。</p>
<p><code>volatile</code> 是一种轻量级的 <code>synchronized</code>，也就是一种轻量级的加锁方式，volatile 通过保证共享变量的可见性来从侧面对对象进行加锁。可见性的意思就是当一个线程修改一个共享变量时，另外一个线程能够 <code>看见</code> 这个修改的值。volatile 的执行成本要比 <code>synchronized</code> 低很多，因为 volatile 不会引起线程的上下文切换。</p>
<p><img src="https://i.loli.net/2020/08/28/uUfTv7oRhjPwBLz.png" alt="526ad007f30d4ae3b7ed9419497ce879_tplv-k3u1fbpfcp-zoom-1"></p>
<p>我们还可以使用 <code> 原子类</code> 来保证线程安全，原子类其实就是 <code>rt.jar</code> 下面以 <code>atomic</code> 开头的类</p>
<p><img src="https://i.loli.net/2020/08/28/3JvDNy8knzPRaFA.png" alt="88cbd9b934514334b039098545dce0df_tplv-k3u1fbpfcp-zoom-1"></p>
<p>除此之外，我们还可以使用 <code>java.util.concurrent</code> 工具包下的线程安全的集合类来确保线程安全，具体的实现类和其原理我们后面会说。</p>
<p>可以使用不同的并发模型来实现并发系统，并发模型说的是系统中的线程如何协作完成并发任务。不同的并发模型以不同的方式拆分任务，线程可以以不同的方式进行通信和协作。</p>
<h2><span id="竞态条件和关键区域">竞态条件和关键区域 </span></h2><p> 竞态条件是在关键代码区域发生的一种特殊条件。关键区域是由多个线程同时执行的代码部分，关键区域中的代码执行顺序会对造成不一样的结果。如果多个线程执行一段关键代码，而这段关键代码会因为执行顺序不同而造成不同的结果时，那么这段代码就会包含竞争条件。</p>
<h2><span id="并发模型和分布式系统很相似">并发模型和分布式系统很相似 </span></h2><p> 并发模型其实和分布式系统模型非常相似，在并发模型中是 <code> 线程 </code> 彼此进行通信，而在分布式系统模型中是 <code>进程</code> 彼此进行通信。然而本质上，进程和线程也非常相似。这也就是为什么并发模型和分布式模型非常相似的原因。</p>
<p>分布式系统通常要比并发系统面临更多的挑战和问题比如进程通信、网络可能出现异常，或者远程机器挂掉等等。但是一个并发模型同样面临着比如 CPU 故障、网卡出现问题、硬盘出现问题等。</p>
<p>因为并发模型和分布式模型很相似，因此他们可以相互借鉴，例如用于线程分配的模型就类似于分布式系统环境中的负载均衡模型。</p>
<p>其实说白了，分布式模型的思想就是借鉴并发模型的基础上推演发展来的。</p>
<h2><span id="认识两个状态">认识两个状态 </span></h2><p> 并发模型的一个重要的方面是，线程是否应该 <code> 共享状态 </code>，是具有<code> 共享状态 </code> 还是 <code> 独立状态</code>。共享状态也就意味着在不同线程之间共享某些状态</p>
<p>状态其实就是 <code> 数据 </code>，比如一个或者多个对象。当线程要共享数据时，就会造成 <code> 竞态条件 </code> 或者 <code> 死锁</code> 等问题。当然，这些问题只是可能会出现，具体实现方式取决于你是否安全的使用和访问共享对象。</p>
<p><img src="https://i.loli.net/2020/08/28/zbjAdaQH1FEetkS.png" alt="d7524f66939846579bf85e7f4a1a801d_tplv-k3u1fbpfcp-zoom-1"><br>独立的状态表明状态不会在多个线程之间共享，如果线程之间需要通信的话，他们可以访问不可变的对象来实现，这是最有效的避免并发问题的一种方式，如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/4wWYgfpeZvrKaJ3.png" alt="eef9af1d393b4034b21bfe37a27dd79d_tplv-k3u1fbpfcp-zoom-1"></p>
<p>使用独立状态让我们的设计更加简单，因为只有一个线程能够访问对象，即使交换对象，也是不可变的对象。</p>
<h2><span id="并发模型">并发模型 </span></h2><h3><span id="并行-worker"> 并行 Worker</span></h3><p>第一个并发模型是并行 worker 模型，客户端会把任务交给 <code>代理人 (Delegator)</code>，然后由代理人把工作分配给不同的 <code> 工人(worker)</code>。如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/YGCcIWVlJOKqdug.png" alt="13f7dbb7dab743d4bcaf54b8adf9bca0_tplv-k3u1fbpfcp-zoom-1"></p>
<p>并行 worker 的核心思想是，它主要有两个进程即代理人和工人，Delegator 负责接收来自客户端的任务并把任务下发，交给具体的 Worker 进行处理，Worker 处理完成后把结果返回给 Delegator，在 Delegator 接收到 Worker 处理的结果后对其进行汇总，然后交给客户端。</p>
<p>并行 Worker 模型是 Java 并发模型中非常常见的一种模型。许多 <code>java.util.concurrent</code> 包下的并发工具都使用了这种模型。</p>
<h4><span id="并行-worker-的优点">并行 Worker 的优点 </span></h4><p> 并行 Worker 模型的一个非常明显的特点就是很容易理解，为了提高系统的并行度你可以增加多个 Worker 完成任务。</p>
<p>并行 Worker 模型的另外一个好处就是，它会将一个任务拆分成多个小任务，并发执行，Delegator 在接受到 Worker 的处理结果后就会返回给 Client，整个 Worker -&gt; Delegator -&gt; Client 的过程是 <code> 异步 </code> 的。</p>
<h4><span id="并行-worker-的缺点">并行 Worker 的缺点 </span></h4><p> 同样的，并行 Worker 模式同样会有一些隐藏的缺点</p>
<p><strong>共享状态会变得很复杂</strong></p>
<p>实际的并行 Worker 要比我们图中画出的更复杂，主要是并行 Worker 通常会访问内存或共享数据库中的某些共享数据。</p>
<p><img src="https://i.loli.net/2020/08/28/K9WgthEsODpkf3Q.png" alt="a7168759b7754ddfa50f3e4e31fe5d73_tplv-k3u1fbpfcp-zoom-1"></p>
<p>这些共享状态可能会使用一些工作队列来保存业务数据、数据缓存、数据库的连接池等。在线程通信中，线程需要确保共享状态是否能够让其他线程共享，而不是仅仅停留在 CPU 缓存中让自己可用，当然这些都是程序员在设计时就需要考虑的问题。线程需要避免 <code>竞态条件 </code>，<code> 死锁</code> 和许多其他共享状态造成的并发问题。</p>
<p>多线程在访问共享数据时，会丢失并发性，因为操作系统要保证只有一个线程能够访问数据，这会导致共享数据的争用和抢占。未抢占到资源的线程会 <code>阻塞</code>。</p>
<p>现代的非阻塞并发算法可以减少争用提高性能，但是非阻塞算法比较难以实现。</p>
<p><code>可持久化的数据结构(Persistent data structures)</code> 是另外一个选择。可持久化的数据结构在修改后始终会保留先前版本。因此，如果多个线程同时修改一个可持久化的数据结构，并且一个线程对其进行了修改，则修改的线程会获得对新数据结构的引用。</p>
<p>虽然可持久化的数据结构是一个新的解决方法，但是这种方法实行起来却有一些问题，比如，一个持久列表会将新元素添加到列表的开头，并返回所添加的新元素的引用，但是其他线程仍然只持有列表中先前的第一个元素的引用，他们看不到新添加的元素。</p>
<p>持久化的数据结构比如 <code>链表(LinkedList)</code> 在硬件性能上表现不佳。列表中的每个元素都是一个对象，这些对象散布在计算机内存中。现代 CPU 的顺序访问往往要快的多，因此使用数组等顺序访问的数据结构则能够获得更高的性能。CPU 高速缓存可以将一个大的矩阵块加载到高速缓存中，并让 CPU 在加载后直接访问 CPU 高速缓存中的数据。对于链表，将元素分散在整个 RAM 上，这实际上是不可能的。</p>
<p><strong>无状态的 worker</strong></p>
<p>共享状态可以由其他线程所修改，因此，worker 必须在每次操作共享状态时重新读取，以确保在副本上能够正确工作。不在线程内部保持状态的 worker 成为无状态的 worker。</p>
<p><strong>作业顺序是不确定的</strong></p>
<p>并行工作模型的另一个缺点是作业的顺序不确定，无法保证首先执行或最后执行哪些作业。任务 A 在任务 B 之前分配给 worker，但是任务 B 可能在任务 A 之前执行。</p>
<h3><span id="流水线">流水线 </span></h3><p> 第二种并发模型就是我们经常在生产车间遇到的 <code>流水线并发模型</code>，下面是流水线设计模型的流程图</p>
<p><img src="https://i.loli.net/2020/08/28/3AzKE4WknQHD7xt.png" alt="f5f95a91ebb545dc8ed501314b8de20e_tplv-k3u1fbpfcp-zoom-1"></p>
<p>这种组织架构就像是工厂中装配线中的 worker，每个 worker 只完成全部工作的一部分，完成一部分后，worker 会将工作转发给下一个 worker。</p>
<p>每道程序都在自己的线程中运行，彼此之间不会共享状态，这种模型也被称为无共享并发模型。</p>
<p>使用流水线并发模型通常被设计为 <code> 非阻塞 I/O</code>，也就是说，当没有给 worker 分配任务时，worker 会做其他工作。非阻塞 I/O 意味着当 worker 开始 I/O 操作，例如从网络中读取文件，worker 不会等待 I/O 调用完成。因为 I/O 操作很慢，所以等待 I/O 非常耗费时间。在等待 I/O 的同时，CPU 可以做其他事情，I/O 操作完成后的结果将传递给下一个 worker。下面是非阻塞 I/O 的流程图</p>
<p><img src="https://i.loli.net/2020/08/28/BXifTrpo7kHlSLK.png" alt="6f07fa8ce9b846b6b558070fd03cd612_tplv-k3u1fbpfcp-zoom-1"></p>
<p>在实际情况中，任务通常不会按着一条装配线流动，由于大多数程序需要做很多事情，因此需要根据完成的不同工作在不同的 worker 之间流动，如下图所示</p>
<p><img src="https://i.loli.net/2020/08/28/Gwfxork2ODgQecP.png" alt="d3b9ee0be6834771bfda46f744700076_tplv-k3u1fbpfcp-zoom-1"></p>
<p>任务还可能需要多个 worker 共同参与完成</p>
<p><img src="https://i.loli.net/2020/08/28/kdqJHOhP6YjxLfv.png" alt="bbb73ee024ae4417b6889666a6e9e68e_tplv-k3u1fbpfcp-zoom-1"></p>
<h4><span id="响应式-事件驱动系统">响应式 - 事件驱动系统 </span></h4><p> 使用流水线模型的系统有时也被称为 <code>响应式 </code> 或者 <code> 事件驱动系统</code>，这种模型会根据外部的事件作出响应，事件可能是某个 HTTP 请求或者某个文件完成加载到内存中。</p>
<h4><span id="actor-模型">Actor 模型 </span></h4><p> 在 Actor 模型中，每一个 Actor 其实就是一个 Worker， 每一个 Actor 都能够处理任务。</p>
<p>简单来说，Actor 模型是一个并发模型，它定义了一系列系统组件应该如何动作和交互的通用规则，最著名的使用这套规则的编程语言是 Erlang。一个参与者 <code>Actor</code> 对接收到的消息做出响应，然后可以创建出更多的 Actor 或发送更多的消息，同时准备接收下一条消息。</p>
<p><img src="https://i.loli.net/2020/08/28/xczXKkt3nVUHaSs.png" alt="1ca5cc858ac84eaa97d78bd9d1e1ef8f_tplv-k3u1fbpfcp-zoom-1"></p>
<h4><span id="channels-模型">Channels 模型 </span></h4><p> 在 Channel 模型中，worker 通常不会直接通信，与此相对的，他们通常将事件发送到不同的 <code>通道 (Channel)</code> 上，然后其他 worker 可以在这些通道上获取消息，下面是 Channel 的模型图</p>
<p><img src="https://i.loli.net/2020/08/28/xNryCdE7a2ghnkO.png" alt="7b8ea6ff301c4e2eb3f91bdbb1106f7b_tplv-k3u1fbpfcp-zoom-1"></p>
<p>有的时候 worker 不需要明确知道接下来的 worker 是谁，他们只需要将作者写入通道中，监听 Channel 的 worker 可以订阅或者取消订阅，这种方式降低了 worker 和 worker 之间的耦合性。</p>
<h4><span id="流水线设计的优点">流水线设计的优点 </span></h4><p> 与并行设计模型相比，流水线模型具有一些优势，具体优势如下</p>
<p><strong>不会存在共享状态</strong></p>
<p>因为流水线设计能够保证 worker 在处理完成后再传递给下一个 worker，所以 worker 与 worker 之间不需要共享任何状态，也就无需考虑并发问题。你甚至可以在实现上把每个 worker 看成是单线程的一种。</p>
<p><strong>有状态 worker</strong></p>
<p>因为 worker 知道没有其他线程修改自身的数据，所以流水线设计中的 worker 是有状态的，有状态的意思是他们可以将需要操作的数据保留在内存中，有状态通常比无状态更快。</p>
<p><strong>更好的硬件整合</strong></p>
<p>因为你可以把流水线看成是单线程的，而单线程的工作优势在于它能够和硬件的工作方式相同。因为有状态的 worker 通常在 CPU 中缓存数据，这样可以更快地访问缓存的数据。</p>
<p><strong>使任务更加有效的进行</strong></p>
<p>可以对流水线并发模型中的任务进行排序，一般用来日志的写入和恢复。</p>
<h4><span id="流水线设计的缺点">流水线设计的缺点 </span></h4><p> 流水线并发模型的缺点是任务会涉及多个 worker，因此可能会分散在项目代码的多个类中。因此很难确定每个 worker 都在执行哪个任务。流水线的代码编写也比较困难，设计许多嵌套回调处理程序的代码通常被称为 <code>回调地狱</code>。回调地狱很难追踪 debug。</p>
<h2><span id="函数性并行">函数性并行 </span></h2><p> 函数性并行模型是最近才提出的一种并发模型，它的基本思路是使用函数调用来实现。消息的传递就相当于是函数的调用。传递给函数的参数都会被拷贝，因此在函数之外的任何实体都无法操纵函数内的数据。这使得函数执行类似于 <code> 原子 </code> 操作。每个函数调用都可以独立于任何其他函数调用执行。</p>
<p>当每个函数调用独立执行时，每个函数都可以在单独的 CPU 上执行。这也就是说，函数式并行并行相当于是各个 CPU 单独执行各自的任务。</p>
<p>JDK 1.7 中的 <code>ForkAndJoinPool</code> 类就实现了函数性并行的功能。Java 8 提出了 stream 的概念，使用并行流也能够实现大量集合的迭代。</p>
<p>函数性并行的难点是要知道函数的调用流程以及哪些 CPU 执行了哪些函数，跨 CPU 函数调用会带来额外的开销。</p>
<p>我们之前说过，线程就是进程中的一条 <code> 顺序流 </code>，在 Java 中，每一条 Java 线程就像是 JVM 的一条顺序流，就像是虚拟 CPU 一样来执行代码。Java 中的 <code>main()</code> 方法是一条特殊的线程，JVM 创建的 main 线程是一条<code> 主执行线程 </code>，在 Java 中，方法都是由 main 方法发起的。在 main 方法中，你照样可以创建其他的<code> 线程</code>(执行顺序流)，这些线程可以和 main 方法共同执行应用代码。</p>
<p>Java 线程也是一种对象，它和其他对象一样。Java 中的 Thread 表示线程，Thread 是 <code>java.lang.Thread</code> 类或其子类的实例。那么下面我们就来一起探讨一下在 Java 中如何创建和启动线程。</p>
<h2><span id="创建并启动线程">创建并启动线程 </span></h2><p> 在 Java 中，创建线程的方式主要有三种</p>
<ul>
<li>通过继承 <code>Thread</code> 类来创建线程</li>
<li>通过实现 <code>Runnable</code> 接口来创建线程</li>
<li>通过 <code>Callable</code> 和 <code>Future</code> 来创建线程</li>
</ul>
<p>下面我们分别探讨一下这几种创建方式</p>
<h3><span id="继承-thread-类来创建线程">继承 Thread 类来创建线程 </span></h3><p> 第一种方式是继承 Thread 类来创建线程，如下示例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TJavaThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">TJavaThread</span> tJavaThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TJavaThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tJavaThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tJavaThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count ="</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程的主要创建步骤如下</p>
<ul>
<li>定义一个线程类使其继承 Thread 类，并重写其中的 run 方法，run 方法内部就是线程要完成的任务，因此 run 方法也被称为 <code>执行体</code></li>
<li>创建了 Thread 的子类，上面代码中的子类是 <code>TJavaThread</code></li>
<li>启动方法需要注意，并不是直接调用 <code>run</code> 方法来启动线程，而是使用 <code>start</code> 方法来启动线程。当然 run 方法可以调用，这样的话就会变成普通方法调用，而不是新创建一个线程来调用了。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>

  <span class="token class-name">TJavaThread</span> tJavaThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TJavaThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  tJavaThread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count ="</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的话，整个 main 方法只有一条执行线程也就是 main 线程，由两条执行线程变为一条执行线程</p>
<p><img src="https://i.loli.net/2020/08/28/8XQcNBoHRnptimu.png" alt="4ee5fe1479de4c0e9baf0d9eea20d051_tplv-k3u1fbpfcp-zoom-1"></p>
<p>Thread 构造器只需要一个 Runnable 对象，调用 Thread 对象的 start() 方法为该线程执行必须的初始化操作，然后调用 Runnable 的 run 方法，以便在这个线程中启动任务。我们上面使用了线程的 <code>join</code> 方法，它用来等待线程的执行结束，如果我们不加 join 方法，它就不会等待 tJavaThread 的执行完毕，输出的结果可能就不是 <code>10000</code></p>
<p><img src="https://i.loli.net/2020/08/28/lorwFOUDZKRLCny.png" alt="bb3dd164ccde4bc19e60f9cb2171078b_tplv-k3u1fbpfcp-zoom-1"></p>
<p>可以看到，在 run  方法还没有结束前，run 就被返回了。也就是说，程序不会等到 run 方法执行完毕就会执行下面的指令。</p>
<p>使用继承方式创建线程的优势：编写比较简单；可以使用 <code>this</code> 关键字直接指向当前线程，而无需使用 <code>Thread.currentThread()</code> 来获取当前线程。</p>
<p>使用继承方式创建线程的劣势：在 Java 中，只允许单继承（拒绝肛精说使用内部类可以实现多继承）的原则，所以使用继承的方式，子类就不能再继承其他类。</p>
<h3><span id="使用-runnable-接口来创建线程">使用 Runnable 接口来创建线程 </span></h3><p> 相对的，还可以使用 <code>Runnable</code> 接口来创建线程，如下示例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TJavaThreadUseImplements</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TJavaThreadUseImplements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count ="</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程的主要创建步骤如下</p>
<ul>
<li>首先定义 Runnable 接口，并重写 Runnable 接口的 run 方法，run 方法的方法体同样是该线程的线程执行体。</li>
<li>创建线程实例，可以使用上面代码这种简单的方式创建，也可以通过 new 出线程的实例来创建，如下所示</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TJavaThreadUseImplements</span> tJavaThreadUseImplements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TJavaThreadUseImplements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>tJavaThreadUseImplements<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>再调用线程对象的 start 方法来启动该线程。</li>
</ul>
<p>线程在使用实现 <code>Runnable</code> 的同时也能实现其他接口，非常适合多个相同线程来处理同一份资源的情况，体现了面向对象的思想。</p>
<p>使用 Runnable 实现的劣势是编程稍微繁琐，如果要访问当前线程，则必须使用 <code>Thread.currentThread()</code> 方法。</p>
<h3><span id="使用-callable-接口来创建线程">使用 Callable 接口来创建线程</span></h3><p>Runnable 接口执行的是独立的任务，Runnable 接口不会产生任何返回值，如果你希望在任务完成后能够返回一个值的话，那么你可以实现 <code>Callable</code> 接口而不是 Runnable 接口。Java SE5 引入了 Callable 接口，它的示例如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">CallableTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Integer</span> total <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total ="</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我想，使用 Callable 接口的好处你已经知道了吧，既能够实现多个接口，也能够得到执行结果的返回值。Callable 和 Runnable 接口还是有一些区别的，主要区别如下</p>
<ul>
<li>Callable 执行的任务有返回值，而 Runnable 执行的任务没有返回值</li>
<li>Callable（重写）的方法是 call 方法，而 Runnable（重写）的方法是 run 方法。</li>
<li>call 方法可以抛出异常，而 Runnable 方法不能抛出异常</li>
</ul>
<h3><span id="使用线程池来创建线程">使用线程池来创建线程 </span></h3><p> 首先先来认识一下顶级接口 <code>Executor</code>，Executor 虽然不是传统线程创建的方式之一，但是它却成为了创建线程的替代者，使用线程池的好处如下</p>
<ul>
<li>利用线程池能够复用线程、控制最大并发数。</li>
<li>实现任务线程队列 <code> 缓存策略 </code> 和<code>拒绝机制</code>。</li>
<li>实现某些与时间相关的功能，如定时执行、周期执行等。</li>
<li>隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池，将较慢的交易服务与搜索服务隔开，避免个服务线程互相影响。</li>
</ul>
<p>你可以使用如下操作来替换线程创建</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 替换为</span>
<span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorSubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 线程池实现类;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RunnableTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RunnableTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ExecutorService</code> 是 Executor 的默认实现，也是 Executor 的扩展接口，ThreadPoolExecutor 类提供了线程池的扩展实现。<code>Executors</code> 类为这些 Executor 提供了方便的工厂方法。下面是使用 ExecutorService 创建线程的几种方式</p>
<h4><span id="cachedthreadpool">CachedThreadPool</span></h4><p>从而简化了并发编程。Executor 在客户端和任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor 允许你管理 <code> 异步 </code> 任务的执行，而无须显示地管理线程的生命周期。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>CachedThreadPool</code> 会为每个任务都创建一个线程。</p>
<blockquote>
<p>注意：ExecutorService 对象是使用静态的 <code>Executors</code> 创建的，这个方法可以确定 Executor 类型。对 <code>shutDown</code> 的调用可以防止新任务提交给 ExecutorService ，这个线程在 Executor 中所有任务完成后退出。</p>
</blockquote>
<h4><span id="fixedthreadpool">FixedThreadPool</span></h4><p>FixedThreadPool 使你可以使用 <code> 有限 </code> 的线程集来启动多线程</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了 FixedThreadPool 使你可以一次性的预先执行高昂的线程分配，因此也就可以限制线程的数量。这可以节省时间，因为你不必为每个任务都固定的付出创建线程的开销。</p>
<h4><span id="singlethreadexecutor">SingleThreadExecutor</span></h4><p>SingleThreadExecutor 就是 <code> 线程数量为 1</code>的 FixedThreadPool，如果向 SingleThreadPool 一次性提交了多个任务，那么这些任务将会排队，每个任务都会在下一个任务开始前结束，所有的任务都将使用相同的线程。SingleThreadPool 会序列化所有提交给他的任务，并会维护它自己 (隐藏) 的悬挂队列。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从输出的结果就可以看到，任务都是挨着执行的。我为任务分配了五个线程，但是这五个线程不像是我们之前看到的有换进换出的效果，它每次都会先执行完自己的那个线程，然后余下的线程继续 <code> 走完 </code> 这条线程的执行路径。你可以用 SingleThreadExecutor 来确保任意时刻都只有唯一一个任务在运行。</p>
<h3><span id="休眠">休眠 </span></h3><p> 影响任务行为的一种简单方式就是使线程 休眠，选定给定的休眠时间，调用它的 <code>sleep()</code> 方法， 一般使用的<code>TimeUnit</code> 这个时间类替换 <code>Thread.sleep()</code> 方法，示例如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperclassThread</span> <span class="token keyword">extends</span> <span class="token class-name">TestThread</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"starting ..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"sleeping ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"wakeup and end ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ExecutorService</span> executors <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            executors<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SuperclassThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        executors<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>关于 TimeUnit 中的 sleep() 方法和 Thread.sleep() 方法的比较，请参考下面这篇博客</p>
<p>(<a href="https://www.cnblogs.com/xiadongqing/p/9925567.html">www.cnblogs.com/xiadongqing…</a>)</p>
</blockquote>
<h3><span id="优先级">优先级 </span></h3><p> 上面提到线程调度器对每个线程的执行都是不可预知的，随机执行的，那么有没有办法告诉线程调度器哪个任务想要优先被执行呢？你可以通过设置线程的优先级状态，告诉线程调度器哪个线程的执行优先级比较高，<strong>请给这个骑手马上派单</strong>，线程调度器倾向于让优先级较高的线程优先执行，然而，这并不意味着优先级低的线程得不到执行，也就是说，优先级不会导致死锁的问题。优先级较低的线程只是执行频率较低。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimplePriorities</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> priority<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SimplePriorities</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">=</span> priority<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> priority<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimplePriorities</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimplePriorities</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>toString() 方法被覆盖，以便通过使用 <code>Thread.toString()</code> 方法来打印线程的名称。你可以改写线程的默认输出，这里采用了 <strong>Thread[pool-1-thread-1,10,main]</strong> 这种形式的输出。</p>
<p>通过输出，你可以看到，最后一个线程的优先级最低，其余的线程优先级最高。注意，优先级是在 run 开头设置的，在构造器中设置它们不会有任何好处，因为这个时候线程还没有执行任务。</p>
<p>尽管 JDK 有 10 个优先级，但是一般只有<strong>MAX_PRIORITY，NORM_PRIORITY，MIN_PRIORITY</strong> 三种级别。</p>
<h3><span id="作出让步">作出让步 </span></h3><p> 我们上面提过，如果知道一个线程已经在 run() 方法中运行的差不多了，那么它就可以给线程调度器一个提示：我已经完成了任务中最重要的部分，可以让给别的线程使用 CPU 了。这个暗示将通过 yield() 方法作出。</p>
<blockquote>
<p>有一个很重要的点就是，Thread.yield() 是建议执行切换 CPU，而不是强制执行 CPU 切换。</p>
</blockquote>
<p>对于任何重要的控制或者在调用应用时，都不能依赖于 <code>yield()</code>方法，实际上， yield() 方法经常被滥用。</p>
<h3><span id="后台线程">后台线程 </span></h3><p><code> 后台 (daemon)</code> 线程，是指运行时在后台提供的一种服务线程，这种线程不是属于必须的。当所有非后台线程结束时，程序也就停止了，<strong>同时会终止所有的后台线程。</strong>反过来说，只要有任何非后台线程还在运行，程序就不会终止。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleDaemons</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep() interrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">Thread</span> daemon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDaemons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            daemon<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            daemon<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All Daemons started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在每次的循环中会创建 10 个线程，并把每个线程设置为后台线程，然后开始运行，for 循环会进行十次，然后输出信息，随后主线程睡眠一段时间后停止运行。在每次 run 循环中，都会打印当前线程的信息，主线程运行完毕，程序就执行完毕了。因为 <code>daemon</code> 是后台线程，无法影响主线程的执行。</p>
<p>但是当你把 <code>daemon.setDaemon(true)</code> 去掉时，while(true) 会进行无限循环，那么主线程一直在执行最重要的任务，所以会一直循环下去无法停止。</p>
<h3><span id="threadfactory">ThreadFactory</span></h3><p>按需要创建线程的对象。使用线程工厂替换了 Thread 或者 Runnable 接口的硬连接，使程序能够使用特殊的线程子类，优先级等。一般的创建方式为</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SimpleThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>Executors.defaultThreadFactory 方法提供了一个更有用的简单实现，它在返回之前将创建的线程上下文设置为已知值</p>
</blockquote>
<p><code>ThreadFactory</code>是一个接口，它只有一个方法就是创建线程的方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 构建一个新的线程。实现类可能初始化优先级，名称，后台线程状态和 线程组等</span>
    <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面来看一个 ThreadFactory 的例子</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaemonThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaemonFromFactory</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Interrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DaemonThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DaemonFromFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All daemons started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Executors.newCachedThreadPool</code> 可以接受一个线程池对象，创建一个根据需要创建新线程的线程池，但会在它们可用时重用先前构造的线程，并在需要时使用提供的 ThreadFactory 创建新线程。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                                <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="加入一个线程">加入一个线程 </span></h3><p> 一个线程可以在其他线程上调用 <code>join()</code> 方法，其效果是等待一段时间直到第二个线程结束才正常执行。如果某个线程在另一个线程 t 上调用 t.join() 方法，此线程将被挂起，直到目标线程 t 结束才回复(可以用 t.isAlive() 返回为真假判断)。</p>
<p>也可以在调用 join 时带上一个超时参数，来设置到期时间，时间到期，join 方法自动返回。</p>
<p>对 join 的调用也可以被中断，做法是在线程上调用 <code>interrupted</code> 方法，这时需要用到 try…catch 子句</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJoinMethod</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Interrupted sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">TestJoinMethod</span> join1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJoinMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TestJoinMethod</span> join2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJoinMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TestJoinMethod</span> join3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestJoinMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        join1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        join1.join();</span>

        join2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        join3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>join() 方法等待线程死亡。 换句话说，它会导致当前运行的线程停止执行，直到它加入的线程完成其任务。</p>
<h3><span id="线程异常捕获">线程异常捕获 </span></h3><p> 由于线程的本质，使你不能捕获从线程中逃逸的异常，一旦异常逃出任务的 run 方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常，在 Java5 之前，你可以通过线程组来捕获，但是在 Java 5 之后，就需要用 Executor 来解决问题，因为线程组不是一次好的尝试。</p>
<p>下面的任务会在 run 方法的执行期间抛出一个异常，并且这个异常会抛到 run 方法的外面，而且 main 方法无法对它进行捕获</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExceptionThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eeeee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了解决这个问题，我们需要修改 Executor 产生线程的方式，Java5 提供了一个新的接口 <code>Thread.UncaughtExceptionHandler</code> ，它允许你在每个 Thread 上都附着一个异常处理器。<code>Thread.UncaughtExceptionHandler.uncaughtException()</code> 会在线程因未捕获临近死亡时被调用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run() by"</span> <span class="token operator">+</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eh ="</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token comment">// 手动抛出异常</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 实现 Thread.UncaughtExceptionHandler 接口，创建异常处理器</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyUncaughtExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token class-name">UncaughtExceptionHandler</span><span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"caught"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">"creating new Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"created"</span> <span class="token operator">+</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ex ="</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CaptureUncaughtException</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HandlerThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExceptionThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在程序中添加了额外的追踪机制，用来验证工厂创建的线程会传递给<code>UncaughtExceptionHandler</code>，你可以看到，未捕获的异常是通过 <code>uncaughtException</code> 来捕获的。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言的调度器</title>
    <url>/2020/01/10/go/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。</p>
<a id="more"></a>
<p>谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：</p>
<p><img src="https://i.loli.net/2020/09/11/Xl2LyF1jMsRbIPY.png" alt="process-and-threads"></p>
<p>多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。</p>
<p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1 兆以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销。</p>
<p><img src="https://i.loli.net/2020/09/11/sxOWUSy4Qq6PENo.png" alt="goroutines-on-thread"></p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<h2><span id="设计原理">设计原理 </span></h2><p> 今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器就会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，几个不同版本的调度器引入了不同的改进，也存在不同的缺陷:</p>
<ul>
<li><p>单线程调度器 <code>0.x</code></p>
<ul>
<li>只包含 40 多行代码；</li>
</ul>
</li>
<li><p>程序中只能存在一个活跃线程，由 G-M 模型组成；</p>
</li>
<li><p>多线程调度器 <code>1.0</code></p>
<ul>
<li><p>允许运行多线程的程序；</p>
</li>
<li><p>全局锁导致竞争严重；</p>
</li>
</ul>
</li>
<li><p>任务窃取调度器 <code>1.1</code></p>
<ul>
<li><p>引入了处理器 P，构成了目前的 <strong>G-M-P</strong> 模型；</p>
</li>
<li><p>在处理器 P 的基础上实现了基于 <strong> 工作窃取 </strong> 的调度器；</p>
</li>
</ul>
</li>
<li><p>在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；</p>
<ul>
<li>时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；</li>
</ul>
</li>
<li><p>抢占式调度器 <code>1.2 ~ 至今</code></p>
<ul>
<li>基于协作的抢占式调度器 - 1.2 ~ 1.13</li>
<li>通过编译器在函数调用时插入 <strong> 抢占检查 </strong> 指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；<ul>
<li>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；</li>
</ul>
</li>
</ul>
</li>
<li><p>基于信号的抢占式调度器 - 1.14 ~ 至今</p>
<ul>
<li>实现 <strong> 基于信号的真抢占式调度</strong>；<ul>
<li>垃圾回收在扫描栈时会触发抢占调度；</li>
</ul>
</li>
<li>抢占的时间点不够多，还不能覆盖全部的边缘情况；</li>
</ul>
</li>
<li><p>非均匀存储访问调度器 <code> 提案</code></p>
<ul>
<li>对运行时的各种资源进行分区；</li>
<li>实现非常复杂，到今天还没有提上日程；</li>
</ul>
</li>
</ul>
<p>除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案，Go 语言在未来也有实现该提案的可能。在这一节中，我们将依次介绍不同版本调度器的实现原理以及未来可能会实现的调度器提案。</p>
<h3><span id="单线程调度器">单线程调度器 </span></h3><p>0.x 版本调度器只包含表示 Goroutine 的 G 和表示线程的 M 两种结构，全局也只有一个线程。我们可以在 <a href="https://github.com/golang/go/commit/96824000ed89d13665f6f24ddc10b3bf812e7f47">clean up scheduler</a> 提交中找到单线程调度器的源代码，在这时 Go 语言的<a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c"> 调度器 </a> 还是由 C 语言实现的，调度函数 <a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c#L340"><code>runtime.schedule</code></a> 也只包含 40 多行代码 ：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	G<span class="token operator">*</span> gp<span class="token punctuation">;</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">gosave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-></span>sched<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">)</span><span class="token punctuation">;</span>
		gp <span class="token operator">=</span> m<span class="token operator">-></span>curg<span class="token punctuation">;</span>
		<span class="token keyword">switch</span><span class="token punctuation">(</span>gp<span class="token operator">-></span>status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> Grunnable<span class="token operator">:</span>
		<span class="token keyword">case</span> Grunning<span class="token operator">:</span>
			gp<span class="token operator">-></span>status <span class="token operator">=</span> Grunnable<span class="token punctuation">;</span>
			<span class="token function">gput</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token operator">-></span>stopped<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	gp <span class="token operator">=</span> <span class="token function">nextgandunlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token operator">-></span>stopped<span class="token punctuation">)</span><span class="token punctuation">;</span>
	gp<span class="token operator">-></span>status <span class="token operator">=</span> Grunning<span class="token punctuation">;</span>
	m<span class="token operator">-></span>curg <span class="token operator">=</span> gp<span class="token punctuation">;</span>
	g <span class="token operator">=</span> gp<span class="token punctuation">;</span>
	<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token operator">-></span>sched<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数会遵循如下的过程调度 Goroutine：</p>
<ol>
<li>获取调度器的全局锁；</li>
<li>调用 <a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/rt0_amd64.s#L69"><code>runtime.gosave</code></a> 保存栈寄存器和程序计数器；</li>
<li>调用 <a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c#L315"><code>runtime.nextgandunlock</code></a> 获取下一个需要运行的 Goroutine 并解锁调度器；</li>
<li>修改全局线程 <code>m</code> 上要执行的 Goroutine；</li>
<li>调用 <a href="https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/rt0_amd64.s#L69"><code>runtime.gogo</code></a> 函数运行最新的 Goroutine；</li>
</ol>
<p>虽然这个单线程调度器的唯一优点就是 <strong> 能运行</strong>，但是这次提交已经包含了 G 和 M 两个重要的数据结构，也建立了 Go 语言调度器的框架。</p>
<h3><span id="多线程调度器">多线程调度器</span></h3><p>Go 语言在 1.0 版本正式发布时就支持了多线程的调度器，与上一个版本几乎不可用的调度器相比，Go 语言团队在这一阶段实现了从不可用到可用的跨越。我们可以在 <a href="https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c"><code>pkg/runtime/proc.c</code></a> 文件中找到 1.0.1 版本的调度器，多线程版本的调度函数 <a href="https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c#L838"><code>runtime.schedule</code></a> 包含 70 多行代码，我们在这里保留了该函数的核心逻辑：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span>G <span class="token operator">*</span>gp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">schedlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>gp <span class="token operator">!=</span> nil<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		gp<span class="token operator">-></span>m <span class="token operator">=</span> nil<span class="token punctuation">;</span>
		uint32 v <span class="token operator">=</span> runtime·<span class="token function">xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>runtime·sched<span class="token punctuation">.</span>atomic<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>mcpuShift<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">atomic_mcpu</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">></span> maxgomaxprocs<span class="token punctuation">)</span>
			runtime·<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"negative mcpu in scheduler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">switch</span><span class="token punctuation">(</span>gp<span class="token operator">-></span>status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> Grunning<span class="token operator">:</span>
			gp<span class="token operator">-></span>status <span class="token operator">=</span> Grunnable<span class="token punctuation">;</span>
			<span class="token function">gput</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">:</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">&#125;</span>
	gp <span class="token operator">=</span> <span class="token function">nextgandunlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	gp<span class="token operator">-></span>status <span class="token operator">=</span> Grunning<span class="token punctuation">;</span>
	m<span class="token operator">-></span>curg <span class="token operator">=</span> gp<span class="token punctuation">;</span>
	gp<span class="token operator">-></span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>
	runtime·<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token operator">-></span>sched<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整体的逻辑与单线程调度器没有太多区别，因为我们的程序中可能同时存在多个活跃线程，所以多线程调度器引入了 <code>GOMAXPROCS</code> 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。</p>
<p>多线程调度器的主要问题是调度时的锁竞争会严重浪费资源，<a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中对调度器做的性能测试发现 14% 的时间都花费在 <a href="https://github.com/golang/go/blob/2fffba7fe19690e038314d17a117d6b87979c89f/src/pkg/runtime/os_linux.h#L9"><code>runtime.futex</code></a> 上，该调度器有以下问题需要解决：</p>
<ol>
<li>调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问严重；</li>
<li>线程需要经常互相传递可运行的 Goroutine，引入了大量的延迟；</li>
<li>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性（Data locality）；</li>
<li>系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；</li>
</ol>
<p>这里的全局锁问题和 Linux 操作系统调度器在早期遇到的问题比较相似，解决的方案也都大同小异。</p>
<h3><span id="任务窃取调度器">任务窃取调度器</span></h3><p>2012 年 Google 的工程师 Dmitry Vyukov 在 <a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中指出了现有多线程调度器的问题并在多线程调度器上提出了两个改进的手段：</p>
<ol>
<li>在当前的 G-M 模型中引入了处理器 P，增加中间层；</li>
<li>在处理器 P 的基础上实现基于工作窃取的调度器；</li>
</ol>
<p>基于任务窃取的 Go 语言调度器使用了沿用至今的 G-M-P 模型，我们能在 <a href="https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8">runtime: improved scheduler</a> 提交中找到任务窃取调度器刚被实现时的 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c"> 源代码</a>，调度器的 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L1039"><code>runtime.schedule</code></a> 函数在这个版本的调度器中反而更简单了：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">static void <span class="token function">schedule</span><span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    G <span class="token operator">*</span>gp<span class="token punctuation">;</span>
 top<span class="token punctuation">:</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>runtime·gcwaiting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">gcstopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> top<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    gp <span class="token operator">=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token operator">></span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>gp <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
        gp <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">...</span>

    <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如果当前运行时在等待垃圾回收，调用 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L907"><code>runtime.gcstopm</code></a> 函数；</li>
<li>调用 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L2075"><code>runtime.runqget</code></a> 和 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L956"><code>runtime.findrunnable</code></a> 从本地或者全局的运行队列中获取待执行的 Goroutine；</li>
<li>调用 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L929"><code>runtime.execute</code></a> 函数在当前线程 M 上运行 Goroutine；</li>
</ol>
<p>当前处理器本地的运行队列中不包含 Goroutine 时，调用 <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L956"><code>findrunnable</code></a> 函数会触发工作窃取，从其它的处理器的队列中随机获取一些 Goroutine。</p>
<p>运行时 G-M-P 模型中引入的处理器 P 是线程和 Goroutine 的中间层，我们从它的结构体中就能看到处理器与 M 和 G 的关系：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">P</span> <span class="token punctuation">&#123;</span>
	Lock<span class="token punctuation">;</span>

	uint32	status<span class="token punctuation">;</span>
	P<span class="token operator">*</span>	link<span class="token punctuation">;</span>
	uint32	tick<span class="token punctuation">;</span>
	M<span class="token operator">*</span>	m<span class="token punctuation">;</span>
	MCache<span class="token operator">*</span>	mcache<span class="token punctuation">;</span>

	G<span class="token operator">*</span><span class="token operator">*</span>	runq<span class="token punctuation">;</span>
	int32	runqhead<span class="token punctuation">;</span>
	int32	runqtail<span class="token punctuation">;</span>
	int32	runqsize<span class="token punctuation">;</span>

	G<span class="token operator">*</span>	gfree<span class="token punctuation">;</span>
	int32	gfreecnt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>处理器持有一个由可运行的 Goroutine 组成的运行队列 <code>runq</code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。如下所示的图片展示了 Go 语言中的线程 M、处理器 P 和 Goroutine 的关系。</p>
<p><img src="https://img.draveness.me/2020-02-02-15805792666151-golang-gmp.png" alt="golang-gmp"></p>
<p><strong>图 6-27 - G-M-P 模型</strong></p>
<p>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能，今天所有的 Go 语言服务都受益于这一改动。</p>
<h3><span id="抢占式调度器">抢占式调度器 </span></h3><p> 对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本中引入基于协作的抢占式调度解决下面的问题：</p>
<ul>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；</li>
<li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作；</li>
</ul>
<p>1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。</p>
<h4><span id="基于协作的抢占式调度">基于协作的抢占式调度 </span></h4><p> 我们可以在 <a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c"><code>pkg/runtime/proc.c</code></a> 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p>
<ul>
<li>runtime: add stackguard0 to G<ul>
<li>为 Goroutine 引入 <code>stackguard0</code> 字段，该字段被设置成 <code>StackPreempt</code> 意味着当前 Goroutine 发出了抢占请求；</li>
</ul>
</li>
<li>runtime: introduce preemption function (not used for now)<ul>
<li>引入抢占函数 <a href="https://github.com/golang/go/blob/354ec5166668cae9be899c82e20c38b32ae3b867/src/pkg/runtime/proc.c#L2103"><code>runtime.preemptone</code></a> 和 <a href="https://github.com/golang/go/blob/354ec5166668cae9be899c82e20c38b32ae3b867/src/pkg/runtime/proc.c#L2083"><code>runtime.preemptall</code></a>，这两个函数会改变 Goroutine 的 <code>stackguard0</code> 字段发出抢占请求；</li>
<li>定义抢占请求 <code>StackPreempt</code>；</li>
</ul>
</li>
<li>runtime: preempt goroutines for GC<ul>
<li>在 <a href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/proc.c#L356"><code>runtime.stoptheworld</code></a> 中调用 <a href="https://github.com/golang/go/blob/354ec5166668cae9be899c82e20c38b32ae3b867/src/pkg/runtime/proc.c#L2083"><code>runtime.preemptall</code></a> 设置所有处理器上正在运行的 Goroutine 的 <code>stackguard0</code> 为 <code>StackPreempt</code>；</li>
<li>在 <a href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.newstack</code></a> 函数中增加抢占的代码，当 <code>stackguard0</code> 等于 <code>StackPreempt</code> 时触发调度器抢占让出线程；</li>
</ul>
</li>
<li>runtime: preempt long-running goroutines<ul>
<li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 <a href="https://github.com/golang/go/blob/bc31bcccd3b94ec8dd324e523c4c7ae9180b937f/src/pkg/runtime/proc.c#L2122"><code>runtime.retake</code></a> 和 <a href="https://github.com/golang/go/blob/354ec5166668cae9be899c82e20c38b32ae3b867/src/pkg/runtime/proc.c#L2103"><code>runtime.preemptone</code></a>；</li>
</ul>
</li>
<li>runtime: more reliable preemption<ul>
<li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li>
</ul>
</li>
</ul>
<p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 <a href="https://github.com/golang/go/commit/7343e03c433ebb0c302ed97bf832ad3bd3170de6">runtime: stack growth adjustments, cleanup</a> 中找到编译器插入函数的出行，最新版本的 Go 语言会通过 <a href="https://github.com/golang/go/blob/b2482e481722357c6daa98ef074d8eaf8ac4baf3/src/cmd/internal/obj/x86/obj6.go#L974"><code>cmd/internal/obj/x86.stacksplit</code></a> 插入 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L432"><code>runtime.morestack</code></a> 函数，该函数可能会调用 <a href="https://github.com/golang/go/blob/0f251028585e052a3d34dcce83b05d8aa9ba170e/src/runtime/stack.go#L918"><code>runtime.newstack</code></a> 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 <a href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a>；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li>
<li>当发生函数调用时，可能会执行编译器插入的 <a href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a> 函数，它调用的 <a href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.newstack</code></a> 会检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li>
<li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li>
</ol>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种 <strong> 协作式的抢占式调度</strong>。</p>
<h4><span id="基于信号的抢占式调度">基于信号的抢占式调度 </span></h4><p> 基于协作的抢占式调度虽然实现巧妙，但是并不完备，我们能在 <a href="https://github.com/golang/go/issues/24543">runtime: non-cooperative goroutine preemption</a> 中找到一些遗留问题：</p>
<ul>
<li><a href="https://github.com/golang/go/issues/10958">runtime: tight loops should be preemptible #10958</a></li>
<li><a href="https://github.com/golang/go/issues/17174">An empty for{} will block large slice allocation in another goroutine, even with GOMAXPROCS &gt; 1 ? #17174</a></li>
<li><a href="https://github.com/golang/go/issues/15442">runtime: tight loop hangs process completely after some time #15442</a></li>
<li>…</li>
</ul>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p>
<ul>
<li>runtime: add general suspendG/resumeG<ul>
<li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 <a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L105"><code>runtime.suspendG</code></a> 和 <a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L258"><code>runtime.resumeG</code></a> 两个函数重构栈扫描这一过程；</li>
<li>调用 <a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L105"><code>runtime.suspendG</code></a> 函数时会将处于运行状态的 Goroutine 的 <code>preemptStop</code> 标记成 <code>true</code>；</li>
<li>调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a> 函数可以挂起当前 Goroutine、将其状态更新成 <code>_Gpreempted</code> 并触发调度器的重新调度，该函数能够交出线程控制权；</li>
</ul>
</li>
<li>runtime: asynchronous preemption function for x86<ul>
<li>在 x86 架构上增加异步抢占的函数 <a href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a> 和 <a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a>；</li>
</ul>
</li>
<li>runtime: use signals to preempt Gs for suspendG<ul>
<li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li>
<li>在 <a href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L507"><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</li>
<li>实现 <a href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 函数，它可以通过 <code>SIGURG</code> 信号向线程发送抢占请求；</li>
</ul>
</li>
<li>runtime: implement async scheduler preemption<ul>
<li>修改 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4666"><code>runtime.preemptone</code></a> 函数的实现，加入异步抢占的逻辑；</li>
</ul>
</li>
</ul>
<p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p>
<ol>
<li><p>程序启动时，在 <a href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L494"><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</p>
</li>
<li><p>在触发垃圾回收的栈扫描时会调用</p>
</li>
</ol>
<p>   <code>runtime.suspendG</code></p>
<p>   挂起 Goroutine，该函数会执行下面的逻辑：</p>
<ol>
<li>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li>
<li>调用 <a href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 触发抢占；</li>
</ol>
<ol>
<li><p><a href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 会调用 <a href="https://github.com/golang/go/blob/8e0be05ec7c369387c0ed3c9cf37968c6d3afbbd/src/runtime/os_linux.go#L483"><code>runtime.signalM</code></a> 向线程发送信号 <code>SIGURG</code>；</p>
</li>
<li><p>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <a href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</p>
</li>
<li><p><a href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <a href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a>；</p>
</li>
<li><p><a href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a> 会修改寄存器并在程序回到用户态时执行 <a href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a>；</p>
</li>
<li><p>汇编指令 <a href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a> 会调用运行时函数 <a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a>；</p>
</li>
<li><p><a href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a> 会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a>；</p>
</li>
<li><p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a> 会修改当前 Goroutine 的状态到 <code>_Gpreempted</code> 并调用 <a href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2482"><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</p>
</li>
</ol>
<p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 <code>SIGURG</code> 作为触发异步抢占的信号；</p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始，相信在未来我们可以会更多的地方触发抢占。</p>
<h3><span id="非均匀内存访问调度器">非均匀内存访问调度器 </span></h3><p> 非均匀内存访问（Non-uniform memory access，NUMA）调度器现在只是 Go 语言的提案，因为该提案过于复杂，而目前的调度器的性能已经足够优异，所以我们暂时没有实现该提案。该提案的原理就是通过拆分全局资源，让各个处理器能够就近获取，减少锁竞争并增加数据的局部性。</p>
<p>在目前的运行时中，线程、处理器、网络轮询器、运行队列、全局内存分配器状态、内存分配缓存和垃圾收集器都是全局资源。运行时没有保证本地化，也不清楚系统的拓扑结构，部分结构可以提供一定的局部性，但是从全局来看没有这种保证。</p>
<p><img src="https://img.draveness.me/2020-02-02-15805792666185-go-numa-scheduler-architecture.png" alt="go-numa-scheduler-architecture"></p>
<p><strong>Go 语言 NUMA 调度器</strong></p>
<p>如上图所示，堆栈、全局运行队列和线程池会按照 NUMA 节点进行分区，网络轮询器和计时器会由单独的处理器持有。这种方式虽然能够利用局部性提高调度器的性能，但是本身的实现过于复杂，所以 Go 语言团队还没有着手实现这一提案。</p>
<h3><span id="小结">小结</span></h3><p>Go 语言的调度器在最初的几个版本中迅速迭代，但是从 1.2 版本之后调度器就没有太多的变化，直到 1.14 版本引入了真正的抢占式调度才解决了自 1.2 以来一直存在的问题。在可预见的未来，Go 语言的调度器还会进一步演进，增加触发抢占式调度的时间点以减少存在的边缘情况。</p>
<h2><span id="数据结构">数据结构 </span></h2><p> 相信各位读者已经对 Go 语言调度相关的数据结构已经非常熟悉了，但是我们在一些还是要回顾一下运行时调度器的三个重要组成部分 — 线程 M、Goroutine G 和处理器 P：</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png" alt="golang-scheduler"></p>
<ol>
<li>G — 表示 Goroutine，它是一个待执行的任务；</li>
<li>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</li>
<li>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</li>
</ol>
<p>我们会在这一节中分别介绍不同的结构体，详细介绍它们的作用、数据结构以及在运行期间可能处于的状态。</p>
<h3><span id="g">G</span></h3><p>Gorotuine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 在 Go 语言运行时使用私有结构体 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量，我们在这里也不会介绍全部字段，而是会挑选其中的一部分进行介绍，首先是与栈相关的两个字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	stack       stack
	stackguard0 <span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>stack</code> 字段描述了当前 Goroutine 的栈内存范围 <code>[stack.lo, stack.hi)</code>，另一个字段 <code>stackguard0</code> 可以用于调度器抢占式调度。除了 <code>stackguard0</code> 之外，Goroutine 中还包含另外三个与抢占密切相关的字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	preempt       <span class="token builtin">bool</span> <span class="token comment">// 抢占信号</span>
	preemptStop   <span class="token builtin">bool</span> <span class="token comment">// 抢占时将状态修改成 `_Gpreempted`</span>
	preemptShrink <span class="token builtin">bool</span> <span class="token comment">// 在同步安全点收缩栈</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Goroutine 与我们在前面章节提到的 <code>defer</code> 和 <code>panic</code> 也有千丝万缕的联系，每一个 Goroutine 上都持有两个分别存储 <code>defer</code> 和 <code>panic</code> 对应结构体的链表：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	_panic       <span class="token operator">*</span>_panic <span class="token comment">// 最内侧的 panic 结构体</span>
	_defer       <span class="token operator">*</span>_defer <span class="token comment">// 最内侧的延迟函数结构体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，我们再节选一些作者认为比较有趣或者重要的字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	m              <span class="token operator">*</span>m
	sched          gobuf
	atomicstatus   <span class="token builtin">uint32</span>
	goid           <span class="token builtin">int64</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>m</code> — 当前 Goroutine 占用的线程，可能为空；</li>
<li><code>atomicstatus</code> — Goroutine 的状态；</li>
<li><code>sched</code> — 存储 Goroutine 的调度相关的数据；</li>
<li><code>goid</code> — Goroutine 的 ID，该字段对开发者不可见，Go 团队认为引入 ID 会让部分 Goroutine 变得更特殊，从而限制语言的并发能力；</li>
</ul>
<p>上述四个字段中，我们需要展开介绍 <code>sched</code> 字段的 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L310"><code>runtime.gobuf</code></a> 结构体中包含哪些内容：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> gobuf <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	sp   <span class="token builtin">uintptr</span>
	pc   <span class="token builtin">uintptr</span>
	g    guintptr
	ret  sys<span class="token punctuation">.</span>Uintreg
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>sp</code> — 栈指针（Stack Pointer）；</li>
<li><code>pc</code> — 程序计数器（Program Counter）；</li>
<li><code>g</code> — 持有 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L310"><code>runtime.gobuf</code></a> 的 Goroutine；</li>
<li><code>ret</code> — 系统调用的返回值；</li>
</ul>
<p>这些内容会在调度器保存或者恢复上下文的时候用到，其中的栈指针和程序计数器会用来存储或者恢复寄存器中的值，改变程序即将执行的代码。</p>
<p>结构体 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 的 <code>atomicstatus</code> 字段就存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 个状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Gidle</code></td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td><code>_Grunnable</code></td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td><code>_Grunning</code></td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td><code>_Gsyscall</code></td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td><code>_Gwaiting</code></td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td><code>_Gdead</code></td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td><code>_Gcopystack</code></td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td><code>_Gpreempted</code></td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td><code>_Gscan</code></td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody>
</table>
</div>
<p>上述状态中比较常见是 <code>_Grunnable</code>、<code>_Grunning</code>、<code>_Gsyscall</code>、<code>_Gwaiting</code> 和 <code>_Gpreempted</code> 五个状态，我们会重点介绍这几个状态，Goroutine 的状态迁移是一个复杂的过程，触发 Goroutine 状态迁移的方法也很多，在这里我们也没有办法介绍全部的迁移线路，我们会从中选择一些进行介绍。</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354603-goroutine-status.png" alt="goroutine-status"></p>
<p><strong>Goroutine 的状态</strong></p>
<p>虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成最终的三种：等待中、可运行、运行中，在运行期间我们会在这三种不同的状态来回切换：</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态；</li>
<li>可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code>；</li>
</ul>
<p><img src="https://img.draveness.me/2020-02-05-15808864354615-golang-goroutine-state-transition.png" alt="golang-goroutine-state-transition"></p>
<p><strong>Goroutine 的常见状态迁移</strong></p>
<p>上图展示了 Goroutine 状态迁移的常见路径，其中包括创建 Goroutine 到 Goroutine 被执行、触发系统调用或者抢占式调度器的状态迁移过程。</p>
<h3><span id="m">M</span></h3><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p>
<p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以使用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/debug.go#L17"><code>runtime.GOMAXPROCS</code></a> 来改变程序中最大的线程数。</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354634-scheduler-m-and-thread.png" alt="scheduler-m-and-thread"></p>
<p><strong>CPU 和活跃线程</strong></p>
<p>在默认情况下，一个四核机器上会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L473"><code>runtime.m</code></a> 结构体。</p>
<p>在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。</p>
<p>操作系统线程在 Go 语言中会使用私有结构体 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L473"><code>runtime.m</code></a> 来表示，这个结构体中也包含了几十个私有的字段，我们依然对其进行了删减，先来了解几个与 Goroutine 直接相关的字段：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> m <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	g0   <span class="token operator">*</span>g 
	curg <span class="token operator">*</span>g
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 g0 是持有调度栈的 Goroutine，<code>curg</code> 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354644-g0-and-g.png" alt="g0-and-g"></p>
<p><strong>调度 Goroutine 和运行 Goroutine</strong></p>
<p>g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。在后面的小节中，我们会经常看到 g0 的身影。<a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L473"><code>runtime.m</code></a> 结构体中还存在着三个处理器字段，它们分别表示正在运行代码的处理器 <code>p</code>、暂存的处理器 <code>nextp</code> 和执行系统调用之前的使用线程的处理器 <code>oldp</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> m <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	p             puintptr
	nextp         puintptr
	oldp          puintptr
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了在上面介绍的字段之外，<a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L473"><code>runtime.m</code></a> 中还包含大量与线程状态、锁、调度、系统调用有关的字段，我们会在分析调度过程时详细介绍。</p>
<h3><span id="p">P</span></h3><p>调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以 Go 语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p><a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L548"><code>runtime.p</code></a> 是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不一一展示了，我们主要关注处理器中的线程和运行队列：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	m           muintptr

	runqhead <span class="token builtin">uint32</span>
	runqtail <span class="token builtin">uint32</span>
	runq     <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span>guintptr
	runnext guintptr
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反向存储的线程维护着线程与处理器之间的关系，而 <code>runhead</code>、<code>runqtail</code> 和 <code>runq</code> 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表，<code>runnext</code> 中是线程下一个需要执行的 Goroutine。</p>
<p><a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L548"><code>runtime.p</code></a> 结构体中的状态 <code>status</code> 字段会是以下五种中的一种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Pidle</code></td>
<td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td>
</tr>
<tr>
<td><code>_Prunning</code></td>
<td>被线程 M 持有，并且正在执行用户代码或者调度器</td>
</tr>
<tr>
<td><code>_Psyscall</code></td>
<td>没有执行用户代码，当前线程陷入系统调用</td>
</tr>
<tr>
<td><code>_Pgcstop</code></td>
<td>被线程 M 持有，当前处理器由于垃圾回收被停止</td>
</tr>
<tr>
<td><code>_Pdead</code></td>
<td>当前处理器已经不被使用</td>
</tr>
</tbody>
</table>
</div>
<p>通过分析处理器 P 的状态，我们能够对处理器的工作过程有一些简单理解，例如处理器在执行用户代码时会处于 <code>_Prunning</code> 状态，在当前线程执行 I/O 操作时会陷入 <code>_Psyscall</code> 状态。</p>
<h3><span id="小结">小结 </span></h3><p> 我们在这一小节简单介绍了 Go 语言调度器中常见的数据结构，包括线程 M、处理器 P 和 Goroutine G，它们在 Go 语言运行时中分别使用不同的私有结构体表示，我们在下面会深入分析 Go 语言调度器的实现原理。</p>
<h2><span id="调度器启动">调度器启动 </span></h2><p> 调度器的启动过程是我们平时比较难以接触的过程，不过作为程序启动前的准备工作，理解调度器的启动过程对我们理解调度器的实现原理很有帮助，运行时通过 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L532"><code>runtime.schedinit</code></a> 函数初始化调度器：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">schedinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>

	sched<span class="token punctuation">.</span>maxmcount <span class="token operator">=</span> <span class="token number">10000</span>

	<span class="token operator">...</span>
	sched<span class="token punctuation">.</span>lastpoll <span class="token operator">=</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	procs <span class="token operator">:=</span> ncpu
	<span class="token keyword">if</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">atoi32</span><span class="token punctuation">(</span><span class="token function">gogetenv</span><span class="token punctuation">(</span><span class="token string">"GOMAXPROCS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		procs <span class="token operator">=</span> n
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token function">procresize</span><span class="token punctuation">(</span>procs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"unknown runnable goroutine during bootstrap"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调度器初始函数执行的过程中会将 <code>maxmcount</code> 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数，虽然最多可以创建 10000 个线程，但是可以同时运行的线程还是由 <code>GOMAXPROCS</code> 变量控制。</p>
<p>我们从环境变量 <code>GOMAXPROCS</code> 获取了程序能够同时运行的最大处理器数之后就会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4154"><code>runtime.procresize</code></a> 更新程序中处理器的数量，在这时整个程序不会执行任何用户 Goroutine，调度器也会进入锁定状态，<a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4154"><code>runtime.procresize</code></a> 的执行过程如下：</p>
<ol>
<li>如果全局变量 <code>allp</code> 切片中的处理器数量少于期望数量，就会对切片进行扩容；</li>
<li>使用 <code>new</code> 创建新的处理器结构体并调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4026"><code>runtime.p.init</code></a> 方法初始化刚刚扩容的处理器；</li>
<li>通过指针将线程 m0 和处理器 <code>allp[0]</code> 绑定到一起；</li>
<li>调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4058"><code>runtime.p.destroy</code></a> 方法释放不再使用的处理器结构；</li>
<li>通过截断改变全局变量 <code>allp</code> 的长度保证与期望处理器数量相等；</li>
<li>将除 <code>allp[0]</code> 之外的处理器 P 全部设置成 <code>_Pidle</code> 并加入到全局的空闲队列中；</li>
</ol>
<p>调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4154"><code>runtime.procresize</code></a> 就是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p>
<h2><span id="创建-goroutine">创建 Goroutine</span></h2><p>想要启动一个新的 Goroutine 来执行任务时，我们需要使用 Go 语言中的 <code>go</code> 关键字，这个关键字会在编译期间通过以下方法 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023"><code>cmd/compile/internal/gc.state.stmt</code></a> 和 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324"><code>cmd/compile/internal/gc.state.call</code></a> 两个方法将该关键字转换成 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3376"><code>runtime.newproc</code></a> 函数调用：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>state<span class="token punctuation">)</span> <span class="token function">call</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">,</span> k callKind<span class="token punctuation">)</span> <span class="token operator">*</span>ssa<span class="token punctuation">.</span>Value <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> k <span class="token operator">==</span> callDeferStack <span class="token punctuation">&#123;</span>
		<span class="token operator">...</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> k <span class="token operator">==</span> callGo<span class="token punctuation">:</span>
			call <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">newValue1A</span><span class="token punctuation">(</span>ssa<span class="token punctuation">.</span>OpStaticCall<span class="token punctuation">,</span> types<span class="token punctuation">.</span>TypeMem<span class="token punctuation">,</span> newproc<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">mem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器会将所有的 <code>go</code> 关键字被转换成 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3376"><code>runtime.newproc</code></a> 函数，该函数会接收大小和表示函数的指针 <code>funcval</code>。在这个函数中我们还会获取 Goroutine 以及调用方的程序计数器，然后调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3388"><code>runtime.newproc1</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newproc</span><span class="token punctuation">(</span>siz <span class="token builtin">int32</span><span class="token punctuation">,</span> fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	argp <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fn<span class="token punctuation">)</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">newproc1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uint8</span><span class="token punctuation">)</span><span class="token punctuation">(</span>argp<span class="token punctuation">)</span><span class="token punctuation">,</span> siz<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> pc<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3388"><code>runtime.newproc1</code></a> 会根据传入参数初始化一个 <code>g</code> 结构体，我们可以将该函数分成以下几个部分介绍它的实现：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体；</li>
<li>将传入的参数移到 Goroutine 的栈上；</li>
<li>更新 Goroutine 调度相关的属性；</li>
<li>将 Goroutine 加入处理器的运行队列；</li>
</ol>
<p>首先是 Goroutine 结构体的创建过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> argp <span class="token operator">*</span><span class="token builtin">uint8</span><span class="token punctuation">,</span> narg <span class="token builtin">int32</span><span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	siz <span class="token operator">:=</span> narg
	siz <span class="token operator">=</span> <span class="token punctuation">(</span>siz <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">&amp;^</span> <span class="token number">7</span>

	_p_ <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	newg <span class="token operator">:=</span> <span class="token function">gfget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>
	<span class="token keyword">if</span> newg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		newg <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span>_StackMin<span class="token punctuation">)</span>
		<span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gidle<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>
		<span class="token function">allgadd</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码会先从处理器的 <code>gFree</code> 列表中查找空闲的 Goroutine，如果不存在空闲的 Goroutine，就会通过 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 函数创建一个栈大小足够的新结构体。</p>
<p>接下来，我们会调用 <a href="https://github.com/golang/go/blob/9b5bd30716914a86619c050f0d75c0da4133b257/src/runtime/memmove_386.s#L34"><code>runtime.memmove</code></a> 函数将 <code>fn</code> 函数的全部参数拷贝到栈上，<code>argp</code> 和 <code>narg</code> 分别是参数的内存空间和大小，我们在该方法中会直接将所有参数对应的内存空间整片的拷贝到栈上：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">...</span>
totalSize <span class="token operator">:=</span> <span class="token number">4</span><span class="token operator">*</span>sys<span class="token punctuation">.</span>RegSize <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>siz<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>MinFrameSize
totalSize <span class="token operator">+=</span> <span class="token operator">-</span>totalSize <span class="token operator">&amp;</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>SpAlign <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
sp <span class="token operator">:=</span> newg<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">-</span> totalSize
spArg <span class="token operator">:=</span> sp
<span class="token keyword">if</span> narg <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
	<span class="token function">memmove</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>spArg<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>argp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>narg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>拷贝了栈上的参数之后，<a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3388"><code>runtime.newproc1</code></a> 会设置新的 Goroutine 结构体的参数，包括栈指针、程序计数器并更新其状态到 <code>_Grunnable</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">...</span>
<span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">)</span>
newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>sp <span class="token operator">=</span> sp
newg<span class="token punctuation">.</span>stktopsp <span class="token operator">=</span> sp
newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>goexit<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>PCQuantum
newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">gostartcallfn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
newg<span class="token punctuation">.</span>gopc <span class="token operator">=</span> callerpc
newg<span class="token punctuation">.</span>startpc <span class="token operator">=</span> fn<span class="token punctuation">.</span>fn
<span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gdead<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
newg<span class="token punctuation">.</span>goid <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>goidcache<span class="token punctuation">)</span>
_p_<span class="token punctuation">.</span>goidcache<span class="token operator">++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在最后，该函数会将初始化好的 Goroutine 加入处理器的运行队列并在满足条件时调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L1948"><code>runtime.wakep</code></a> 函数唤醒新的处理执行 Goroutine：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">	<span class="token operator">...</span>
	<span class="token function">runqput</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> newg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mainStarted <span class="token punctuation">&#123;</span>
		<span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在分析 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3388"><code>runtime.newproc1</code></a> 函数的过程中，省略了两个比较重要的过程，分别是用于获取结构体的 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3563"><code>runtime.gfget</code></a>、<a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 函数、将 Goroutine 加入运行队列的 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4949"><code>runtime.runqput</code></a> 以及调度信息的设置过程。</p>
<h3><span id="初始化结构体">初始化结构体</span></h3><p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3563"><code>runtime.gfget</code></a> 通过两种不同的方式获取新的 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 结构体：</p>
<ol>
<li>从 Goroutine 所在处理器的 <code>gFree</code> 列表或者调度器的 <code>sched.gFree</code> 列表中获取 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 结构体；</li>
<li>调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 函数生成一个新的 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 函数并将当前结构体追加到全局的 Goroutine 列表 <code>allgs</code> 中。</li>
</ol>
<p><img src="https://img.draveness.me/golang-newproc-get-goroutine.png" alt="golang-newproc-get-goroutine"></p>
<p><strong>获取 Goroutine 结构体的三种方法</strong></p>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3563"><code>runtime.gfget</code></a> 中包含两部分逻辑，它会根据处理器中 <code>gFree</code> 列表中 Goroutine 的数量做出不同的决策：</p>
<ol>
<li>当处理器的 Goroutine 列表为空时，会将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 <code>gFree</code> 列表中的 Goroutine 数量达到 32；</li>
<li>当处理器的 Goroutine 数量充足时，会从列表头部返回一个新的 Goroutine；</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gfget</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">&#123;</span>
retry<span class="token punctuation">:</span>
	<span class="token keyword">if</span> _p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>sched<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>sched<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>noStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> _p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>n <span class="token operator">&lt;</span> <span class="token number">32</span> <span class="token punctuation">&#123;</span>
			gp <span class="token operator">:=</span> sched<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
				gp <span class="token operator">=</span> sched<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>noStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
					<span class="token keyword">break</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			_p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">goto</span> retry
	<span class="token punctuation">&#125;</span>
	gp <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> gp
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当调度器的 <code>gFree</code> 和处理器的 <code>gFree</code> 列表都不存在结构体时，运行时会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 初始化一个新的 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L395"><code>runtime.g</code></a> 结构体，如果申请的堆栈大小大于 0，在这里我们会通过 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/stack.go#L324"><code>runtime.stackalloc</code></a> 分配 2KB 的栈空间：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">malg</span><span class="token punctuation">(</span>stacksize <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">&#123;</span>
	newg <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>
	<span class="token keyword">if</span> stacksize <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		stacksize <span class="token operator">=</span> <span class="token function">round2</span><span class="token punctuation">(</span>_StackSystem <span class="token operator">+</span> stacksize<span class="token punctuation">)</span>
		newg<span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token function">stackalloc</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">)</span>
		newg<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> newg<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard
		newg<span class="token punctuation">.</span>stackguard1 <span class="token operator">=</span> <span class="token operator">^</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> newg
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 返回的 Goroutine 会存储到全局变量 <code>allgs</code> 中。</p>
<p>简单总结一下，<a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3388"><code>runtime.newproc1</code></a> 会从处理器或者调度器的缓存中获取新的结构体，也可以调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3353"><code>runtime.malg</code></a> 函数创建新的结构体。</p>
<h3><span id="运行队列">运行队列</span></h3><p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4949"><code>runtime.runqput</code></a> 函数会将新创建的 Goroutine 运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">runqput</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">,</span> gp <span class="token operator">*</span>g<span class="token punctuation">,</span> next <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> next <span class="token punctuation">&#123;</span>
	retryNext<span class="token punctuation">:</span>
		oldnext <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>runnext
		<span class="token keyword">if</span> <span class="token operator">!</span>_p_<span class="token punctuation">.</span>runnext<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>oldnext<span class="token punctuation">,</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">goto</span> retryNext
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> oldnext <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">&#125;</span>
		gp <span class="token operator">=</span> oldnext<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
retry<span class="token punctuation">:</span>
	h <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadAcq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runqhead<span class="token punctuation">)</span>
	t <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>runqtail
	<span class="token keyword">if</span> t<span class="token operator">-</span>h <span class="token operator">&lt;</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		_p_<span class="token punctuation">.</span>runq<span class="token punctuation">[</span>t<span class="token operator">%</span><span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
		atomic<span class="token punctuation">.</span><span class="token function">StoreRel</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runqtail<span class="token punctuation">,</span> t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token function">runqputslow</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> h<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">goto</span> retry
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>当 <code>next</code> 为 <code>true</code> 时，将 Goroutine 设置到处理器的 <code>runnext</code> 上作为下一个处理器执行的任务；</li>
<li>当 <code>next</code> 为 <code>false</code> 并且本地运行队列还有剩余空间时，将 Goroutine 加入处理器持有的本地运行队列；</li>
<li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 <code>runqputslow</code> 添加到调度器持有的全局运行队列上；</li>
</ol>
<p>处理器本地的运行队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p>
<p><img src="https://i.loli.net/2020/09/11/pnUmLD2SxOdeXwM.png" alt="golang-runnable-queue"></p>
<p><strong>全局和本地运行队列</strong></p>
<p>简单总结一下，Go 语言中有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列。</p>
<h3><span id="调度信息">调度信息 </span></h3><p> 运行时创建 Goroutine 时会通过下面的代码设置调度相关的信息，前两行代码会分别将程序计数器和 Goroutine 设置成 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 函数和新创建的 Goroutine：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">...</span>
newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>goexit<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>PCQuantum
newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">gostartcallfn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
<span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这里的调度信息 <code>sched</code> 不是初始化后的 Goroutine 的最终结果，经过 <a href="https://github.com/golang/go/blob/0f251028585e052a3d34dcce83b05d8aa9ba170e/src/runtime/stack.go#L1058"><code>runtime.gostartcallfn</code></a> 和 <a href="https://github.com/golang/go/blob/03ef105daeff4fef1fd66dbffb8e17d1f779b9ea/src/runtime/sys_x86.go#L16"><code>runtime.gostartcall</code></a> 两个函数的处理：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gostartcallfn</span><span class="token punctuation">(</span>gobuf <span class="token operator">*</span>gobuf<span class="token punctuation">,</span> fv <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">gostartcall</span><span class="token punctuation">(</span>gobuf<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>fv<span class="token punctuation">.</span>fn<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>fv<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">gostartcall</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>gobuf<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> ctxt unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sp <span class="token operator">:=</span> buf<span class="token punctuation">.</span>sp
	<span class="token keyword">if</span> sys<span class="token punctuation">.</span>RegSize <span class="token operator">></span> sys<span class="token punctuation">.</span>PtrSize <span class="token punctuation">&#123;</span>
		sp <span class="token operator">-=</span> sys<span class="token punctuation">.</span>PtrSize
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
	sp <span class="token operator">-=</span> sys<span class="token punctuation">.</span>PtrSize
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> buf<span class="token punctuation">.</span>pc
	buf<span class="token punctuation">.</span>sp <span class="token operator">=</span> sp
	buf<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
	buf<span class="token punctuation">.</span>ctxt <span class="token operator">=</span> ctxt
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调度信息的 <code>sp</code> 中存储了 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 函数的程序计数器，而 <code>pc</code> 中存储了传入函数的程序计数器。因为 <code>pc</code> 寄存器的作用就是存储程序接下来运行的位置，所以这里 <code>pc</code> 的使用比较好理解，但是 <code>sp</code> 中存储的 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 就会让人感到困惑，我们需要配合下面的调度循环来理解 <code>sp</code> 的作用。</p>
<h2><span id="调度循环">调度循环 </span></h2><p> 调度器启动之后，Go 语言运行时会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L1041"><code>runtime.mstart</code></a> 以及 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L1075"><code>runtime.mstart1</code></a>，前者会初始化 g0 的 <code>stackguard0</code> 和 <code>stackguard1</code> 字段，后者会初始化线程并调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 进入调度循环：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

top<span class="token punctuation">:</span>
	<span class="token keyword">var</span> gp <span class="token operator">*</span>g
	<span class="token keyword">var</span> inheritTime <span class="token builtin">bool</span>

	<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">%</span><span class="token number">61</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
			gp <span class="token operator">=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 函数的会从不同地方查找待执行的 Goroutine：</p>
<ol>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 <code>schedtick</code> 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，就会通过 <a href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2111"><code>runtime.findrunnable</code></a> 进行阻塞地查找 Goroutine；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2111"><code>runtime.findrunnable</code></a> 函数的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：</p>
<ol>
<li>从本地运行队列、全局运行队列中查找；</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行；</li>
<li>通过 <a href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L5147"><code>runtime.runqsteal</code></a> 函数尝试从其他随机的处理器中窃取待运行的 Goroutine，在该过程中还可能窃取处理器中的计时器；</li>
</ol>
<p>因为函数的实现过于复杂，上述执行过程是经过大量简化的，总而言之，当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。</p>
<p>接下来由 <a href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2076"><code>runtime.execute</code></a> 函数执行获取的 Goroutine，做好准备工作后，它会通过 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L301"><code>runtime.gogo</code></a> 将 Goroutine 调度到当前线程上。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">execute</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token operator">=</span> gp
	gp<span class="token punctuation">.</span>m <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>waitsince <span class="token operator">=</span> <span class="token number">0</span>
	gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>
	gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard
	<span class="token keyword">if</span> <span class="token operator">!</span>inheritTime <span class="token punctuation">&#123;</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">++</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>sched<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L301"><code>runtime.gogo</code></a> 在不同处理器架构上的实现都不同，但是不同的实现也都大同小异，下面是该函数在 386 架构上的实现：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">TEXT runtime·<span class="token function">gogo</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> NOSPLIT<span class="token punctuation">,</span> $<span class="token number">8</span><span class="token operator">-</span><span class="token number">4</span>
	MOVL buf<span class="token operator">+</span><span class="token function">0</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> BX     <span class="token comment">// 获取调度信息</span>
	MOVL <span class="token function">gobuf_g</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> DX
	MOVL <span class="token function">0</span><span class="token punctuation">(</span>DX<span class="token punctuation">)</span><span class="token punctuation">,</span> CX         <span class="token comment">// 保证 Goroutine 不为空</span>
	<span class="token function">get_tls</span><span class="token punctuation">(</span>CX<span class="token punctuation">)</span>
	MOVL DX<span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span>CX<span class="token punctuation">)</span>
	MOVL <span class="token function">gobuf_sp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> SP  <span class="token comment">// 将 runtime.goexit 函数的 PC 恢复到 SP 中</span>
	MOVL <span class="token function">gobuf_ret</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX
	MOVL <span class="token function">gobuf_ctxt</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> DX
	MOVL $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">gobuf_sp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
	MOVL $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">gobuf_ret</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
	MOVL $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">gobuf_ctxt</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
	MOVL <span class="token function">gobuf_pc</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> BX  <span class="token comment">// 获取待执行函数的程序计数器</span>
	JMP  BX                <span class="token comment">// 开始执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数的实现非常巧妙，它从 <a href="https://github.com/golang/go/blob/753d56d3642eb83848aa39e65982a9fc77e722d7/src/runtime/runtime2.go#L310"><code>runtime.gobuf</code></a> 中取出了 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 的程序计数器和待执行函数的程序计数器，其中：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 的程序计数器被放到了栈 SP 上；</li>
<li>待执行函数的程序计数器被放到了寄存器 BX 上；</li>
</ul>
<p>在函数调用一节中，我们曾经介绍过 Go 语言的调用惯例，正常的函数调用都会使用 <code>CALL</code> 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。</p>
<p><a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L301"><code>runtime.gogo</code></a> 就利用了 Go 语言的调用惯例成功模拟这一调用过程，通过以下几个关键指令模拟 <code>CALL</code> 的过程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">MOVL <span class="token function">gobuf_sp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> SP  <span class="token comment">// 将 runtime.goexit 函数的 PC 恢复到 SP 中</span>
MOVL <span class="token function">gobuf_pc</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> BX  <span class="token comment">// 获取待执行函数的程序计数器</span>
JMP  BX                <span class="token comment">// 开始执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.draveness.me/2020-02-05-15808864354661-golang-gogo-stack.png" alt="golang-gogo-stack"></p>
<p><strong>runtime.gogo 栈内存</strong></p>
<p>上图展示了调用 <code>JMP</code> 指令后的栈中数据，当 Goroutine 中运行的函数返回时就会跳转到 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1336"><code>runtime.goexit</code></a> 所在位置执行该函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">TEXT runtime·<span class="token function">goexit</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">0</span>
	CALL	runtime·<span class="token function">goexit1</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过套娃似的一系列函数调用，我们最终在当前线程的 g0 的栈上调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2792"><code>runtime.goexit0</code></a> 函数，该函数会将 Goroutine 转换会 <code>_Gdead</code> 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3528"><code>runtime.gfput</code></a> 重新加入处理器的 Goroutine 空闲列表 <code>gFree</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goexit0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token operator">...</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>labels <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token boolean">nil</span>

	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在最后 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2792"><code>runtime.goexit0</code></a> 函数会重新调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 触发新的 Goroutine 调度，我们可以认为调度循环永远都不会返回。</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354669-golang-scheduler-loop.png" alt="golang-scheduler-loop"></p>
<p><strong>调度循环</strong></p>
<p>Go 语言中的运行时调度循环会从 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 函数开始，最终又回到 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a>；这里介绍的是 Goroutine 正常执行并退出的逻辑，实际情况会复杂得多，多数情况下 Goroutine 的执行的过程中都会经历协作式或者抢占式调度，这时会让出线程的使用权等待调度器的唤醒。</p>
<h2><span id="触发调度">触发调度 </span></h2><p> 调度器的 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 函数重新选择 Goroutine 在线程上执行，所以我们只要找到该函数的调用方就能找到所有触发调度的时间点，经过分析和整理，我们能得到如下的树形结构：</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354679-schedule-points.png" alt="schedule-points"></p>
<p><strong>调度时间点</strong></p>
<p>除了上图中可能触发调度的时间点，运行时还会在线程启动 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L1041"><code>runtime.mstart</code></a> 和 Goroutine 执行结束 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2792"><code>runtime.goexit0</code></a> 触发调度。我们在这里会重点介绍运行时触发调度的几个路径：</p>
<ul>
<li>主动挂起 — <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287"><code>runtime.gopark</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2668"><code>runtime.park_m</code></a></li>
<li>系统调用 — <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3074"><code>runtime.exitsyscall</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3236"><code>runtime.exitsyscall0</code></a></li>
<li>协作式调度 — <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L267"><code>runtime.Gosched</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2709"><code>runtime.gosched_m</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2693"><code>runtime.goschedImpl</code></a></li>
<li>系统监控 — <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4455"><code>runtime.sysmon</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4569"><code>runtime.retake</code></a> -&gt; <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L4666"><code>runtime.preemptone</code></a></li>
</ul>
<p>我们在这里介绍的调度时间点不是直接将线程的运行权交给其他任务，而是通过调度器的 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 重新调度。</p>
<h3><span id="主动挂起">主动挂起</span></h3><p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287"><code>runtime.gopark</code></a> 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列，我们来分析该函数的实现原理：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gopark</span><span class="token punctuation">(</span>unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> lock unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> reason waitReason<span class="token punctuation">,</span> traceEv <span class="token builtin">byte</span><span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	gp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>curg
	mp<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> lock
	mp<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> unlockf
	gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> reason
	mp<span class="token punctuation">.</span>waittraceev <span class="token operator">=</span> traceEv
	mp<span class="token punctuation">.</span>waittraceskip <span class="token operator">=</span> traceskip
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>park_m<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数会通过 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L320"><code>runtime.mcall</code></a> 在切换到 g0 的栈上调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2668"><code>runtime.park_m</code></a> 函数：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">park_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>
	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数会将当前 Goroutine 的状态从 <code>_Grunning</code> 切换至 <code>_Gwaiting</code>，调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2571"><code>runtime.dropg</code></a> 移除线程和 Gorooutine 之间的关联，在这之后就可以调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 触发新一轮的调度了。</p>
<p>当 Goroutine 等待的特定条件满足后，运行时会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313"><code>runtime.goready</code></a> 将因为调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287"><code>runtime.gopark</code></a> 而陷入休眠的 Goroutine 唤醒。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goready</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">ready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> traceskip<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">ready</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">,</span> next <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
	<span class="token function">runqput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
	<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L658"><code>runtime.ready</code></a> 会将准备就绪的 Goroutine 的状态切换至 <code>_Grunnable</code> 并将其加入处理器的运行队列中，等待调度器的调度。</p>
<h3><span id="系统调用">系统调用 </span></h3><p> 系统调用也会触发运行时调度器的调度，为了处理特殊的系统调用，我们甚至在 Goroutine 中加入了 <code>_Gsyscall</code> 状态，Go 语言通过 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L18"><code>syscall.Syscall</code></a> 和 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L69"><code>syscall.RawSyscall</code></a> 等使用汇编语言编写的方法封装了操作系统提供的所有系统调用，其中 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L18"><code>syscall.Syscall</code></a> 的实现如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">#define INVOKE_SYSCALL	INT	$<span class="token number">0x80</span>

TEXT ·<span class="token function">Syscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">28</span>
	CALL	runtime·<span class="token function">entersyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	<span class="token operator">...</span>
	INVOKE_SYSCALL
	<span class="token operator">...</span>
	CALL	runtime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	RET
ok<span class="token punctuation">:</span>
	<span class="token operator">...</span>
	CALL	runtime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在通过汇编指令 <code>INVOKE_SYSCALL</code> 执行系统调用前后，上述函数会调用运行时的 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2980"><code>runtime.entersyscall</code></a> 和 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3074"><code>runtime.exitsyscall</code></a>，正是这一层包装能够让我们在陷入系统调用前触发运行时的准备和清理工作。</p>
<p><img src="https://img.draveness.me/2020-02-05-15808864354688-golang-syscall-and-rawsyscall.png" alt="golang-syscall-and-rawsyscal"></p>
<p><strong>图 6-38 Go 语言系统调用</strong></p>
<p>不过出于性能的考虑，如果这次系统调用不需要运行时参与，就会使用 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L69"><code>syscall.RawSyscall</code></a> 简化这一过程，不再调用运行时函数。<a href="https://gist.github.com/draveness/50c88883f30fa99d548cf1163c98aeb1">这里 </a> 包含 Go 语言对 Linux 386 架构上不同系统调用的分类，我们会按需决定是否需要运行时的参与：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>SYS_TIME</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_GETTIMEOFDAY</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_SETRLIMIT</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_GETRLIMIT</td>
<td>RawSyscall</td>
</tr>
<tr>
<td>SYS_EPOLL_WAIT</td>
<td>Syscall</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>由于直接进行系统调用会阻塞当前的线程，所以只有可以立刻返回的系统调用才可能会被设置成 <code>RawSyscall</code> 类型，例如：<code>SYS_EPOLL_CREATE</code>、<code>SYS_EPOLL_WAIT</code>（超时时间为 0）、<code>SYS_TIME</code> 等。</p>
<p>正常的系统调用过程相比之下比较复杂，接下来我们将分别介绍进入系统调用前的准备工作和系统调用结束后的收尾工作。</p>
<h4><span id="准备工作">准备工作</span></h4><p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2980"><code>runtime.entersyscall</code></a> 函数会在获取当前程序计数器和栈位置之后调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2913"><code>runtime.reentersyscall</code></a>，它会完成 Goroutine 进入系统调用前的准备工作：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reentersyscall</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">++</span>
	_g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt
	_g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">true</span>

	<span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> sp
	_g_<span class="token punctuation">.</span>syscallpc <span class="token operator">=</span> pc
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">)</span>

	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>syscalltick <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mcache <span class="token operator">=</span> <span class="token boolean">nil</span>
	pp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pp<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token number">0</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">0</span>
	atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>status<span class="token punctuation">,</span> _Psyscall<span class="token punctuation">)</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token function">systemstack</span><span class="token punctuation">(</span>entersyscall_gcwait<span class="token punctuation">)</span>
		<span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>禁止线程上发生的抢占，防止出现内存不一致的问题；</li>
<li>保证当前函数不会触发栈分裂或者增长；</li>
<li>保存当前的程序计数器 PC 和栈指针 SP 中的内容；</li>
<li>将 Goroutine 的状态更新至 <code>_Gsyscall</code>；</li>
<li>将 Goroutine 的处理器和线程暂时分离并更新处理器的状态到 <code>_Psyscall</code>；</li>
<li>释放当前线程上的锁；</li>
</ol>
<p>需要注意的是 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2913"><code>runtime.reentersyscall</code></a> 方法会使处理器和线程的分离，当前线程会陷入系统调用等待返回，当前线程上的锁被释放后，会有其他 Goroutine 抢占处理器资源。</p>
<h4><span id="恢复工作">恢复工作 </span></h4><p> 当系统调用结束后，会调用退出系统调用的函数 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3074"><code>runtime.exitsyscall</code></a> 为当前 Goroutine 重新分配资源，该函数有两个不同的执行路径：</p>
<ol>
<li>调用 <code>exitsyscallfast</code> 函数；</li>
<li>切换至调度器的 Goroutine 并调用 <code>exitsyscall0</code> 函数：</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	oldp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">if</span> <span class="token function">exitsyscallfast</span><span class="token punctuation">(</span>oldp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>
		<span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
		<span class="token operator">...</span>

		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">mcall</span><span class="token punctuation">(</span>exitsyscall0<span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>
	_g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两种不同的路径会分别通过不同的方法查找一个用于执行当前 Goroutine 处理器 P，快速路径 <a href="https://github.com/golang/go/blob/cf630586ca5901f4aa7817a536209f2366f9c944/src/runtime/proc.go#L3070-L3107"><code>exitsyscallfast</code></a> 中包含两个不同的分支：</p>
<ol>
<li>如果 Goroutine 的原处理器处于 <code>_Psyscall</code> 状态，就会直接调用 <code>wirep</code> 将 Goroutine 与处理器进行关联；</li>
<li>如果调度器中存在闲置的处理器，就会调用 <code>acquirep</code> 函数使用闲置的处理器处理当前 Goroutine；</li>
</ol>
<p>另一个相对较慢的路径 <a href="https://github.com/golang/go/blob/cf630586ca5901f4aa7817a536209f2366f9c944/src/runtime/proc.go#L3151-L3179"><code>exitsyscall0</code></a> 就会将当前 Goroutine 切换至 <code>_Grunnable</code> 状态，并移除线程 M 和当前 Goroutine 的关联：</p>
<ol>
<li>当我们通过 <code>pidleget</code> 获取到闲置的处理器时就会在该处理器上执行 Goroutine；</li>
<li>在其它情况下，我们会将当前 Goroutine 放到全局的运行队列中，等待调度器的调度；</li>
</ol>
<p>无论哪种情况，我们在这个函数中都会调用 <code>schedule</code> 函数触发调度器的调度，我们在上一节中已经介绍过调度器的调度过程，所以在这里就不展开介绍了。</p>
<h3><span id="协作式调度">协作式调度 </span></h3><p> 我们在设计原理中介绍过了 Go 语言基于协作式和信号的两种抢占式调度，在这里我们介绍 Go 语言中的协作式调度。<a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L267"><code>runtime.Gosched</code></a> 就是主动让出处理器，允许其他 Goroutine 运行。该函数无法挂起 Goroutine，调度器会在自动调度当前 Goroutine：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">checkTimeouts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>gosched_m<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">gosched_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">goschedImpl</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">goschedImpl</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token function">globrunqput</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>

	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过连续几次跳转，我们最终在 g0 的栈上调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2693"><code>runtime.goschedImpl</code></a> 函数，运行时会更新 Goroutine 的状态到 <code>_Grunnable</code>，让出当前的处理器并将 Goroutine 重新放回全局队列，在最后，该函数会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2446"><code>runtime.schedule</code></a> 重新触发调度。</p>
<h2><span id="线程管理">线程管理</span></h2><p>Go 语言的运行时会通过调度器改变线程的所有权，它也提供了 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3656"><code>runtime.LockOSThread</code></a> 和 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3708"><code>runtime.UnlockOSThread</code></a> 让我们有能力绑定 Goroutine 和线程完成一些比较特殊的操作。Goroutine 应该在调用操作系统服务或者依赖线程状态的非 Go 语言库时调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3656"><code>runtime.LockOSThread</code></a> 函数，例如：C 语言图形库等。</p>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3656"><code>runtime.LockOSThread</code></a> 会通过如下所示的代码绑定 Goroutine 和当前线程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newmHandoff<span class="token punctuation">.</span>haveTemplateThread<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> GOOS <span class="token operator">!=</span> <span class="token string">"plan9"</span> <span class="token punctuation">&#123;</span>
		<span class="token function">startTemplateThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt<span class="token operator">++</span>
	<span class="token function">dolockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">dolockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_g_<span class="token punctuation">)</span>
	_g_<span class="token punctuation">.</span>lockedm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3631"><code>runtime.dolockOSThread</code></a> 会分别设置线程的 <code>lockedg</code> 字段和 Goroutine 的 <code>lockedm</code> 字段，这两行代码会绑定线程和 Goroutine。</p>
<p>当 Goroutine 完成了特定的操作之后，就会调用以下函数 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3708"><code>runtime.UnlockOSThread</code></a> 分离 Goroutine 和线程：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">UnlockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt<span class="token operator">--</span>
	<span class="token function">dounlockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">dounlockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedInt <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg <span class="token operator">=</span> <span class="token number">0</span>
	_g_<span class="token punctuation">.</span>lockedm <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数执行的过程与 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L3656"><code>runtime.LockOSThread</code></a> 正好相反。在多数的服务中，我们都用不到这一对函数，不过使用 CGO 或者经常与操作系统打交道的读者可能会见到它们的身影。</p>
<h2><span id="小结">小结</span></h2><p>Goroutine 和调度器是 Go 语言能够高效地处理任务并且最大化利用资源的基础，本节介绍了 Go 语言用于处理并发任务的 G - M - P 模型，我们不仅介绍了它们各自的数据结构以及常见状态，还通过特定场景介绍调度器的工作原理以及不同数据结构之间的协作关系，相信能够帮助各位读者理解调度器的实现。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 面试题详解</title>
    <url>/2017/09/09/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>总结一波 MySQL 面试题。</p>
<a id="more"></a>
<h2><span id="数据库基础知识">数据库基础知识 </span></h2><h3><span id="为什么要使用数据库"> 为什么要使用数据库 </span></h3><p><strong> 数据保存在内存</strong></p>
<p>优点： 存取速度快</p>
<p>缺点： 数据不能永久保存</p>
<p><strong>数据保存在文件</strong></p>
<p>优点： 数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的 IO 操作。2）查询数据不方便</p>
<p><strong>数据保存在数据库</strong></p>
<p>1）数据永久保存</p>
<p>2）使用 SQL 语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
<h3><span id="什么是-sql">什么是 SQL？</span></h3><p>结构化查询语言 (Structured Query Language) 简称 SQL，是一种数据库查询语言。</p>
<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h3><span id="什么是-mysql">什么是 MySQL?</span></h3><p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL 是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在 Java 企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h3><span id="数据库三大范式是什么">数据库三大范式是什么 </span></h3><p> 第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h3><span id="mysql-有关权限的表都有哪几个">mysql 有关权限的表都有哪几个</span></h3><p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由 mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db 权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv 权限表：记录数据表级的操作权限。</li>
<li>columns_priv 权限表：记录数据列级的操作权限。</li>
<li>host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和 REVOKE 语句的影响。</li>
</ul>
<h3><span id="mysql-的-binlog-有有几种录入格式分别有什么区别">MySQL 的 binlog 有有几种录入格式？分别有什么区别？</span></h3><p>有三种格式，statement，row 和 mixed。</p>
<ul>
<li>statement 模式下，每一条会修改数据的 sql 都会记录在 binlog 中。不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高性能。由于 sql 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row 级别下，不记录 sql 语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如 alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用 row。</li>
</ul>
<p>此外，新版的 MySQL 中对 row 级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h2><span id="数据类型">数据类型</span></h2><h3><span id="mysql-有哪些数据类型">mysql 有哪些数据类型</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8 位二进制)</td>
</tr>
<tr>
<td></td>
<td>smallint</td>
<td>小的整数(16 位二进制)</td>
</tr>
<tr>
<td></td>
<td>mediumint</td>
<td>中等大小的整数(24 位二进制)</td>
</tr>
<tr>
<td></td>
<td>int(integer)</td>
<td>普通大小的整数(32 位二进制)</td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td>datetime</td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td>CHAR(M)</td>
<td>M 为 0~255 之间的整数</td>
</tr>
<tr>
<td></td>
<td>VARCHAR(M)</td>
<td>M 为 0~65535 之间的整数</td>
</tr>
<tr>
<td></td>
<td>TINYBLOB</td>
<td>允许长度 0~255 字节</td>
</tr>
<tr>
<td></td>
<td>BLOB</td>
<td>允许长度 0~65535 字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMBLOB</td>
<td>允许长度 0~167772150 字节</td>
</tr>
<tr>
<td></td>
<td>LONGBLOB</td>
<td>允许长度 0~4294967295 字节</td>
</tr>
<tr>
<td></td>
<td>TINYTEXT</td>
<td>允许长度 0~255 字节</td>
</tr>
<tr>
<td></td>
<td>TEXT</td>
<td>允许长度 0~65535 字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMTEXT</td>
<td>允许长度 0~167772150 字节</td>
</tr>
<tr>
<td></td>
<td>LONGTEXT</td>
<td>允许长度 0~4294967295 字节</td>
</tr>
<tr>
<td></td>
<td>VARBINARY(M)</td>
<td>允许长度 0~M 个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td>BINARY(M)</td>
<td>允许长度 0~M 个字节的定长字节字符串</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>1、整数类型 </code>，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3 字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整数。<br><code> 长度 </code>：整数类型可以被指定长度，例如：INT(11) 表示长度为 11 的 INT 类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配合使用才有意义。<br><code>例子</code>，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数据库实际存储数据为 00012。</p>
</li>
<li><p><code>2、实数类型 </code>，包括 FLOAT、DOUBLE、DECIMAL。<br>DECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。<br> 而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。</p>
</li>
<li><p><code>3、字符串类型</code>，包括 VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR 用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2 字节表示。<br>VARCHAR 存储的内容超出设置的长度时，内容会被截断。<br>CHAR 是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR 会根据需要使用空格进行填充方便比较。<br>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR 存储的内容超出设置的长度时，内容同样会被截断。</p>
<p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。<br>对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p>
</li>
<li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br>有时可以使用 ENUM 代替常用的字符串类型。<br>ENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM 在内部存储时，其实存的是整数。<br>尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>
</li>
<li><p><code>5、日期和时间类型 </code>，尽量使用 timestamp，空间效率高于 datetime，<br> 用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用 bigint 存储。<br>看到这里，这道真题是不是就比较容易回答了。</p>
</li>
</ul>
<h2><span id="引擎">引擎 </span></h2><h3><span id="mysql-存储引擎-myisam-与-innodb-区别">MySQL 存储引擎 MyISAM 与 InnoDB 区别</span></h3><p> 存储引擎 Storage engine：MySQL 中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ul>
<li><strong>Innodb 引擎</strong>：Innodb 引擎提供了对数据库 ACID 事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyIASM 引擎</strong>(原本 Mysql 的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY 引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<p><strong>MyISAM 与 InnoDB 区别</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm- 表格定义、MYD(MYData)- 数据文件、MYI(MYIndex)- 索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM 可被压缩，存储空间较小</td>
<td>InnoDB 的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于 MyISAM 的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十 G 的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL 锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM 更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB 更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam 更快，因为 myisam 内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+ 树索引，myisam 是堆表</td>
<td>B+ 树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="myisam-索引与-innodb-索引的区别">MyISAM 索引与 InnoDB 索引的区别？</span></h3><ul>
<li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</li>
<li>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3><span id="innodb-引擎的-4-大特性">InnoDB 引擎的 4 大特性</span></h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3><span id="存储引擎选择">存储引擎选择 </span></h3><p> 如果没有特别的需求，使用默认的 <code>Innodb</code> 即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如 OA 自动化办公系统。</p>
<h2><span id="索引">索引 </span></h2><h3><span id="什么是索引"> 什么是索引？</span></h3><p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+ 树。</p>
<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>
<h3><span id="索引有哪些优缺点">索引有哪些优缺点？</span></h3><p>索引的优点</p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增 / 改 / 删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3><span id="索引使用场景重点">索引使用场景（重点）</span></h3><p>where</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI?x-oss-process=image/format,png" alt="img"></p>
<p>上图中，根据 <code>id</code> 查询记录，因为 <code>id</code> 字段仅建立了主键索引，因此此 SQL 执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 增加一个没有建立索引的字段</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> innodb1 <span class="token keyword">add</span> sex <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 按 sex 检索时可选的索引为 null</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb1 <span class="token keyword">where</span> sex<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span>
<span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk?x-oss-process=image/format,png" alt="img"></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的 SQL 执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<p>order by</p>
<p>当我们使用 <code>order by</code> 将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引 <code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong> 取出索引表某个范围内的索引对应的数据 </strong>，而不用像上述那<strong> 取出所有数据 </strong> 进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<p>join</p>
<blockquote>
<p>对 <code>join</code> 语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p>
</blockquote>
<p>索引覆盖</p>
<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在 <code>select</code> 后只写必要的查询字段，以增加索引覆盖的几率。</p>
<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>
<h3><span id="索引有哪几种类型">索引有哪几种类型？</span></h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为 NULL 值。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD INDEX index_name (column);</code> 创建普通索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code> 创建组合索引</li>
</ul>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD FULLTEXT (column);</code> 创建全文索引</li>
</ul>
<h3><span id="索引的数据结构b-树hash">索引的数据结构（b 树，hash）</span></h3><p>索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 <strong>Hash 索引</strong>，<strong>B+ 树索引</strong> 等，而我们经常使用的 InnoDB 存储引擎的默认索引实现为：B+ 树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 BTree 索引。</p>
<p>1）B 树索引</p>
<p>mysql 通过存储引擎取数据，基本上 90% 的人用的就是 InnoDB 了，按照实现方式分，InnoDB 的索引类型目前只有两种：BTREE（B 树）索引和 HASH 索引。B 树索引是 Mysql 数据库中使用最频繁的索引类型，基本所有存储引擎都支持 BTree 索引。通常我们说的索引不出意外指的就是（B 树）索引（实际是用 B+ 树实现的，因为在查看表索引时，mysql 一律打印 BTREE，所以简称为 B 树索引）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img"></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的 id 的地址, 然后再到达上面的地址)。所以按主键查询, 速度最快</p>
<p>B+tree 性质：</p>
<p>1.）n 棵子 tree 的节点包含 n 个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>
<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+ 树有 2 个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>2）哈希索引</p>
<p>简要说下，类似于数据结构中简单实现的 HASH 表（散列表）一样，当我们在 mysql 中用哈希索引时，主要就是通过 Hash 算法（常见的 Hash 算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的 Hash 值，与这条数据的行指针一并存入 Hash 表的对应位置；如果发生 Hash 碰撞（两个不同关键字的 Hash 值相同），则在对应 Hash 键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img"></p>
<h3><span id="索引的基本原理">索引的基本原理 </span></h3><p> 索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h3><span id="索引算法有哪些">索引算法有哪些？</span></h3><p>索引算法有 BTree 算法和 Hash 算法</p>
<p><strong>BTree 算法</strong></p>
<p>BTree 是最常用的 mysql 数据库索引算法，也是 mysql 默认的算法。因为它不仅可以被用在 =,&gt;,&gt;=,&lt;,&lt;= 和 between 这些比较操作符上，而且还可以用于 like 操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 只要它的查询条件是一个不以通配符开头的常量</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'jack%'</span><span class="token punctuation">;</span> 
<span class="token comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%jack'</span><span class="token punctuation">;</span> 
<span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Hash 算法</strong></p>
<p>Hash Hash 索引只能用于对等比较，例如 =,&lt;=&gt;（相当于 =）操作符。由于是一次定位数据，不像 BTree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次 IO 访问，所以检索效率远高于 BTree 索引。</p>
<h3><span id="索引设计的原则">索引设计的原则？</span></h3><ol>
<li>适合索引的列是出现在 where 子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h3><span id="创建索引的原则重中之重">创建索引的原则（重中之重）</span></h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>
<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql 会一直向右匹配直到遇到范围查询 (&gt;、&lt;、between、like) 就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
<p>8）对于定义为 text、image 和 bit 的数据类型的列不要建立索引。</p>
<h3><span id="创建索引的三种方式删除索引">创建索引的三种方式，删除索引 </span></h3><p> 第一种方式：在执行 CREATE TABLE 时创建索引</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> user_index2 <span class="token punctuation">(</span>
	id <span class="token keyword">INT</span> <span class="token keyword">auto_increment</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
	first_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	last_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	id_card <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	information <span class="token keyword">text</span><span class="token punctuation">,</span>
	<span class="token keyword">KEY</span> name <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">,</span>
	FULLTEXT <span class="token keyword">KEY</span> <span class="token punctuation">(</span>information<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id_card<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12345678910</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二种方式：使用 ALTER TABLE 命令去增加索引</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。</p>
<p>其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用 CREATE INDEX 命令创建</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> name<span class="token punctuation">;</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> id_card<span class="token punctuation">;</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> information<span class="token punctuation">;</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt="img"></p>
<p>需要取消自增长再行删除：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index
<span class="token comment">-- 重新定义字段</span>
<span class="token keyword">MODIFY</span> id <span class="token keyword">int</span><span class="token punctuation">,</span>
<span class="token keyword">drop</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span>
<span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h3><span id="创建索引时需要注意什么">创建索引时需要注意什么？</span></h3><ul>
<li>非空字段：应该指定列为 NOT NULL，除非你想存储 NULL。在 mysql 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用 0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过 count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次 IO 操作获取的数据越大效率越高。</li>
</ul>
<h3><span id="使用索引查询一定能提高查询的性能吗为什么">使用索引查询一定能提高查询的性能吗？为什么 </span></h3><p> 通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的 INSERT，DELETE，UPDATE 将为此多付出 4，5 次的磁盘 I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询 (INDEX RANGE SCAN) 适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3><span id="百万级别或以上的数据如何删除">百万级别或以上的数据如何删除 </span></h3><p> 关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件, 所以当我们对数据的增加, 修改, 删除, 都会产生额外的对索引文件的操作, 这些操作需要消耗额外的 IO, 会降低增 / 改 / 删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引 (此时数据较少了) 创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断, 一切删除会回滚。那更是坑了。</li>
</ol>
<h3><span id="前缀索引">前缀索引 </span></h3><p> 语法：<code>index(field(10))</code>，使用字段值的前 10 个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>我们可以利用 <code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code> 的值（从 1 自增）查看不同前缀长度的一个平均匹配度，接近 1 时就可以了（表示一个密码的前 <code>prefixLen</code> 个字符几乎能确定唯一一条记录）</p>
<h3><span id="什么是最左前缀原则什么是最左匹配原则">什么是最左前缀原则？什么是最左匹配原则</span></h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询 (&gt;、&lt;、between、like) 就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。</li>
<li>= 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立 (a,b,c) 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3><span id="b-树和-b-树的区别">B 树和 B+ 树的区别</span></h3><ul>
<li><p>在 B 树中，你可以将键和值存放在内部节点和叶子节点；但在 B+ 树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li><p>B+ 树的叶子节点有一条链相连，而 B 树的叶子节点各自独立。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img"></p>
</li>
</ul>
<h3><span id="使用-b-树的好处">使用 B 树的好处</span></h3><p>B 树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得 B 树在特定数据重复多次查询的场景中更加高效。</p>
<h3><span id="使用-b-树的好处">使用 B+ 树的好处 </span></h3><p> 由于 B+ 树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+ 树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+ 树只需要使用 O(logN)时间找到最小的一个节点，然后通过链进行 O(N)的顺序遍历即可。而 B 树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h3><span id="hash-索引和-b-树所有有什么区别或者说优劣呢">Hash 索引和 B+ 树所有有什么区别或者说优劣呢?</span></h3><p>首先要知道 Hash 索引和 B+ 树索引的底层实现原理：</p>
<p>hash 索引底层就是 hash 表，进行查找时，调用一次 hash 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+ 树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<ul>
<li>hash 索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>
</ul>
<p>因为在 hash 索引中经过 hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而 B+ 树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<ul>
<li>hash 索引不支持使用索引进行排序，原理同上。</li>
<li>hash 索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为 hash 函数的不可预测。AAAA 和 AAAAB 的索引没有相关性。</li>
<li>hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件 (聚簇索引，覆盖索引等) 的时候可以只通过索引完成查询。</li>
<li>hash 索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B+ 树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<p>因此，在大多数情况下，直接选择 B+ 树索引可以获得稳定且较好的查询速度。而不需要使用 hash 索引。</p>
<h3><span id="数据库为什么使用-b-树而不是-b-树">数据库为什么使用 B+ 树而不是 B 树</span></h3><ul>
<li>B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索；</li>
<li>B+ 树空间利用率更高，可减少 I/O 次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗。B+ 树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比 B 树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO 读写次数也就降低了。而 IO 读写次数是影响索引检索效率的最大因素；</li>
<li>B+ 树的查询效率更加稳定。B 树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在 B+ 树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B- 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题。B+ 树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为 B+ 树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3><span id="b-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据">B+ 树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</span></h3><p>在 B+ 树的索引中，叶子节点可能存储了当前的 key 值，也可能存储了当前的 key 值以及整行的数据，这就是聚簇索引和非聚簇索引。 在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<h3><span id="什么是聚簇索引何时使用聚簇索引与非聚簇索引">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</span></h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam 通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb 中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<h3><span id="非聚簇索引一定会回表查询吗">非聚簇索引一定会回表查询吗？</span></h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 <code>select age from employee where age &lt; 20</code> 的查询时，在索引的叶子节点上，已经包含了 age 信息，不会再次进行回表查询。</p>
<h3><span id="联合索引是什么为什么需要注意联合索引中的顺序">联合索引是什么？为什么需要注意联合索引中的顺序？</span></h3><p>MySQL 可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为:</p>
<p>MySQL 使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照 name 排序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。</p>
<p>当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h2><span id="事务">事务 </span></h2><h3><span id="什么是数据库事务"> 什么是数据库事务？</span></h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3><span id="事物的四大特性-acid-介绍一下">事物的四大特性 (ACID) 介绍一下?</span></h3><p>关系性数据库需要遵循 ACID 规则，具体内容如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt="事务的特性"></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3><span id="什么是脏读幻读不可重复读">什么是脏读？幻读？不可重复读？</span></h3><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个 RollBack 了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read): 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读 (Phantom Read): 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row) 数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3><span id="什么是事务的隔离级别mysql-的默认隔离级别是什么">什么是事务的隔离级别？MySQL 的默认隔离级别是什么？</span></h3><p>为了达到事务的四大特性，数据库定义了 4 种不同的事务隔离级别，由低到高依次为 Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是 MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容):</strong>，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务 </strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<h2><span id="锁">锁 </span></h2><h3><span id="对-mysql-的锁了解吗"> 对 MySQL 的锁了解吗 </span></h3><p> 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>
<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>
<h3><span id="隔离级别与锁的关系">隔离级别与锁的关系 </span></h3><p> 在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别 <strong> 锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p>
<h3><span id="按照锁的粒度分数据库锁有哪些锁机制与-innodb-锁算法">按照锁的粒度分数据库锁有哪些？锁机制与 InnoDB 锁算法 </span></h3><p> 在关系型数据库中，可以 <strong> 按照锁的粒度把数据库锁分 </strong> 为行级锁 (INNODB 引擎)、表级锁(MYISAM 引擎) 和页级锁(BDB 引擎)。</p>
<p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM 采用表级锁(table-level locking)。</li>
<li>InnoDB 支持行级锁 (row-level locking) 和表级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p><strong>行级锁</strong> 行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁</strong> 表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁</strong> 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h3><span id="从锁的类别上分-mysql-都有哪些锁呢像上面那样子进行锁定岂不是有点阻碍并发效率了">从锁的类别上分 MySQL 都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了 </span></h3><p><strong> 从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB 实现了行级锁，页级锁，表级锁。</p>
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>
<h3><span id="mysql-中-innodb-引擎的行锁是怎么实现的">MySQL 中 InnoDB 引擎的行锁是怎么实现的？</span></h3><p>答：InnoDB 是基于索引来完成行锁</p>
<p>例: select * from tab_with_index where id = 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起</p>
<h3><span id="innodb-存储引擎的锁的算法有三种">InnoDB 存储引擎的锁的算法有三种</span></h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb 对于行的查询使用 next-key lock</li>
<li>Next-locking keying 为了解决 Phantom Problem 幻读问题</li>
<li>当查询的索引含有唯一属性时，将 next-key lock 降级为 record key</li>
<li>Gap 锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭 gap 锁：（除了外键约束和唯一性检查外，其余情况仅使用 record lock） A. 将事务隔离级别设置为 RC B. 将参数 innodb_locks_unsafe_for_binlog 设置为 1</li>
</ol>
<h3><span id="什么是死锁怎么解决">什么是死锁？怎么解决？</span></h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
<h3><span id="数据库的乐观锁和悲观锁是什么怎么实现的">数据库的乐观锁和悲观锁是什么？怎么实现的？</span></h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：乐一般会使用版本号机制或 CAS 算法实现。</p>
<p><strong>两种锁的使用场景</strong></p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像 <strong> 乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以 <strong> 一般多写的场景下用悲观锁就比较合适。</strong></p>
<h2><span id="视图">视图 </span></h2><h3><span id="为什么要使用视图什么是视图"> 为什么要使用视图？什么是视图？</span></h3><p>为了提高复杂 SQL 语句的复用性和表操作的安全性，MySQL 数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h3><span id="视图有哪些特点">视图有哪些特点？</span></h3><p>视图的特点如下:</p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表 (实表) 产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新 (添加，删除和修改) 直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3><span id="视图的使用场景有哪些">视图的使用场景有哪些？</span></h3><p>视图根本用途：简化 sql 查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<p>下面是视图的常见使用场景：</p>
<ul>
<li>重用 SQL 语句；</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3><span id="视图的优点">视图的优点</span></h3><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3><span id="视图的缺点">视图的缺点</span></h3><ol>
<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>
<p>这些视图有如下特征：1. 有 UNIQUE 等集合操作符的视图。2. 有 GROUP BY 子句的视图。3. 有诸如 AVG\SUM\MAX 等聚合函数的视图。 4. 使用 DISTINCT 关键字的视图。5. 连接表的视图（其中有些例外）</p>
</li>
</ol>
<h3><span id="什么是游标">什么是游标？</span></h3><p>游标是系统为用户开设的一个数据缓冲区，存放 SQL 语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h2><span id="存储过程与函数">存储过程与函数 </span></h2><h3><span id="什么是存储过程有哪些优缺点"> 什么是存储过程？有哪些优缺点？</span></h3><p>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。</p>
<p><strong>优点</strong></p>
<p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<p><strong>缺点</strong></p>
<p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h2><span id="触发器">触发器 </span></h2><h3><span id="什么是触发器触发器的使用场景有哪些"> 什么是触发器？触发器的使用场景有哪些？</span></h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型 CHAR 和 VARCHAR 的差异，表存储引擎 InnoDB 和 MyISAM 的区别。</li>
</ul>
<h3><span id="mysql-中都有哪些触发器">MySQL 中都有哪些触发器？</span></h3><p>在 MySQL 数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h2><span id="常用-sql-语句">常用 SQL 语句 </span></h2><h3><span id="sql-语句主要分为哪几类">SQL 语句主要分为哪几类</span></h3><p> 数据定义语言 DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言 DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以 select 关键字。各种简单查询，连接查询等 都属于 DQL。</p>
<p>数据操纵语言 DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL 与 DML 共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到 DQL 中。</p>
<p>数据控制功能 DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
<h3><span id="超键-候选键-主键-外键分别是什么">超键、候选键、主键、外键分别是什么？</span></h3><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3><span id="sql-约束有哪几种">SQL 约束有哪几种？</span></h3><blockquote>
<p>SQL 约束有哪几种？</p>
</blockquote>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3><span id="六种关联查询">六种关联查询</span></h3><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION 与 UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
<li>交叉连接（CROSS JOIN）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">SELECT * FROM A,B(,C)或者 SELECT * FROM A CROSS JOIN B (CROSS JOIN C)# 没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id&#x3D;B.id 或者 SELECT * FROM A INNER JOIN B ON A.id&#x3D;B.id 多表中同时符合某种条件的数据记录的集合，INNER JOIN 可以缩写为 JOIN
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内连接分为三类</p>
<ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照 ON 后的关联条件匹配右表，没有匹配到的用 NULL 填充，可以简写成 LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照 ON 后的关联条件匹配左表，没有匹配到的用 NULL 填充，可以简写成 RIGHT JOIN</li>
</ul>
<p>联合查询（UNION 与 UNION ALL）</p>
<pre class="line-numbers language-none"><code class="language-none">SELECT * FROM A UNION SELECT * FROM B UNION ...
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>就是把多个结果集集中在一起，UNION 前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用 UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p>全连接（FULL JOIN）</p>
<ul>
<li>mysql 不支持全连接</li>
<li>可以使用 LEFT JOIN 和 UNION 和 RIGHT JOIN 联合使用</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">SELECT * FROM A LEFT JOIN B ON A.id&#x3D;B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id&#x3D;B.id
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>表连接面试题</p>
<p>有 2 张表，1 张 R、1 张 S，R 表有 ABC 三列，S 表有 CD 两列，表中各有三条记录。</p>
<p>R 表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody>
</table>
</div>
<p>S 表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>交叉连接(笛卡尔积):</li>
</ol>
<p>select r.<code>*</code>,s.<code>*</code> from r,s</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>内连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r inner join s on r.c=s.c</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>左连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r left join s on r.c=s.c</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>右连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r right join s on r.c=s.c</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>全表连接的结果（MySql 不支持，Oracle 支持）：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r full join s on r.c=s.c</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="什么是子查询">什么是子查询</span></h3><ol>
<li>条件：一条 SQL 语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条 SQL 语句嵌套使用，内部的 SQL 查询语句称为子查询。</li>
</ol>
<h3><span id="子查询的三种情况">子查询的三种情况</span></h3><ol>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询工资最高的员工是谁？ </span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> salary<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">from</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询工资最高的员工是谁？ </span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> salary<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">from</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于 where 条件，用于 select 子句中做为子表</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1) 查询出 2011 年以后入职的员工信息</span>
<span class="token comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门 ID 相等的员工。</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept d<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employee <span class="token keyword">where</span> join_date <span class="token operator">></span> <span class="token string">'2011-1-1'</span><span class="token punctuation">)</span> e <span class="token keyword">where</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span>  d<span class="token punctuation">.</span>id<span class="token punctuation">;</span>    

<span class="token comment">-- 使用表连接：</span>
<span class="token keyword">select</span> d<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span>  dept d <span class="token keyword">inner</span> <span class="token keyword">join</span> employee e <span class="token keyword">on</span> d<span class="token punctuation">.</span>id <span class="token operator">=</span> e<span class="token punctuation">.</span>dept_id <span class="token keyword">where</span> e<span class="token punctuation">.</span>join_date <span class="token operator">></span>  <span class="token string">'2011-1-1'</span>  
<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="mysql-中-in-和-exists-区别">mysql 中 in 和 exists 区别</span></h3><p>mysql 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。一直大家都认为 exists 比 in 语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<ol>
<li>如果查询的两个表大小相当，那么用 in 和 exists 差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。</li>
<li>not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。</li>
</ol>
<h3><span id="varchar-与-char-的区别">varchar 与 char 的区别</span></h3><p><strong>char 的特点</strong></p>
<ul>
<li>char 表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于 char 来说，最多能存放的字符个数为 255，和编码无关</li>
</ul>
<p><strong>varchar 的特点</strong></p>
<ul>
<li>varchar 表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于 varchar 来说，最多能存放的字符个数为 65532</li>
</ul>
<p>总之，结合性能角度（char 更快）和节省磁盘空间角度（varchar 更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h3><span id="varchar50中-50-的涵义">varchar(50)中 50 的涵义 </span></h3><p> 最多存放 50 个字符，varchar(50)和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 长度(memory 引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<h3><span id="int20中-20-的涵义">int(20)中 20 的涵义 </span></h3><p> 是指显示字符的长度。20 表示最大显示宽度为 20，但仍占 4 字节存储，存储范围不变；</p>
<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h3><span id="mysql-为什么这么设计">mysql 为什么这么设计 </span></h3><p> 对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和 int(20)存储和计算均一样；</p>
<h3><span id="mysql-中-int10和-char10以及-varchar10的区别">mysql 中 int(10)和 char(10)以及 varchar(10)的区别</span></h3><ul>
<li><p>int(10)的 10 表示显示的数据的长度，不是存储数据的大小；chart(10)和 varchar(10)的 10 表示存储数据的大小，即表示存储多少个字符。</p>
<p>int(10) 10 位的数据长度 9999999999，占 32 个字节，int 型 4 位<br>char(10) 10 位固定字符串，不足补空格 最多 10 个字符<br>varchar(10) 10 位可变字符串，不足补空格 最多 10 个字符</p>
</li>
<li><p>char(10)表示存储定长的 10 个字符，不足 10 个就用空格补齐，占用更多的存储空间</p>
</li>
<li><p>varchar(10)表示存储 10 个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和 char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p>
</li>
</ul>
<h3><span id="float-和-double-的区别是什么">FLOAT 和 DOUBLE 的区别是什么？</span></h3><ul>
<li>FLOAT 类型数据可以存储至多 8 位十进制数，并在内存中占 4 字节。</li>
<li>DOUBLE 类型数据可以存储至多 18 位十进制数，并在内存中占 8 字节。</li>
</ul>
<h3><span id="drop-delete-与-truncate-的区别">drop、delete 与 truncate 的区别 </span></h3><p> 三者都表示删除，但是三者有一些差别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属于 DML</td>
<td>属于 DDL</td>
<td>属于 DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody>
</table>
</div>
<p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p>
<h3><span id="union-与-union-all-的区别">UNION 与 UNION ALL 的区别？</span></h3><ul>
<li>如果使用 UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2><span id="sql-优化">SQL 优化 </span></h2><h3><span id="如何定位及优化-sql-语句的性能问题创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因"> 如何定位及优化 SQL 语句的性能问题？创建的索引有没有被使用到? 或者说怎么才可以知道这条语句运行很慢的原因？</span></h3><p>对于低性能的 SQL 语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL 提供了 explain 命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条 SQL 语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引 </strong>。 而<strong> 执行计划，就是显示数据库引擎对于 SQL 语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id 相同执行顺序由上至下。</li>
<li>id 不同，id 值越大优先级越高，越先被执行。</li>
<li>id 为 null 时表示一个结果集，不需要使用它查询，常出现在包含 union 等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或 union 等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在 select 或 where 字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from 字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在 union 后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从 UNION 中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody>
</table>
</div>
<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划 id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> tmp <span class="token punctuation">(</span>
    id <span class="token keyword">int</span> <span class="token keyword">unsigned</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span>
<span class="token keyword">partition</span> <span class="token keyword">by</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> partitions <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对 Null 进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在 join 查询中使用 PRIMARY KEYorUNIQUE NOT NULL 索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL 时就要考虑当前的 SQL 是否需要优化了。</p>
<p><strong>key</strong> 显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL。</p>
<p><strong>TIPS</strong>: 查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在 key 列表中</p>
<p><strong>key_length</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>
<ol>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用 where 子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>
<li>Using temporary 使用了临时表 sql 优化的目标可以参考阿里开发手册</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 
说明： 
1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 
2） ref 指的是使用普通的索引（normal index）。 
3） range 对索引进行范围检索。 
反例：explain 表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。
123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="sql-的生命周期">SQL 的生命周期？</span></h3><ol>
<li><p>应用服务器与数据库服务器建立一个连接</p>
</li>
<li><p>数据库进程拿到请求 sql</p>
</li>
<li><p>解析并生成执行计划，执行</p>
</li>
<li><p>读取数据到内存并进行逻辑处理</p>
</li>
<li><p>通过步骤一的连接，发送结果到客户端</p>
</li>
<li><p>关掉连接，释放资源</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3><span id="大表数据查询怎么优化">大表数据查询，怎么优化</span></h3><ol>
<li>优化 shema、sql 语句 + 索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的 sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql 中尽量带 sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h3><span id="超大分页怎么处理">超大分页怎么处理？</span></h3><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面, 这也是我们主要集中关注的 (虽然收效没那么大), 类似于<code>select * from table where age &gt; 20 limit 1000000,10</code> 这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃, 只取 10 条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>. 这样虽然也 load 了一百万的数据, 但是由于索引覆盖, 要查询的所有字段都在索引中, 所以速度会很快. 同时如果 ID 连续的好, 我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>, 效率也是不错的, 优化的可能性有许多种, 但是核心思想都一样, 就是减少 load 的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求 (直接跳转到几百万页之后的具体某一页. 只允许逐页查看或者按照给定的路线走, 这样可预测, 可缓存) 以及防止 ID 泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页, 其实主要是靠缓存, 可预测性的提前查到内容, 缓存至 redis 等 k-V 数据库中, 直接返回即可.</p>
<p>在阿里巴巴《Java 开发手册》中, 对超大分页的解决办法是类似于上面提到的第一种.</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">【推荐】利用延迟关联或者子查询优化超多分页场景。 

说明：MySQL 并不是跳过 <span class="token keyword">offset</span> 行，而是取 <span class="token keyword">offset</span><span class="token operator">+</span>N 行，然后返回放弃前<span class="token keyword">offset</span> 行，返回 N 行，那当 <span class="token keyword">offset</span> 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 <span class="token keyword">SQL</span> 改写。 

正例：先快速定位需要获取的 id 段，然后再关联： 

<span class="token keyword">SELECT</span> a<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> 表<span class="token number">1</span> a<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> 表<span class="token number">1</span> <span class="token keyword">where</span> 条件 <span class="token keyword">LIMIT</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">20</span> <span class="token punctuation">)</span> b <span class="token keyword">where</span> a<span class="token punctuation">.</span>id<span class="token operator">=</span>b<span class="token punctuation">.</span>id
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="mysql-分页">mysql 分页</span></h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last. 
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F; 检索前 5 个记录行 
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>
<h3><span id="慢查询日志">慢查询日志</span></h3><blockquote>
<p>用于记录执行时间超过某个临界值的 SQL 日志，用于快速定位慢查询，为我们的优化做参考。</p>
</blockquote>
<p>开启慢查询日志</p>
<p>配置项：<code>slow_query_log</code></p>
<p>可以使用 <code>show variables like ‘slov_query_log’</code> 查看是否开启，如果状态值为 <code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code> 来开启，它会在 <code>datadir</code> 下产生一个 <code>xxx-slow.log</code> 的文件。</p>
<p>设置临界时间</p>
<p>配置项：<code>long_query_time</code></p>
<p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p>
<p>设置：<code>set long_query_time=0.5</code></p>
<p>实操时应该从长时间设置到短的时间，即将最慢的 SQL 优化掉</p>
<p>查看日志，一旦 SQL 超过了我们设置的临界时间就会被记录到 <code>xxx-slow.log</code> 中</p>
<h3><span id="关心过业务系统里面的-sql-耗时吗统计过慢查询吗对慢查询都怎么优化过">关心过业务系统里面的 sql 耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span></h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是 load 了不需要的数据列？还是数据量太大？</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否 load 了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h3><span id="为什么要尽量设定一个主键">为什么要尽量设定一个主键？</span></h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的 ID 列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h3><span id="主键使用自增-id-还是-uuid">主键使用自增 ID 还是 UUID？</span></h3><p>推荐使用自增 ID，不要使用 UUID。</p>
<p>因为在 InnoDB 存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的 B+ 树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增 ID，那么只需要不断向后排列即可，如果是 UUID，由于到来的 ID 与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB 会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h3><span id="字段为什么要求定义为-not-null">字段为什么要求定义为 not null？</span></h3><p>null 值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h3><span id="如果要存储用户的密码散列应该使用什么字段进行存储">如果要存储用户的密码散列，应该使用什么字段进行存储？</span></h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用 char 而不是 varchar 来存储，这样可以节省空间且提高检索效率。</p>
<h3><span id="优化查询过程中的数据访问">优化查询过程中的数据访问</span></h3><ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认 MySQL 服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下 SQL 语句错误</li>
<li>查询不需要的数据。解决办法：使用 limit 解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用 SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>是否在扫描额外的记录。解决办法：</li>
<li>使用 explain 进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写 SQL 语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h3><span id="优化长难的查询语句">优化长难的查询语句</span></h3><ul>
<li>一个复杂查询还是多个简单查询</li>
<li>mysql 内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>切分查询</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除 1000 万的数据要比一次删除 1 万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h3><span id="优化特定类型的查询语句">优化特定类型的查询语句</span></h3><ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用 count(列名)</li>
<li>MyISAM 中，没有任何 where 条件的 count(*)非常快。</li>
<li>当有 where 条件时，MyISAM 的 count 统计不一定比其它引擎快。</li>
<li>可以使用 explain 查询近似值，用近似值替代 count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h3><span id="优化关联查询">优化关联查询</span></h3><ul>
<li>确定 ON 或者 USING 子句中是否有索引。</li>
<li>确保 GROUP BY 和 ORDER BY 只有一个表中的列，这样 MySQL 才有可能使用索引。</li>
</ul>
<h3><span id="优化子查询">优化子查询</span></h3><ul>
<li>用关联查询替代</li>
<li>优化 GROUP BY 和 DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要 ORDER BY，进行 GROUP BY 时加 ORDER BY NULL，MySQL 不会再进行文件排序。</li>
<li>WITH ROLLUP 超级聚合，可以挪到应用程序处理</li>
</ul>
<h3><span id="优化-limit-分页">优化 LIMIT 分页</span></h3><ul>
<li>LIMIT 偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大 ID，下次查询时直接根据该 ID 来查询</li>
</ul>
<h3><span id="优化-union-查询">优化 UNION 查询</span></h3><ul>
<li>UNION ALL 的效率高于 UNION</li>
</ul>
<h3><span id="优化-where-子句">优化 WHERE 子句 </span></h3><p> 解题方法</p>
<p>对于此类考题，先说明如何定位低效 SQL 语句，然后根据 SQL 语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>
<p>SQL 语句优化的一些方法？</p>
<ul>
<li>1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">is</span> <span class="token boolean">null</span>
<span class="token comment">-- 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>3. 应尽量避免在 where 子句中使用!= 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>4. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">or</span> num<span class="token operator">=</span><span class="token number">20</span>
<span class="token comment">-- 可以这样查询：</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">20</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> 
<span class="token comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>6. 下面的查询也将导致全表扫描：select id from t where name like ‘% 李 %’若要提高效率，可以考虑全文检索。</li>
<li>7. 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span>
<span class="token comment">-- 可以改为强制查询使用索引：</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token comment">-- 应改为:</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">2</span>
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>9. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> substring<span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span>’abc’
<span class="token comment">-- name 以 abc 开头的 id 应改为:</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> ‘abc<span class="token operator">%</span>’
<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>10. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
</ul>
<h2><span id="数据库优化">数据库优化 </span></h2><h3><span id="为什么要优化"> 为什么要优化</span></h3><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h3><span id="数据库结构优化">数据库结构优化 </span></h3><p> 一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p><strong>将字段很多的表分解成多个表</strong></p>
<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p><strong>增加中间表</strong></p>
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>
<p><strong>增加冗余字段</strong></p>
<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
<p><strong>注意：</strong></p>
<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>
<h3><span id="mysql-数据库-cpu-飙升到-500-的话他怎么处理">MySQL 数据库 cpu 飙升到 500% 的话他怎么处理？</span></h3><p>当 cpu 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程 (同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数) 之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h3><span id="大表怎么优化某个表有近千万数据crud-比较慢如何优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么">大表怎么优化？某个表有近千万数据，CRUD 比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</span></h3><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读 / 写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用 MySQL 的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ol>
<li><p><strong>垂直分区：</strong></p>
<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt="img"></p>
<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h4><span id="垂直分表">垂直分表 </span></h4><p> 把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt="img"></p>
<h5><span id="适用场景">适用场景</span></h5><ul>
<li>1、如果一个表中某些列常用，另外一些列不常用</li>
<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少 I/O 次数</li>
</ul>
<h5><span id="缺点">缺点</span></h5><ul>
<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>
<li>对于应用层来说，逻辑算法增加开发成本</li>
<li>管理冗余列，查询所有数据需要 join 操作</li>
</ul>
</li>
<li><p><strong>水平分区：</strong></p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt="数据库水平拆分"></p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是: 分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少 </strong>，但 <strong> 分片事务难以解决</strong> ，跨界点 Join 性能较差，逻辑复杂。</p>
<p>《Java 工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。</p>
<h4><span id="水平分表">水平分表：</span></h4><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt="img"></p>
<h5><span id="适用场景">适用场景</span></h5><ul>
<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>2、需要把数据存放在多个介质上。</li>
</ul>
<h5><span id="水平切分的缺点">水平切分的缺点</span></h5><ul>
<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需 UNION 操作</li>
<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ul>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的 TDDL 是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</li>
</ul>
</li>
</ol>
<p><strong>分库分表后面临的问题</strong></p>
<ul>
<li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li><p><strong>跨库 join</strong></p>
<p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的 id, 根据这些 id 发起第二次请求得到关联数据。 分库分表方案产品</p>
</li>
<li><p><strong>跨节点的 count,order by,group by 以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</li>
<li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性（如对 4 取余得 1 的数对 2 取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p>
</li>
<li><p><strong>ID 问题</strong></p>
</li>
<li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID, 以便进行 SQL 路由. 一些常见的主键生成策略</p>
</li>
</ul>
<p><strong>UUID</strong> 使用 UUID 作主键是最简单的方案，但是缺点也是非常明显的。由于 UUID 非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter 的分布式自增 ID 算法 Snowflake</strong> 在分布式系统中，需要生成全局 UID 的场合还是比较多的，twitter 的 snowflake 解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间 41 位 机器 ID 10 位 毫秒内序列 12 位。</p>
<ul>
<li><p>跨分片的排序分页</p>
<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3><span id="mysql-的复制原理以及流程">MySQL 的复制原理以及流程 </span></h3><p> 主从复制：将主数据库中的 DDL 和 DML 操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<p><strong>主从复制的作用</strong></p>
<ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<p><strong>MySQL 主从复制解决的问题</strong></p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的 MySQL 作为从库</li>
</ul>
<p><strong>MySQL 主从复制工作原理</strong></p>
<ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<p><strong>基本原理流程，3 个线程以及之间的关联</strong></p>
<p><strong>主</strong>：binlog 线程——记录下所有改变了数据库数据的语句，放进 master 上的 binlog 中；</p>
<p><strong>从</strong>：io 线程——在使用 start slave 之后，负责从 master 上拉取 binlog 内容，放进自己的 relay log 中；</p>
<p><strong>从</strong>：sql 执行线程——执行 relay log 中的语句；</p>
<p><strong>复制过程</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt="img"></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master 在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog 文件中。</p>
<p>第二步：salve 开启一个 I/O Thread，该线程在 master 打开一个普通连接，主要工作是 binlog dump process。如果读取的进度已经跟上了 master，就进入睡眠状态并等待 master 产生新的事件。I/O 线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread 会读取中继日志，并顺序执行该日志中的 SQL 事件，从而与主数据库中的数据保持一致。</p>
<h3><span id="读写分离有哪些解决方案">读写分离有哪些解决方案？</span></h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求 <code>slave</code> 不能写只能读（如果对 <code>slave</code> 执行写操作，那么 <code>show slave status</code> 将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p>
<p><strong>方案一</strong></p>
<p>使用 mysql-proxy 代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master 和 slave 用一样的帐号，mysql 官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二</strong></p>
<p>使用 AbstractRoutingDataSource+aop+annotation 在 dao 层决定数据源。<br>如果采用了 mybatis， 可以将读写分离放在 ORM 层，比如 mybatis 可以通过 mybatis plugin 拦截 sql 语句，所有的 insert/update/delete 都访问 master 库，所有的 select 都访问 salve 库，这样对于 dao 层都是透明。 plugin 实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下 DataSourceTransactionManager， 将 read-only 的事务扔进读库， 其余的有读有写的扔进写库。</p>
<p><strong>方案三</strong></p>
<p>使用 AbstractRoutingDataSource+aop+annotation 在 service 层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过 this.xx()方式相互调用时，aop 不会进行拦截，需进行特殊处理。</p>
<h3><span id="备份计划mysqldump-以及-xtranbackup-的实现原理">备份计划，mysqldump 以及 xtranbackup 的实现原理 </span></h3><p><strong>(1) 备份计划</strong></p>
<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump 更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p><strong>(2)备份恢复时间</strong></p>
<p>物理备份恢复快，逻辑备份恢复慢</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<p>20G 的 2 分钟（mysqldump）</p>
<p>80G 的 30 分钟(mysqldump)</p>
<p>111G 的 30 分钟（mysqldump)</p>
<p>288G 的 3 小时（xtra)</p>
<p>3T 的 4 小时（xtra)</p>
<p>逻辑导入时间一般是备份时间的 5 倍以上</p>
<p><strong>(3)备份恢复失败如何处理</strong></p>
<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<p><strong>(4)mysqldump 和 xtrabackup 实现原理</strong></p>
<p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /<em>!40100 WITH CONSISTENTSNAPSHOT </em>/)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK), 等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
<p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在 5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>
<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
<h3><span id="数据表损坏的修复方式有哪些">数据表损坏的修复方式有哪些？</span></h3><p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1）修复前将 mysql 服务停止。</li>
<li>2）打开命令行方式，然后进入到 mysql 的 /bin 目录。</li>
<li>3）执行 myisamchk –recover 数据库所在路径 /*.MYI</li>
</ul>
<p>使用 repair table 或者 OPTIMIZE table 命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了 OPTIMIZE TABLE 命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
