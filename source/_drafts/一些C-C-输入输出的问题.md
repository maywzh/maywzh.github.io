---
title: 一些C++输入输出的问题
categories: 编程
comments: false
thumbnail: https://i.loli.net/2020/08/23/BxKw7Ck12O8zpjJ.jpg
cover: https://i.loli.net/2020/08/23/BxKw7Ck12O8zpjJ.jpg
mathjax: false
date: 2015-09-02 20:52:00
tags:
  - C/C++
---

总结C/C++的IO的一些问题。

<!--more-->

## cin的">>"函数返回值是什么?

> 为什么用while(cin>>a)一直跳不出循环？

```c++
int a;
while (cin >> a){
  
}
```



`>>`是一个被重载过的运算符，它本质上是调用函数`operator>>(cin)`，这个重载函数的返回值类型为`istream&`，返回值通常就是输入流`cin`本身, `cin`是定义在`std`空间中的标准输入流变量。如果没有遇到错误输入或者文件末尾（EOF），`cin`就一直有效，当然就跳不出while循环。当你在键盘上输入`Ctrl+Z`，再按Enter键，就等同于输入遇到了文件末尾EOF，遇到EOF后，`>>`函数的返回值是0，就能结束while循环了。





## scanf的返回值是什么？

>  `while(scanf("%d %d",&a,&b)){ }`为何是死循环？遇到文件结束符EOF也跳不出循环？

`scanf`是函数，这和`cin`不同，`cin`是一个类，而`>>`是`cin`类中的函数。`scanf`返回的是成功输入数据的个数，例如`scanf(”%d %d",&a,&b)`成功输入两个数，返回值就是2，`scanf("%d",&a)`成功输入一个数，返回值就是1。当遇到文件末尾时，`scanf`函数返回值是EOF。
EOF是一个宏，标准规定EOF必须是一个int类型的负数，编译器通常令EOF的值为-1。因此，想要跳出循环，要写成`while( scanf("%d %d",&a,&b) !=EOF){ }`。



## 输入的数据什么时候才会进入缓冲区？

> 为什么`cin`只输入1个或几个数，在键盘上输入了多个（超过几个）数之后，控制台输入界面仍然不停止？

```c++
int a,b;
cin>>a>>b;
```

调用`cin`的`>>`函数时，程序就等着用户按键，**直到用户按下回车键，包换换行符在内的这一行数据才被放入缓冲区中，形成输入流**，提取符`>>`才能从中提取数据。也就是说，没按下回车键之前，在键盘上输入的数据都还没被放入缓冲区只是在控制台上显示出你按下的数据了而已，这也是为什么输错了的时候还能按退格键删除数据然后重新输入。
以上面程序为例，当在键盘上输入了超过2个字符时，其他字符也会被保留在缓冲区中，等待后面程序中的`cin>>`读取，若后面程序中再出现`cin>>c`之类的，程序也不会出现控制台等待用户输入，而是直接读取缓冲区中剩下的数据，直到缓冲区中的字符读完后，才等待用户按键。



## getchar()函数的返回值是什么？

> 使用getchar()函数，我明明输入的是数字1，怎么输入的是49？

`getchar()`函数会从stdin中读入一个字符（空格回车等空白符它也不会跳过，通通都读），并返回一个int型数据，返回的是输入字符的ASCII码。也就是说，输入数字1，它返回的是数字1的ASCII码49，输入字符A，它返回的是字符A的ASCII码65，你输入空格，它返回的是空格的ASCII码32。一般都是用`getchar()`来判断是否已经到了一行末尾，因为它换行符也读。

```c++
int main(){
  int n;
  scanf_s("%d", &n);
  int a,b,c,d,e;
  a=getchar();
  b=getchar();
  c=getchar();
  d=getchar();
  e=getchar();
 	cout<<"n:"<<n<<endl;
  cout<<"a:"<<a<<endl;
  cout<<"b:"<<b<<endl;
  cout<<"c:"<<c<<endl;
  cout<<"d:"<<d<<endl;
  cout<<"e:"<<e<<endl;
}
// input:
//3 AB 7 1 2↩︎
// output:
//n:3
//a:32
//b:65
//c:66
//d:32
//e:55
```

