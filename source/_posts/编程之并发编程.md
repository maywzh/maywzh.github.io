---
title: 编程之并发编程
categories: 编程
comments: false
date: 2018-01-28 10:46:03
tags:
  - 并发
  - 多线程
thumbnail: https://i.loli.net/2020/08/28/aCvM4DhEVJA1gRI.jpg
---

在计算机最早期的时候，没有操作系统，执行程序只需要一种方式，那就是从头到尾依次执行。任何资源都会为这个程序服务，在计算机使用某些资源时，其他资源就会空闲，就会存在 `浪费资源` 的情况。

操作系统的出现为我们的程序带来了 `并发性`，操作系统使我们的程序能够同时运行多个程序，一个程序就是一个进程，也就相当于同时运行多个进程。

<!--more-->

## 操作系统的并发性

操作系统是一个`并发系统`，并发性是操作系统非常重要的特征，操作系统具有同时处理和调度多个程序的能力，比如多个 I/O 设备同时在输入输出；设备 I/O 和 CPU 计算同时进行；内存中同时有多个系统和用户程序被启动交替、穿插地执行。操作系统在协调和分配进程的同时，操作系统也会为不同进程分配不同的资源。

操作系统实现多个程序同时运行解决了单个程序无法做到的问题，主要有下面三点

- `资源利用率`，我们上面说到，单个进程存在资源浪费的情况，举个例子，当你在为某个文件夹赋予权限的时候，输入程序无法接受外部的输入字符，只有等到权限赋予完毕后才能接受外部输入。总的来讲，就是在等待程序时无法执行其他工作。如果在等待程序时可以运行另一个程序，那么将会大大提高资源的利用率。（资源并不会觉得累）因为它不会划水～
- `公平性`，不同的用户和程序都能够使用计算机上的资源。一种高效的运行方式是为不同的程序划分时间片来使用资源，但是有一点需要注意，操作系统可以决定不同进程的优先级。虽然每个进程都有能够公平享有资源的权利，但是当有一个进程释放资源后的同时有一个优先级更高的进程抢夺资源，就会造成优先级低的进程无法获得资源，进而导致进程饥饿。
- `便利性`，单个进程是是不用通信的，通信的本质就是`信息交换`，及时进行信息交换能够避免`信息孤岛`，做重复性的工作；任何并发能做的事情，单进程也能够实现，只不过这种方式效率很低，它是一种`顺序性`的。

但是，顺序编程（也称为`串行编程`）也不是`一无是处`的，串行编程的优势在于其**直观性和简单性**，客观来讲，串行编程更适合我们人脑的思考方式，但是我们并不会满足于顺序编程，**we want it more!!!** 。资源利用率、公平性和便利性促使着进程出现的同时，也促使着`线程`的出现。

关于进程和线程的区别，简单理解就一句话：**进程是一个应用程序，而线程是应用程序中的一条顺序流**。



![img](https://i.loli.net/2020/08/28/9EQ5HDcLPFhydSm.png)



进程中会有多个线程来完成一些任务，这些任务有可能相同有可能不同。每个线程都有自己的执行顺序。



![img](https://i.loli.net/2020/08/28/mCoROYJhPqZegNu.png)



每个线程都有自己的栈空间，这是线程私有的，还有一些其他线程内部的和线程共享的资源，如下所示。

> 在计算机中，一般堆栈指的就是栈，而堆指的才是堆

线程会共享进程范围内的资源，例如内存和文件句柄，但是每个线程也有自己私有的内容，比如程序计数器、栈以及局部变量。下面汇总了进程和线程共享资源的区别



![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c323cd6f49f40ce88ecf01e1c8ca6dd~tplv-k3u1fbpfcp-zoom-1.image)



线程是一种`轻量级`的进程，轻量级体现在线程的创建和销毁要比进程的开销小很多。

> 注意：任何比较都是相对的。

在大多数现代操作系统中，都以线程为基本的调度单位，所以我们的视角着重放在对`线程`的探究。



## 线程

### 什么是多线程

多线程意味着你能够在同一个应用程序中运行多个线程，我们知道，指令是在 CPU 中执行的，多线程应用程序就像是具有多个 CPU 在同时执行应用程序的代码。



![img](https://i.loli.net/2020/08/28/UIT3HkbCR1Mv5tg.png)



其实这是一种假象，线程数量并不等于 CPU 数量，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行，如下图所示



![28f4eee4f9b146b583775f58bd8499b6_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/c9nG1zNHjkoaiwg.png)

### 并发与并行

`并发`意味着应用程序会执行多个的任务，但是如果计算机只有一个 CPU 的话，那么应用程序无法同时执行多个的任务，但是应用程序又需要执行多个任务，所以计算机在开始执行下一个任务之前，它并没有完成当前的任务，只是把状态暂存，进行任务切换，CPU 在多个任务之间进行切换，直到任务完成。如下图所示

![2b9f5d2444564a4892dae6773ed49dfc_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/MLkJm1wf96hjvEq.png)

`并行`是指应用程序将其任务分解为较小的子任务，这些子任务可以并行处理，例如在多个CPU上同时进行。

![db5307cfa3454ae19626a6b5d0c0720d_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/6zmK3IGcHRX7Lfd.png)



### 优势和劣势

合理使用线程是一门艺术，合理编写一道准确无误的多线程程序更是一门艺术，如果线程使用得当，能够有效的降低程序的开发和维护成本。

Java 很好的在用户空间实现了开发工具包，并在内核空间提供系统调用来支持多线程编程，Java 支持了丰富的类库 `java.util.concurrent` 和跨平台的`内存模型`，同时也提高了开发人员的门槛，并发一直以来是一个高阶的主题，但是现在，并发也成为了主流开发人员的必备素质。

虽然线程带来的好处很多，但是编写正确的多线程（并发）程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现又诡异的消失，在当你认为没有问题的时候它就出现了，`难以定位` 是并发程序的一个特征，所以在此基础上你需要有扎实的并发基本功。那么，并发为什么会出现呢？



### 并发为什么会出现

计算机世界的快速发展离不开 CPU、内存和 I/O 设备的高速发展，但是这三者一直存在速度差异性问题，我们可以从存储器的层次结构可以看出

![1d414061db36482eb05bac3ca3bc686f_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/UsuhfLiE3QcKvog.png)

CPU 内部是寄存器的构造，寄存器的访问速度要高于`高速缓存`，高速缓存的访问速度要高于内存，最慢的是磁盘访问。

程序是在内存中执行的，程序里大部分语句都要访问内存，有些还需要访问 I/O 设备，根据漏桶理论来说，程序整体的性能取决于最慢的操作也就是磁盘访问速度。

因为 CPU 速度太快了，所以为了发挥 CPU 的速度优势，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

- CPU 使用缓存来中和和内存的访问速度差异
- 操作系统提供进程和线程调度，让 CPU 在执行指令的同时分时复用线程，让内存和磁盘不断交互，不同的 `CPU 时间片` 能够执行不同的任务，从而均衡这三者的差异
- 编译程序提供优化指令的执行顺序，让缓存能够合理的使用

我们在享受这些便利的同时，多线程也为我们带来了挑战，下面我们就来探讨一下并发问题为什么会出现以及多线程的源头是什么。



### 线程带来的安全性问题

线程安全性是非常复杂的，在没有采用`同步机制`的情况下，多个线程中的执行操作往往是不可预测的，这也是多线程带来的挑战之一，下面我们给出一段代码，来看看安全性问题体现在哪

```java
public class TSynchronized implements Runnable{

    static int i = 0;

    public void increase(){
        i++;
    }


    @Override
    public void run() {
        for(int i = 0;i < 1000;i++) {
            increase();
        }
    }

    public static void main(String[] args) throws InterruptedException {

        TSynchronized tSynchronized = new TSynchronized();
        Thread aThread = new Thread(tSynchronized);
        Thread bThread = new Thread(tSynchronized);
        aThread.start();
        bThread.start();
        System.out.println("i = " + i);
    }
}
```

这段程序输出后会发现，i 的值每次都不一样，这不符合我们的预测，那么为什么会出现这种情况呢？我们先来分析一下程序的运行过程。

`TSynchronized` 实现了 Runnable 接口，并定义了一个静态变量 `i`，然后在 `increase` 方法中每次都增加 i 的值，在其实现的 run 方法中进行循环调用，共执行 1000 次。



#### 可见性

在单核 CPU 时代，所有的线程共用一个 CPU，CPU 缓存和内存的一致性问题容易解决，CPU 和 内存之间

如果用图来表示的话我想会是下面这样：

![74cb25a3dc3a4ff8902c7d0088c393e7_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/Dbr51qVywGNipER.png)

在多核时代，因为有多核的存在，每个核都能够独立的运行一个线程，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。

![ad95cb50434c4017a4acd6990ab0e03c_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/fmU13JXVRC6psQN.png)



因为 i 是静态变量，没有经过任何线程安全措施的保护，多个线程会并发修改 i 的值，所以我们认为 i 不是线程安全的，导致这种结果的出现是由于 aThread 和 bThread 中读取的 i 值彼此不可见，所以这是由于 `可见性` 导致的线程安全问题。



#### 原子性问题

看起来很普通的一段程序却因为两个线程 `aThread` 和 `bThread` 交替执行产生了不同的结果。但是根源不是因为创建了两个线程导致的，多线程只是产生线程安全性的必要条件，最终的根源出现在 `i++` 这个操作上。

这个操作怎么了？这不就是一个给 i 递增的操作吗？也就是 **i++ => i = i + 1**，这怎么就会产生问题了？

因为 `i++` 不是一个 `原子性` 操作，仔细想一下，i++ 其实有三个步骤，读取 i 的值，执行 i + 1 操作，然后把 i + 1 得出的值重新赋给 i（将结果写入内存）。

当两个线程开始运行后，每个线程都会把 i 的值读入到 CPU 缓存中，然后执行 + 1 操作，再把 + 1 之后的值写入内存。因为线程间都有各自的虚拟机栈和程序计数器，他们彼此之间没有数据交换，所以当 aThread 执行 + 1 操作后，会把数据写入到内存，同时 bThread 执行 + 1 操作后，也会把数据写入到内存，因为 CPU 时间片的执行周期是不确定的，所以会出现当 aThread 还没有把数据写入内存时，bThread 就会读取内存中的数据，然后执行 + 1操作，再写回内存，从而覆盖 i 的值，导致 aThread 所做的努力白费。


![ad95cb50434c4017a4acd6990ab0e03c_tplv-k3u1fbpfcp-zoom-1](https://i.loli.net/2020/08/28/fmU13JXVRC6psQN.png)